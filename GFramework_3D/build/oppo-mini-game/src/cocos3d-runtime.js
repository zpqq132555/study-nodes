var ccm = function(exports) {
    "use strict";
    function _typeof(obj) {
        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        })(obj);
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
        Constructor;
    }
    function _defineProperty(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }
    function _inherits(subClass, superClass) {
        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: !0,
                configurable: !0
            }
        }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        })(o);
    }
    function _setPrototypeOf(o, p) {
        return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            return o.__proto__ = p, o;
        })(o, p);
    }
    function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }
    function _possibleConstructorReturn(self, call) {
        return !call || "object" != typeof call && "function" != typeof call ? _assertThisInitialized(self) : call;
    }
    function _superPropBase(object, property) {
        for (;!Object.prototype.hasOwnProperty.call(object, property) && null !== (object = _getPrototypeOf(object)); ) ;
        return object;
    }
    function _get(target, property, receiver) {
        return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function _get(target, property, receiver) {
            var base = _superPropBase(target, property);
            if (base) {
                var desc = Object.getOwnPropertyDescriptor(base, property);
                return desc.get ? desc.get.call(receiver) : desc.value;
            }
        })(target, property, receiver || target);
    }
    function set(target, property, value, receiver) {
        return (set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function set(target, property, value, receiver) {
            var desc, base = _superPropBase(target, property);
            if (base) {
                if ((desc = Object.getOwnPropertyDescriptor(base, property)).set) return desc.set.call(receiver, value), 
                !0;
                if (!desc.writable) return !1;
            }
            if (desc = Object.getOwnPropertyDescriptor(receiver, property)) {
                if (!desc.writable) return !1;
                desc.value = value, Object.defineProperty(receiver, property, desc);
            } else _defineProperty(receiver, property, value);
            return !0;
        })(target, property, value, receiver);
    }
    function _set(target, property, value, receiver, isStrict) {
        if (!set(target, property, value, receiver || target) && isStrict) throw new Error("failed to set property");
        return value;
    }
    function _toConsumableArray(arr) {
        return function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) {
                for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                return arr2;
            }
        }(arr) || function _iterableToArray(iter) {
            if (Symbol.iterator in Object(iter) || "[object Arguments]" === Object.prototype.toString.call(iter)) return Array.from(iter);
        }(arr) || function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance");
        }();
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
        descriptor && Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
        });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        return Object.keys(descriptor).forEach((function(key) {
            desc[key] = descriptor[key];
        })), desc.enumerable = !!desc.enumerable, desc.configurable = !!desc.configurable, 
        ("value" in desc || desc.initializer) && (desc.writable = !0), desc = decorators.slice().reverse().reduce((function(desc, decorator) {
            return decorator(target, property, desc) || desc;
        }), desc), context && void 0 !== desc.initializer && (desc.value = desc.initializer ? desc.initializer.call(context) : void 0, 
        desc.initializer = void 0), void 0 === desc.initializer && (Object.defineProperty(target, property, desc), 
        desc = null), desc;
    }
    var _global = "undefined" == typeof window ? global : window, cc$1 = _global.cc = _global.cc || {};
    function defineMacro(name, defaultValue) {
        void 0 === _global[name] && (_global[name] = defaultValue);
    }
    cc$1.internal = cc$1.internal || {}, cc$1._global = _global, defineMacro("CC_BUILD", !1), 
    _global.CC_BUILD = !0, _global.CC_TEST = !1, _global.CC_EDITOR = !1, _global.CC_PREVIEW = !1, 
    _global.CC_DEV = !1, _global.CC_DEBUG = !0, _global.CC_JSB = !0, _global.CC_WECHAT = !1, 
    _global.CC_ALIPAY = !1, _global.CC_XIAOMI = !1, _global.CC_BAIDU = !1, _global.CC_COCOSPLAY = !1, 
    _global.CC_MINIGAME = !1, _global.CC_RUNTIME_BASED = !0, _global.CC_SUPPORT_JIT = !1, 
    _global.CC_PHYSICS_BUILTIN = !1, _global.CC_PHYSICS_CANNON = !0, _global.CC_PHYSICS_AMMO = !1;
    _global.CocosEngine = cc$1.ENGINE_VERSION = "1.0.4";
    var debugInfos = {
        1100: "Expected 'data' dict, but not found. Config file: %s",
        1101: "Please load the resource first : %s",
        1200: "cocos2d: Director: Error in gettimeofday",
        1204: "running scene should not null",
        1205: "the scene should not null",
        1206: "loadScene: The scene index to load (%s) is out of range.",
        1207: "loadScene: Unknown name type to load: '%s'",
        1208: "loadScene: Failed to load scene '%s' because '%s' is already loading",
        1209: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
        1210: "Failed to preload '%s', %s",
        1211: "loadScene: The scene index to load (%s) is out of range.",
        1212: "loadScene: Unknown name type to load: '%s'",
        1213: "loadScene: Failed to load scene '%s' because '%s' is already loading",
        1214: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
        1215: "Failed to preload '%s', %s",
        1216: "Director.runSceneImmediate: scene is not valid",
        1300: "element type is wrong!",
        1400: "'%s' is deprecated, please use '%s' instead.",
        1401: "The first argument should be the destination object",
        1402: "The 'visible' property of %s is deprecated, use 'enabled' instead please.",
        1403: "Sorry, cc.audioEngine.willPlayMusic is removed.",
        1404: "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
        1405: "The '%s' will be removed in v2.0, please use '%s' instead.",
        1406: "'%s.%s' is removed",
        1407: "cc.pool is being removed from v2.0, you are getting cc.js.Pool instead",
        1502: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
        1503: "cc.Scheduler.pauseTarget():target should be non-null",
        1504: "cc.Scheduler.resumeTarget():target should be non-null",
        1505: "cc.Scheduler.isTargetPaused():target should be non-null",
        1506: "warning: you CANNOT change update priority in scheduled function",
        1507: "scheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f",
        1508: "Argument callback must not be empty",
        1509: "Argument target must be non-nullptr",
        1510: "cc.Scheduler: Illegal target which doesn't have id, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
        1511: "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
        1512: "cc.Scheduler: updateFunc parameter is deprecated in scheduleUpdate function, and will be removed in v2.0",
        1513: "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
        1605: "child already added. It can't be added again",
        1606: "child must be non-null",
        1607: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
        1608: "boundingBox is deprecated. Use getBoundingBox instead",
        1609: "argument tag is an invalid tag",
        1619: "callback function must be non-null",
        1620: "interval must be positive",
        1623: "Set '%s' to normal node (not persist root node).",
        1624: "Replacing with the same sgNode",
        1625: "The replacement sgNode should not contain any child.",
        1626: "Should not set alpha via 'color', set 'opacity' please.",
        1627: "Not support for asynchronous creating node in SG",
        1632: "Node name can not include '/'.",
        1633: "Internal error, should not remove unknown node from parent.",
        1634: "addChild: The child to add must be instance of cc.Node, not %s.",
        1635: "reorderChild: this child is not in children list.",
        1636: "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
        1637: "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
        1638: "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
        1800: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
        1801: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
        1802: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
        1803: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
        1900: "Invalid parameter.",
        2200: "Resolution not valid",
        2201: "should set resolutionPolicy",
        2300: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
        3103: "textureUtil.addImage(): path should be non-null",
        3119: "Lazy init texture with image element failed due to image loading failure: %s",
        3300: "Rect width exceeds maximum margin: %s",
        3301: "Rect height exceeds maximum margin: %s",
        3500: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
        3501: "Invalid listener type!",
        3502: "Can't set fixed priority with scene graph based listener.",
        3503: "Invalid parameters.",
        3504: "listener must be a cc.EventListener object when adding a fixed priority listener",
        3505: "The listener has been registered, please don't register it again.",
        3506: "Unsupported listener target.",
        3507: "Invalid scene graph priority!",
        3508: "If program goes here, there should be event in dispatch.",
        3509: "_inDispatch should be 1 here.",
        3510: "%s's scene graph node not contains in the parent's children",
        3511: "event is undefined",
        3512: "Event manager only support scene graph priority for ui nodes which contain UIComponent",
        3600: "cc.Class will automatically call super constructor of %s, you should not call it manually.",
        3601: "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
        3602: "Unknown editor property '%s' in class '%s'.",
        3603: "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please.",
        3604: "Can only indicate one type attribute for %s.",
        3605: "The default value of %s is not instance of %s.",
        3606: "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
        3607: "The default value of %s must be an empty string.",
        3608: "The type of %s must be CCString, not String.",
        3609: "The type of %s must be CCBoolean, not Boolean.",
        3610: "The type of %s must be CCFloat or CCInteger, not Number.",
        3611: "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
        3612: "%s Just set the default value to 'new %s()' and it will be handled properly.",
        3613: "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
        3614: "Should not define constructor for cc.Component %s.",
        3615: "Each script can have at most one Component.",
        3616: "Should not specify class name %s for Component which defines in project.",
        3617: "Can not instantiate CCClass '%s' with arguments.",
        3618: "ctor of '%s' can not be another CCClass",
        3619: "ctor of '%s' must be function type",
        3620: "this._super declared in '%s.%s' but no super method defined",
        3621: "Unknown type of %s.%s, maybe you want is '%s'.",
        3622: "Unknown type of %s.%s, property should be defined in 'properties' or 'ctor'",
        3623: "Can not use 'editor' attribute, '%s' not inherits from Components.",
        3624: "'%s' overrided '%s' but '%s' is defined as 'false' so the super method will not be called. You can set '%s' to null to disable this warning.",
        3625: "[isChildClassOf] superclass should be function type, not",
        3626: "Can't remove '%s' because '%s' depends on it.",
        3627: "Should not add renderer component (%s) to a Canvas node.",
        3628: "Should not add %s to a node which size is already used by its other component.",
        3629: "attribute must be type object",
        3633: "Properties function of '%s' should return an object!",
        3634: "Disallow to use '.' in property name",
        3635: "Default array must be empty, set default value of %s.%s to [], and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = [...];')",
        3636: "Do not set default value to non-empty object, unless the object defines its own 'clone' function. Set default value of %s.%s to null or {}, and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = {foo: bar};')",
        3637: "Can not declare %s.%s, it is already defined in the prototype of %s",
        3638: "'%s': the getter of '%s' is already defined!",
        3639: "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
        3640: "'%s': the setter of '%s' is already defined!",
        3641: "Can not construct %s because it contains object property.",
        3642: "Cannot define %s.%s because static member name can not be '%s'.",
        3643: "Can not define a member called 'constructor' in the class '%s', please use 'ctor' instead.",
        3644: "Please define 'type' parameter of %s.%s as the actual constructor.",
        3645: "Please define 'type' parameter of %s.%s as the constructor of %s.",
        3646: "Unknown 'type' parameter of %s.%s：%s",
        3647: "The length of range array must be equal or greater than 2",
        3648: "Can not declare %s.%s method, it is already defined in the properties of %s.",
        3649: "CCClass %s have conflict between its ctor and __ctor__.",
        3651: 'Can not call `_super` or `prototype.ctor` in ES6 Classes "%s", use `super` instead please.',
        3652: 'Failed to construct a dummy instance of the "%s" class using `new` behind the scenes. This is for getting default values declared in TypeScript. Please ensure the class will be able to construct during script\'s initialization. %s.',
        3653: 'Please do not specifiy "default" attribute in decorator of "%s" property in "%s" class.\nDefault value must be initialized at their declaration:\n \n// Before:\n@property({ default: 0 }) // <--\n@integer\nvalue;\n// After:\n@integer\nvalue = 0;    // <--',
        3654: 'Please specifiy a default value for "%s" property at its declaration:\n \n// Before:\n@property(...)\nvalue;\n// After:\n@property(...)\nvalue = 0',
        3655: 'Can not specifiy "get" or "set"  attribute in decorator for "%s" property in "%s" class.\nPlease use:\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}',
        3656: "The default value of %s.%s must be an empty string. (changed since 1.8)",
        3657: "The value assigned to %s should be Texture2D object, not url string. Since 1.8,\nyou can declare a texture object directly in properties by using:\n \n{\n    default: null,\n    type: cc.Texture2D  // use 'type:' instead of 'url:'\n}",
        3658: "browser does not support getters",
        3659: "Violation error: extending enumerations shall have non-overlaped member names or member values",
        3660: "You are explicitly specifying `undefined` type to cc property \"%s\" of cc class \"%s\".\nIs this intended? If not, this may indicate a circular reference.\nFor example:\n \n// foo.ts\nimport { _decorator } from 'cc';\nimport { Bar } from './bar';  // Given that './bar' also reference 'foo.ts'.\n                              // When importing './bar', execution of './bar' is hung on to wait execution of 'foo.ts',\n                              // the `Bar` imported here is `undefined` until './bar' finish its execution.\n                              // It leads to that\n@_decorator.ccclass           //  ↓\nexport class Foo {            //  ↓\n    @_decorator.type(Bar)     //  → is equivalent to `@_decorator.type(undefined)`\n    public bar: Bar;          // To eliminate this error, either:\n                              // - Refactor your module structure(recommended), or\n                              // - specify the type as cc class name: `@_decorator.type('Bar'/* or any name you specified for `Bar` */)`\n}",
        3661: 'Register a cc-class through `cc.Class({ /* ... */ })` is deprecated (when registering cc-class "%s"). Use ES6 class syntax and decorators for that purpose instead.',
        3700: "internal error: _prefab is undefined",
        3701: "Failed to load prefab asset for node '%s'",
        3800: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
        3801: "The node can not be made persist because it's not under root node.",
        3802: "The node can not be made persist because it's not in current scene.",
        3803: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
        3804: "getComponent: Type must be non-nil",
        3805: "Can't add component '%s' because %s already contains the same component.",
        3806: "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
        3807: "addComponent: Failed to get class '%s'",
        3808: "addComponent: Should not add component ('%s') when the scripts are still loading.",
        3809: "addComponent: The component to add must be a constructor",
        3810: "addComponent: The component to add must be child class of cc.Component",
        3811: "_addComponentAt: The component to add must be a constructor",
        3812: "_addComponentAt: Index out of range",
        3813: "removeComponent: Component must be non-nil",
        3814: "Argument must be non-nil",
        3815: "Component not owned by this entity",
        3816: "Node '%s' is already activating",
        3817: "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
        3818: "Failed to read or parse project.json",
        3819: "Warning: target element is not a DIV or CANVAS",
        3820: "The renderer doesn't support the renderMode %s",
        3821: "Cannot change hierarchy while activating or deactivating the parent.",
        3822: "addComponent: Cannot add any component to the scene.",
        3900: "Invalid clip to add",
        3901: "Invalid clip to remove",
        3902: "clip is defaultClip, set force to true to force remove clip and animation state",
        3903: "animation state is playing, set force to true to force stop and remove clip and animation state",
        3904: "motion path of target [%s] in prop [%s] frame [%s] is not valid",
        3905: "sprite frames must be an Array.",
        3906: "Can't find easing type [%s]",
        3907: "animator not added or already removed",
        3908: "animation not added or already removed",
        3912: "already-playing",
        4e3: "Sorry, the cc.Font has been modified from Raw Asset to Asset. Please load the font asset before using.",
        4003: "Label font size can't be shirnked less than 0!",
        4004: "force notify all fonts loaded!",
        4011: "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
        4012: "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
        4013: "Sorry, lineHeight of system font not supported on JSB.",
        4100: "Property padding is deprecated, please use paddingLeft, paddingRight, paddingTop and paddingBottom instead",
        4200: "MaskType: IMAGE_STENCIL only support WebGL mode.",
        4201: "The alphaThreshold invalid in Canvas Mode.",
        4202: "The inverted invalid in Canvas Mode.",
        4300: "can not found the %s page.",
        4400: "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
        4600: "Script attached to '%s' is missing or invalid.",
        4700: "The dom control is not created!",
        4800: "unknown asset type",
        4901: "loadRes: should not specify the extname in %s %s",
        4902: "No need to release non-cached asset.",
        4903: "Can not get class '%s'",
        4914: "Resources url '%s' does not exist.",
        4915: "Pack indices and data do not match in size",
        4916: "Failed to download package for %s",
        4920: "Sorry, you shouldn't use id as item identity any more, please use url or uuid instead, the current id is being set as url: (%s)",
        4921: "Invalid pipe or invalid index provided!",
        4922: "The pipe to be inserted is already in the pipeline!",
        4923: "Uuid Loader: Parse asset [ %s ] failed : %s",
        4924: "JSON Loader: Input item doesn't contain string content",
        4925: "Uuid Loader: Deserialize asset [ %s ] failed : %s",
        4926: "Audio Downloader: no web audio context.",
        4927: "Audio Downloader: audio not supported on this browser!",
        4928: "Load %s failed!",
        4929: "Load Webp ( %s ) failed",
        4930: "Load image ( %s ) failed",
        4931: "Download Uuid: can not find type of raw asset[ %s ]: %s",
        4932: 'Since v1.10, for any atlas ("%s") in the "resources" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.',
        4933: "Download Font [ %s ] failed, using Arial or system default font instead",
        4934: "Please assure that the full path of sub asset is correct!",
        4935: "Failed to skip prefab asset while deserializing PrefabInfo",
        5e3: "object already destroyed",
        5001: "object not yet destroyed",
        5100: "Not a plist file!",
        5200: "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
        5201: "browser don't support web audio",
        5202: "This feature supports WebGL render mode only.",
        5300: "Type of target to deserialize not matched with data: target is %s, data is %s",
        5301: "Can not find script '%s'",
        5302: "Can not find class '%s'",
        5400: "'%s' is deprecated, use '%s' instead please.",
        5401: "'%s' is deprecated, use '%s' instead please.",
        5402: "cc.js.addon called on non-object:",
        5403: "cc.js.mixin: arguments must be type object:",
        5404: "The base class to extend from must be non-nil",
        5405: "The class to extend must be non-nil",
        5406: "Class should be extended before assigning any prototype members.",
        5500: "'notify' can't work with 'get/set' !",
        5501: "'notify' must work with 'default' !",
        5502: "Invalid url of %s.%s",
        5503: "The 'url' attribute of '%s.%s' is undefined when loading script.",
        5504: "The 'url' type of '%s.%s' must be child class of cc.RawAsset.",
        5505: "The 'url' type of '%s.%s' must not be child class of cc.Asset, otherwise you should use 'type: %s' instead.",
        5506: "Can not specify 'type' attribute for '%s.%s', because its 'url' is already defined.",
        5507: "The 'default' attribute of '%s.%s' must be an array",
        5508: "Invalid type of %s.%s",
        5510: "The 'type' attribute of '%s.%s' can not be 'Number', use 'Float' or 'Integer' instead please.",
        5511: "The 'type' attribute of '%s.%s' is undefined when loading script",
        5512: "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
        5513: "The 'default' value of '%s.%s' should not be used with a 'get' function.",
        5514: "The 'default' value of '%s.%s' should not be used with a 'set' function.",
        5515: "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
        5516: "Property '%s.%s' must define at least one of 'default', 'get' or 'set'.",
        5517: "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
        5600: "Argument must be non-nil",
        5601: "Can not get current scene.",
        5602: "Scene is destroyed",
        5603: "reference node is destroyed",
        5700: "no %s or %s on %s",
        5800: "%s.lerp not yet implemented.",
        5801: "%s.clone not yet implemented.",
        5802: "%s.equals not yet implemented.",
        5900: "MotionStreak only support WebGL mode.",
        5901: "cc.MotionStreak.getOpacity has not been supported.",
        5902: "cc.MotionStreak.setOpacity has not been supported.",
        6e3: "Custom should not be false if file is not specified.",
        6001: "The new %s must not be NaN",
        6017: "Incomplete or corrupt PNG file",
        6018: "Invalid filter algorithm: %s",
        6019: "Invalid byte order value.",
        6020: "You forgot your towel!",
        6021: "Unknown Field Tag: %s",
        6022: "Too many bits requested",
        6023: "No bits requested",
        6024: "Cannot recover from missing StripByteCounts",
        6025: "Cannot handle sub-byte bits per sample",
        6026: "Cannot handle sub-byte bits per pixel",
        6027: "Palette image missing color map",
        6028: "Unknown Photometric Interpretation: %s",
        6029: "Unkown error",
        6030: "cc.ParticleSystem: error decoding or ungzipping textureImageData",
        6031: "cc.ParticleSystem: unknown image format with Data",
        6032: "cc.ParticleSystem.initWithDictionary() : error loading the texture",
        6200: "Canvas doesn't support mesh slot!",
        6300: "only cc.DrawNode is accepted as stencil",
        6301: "Stencil buffer is not enabled.",
        6302: "Nesting more than %d stencils is not supported. Everything will be drawn without stencil for this node and its children.",
        6400: "asset.url is not usable in core process",
        6401: "asset.urls is not usable in core process",
        6402: "AssetLibrary has already been initialized!",
        6500: "Widget target must be one of the parent nodes of it",
        6501: "%s's widget target must have UITransformComponent, Please add it in target",
        6600: "collider not added or already removed",
        6601: "Can't find testFunc for (%s, $s).",
        6700: "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time",
        6701: "Should not add Canvas to a node which already contains a renderer component (%s).",
        6702: "Should not add Canvas to a node which size is already used by its other component.",
        6703: "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext",
        6704: "Polygon's point must greater than 2",
        6705: "Argument must be non-nil",
        6800: "Callback of event must be non-nil",
        6801: "The message must be provided",
        6900: "The thing you want to instantiate must be an object",
        6901: "The thing you want to instantiate is nil",
        6902: "The thing you want to instantiate is destroyed",
        6903: "The instantiate method for given asset do not implemented",
        6904: "Can not instantiate array",
        6905: "Can not instantiate DOM element",
        7e3: "Failed to init asset's raw path.",
        7001: "Should not load '%s' from script dynamically, unless it is placed in the 'resources' folder.",
        7002: "Sorry can not load '%s' because it is not placed in the 'resources' folder.",
        7003: "Failed to init builtin asset's raw path.",
        7100: "%s already defined in Enum.",
        7101: "Sorry, 'cc.Enum' not available on this platform, please report this error here: https://github.com/cocos-creator/engine/issues/new",
        7200: "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
        7201: "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
        7202: "Add component TiledLayer into node failed.",
        7203: "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
        7210: "TMX Hexa zOrder not supported",
        7211: "TMX invalid value",
        7214: "propertiesForGID is deprecated. Please use getPropertiesForGID instead.",
        7215: "cocos2d: Warning: TMX Layer %s has no tiles",
        7216: "cocos2d: TMXFormat: Unsupported TMX version: %s",
        7217: "cocos2d: TMXFomat: Unsupported orientation: %s",
        7218: "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
        7219: "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
        7221: "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
        7222: "Parse %s failed.",
        7236: "cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
        7237: "cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
        7238: "cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
        7239: "cc.TMXLayer.setTileGID(): invalid gid: %s",
        7240: "cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
        7241: "cc.TiledMap.initWithXML(): Map not found. Please check the filename.",
        7401: "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
        7402: "Failed to set _animationIndex for '%s' because the index is out of range.",
        7501: "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
        7502: "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
        7503: "Failed to set _animationIndex for '%s' because the index is out of range.",
        7504: "Can not render dynamic created SkeletonData",
        7505: "Invalid type of atlasFile, atlas should be registered as raw asset.",
        7506: "Failed to load spine atlas '$s'",
        7507: "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
        7508: "The atlas asset of '%s' is not exists!",
        7509: "Spine: Animation not found: %s",
        7510: "Spine: Animation not found: %s",
        7600: "The context of RenderTexture is invalid.",
        7601: "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
        7602: "Could not attach texture to the framebuffer",
        7603: "clearDepth isn't supported on Cocos2d-Html5",
        7604: "saveToFile isn't supported on Cocos2d-Html5",
        7605: "newCCImage isn't supported on Cocos2d-Html5",
        7700: "On the web is always keep the aspect ratio",
        7701: "Can't know status",
        7702: "Video player's duration is not ready to get now!",
        7800: "Web does not support loading",
        7801: "Web does not support query history",
        7802: "Web does not support query history",
        7803: "The current browser does not support the GoBack",
        7804: "The current browser does not support the GoForward",
        7805: "Web does not support zoom",
        7900: "cc.math.Matrix3.assign(): current matrix equals matIn",
        7901: "cc.math.mat4Assign(): pOut equals pIn",
        7902: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
        7903: "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
        7904: "cc.math.Matrix4.extractPlane: Invalid plane index",
        7905: "cc.math.mat4Assign(): pOut equals pIn",
        7906: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
        7907: "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
        7908: "Invalid matrix mode specified",
        7909: "current quaternion is an invalid value",
        8e3: "Can't handle this field type or size",
        8001: "No bytes requested",
        8002: "Too many bytes requested",
        8003: "Missing StripByteCounts!",
        8100: "cocos2d: ERROR: Failed to compile shader:\n %s",
        8101: "cocos2d: ERROR: Failed to compile vertex shader",
        8102: "cocos2d: ERROR: Failed to compile fragment shader",
        8103: "cc.GLProgram.link(): Cannot link invalid program",
        8104: "cocos2d: ERROR: Failed to link program: %s",
        8105: "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
        8106: "Please load the resource firset : %s",
        8107: "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
        8108: "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
        8109: "modelView matrix is undefined.",
        8200: "Please set node's active instead of rigidbody's enabled.",
        8300: "Should only one camera exists, please check your project.",
        8301: "Camera does not support Canvas Mode.",
        8400: "Wrong type arguments, 'filePath' must be a String.",
        8401: "Since 1.10, `%s` accept %s instance directly, not a URL string. Please directly reference the %s object in your script, or load %s by loader first. Don't use %s's URL anymore.",
        9e3: "Stencil manager does not support level bigger than %d in this device.",
        9001: "Stencil manager is already empty, cannot pop any mask",
        9100: "texture size exceeds current device limits %d/%d",
        9200: "Priority can't be set in Canvas node",
        9300: "The current buffer beyond the limit in ui static component, please reduce the amount",
        9301: "The UI has not been initialized",
        10001: "The sub-mesh contains %d vertices, which beyonds the capability (%d vertices most) of renderer of your platform.",
        "0100": "%s not yet implemented.",
        "0200": "You should specify a valid DOM canvas element."
    }, logList = null, ccLog = console.log, ccWarn = console.log, ccError = console.log, ccAssert = function ccAssert(condition, message) {
        if (!condition) {
            for (var _len = arguments.length, optionalParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) optionalParams[_key - 2] = arguments[_key];
            console.log("ASSERT: " + formatString.apply(void 0, [ message ].concat(optionalParams)));
        }
    };
    function formatString(message) {
        for (var _len2 = arguments.length, optionalParams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) optionalParams[_key2 - 1] = arguments[_key2];
        return cc.js.formatStr.apply(null, [ message ].concat(optionalParams));
    }
    function log(message) {
        for (var _len3 = arguments.length, optionalParams = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) optionalParams[_key3 - 1] = arguments[_key3];
        return ccLog.apply(void 0, [ message ].concat(optionalParams));
    }
    function warn(message) {
        for (var _len4 = arguments.length, optionalParams = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) optionalParams[_key4 - 1] = arguments[_key4];
        return ccWarn.apply(void 0, [ message ].concat(optionalParams));
    }
    function error(message) {
        for (var _len5 = arguments.length, optionalParams = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) optionalParams[_key5 - 1] = arguments[_key5];
        return ccError.apply(void 0, [ message ].concat(optionalParams));
    }
    function assert(value, message) {
        for (var _len6 = arguments.length, optionalParams = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) optionalParams[_key6 - 2] = arguments[_key6];
        return ccAssert.apply(void 0, [ value, message ].concat(optionalParams));
    }
    function _resetDebugSetting(mode) {
        if (ccLog = ccWarn = ccError = ccAssert = function ccAssert() {}, mode !== DebugMode.NONE) {
            if (mode > DebugMode.ERROR) {
                var logToWebPage = function logToWebPage(msg) {
                    if (cc.game.canvas) {
                        if (!logList) {
                            var logDiv = document.createElement("Div");
                            logDiv.setAttribute("id", "logInfoDiv"), logDiv.setAttribute("width", "200"), logDiv.setAttribute("height", cc.game.canvas.height);
                            var logDivStyle = logDiv.style;
                            logDivStyle.zIndex = "99999", logDivStyle.position = "absolute", logDivStyle.top = logDivStyle.left = "0", 
                            (logList = document.createElement("textarea")).setAttribute("rows", "20"), logList.setAttribute("cols", "30"), 
                            logList.setAttribute("disabled", "true");
                            var logListStyle = logList.style;
                            logListStyle.backgroundColor = "transparent", logListStyle.borderBottom = "1px solid #cccccc", 
                            logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = "0px", 
                            logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = "none", 
                            logListStyle.padding = "0px", logListStyle.margin = "0px", logDiv.appendChild(logList), 
                            cc.game.canvas.parentNode.appendChild(logDiv);
                        }
                        logList.value = logList.value + msg + "\r\n", logList.scrollTop = logList.scrollHeight;
                    }
                };
                ccError = function ccError(message) {
                    for (var _len7 = arguments.length, optionalParams = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) optionalParams[_key7 - 1] = arguments[_key7];
                    logToWebPage("ERROR :  " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                }, ccAssert = function ccAssert(condition, message) {
                    if (!condition) {
                        for (var _len8 = arguments.length, optionalParams = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) optionalParams[_key8 - 2] = arguments[_key8];
                        logToWebPage("ASSERT: " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                    }
                }, mode !== DebugMode.ERROR_FOR_WEB_PAGE && (ccWarn = function ccWarn(message) {
                    for (var _len9 = arguments.length, optionalParams = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) optionalParams[_key9 - 1] = arguments[_key9];
                    logToWebPage("WARN :  " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                }), mode === DebugMode.INFO_FOR_WEB_PAGE && (ccLog = function ccLog(message) {
                    for (var _len10 = arguments.length, optionalParams = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) optionalParams[_key10 - 1] = arguments[_key10];
                    logToWebPage(formatString.apply(void 0, [ message ].concat(optionalParams)));
                });
            } else console && console.log.apply && (console.error || (console.error = console.log), 
            console.warn || (console.warn = console.log), ccError = console.error.bind ? console.error.bind(console) : console.error, 
            ccAssert = function ccAssert(condition, message) {
                if (!condition) {
                    for (var _len12 = arguments.length, optionalParams = new Array(_len12 > 2 ? _len12 - 2 : 0), _key12 = 2; _key12 < _len12; _key12++) optionalParams[_key12 - 2] = arguments[_key12];
                    var errorText = formatString.apply(void 0, [ message ].concat(optionalParams));
                    throw new Error(errorText);
                }
            });
            mode !== DebugMode.ERROR && (ccWarn = console.warn.bind ? console.warn.bind(console) : console.warn), 
            mode === DebugMode.INFO && (ccLog = "JavaScriptCore" === scriptEngineType ? function ccLog(message) {
                for (var _len14 = arguments.length, optionalParams = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) optionalParams[_key14 - 1] = arguments[_key14];
                return console.log.apply(console, [ message ].concat(optionalParams));
            } : console.log);
        }
    }
    function _throw(error_) {
        var stack = error_.stack;
        error(stack ? error_ + "\n" + stack : error_);
    }
    function getTypedFormatter(type) {
        return function(id) {
            for (var msg = debugInfos[id] || "unknown id", _len16 = arguments.length, args = new Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) args[_key16 - 1] = arguments[_key16];
            return 0 === args.length ? msg : formatString.apply(void 0, [ msg ].concat(args));
        };
    }
    var logFormatter = getTypedFormatter();
    function logID(id) {
        for (var _len17 = arguments.length, optionalParams = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) optionalParams[_key17 - 1] = arguments[_key17];
        log(logFormatter.apply(void 0, [ id ].concat(optionalParams)));
    }
    var warnFormatter = getTypedFormatter();
    function warnID(id) {
        for (var _len18 = arguments.length, optionalParams = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) optionalParams[_key18 - 1] = arguments[_key18];
        warn(warnFormatter.apply(void 0, [ id ].concat(optionalParams)));
    }
    var errorFormatter = getTypedFormatter();
    function errorID(id) {
        for (var _len19 = arguments.length, optionalParams = new Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) optionalParams[_key19 - 1] = arguments[_key19];
        error(errorFormatter.apply(void 0, [ id ].concat(optionalParams)));
    }
    var DebugMode, assertFormatter = getTypedFormatter();
    function assertID(condition, id) {
        if (!condition) {
            for (var _len20 = arguments.length, optionalParams = new Array(_len20 > 2 ? _len20 - 2 : 0), _key20 = 2; _key20 < _len20; _key20++) optionalParams[_key20 - 2] = arguments[_key20];
            assert(!1, assertFormatter.apply(void 0, [ id ].concat(optionalParams)));
        }
    }
    function getError(errorId) {
        for (var _len21 = arguments.length, param = new Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) param[_key21 - 1] = arguments[_key21];
        return errorFormatter.apply(void 0, [ errorId ].concat(param));
    }
    function isDisplayStats() {
        return !!cc.profiler && cc.profiler.isShowingStats();
    }
    function setDisplayStats(displayStats) {
        cc.profiler && (displayStats ? cc.profiler.showStats() : cc.profiler.hideStats(), 
        cc.game.config.showFPS = !!displayStats);
    }
    !function(DebugMode) {
        DebugMode[DebugMode.NONE = 0] = "NONE", DebugMode[DebugMode.INFO = 1] = "INFO", 
        DebugMode[DebugMode.WARN = 2] = "WARN", DebugMode[DebugMode.ERROR = 3] = "ERROR", 
        DebugMode[DebugMode.INFO_FOR_WEB_PAGE = 4] = "INFO_FOR_WEB_PAGE", DebugMode[DebugMode.WARN_FOR_WEB_PAGE = 5] = "WARN_FOR_WEB_PAGE", 
        DebugMode[DebugMode.ERROR_FOR_WEB_PAGE = 6] = "ERROR_FOR_WEB_PAGE";
    }(DebugMode || (DebugMode = {}));
    var debug = Object.freeze({
        __proto__: null,
        log: log,
        warn: warn,
        error: error,
        assert: assert,
        _resetDebugSetting: _resetDebugSetting,
        _throw: _throw,
        logID: logID,
        warnID: warnID,
        errorID: errorID,
        assertID: assertID,
        get DebugMode() {
            return DebugMode;
        },
        getError: getError,
        isDisplayStats: isDisplayStats,
        setDisplayStats: setDisplayStats
    }), EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/, DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/, NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
    function join() {
        for (var result = "", _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++) segments[_key] = arguments[_key];
        for (var _i = 0, _segments = segments; _i < _segments.length; _i++) {
            var segment = _segments[_i];
            result = (result + ("" === result ? "" : "/") + segment).replace(/(\/|\\\\)$/, "");
        }
        return result;
    }
    function extname(path) {
        var temp = EXTNAME_RE.exec(path);
        return temp ? temp[1] : "";
    }
    function mainFileName(fileName) {
        if (fileName) {
            var idx = fileName.lastIndexOf(".");
            if (-1 !== idx) return fileName.substring(0, idx);
        }
        return fileName;
    }
    function basename(path, extName) {
        var index = path.indexOf("?");
        index > 0 && (path = path.substring(0, index));
        var result = /(\/|\\)([^\/\\]+)$/g.exec(path.replace(/(\/|\\)$/, ""));
        if (!result) return "";
        var baseName = result[2];
        return extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase() ? baseName.substring(0, baseName.length - extName.length) : baseName;
    }
    function dirname(path) {
        var temp = DIRNAME_RE.exec(path);
        return temp ? temp[2] : "";
    }
    function changeExtname(path, extName) {
        extName = extName || "";
        var index = path.indexOf("?"), tempStr = "";
        return index > 0 && (tempStr = path.substring(index), path = path.substring(0, index)), 
        (index = path.lastIndexOf(".")) < 0 ? path + extName + tempStr : path.substring(0, index) + extName + tempStr;
    }
    function changeBasename(path, baseName, isSameExt) {
        if (0 === baseName.indexOf(".")) return changeExtname(path, baseName);
        var index = path.indexOf("?"), tempStr = "", ext = isSameExt ? extname(path) : "";
        return index > 0 && (tempStr = path.substring(index), path = path.substring(0, index)), 
        index = (index = path.lastIndexOf("/")) <= 0 ? 0 : index + 1, path.substring(0, index) + baseName + ext + tempStr;
    }
    function _normalize(url) {
        var oldUrl = url = String(url);
        do {
            oldUrl = url, url = url.replace(NORMALIZE_RE, "");
        } while (oldUrl.length !== url.length);
        return url;
    }
    function stripSep(path) {
        return path.replace(/[\/\\]$/, "");
    }
    function getSeperator() {
        return cc.sys.os === cc.sys.OS_WINDOWS ? "\\" : "/";
    }
    var path = Object.freeze({
        __proto__: null,
        join: join,
        extname: extname,
        mainFileName: mainFileName,
        basename: basename,
        dirname: dirname,
        changeExtname: changeExtname,
        changeBasename: changeBasename,
        _normalize: _normalize,
        stripSep: stripSep,
        getSeperator: getSeperator
    });
    cc.log = log, cc.warn = warn, cc.error = error, cc.assert = assert, cc._throw = _throw, 
    cc.logID = logID, cc.warnID = warnID, cc.errorID = errorID, cc.assertID = assertID, 
    cc.debug = debug, cc.path = {
        join: join,
        extname: extname,
        mainFileName: mainFileName,
        basename: basename,
        dirname: dirname,
        changeExtname: changeExtname,
        changeBasename: changeBasename,
        _normalize: _normalize,
        stripSep: stripSep,
        get sep() {
            return getSeperator();
        }
    };
    var enums = {
        SHAPE_RAY: 1,
        SHAPE_LINE: 2,
        SHAPE_SPHERE: 4,
        SHAPE_AABB: 8,
        SHAPE_OBB: 16,
        SHAPE_PLANE: 32,
        SHAPE_TRIANGLE: 64,
        SHAPE_FRUSTUM: 128,
        SHAPE_FRUSTUM_ACCURATE: 256,
        SHAPE_CAPSULE: 512
    };
    function sign(v) {
        return (v > 0) - (v < 0);
    }
    function countTrailingZeros(v) {
        var c = 32;
        return (v &= -v) && c--, 65535 & v && (c -= 16), 16711935 & v && (c -= 8), 252645135 & v && (c -= 4), 
        858993459 & v && (c -= 2), 1431655765 & v && (c -= 1), c;
    }
    var REVERSE_TABLE = new Array(256);
    !function(tab) {
        for (var i = 0; i < 256; ++i) {
            var v = i, r = i, s = 7;
            for (v >>>= 1; v; v >>>= 1) r <<= 1, r |= 1 & v, --s;
            tab[i] = r << s & 255;
        }
    }(REVERSE_TABLE);
    var bits = Object.freeze({
        __proto__: null,
        INT_BITS: 32,
        INT_MAX: 2147483647,
        INT_MIN: -1 << 31,
        sign: sign,
        abs: function abs(v) {
            var mask = v >> 31;
            return (v ^ mask) - mask;
        },
        min: function min(x, y) {
            return y ^ (x ^ y) & -(x < y);
        },
        max: function max(x, y) {
            return x ^ (x ^ y) & -(x < y);
        },
        isPow2: function isPow2(v) {
            return !(v & v - 1 || !v);
        },
        log2: function log2(v) {
            var r, shift;
            return r = (v > 65535) << 4, r |= shift = ((v >>>= r) > 255) << 3, r |= shift = ((v >>>= shift) > 15) << 2, 
            (r |= shift = ((v >>>= shift) > 3) << 1) | (v >>>= shift) >> 1;
        },
        log10: function log10(v) {
            return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
        },
        popCount: function popCount(v) {
            return 16843009 * ((v = (858993459 & (v -= v >>> 1 & 1431655765)) + (v >>> 2 & 858993459)) + (v >>> 4) & 252645135) >>> 24;
        },
        countTrailingZeros: countTrailingZeros,
        nextPow2: function nextPow2(v) {
            return v += 0 === v, --v, v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, 
            (v |= v >>> 16) + 1;
        },
        prevPow2: function prevPow2(v) {
            return v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, (v |= v >>> 16) - (v >>> 1);
        },
        parity: function parity(v) {
            return v ^= v >>> 16, v ^= v >>> 8, v ^= v >>> 4, 27030 >>> (v &= 15) & 1;
        },
        reverse: function reverse(v) {
            return REVERSE_TABLE[255 & v] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
        },
        interleave2: function interleave2(x, y) {
            return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x &= 65535) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y &= 65535) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1;
        },
        deinterleave2: function deinterleave2(v, n) {
            return (v = 65535 & ((v = 16711935 & ((v = 252645135 & ((v = 858993459 & ((v = v >>> n & 1431655765) | v >>> 1)) | v >>> 2)) | v >>> 4)) | v >>> 16)) << 16 >> 16;
        },
        interleave3: function interleave3(x, y, z) {
            return x = 1227133513 & ((x = 3272356035 & ((x = 251719695 & ((x = 4278190335 & ((x &= 1023) | x << 16)) | x << 8)) | x << 4)) | x << 2), 
            (x |= (y = 1227133513 & ((y = 3272356035 & ((y = 251719695 & ((y = 4278190335 & ((y &= 1023) | y << 16)) | y << 8)) | y << 4)) | y << 2)) << 1) | (z = 1227133513 & ((z = 3272356035 & ((z = 251719695 & ((z = 4278190335 & ((z &= 1023) | z << 16)) | z << 8)) | z << 4)) | z << 2)) << 2;
        },
        deinterleave3: function deinterleave3(v, n) {
            return (v = 1023 & ((v = 4278190335 & ((v = 251719695 & ((v = 3272356035 & ((v = v >>> n & 1227133513) | v >>> 2)) | v >>> 4)) | v >>> 8)) | v >>> 16)) << 22 >> 22;
        },
        nextCombination: function nextCombination(v) {
            var t = v | v - 1;
            return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
        }
    }), MutableForwardIterator = function() {
        function MutableForwardIterator(array) {
            _classCallCheck(this, MutableForwardIterator), this.i = 0, this.array = array;
        }
        return _createClass(MutableForwardIterator, [ {
            key: "remove",
            value: function remove(value) {
                var index = this.array.indexOf(value);
                index >= 0 && this.removeAt(index);
            }
        }, {
            key: "removeAt",
            value: function removeAt(i) {
                this.array.splice(i, 1), i <= this.i && --this.i;
            }
        }, {
            key: "fastRemove",
            value: function fastRemove(value) {
                var index = this.array.indexOf(value);
                index >= 0 && this.fastRemoveAt(index);
            }
        }, {
            key: "fastRemoveAt",
            value: function fastRemoveAt(i) {
                var array = this.array;
                array[i] = array[array.length - 1], --array.length, i <= this.i && --this.i;
            }
        }, {
            key: "push",
            value: function push(item) {
                this.array.push(item);
            }
        }, {
            key: "length",
            get: function get() {
                return this.array.length;
            },
            set: function set(value) {
                this.array.length = value, this.i >= value && (this.i = value - 1);
            }
        } ]), MutableForwardIterator;
    }();
    function removeAt(array, index) {
        array.splice(index, 1);
    }
    function remove(array, value) {
        var index = array.indexOf(value);
        return index >= 0 && (removeAt(array, index), !0);
    }
    function contains(array, value) {
        return array.indexOf(value) >= 0;
    }
    var jsarray = Object.freeze({
        __proto__: null,
        removeAt: removeAt,
        fastRemoveAt: function fastRemoveAt(array, index) {
            var length = array.length;
            index < 0 || index >= length || (array[index] = array[length - 1], array.length = length - 1);
        },
        remove: remove,
        fastRemove: function fastRemove(array, value) {
            var index = array.indexOf(value);
            index >= 0 && (array[index] = array[array.length - 1], --array.length);
        },
        removeIf: function removeIf(array, predicate) {
            var index = array.findIndex(predicate);
            if (index >= 0) {
                var _value = array[index];
                return removeAt(array, index), _value;
            }
        },
        verifyType: function verifyType(array, type) {
            if (array && array.length > 0) {
                var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    if (!(_ref instanceof type)) return cc.logID(1300), !1;
                }
            }
            return !0;
        },
        removeArray: function removeArray(array, minusArr) {
            for (var i = 0, l = minusArr.length; i < l; i++) remove(array, minusArr[i]);
        },
        appendObjectsAt: function appendObjectsAt(array, addObjs, index) {
            return array.splice.apply(array, [ index, 0 ].concat(_toConsumableArray(addObjs))), 
            array;
        },
        indexOf: function indexOf(array, searchElement, fromIndex) {
            return Array.prototype.indexOf.call(array, [ searchElement, fromIndex ]);
        },
        contains: contains,
        copy: function copy(array) {
            for (var len = array.length, arr_clone = new Array(len), i = 0; i < len; i += 1) arr_clone[i] = array[i];
            return arr_clone;
        },
        MutableForwardIterator: MutableForwardIterator
    }), IDGenerator = function() {
        function IDGenerator(category) {
            _classCallCheck(this, IDGenerator), this.id = 0 | 998 * Math.random(), this.prefix = category ? category + "." : "";
        }
        return _createClass(IDGenerator, [ {
            key: "getNewId",
            value: function getNewId() {
                return this.prefix + ++this.id;
            }
        } ]), IDGenerator;
    }();
    IDGenerator.global = new IDGenerator("global");
    var tempCIDGenerator = new IDGenerator("TmpCId.");
    function isNumber(object) {
        return "number" == typeof object || object instanceof Number;
    }
    function isString(object) {
        return "string" == typeof object || object instanceof String;
    }
    var descriptor, value = (descriptor = {
        value: void 0,
        enumerable: !1,
        writable: !1,
        configurable: !0
    }, function(object, propertyName, value_, writable, enumerable) {
        descriptor.value = value_, descriptor.writable = writable, descriptor.enumerable = enumerable, 
        Object.defineProperty(object, propertyName, descriptor), descriptor.value = void 0;
    }), getset = function() {
        var descriptor = {
            get: void 0,
            set: void 0,
            enumerable: !1
        };
        return function(object, propertyName, getter, setter) {
            var enumerable = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], configurable = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
            "boolean" == typeof setter && (enumerable = setter, setter = void 0), descriptor.get = getter, 
            descriptor.set = setter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
            Object.defineProperty(object, propertyName, descriptor), descriptor.get = void 0, 
            descriptor.set = void 0;
        };
    }(), get = function() {
        var descriptor = {
            get: void 0,
            enumerable: !1,
            configurable: !1
        };
        return function(object, propertyName, getter, enumerable, configurable) {
            descriptor.get = getter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
            Object.defineProperty(object, propertyName, descriptor), descriptor.get = void 0;
        };
    }(), set$1 = function() {
        var descriptor = {
            set: void 0,
            enumerable: !1,
            configurable: !1
        };
        return function(object, propertyName, setter, enumerable, configurable) {
            descriptor.set = setter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
            Object.defineProperty(object, propertyName, descriptor), descriptor.set = void 0;
        };
    }();
    function createMap(forceDictMode) {
        var map = Object.create(null);
        if (forceDictMode) {
            map["."] = !0, map["/"] = !0, delete map["."], delete map["/"];
        }
        return map;
    }
    function getClassName(objOrCtor) {
        if ("function" == typeof objOrCtor) {
            var prototype = objOrCtor.prototype;
            if (prototype && prototype.hasOwnProperty("__classname__") && prototype.__classname__) return prototype.__classname__;
            var retval = "";
            if (objOrCtor.name && (retval = objOrCtor.name), objOrCtor.toString) {
                var arr, str = objOrCtor.toString();
                (arr = "[" === str.charAt(0) ? str.match(/\[\w+\s*(\w+)\]/) : str.match(/function\s*(\w+)/)) && 2 === arr.length && (retval = arr[1]);
            }
            return "Object" !== retval ? retval : "";
        }
        return objOrCtor && objOrCtor.constructor ? getClassName(objOrCtor.constructor) : "";
    }
    function obsolete(object, obsoleted, newExpr, writable) {
        var extractPropName = /([^.]+)$/, oldProp = extractPropName.exec(obsoleted)[0], newProp = extractPropName.exec(newExpr)[0];
        function getter() {
            return this[newProp];
        }
        writable ? getset(object, oldProp, getter, (function setter(value_) {
            this[newProp] = value_;
        })) : get(object, oldProp, getter);
    }
    function obsoletes(obj, objName, props, writable) {
        for (var obsoleted in props) {
            obsolete(obj, objName + "." + obsoleted, props[obsoleted], writable);
        }
    }
    var REGEXP_NUM_OR_STR = /(%d)|(%s)/, REGEXP_STR = /%s/;
    function formatStr(msg) {
        for (var _len = arguments.length, subst = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) subst[_key - 1] = arguments[_key];
        if (0 === arguments.length) return "";
        if (0 === subst.length) return "" + msg;
        var hasSubstitution = "string" == typeof msg && REGEXP_NUM_OR_STR.test(msg);
        if (hasSubstitution) {
            var _iterator = subst, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var arg = _ref, regExpToTest = "number" == typeof arg ? REGEXP_NUM_OR_STR : REGEXP_STR;
                regExpToTest.test(msg) ? msg = msg.replace(regExpToTest, arg) : msg += " " + arg;
            }
        } else {
            var _iterator2 = subst, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                msg += " " + _ref2;
            }
        }
        return msg;
    }
    function shiftArguments() {
        for (var len = arguments.length - 1, args = new Array(len), i = 0; i < len; ++i) args[i] = arguments[i + 1];
        return args;
    }
    function getPropertyDescriptor(object, propertyName) {
        for (;object; ) {
            var pd = Object.getOwnPropertyDescriptor(object, propertyName);
            if (pd) return pd;
            object = Object.getPrototypeOf(object);
        }
        return null;
    }
    function _copyprop(name, source, target) {
        var pd = getPropertyDescriptor(source, name);
        pd && Object.defineProperty(target, name, pd);
    }
    function addon(object) {
        object = object || {};
        for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) sources[_key2 - 1] = arguments[_key2];
        for (var _i3 = 0, _sources = sources; _i3 < _sources.length; _i3++) {
            var source = _sources[_i3];
            if (source) {
                if ("object" !== _typeof(source)) {
                    cc.errorID(5402, source);
                    continue;
                }
                for (var name in source) name in object || _copyprop(name, source, object);
            }
        }
        return object;
    }
    function mixin(object) {
        object = object || {};
        for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) sources[_key3 - 1] = arguments[_key3];
        for (var _i4 = 0, _sources2 = sources; _i4 < _sources2.length; _i4++) {
            var source = _sources2[_i4];
            if (source) {
                if ("object" !== _typeof(source)) {
                    cc.errorID(5403, source);
                    continue;
                }
                for (var name in source) _copyprop(name, source, object);
            }
        }
        return object;
    }
    function extend(cls, base) {
        for (var p in base) base.hasOwnProperty(p) && (cls[p] = base[p]);
        return cls.prototype = Object.create(base.prototype, {
            constructor: {
                value: cls,
                writable: !0,
                configurable: !0
            }
        }), cls;
    }
    function getSuper(constructor) {
        var proto = constructor.prototype, dunderProto = proto && Object.getPrototypeOf(proto);
        return dunderProto && dunderProto.constructor;
    }
    function isChildClassOf(subclass, superclass) {
        if (subclass && superclass) {
            if ("function" != typeof subclass) return !1;
            if ("function" != typeof superclass) return !1;
            if (subclass === superclass) return !0;
            for (;;) {
                if (!(subclass = getSuper(subclass))) return !1;
                if (subclass === superclass) return !0;
            }
        }
        return !1;
    }
    function clear(object) {
        for (var _i5 = 0, _Object$keys = Object.keys(object); _i5 < _Object$keys.length; _i5++) {
            delete object[_Object$keys[_i5]];
        }
    }
    var _idToClass = {}, _nameToClass = {};
    function _setClassId(id, constructor) {
        var key = "__cid__", table = _idToClass;
        if (constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]], 
        value(constructor.prototype, key, id), id) {
            var registered = table[id];
            if (registered && registered !== constructor) {
                var error = 'A Class already exists with the same __cid__ : "' + id + '".';
                0, cc.error(error);
            } else table[id] = constructor;
        }
    }
    function setClassName(className, constructor) {
        if (function doSetClassName(id, constructor) {
            var key = "__classname__", table = _nameToClass;
            if (constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]], 
            value(constructor.prototype, key, id), id) {
                var registered = table[id];
                if (registered && registered !== constructor) {
                    var error = "A Class already exists with the same " + key + ' : "' + id + '".';
                    0, cc.error(error);
                } else table[id] = constructor;
            }
        }(className, constructor), !constructor.prototype.hasOwnProperty("__cid__")) {
            var id = className || tempCIDGenerator.getNewId();
            id && _setClassId(id, constructor);
        }
    }
    function unregisterClass() {
        for (var _len4 = arguments.length, constructors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) constructors[_key4] = arguments[_key4];
        for (var _i6 = 0, _constructors = constructors; _i6 < _constructors.length; _i6++) {
            var _constructor = _constructors[_i6], p = _constructor.prototype, classId = p.__cid__;
            classId && delete _idToClass[classId];
            var classname = p.__classname__;
            classname && delete _nameToClass[classname];
        }
    }
    function _getClassById(classId) {
        return _idToClass[classId];
    }
    function getClassByName(classname) {
        return _nameToClass[classname];
    }
    function _getClassId(obj, allowTempId) {
        if (allowTempId = void 0 === allowTempId || allowTempId, "function" == typeof obj && obj.prototype.hasOwnProperty("__cid__")) return obj.prototype.__cid__;
        if (obj && obj.constructor) {
            var prototype = obj.constructor.prototype;
            if (prototype && prototype.hasOwnProperty("__cid__")) return obj.__cid__;
        }
        return "";
    }
    var Pool = function() {
        function Pool(_0, _1) {
            _classCallCheck(this, Pool);
            var size = void 0 === _1 ? _0 : _1, cleanupFunc = void 0 === _1 ? null : _0;
            this.count = 0, this._pool = new Array(size), this._cleanup = cleanupFunc;
        }
        return _createClass(Pool, [ {
            key: "get",
            value: function get() {
                return this._get();
            }
        } ]), _createClass(Pool, [ {
            key: "_get",
            value: function _get() {
                if (this.count > 0) {
                    --this.count;
                    var cache = this._pool[this.count];
                    return this._pool[this.count] = null, cache;
                }
                return null;
            }
        }, {
            key: "put",
            value: function put(obj) {
                var pool = this._pool;
                if (this.count < pool.length) {
                    if (this._cleanup && !1 === this._cleanup(obj)) return;
                    pool[this.count] = obj, ++this.count;
                }
            }
        }, {
            key: "resize",
            value: function resize(length) {
                length >= 0 && (this._pool.length = length, this.count > length && (this.count = length));
            }
        } ]), Pool;
    }(), array = jsarray, js = {
        IDGenerator: IDGenerator,
        Pool: Pool,
        array: jsarray,
        isNumber: isNumber,
        isString: isString,
        getPropertyDescriptor: getPropertyDescriptor,
        addon: addon,
        mixin: mixin,
        extend: extend,
        getSuper: getSuper,
        isChildClassOf: isChildClassOf,
        clear: clear,
        value: value,
        getset: getset,
        get: get,
        set: set$1,
        unregisterClass: unregisterClass,
        getClassName: getClassName,
        setClassName: setClassName,
        getClassByName: getClassByName,
        _getClassId: _getClassId,
        _setClassId: _setClassId,
        _getClassById: _getClassById,
        obsolete: obsolete,
        obsoletes: obsoletes,
        formatStr: formatStr,
        shiftArguments: shiftArguments,
        createMap: createMap
    };
    cc.js = js;
    for (var js$1 = Object.freeze({
        __proto__: null,
        array: array,
        js: js,
        IDGenerator: IDGenerator,
        Pool: Pool,
        isNumber: isNumber,
        isString: isString,
        value: value,
        getset: getset,
        get: get,
        set: set$1,
        createMap: createMap,
        getClassName: getClassName,
        obsolete: obsolete,
        obsoletes: obsoletes,
        formatStr: formatStr,
        shiftArguments: shiftArguments,
        getPropertyDescriptor: getPropertyDescriptor,
        addon: addon,
        mixin: mixin,
        extend: extend,
        getSuper: getSuper,
        isChildClassOf: isChildClassOf,
        clear: clear,
        _idToClass: _idToClass,
        _nameToClass: _nameToClass,
        _setClassId: _setClassId,
        setClassName: setClassName,
        unregisterClass: unregisterClass,
        _getClassById: _getClassById,
        getClassByName: getClassByName,
        _getClassId: _getClassId
    }), BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/, values = new Array(123), i = 0; i < 123; ++i) values[i] = 64;
    for (var _i = 0; _i < 64; ++_i) values["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charCodeAt(_i)] = _i;
    var BASE64_VALUES = values;
    function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
        function define(np, propName, getter, setter) {
            var pd = Object.getOwnPropertyDescriptor(np, propName);
            if (pd) pd.get && (np[getter] = pd.get), pd.set && setter && (np[setter] = pd.set); else {
                var getterFunc = np[getter];
                getset(np, propName, getterFunc, np[setter]);
            }
        }
        for (var propName, np = ctor.prototype, _i2 = 0; _i2 < sameNameGetSets.length; _i2++) {
            var suffix = (propName = sameNameGetSets[_i2])[0].toUpperCase() + propName.slice(1);
            define(np, propName, "get" + suffix, "set" + suffix);
        }
        for (propName in diffNameGetSets) {
            var gs = diffNameGetSets[propName];
            define(np, propName, gs[0], gs[1]);
        }
    }
    function nextPOT(x) {
        return x -= 1, x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, (x |= x >> 16) + 1;
    }
    function pushToMap(map, key, value, pushFront) {
        var exists = map[key];
        exists ? Array.isArray(exists) ? pushFront ? (exists.push(exists[0]), exists[0] = value) : exists.push(value) : map[key] = pushFront ? [ value, exists ] : [ exists, value ] : map[key] = value;
    }
    function contains$1(refNode, otherNode) {
        if ("function" == typeof refNode.contains) return refNode.contains(otherNode);
        if ("function" == typeof refNode.compareDocumentPosition) return !!(16 & refNode.compareDocumentPosition(otherNode));
        var node = otherNode.parentNode;
        if (node) do {
            if (node === refNode) return !0;
            node = node.parentNode;
        } while (null !== node);
        return !1;
    }
    function isDomNode(obj) {
        return "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && "function" == typeof Node ? obj instanceof Node : obj && "object" === _typeof(obj) && "number" == typeof obj.nodeType && "string" == typeof obj.nodeName;
    }
    function callInNextTick(callback, p1, p2) {
        callback && setTimeout((function() {
            callback(p1, p2);
        }), 0);
    }
    function tryCatchFunctor_EDITOR(funcName, forwardArgs, afterCall, bindArg) {
        return Function("arg", "return " + function call_FUNC_InTryCatch(_R_ARGS_) {
            try {
                target._FUNC_(_U_ARGS_);
            } catch (e) {
                cc._throw(e);
            }
            _AFTER_CALL_;
        }.toString().replace(/_FUNC_/g, funcName).replace("_R_ARGS_", "target" + (forwardArgs ? ", " + forwardArgs : "")).replace("_U_ARGS_", forwardArgs || "").replace("_AFTER_CALL_", afterCall || ""))(bindArg);
    }
    function isPlainEmptyObj_DEV(obj) {
        if (!obj || obj.constructor !== Object) return !1;
        for (var k in obj) return !1;
        return !0;
    }
    function cloneable_DEV(obj) {
        return obj && "function" == typeof obj.clone && (obj.constructor && obj.constructor.prototype.hasOwnProperty("clone") || obj.hasOwnProperty("clone"));
    }
    cc.misc = {
        BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
        BASE64_VALUES: BASE64_VALUES,
        propertyDefine: propertyDefine,
        nextPOT: nextPOT,
        pushToMap: pushToMap,
        contains: contains$1,
        isDomNode: isDomNode,
        callInNextTick: callInNextTick,
        tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
        isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
        cloneable_DEV: cloneable_DEV
    };
    var misc = Object.freeze({
        __proto__: null,
        BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
        BASE64_VALUES: BASE64_VALUES,
        propertyDefine: propertyDefine,
        nextPOT: nextPOT,
        pushToMap: pushToMap,
        contains: contains$1,
        isDomNode: isDomNode,
        callInNextTick: callInNextTick,
        tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
        isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
        cloneable_DEV: cloneable_DEV
    });
    function BitMask(obj) {
        if ("__bitmask__" in obj) return obj;
        value(obj, "__bitmask__", null, !0);
        for (var lastIndex = -1, keys = Object.keys(obj), i = 0; i < keys.length; i++) {
            var key = keys[i], val = obj[key];
            if (-1 === val) val = ++lastIndex, obj[key] = val; else if ("number" == typeof val) lastIndex = val; else if ("string" == typeof val && Number.isInteger(parseFloat(key))) continue;
            var reverseKey = "" + val;
            key !== reverseKey && value(obj, reverseKey, key);
        }
        return obj;
    }
    function Enum(obj) {
        if ("__enums__" in obj) return obj;
        value(obj, "__enums__", null, !0);
        for (var lastIndex = -1, keys = Object.keys(obj), i = 0; i < keys.length; i++) {
            var key = keys[i], val = obj[key];
            if (-1 === val) val = ++lastIndex, obj[key] = val; else if ("number" == typeof val) lastIndex = val; else if ("string" == typeof val && Number.isInteger(parseFloat(key))) continue;
            var reverseKey = "" + val;
            key !== reverseKey && value(obj, reverseKey, key);
        }
        return obj;
    }
    function ccenum(enumx) {
        "__enums__" in enumx || value(enumx, "__enums__", null, !0);
    }
    BitMask.isBitMask = function(BitMaskType) {
        return BitMaskType && BitMaskType.hasOwnProperty("__bitmask__");
    }, BitMask.getList = function(BitMaskDef) {
        if (BitMaskDef.__bitmask__) return BitMaskDef.__bitmask__;
        var bitlist = BitMaskDef.__bitmask__ = [];
        for (var name in BitMaskDef) {
            var v = BitMaskDef[name];
            Number.isInteger(v) && bitlist.push({
                name: name,
                value: v
            });
        }
        return bitlist.sort((function(a, b) {
            return a.value - b.value;
        })), bitlist;
    }, cc.BitMask = BitMask, Enum.isEnum = function(enumType) {
        return enumType && enumType.hasOwnProperty("__enums__");
    }, Enum.getList = function(enumDef) {
        if (enumDef.__enums__) return enumDef.__enums__;
        var enums = enumDef.__enums__ = [];
        for (var name in enumDef) {
            var v = enumDef[name];
            Number.isInteger(v) && enums.push({
                name: name,
                value: v
            });
        }
        return enums.sort((function(a, b) {
            return a.value - b.value;
        })), enums;
    }, cc.Enum = Enum;
    var ValueType = function() {
        function ValueType() {
            _classCallCheck(this, ValueType);
        }
        return _createClass(ValueType, [ {
            key: "clone",
            value: function clone() {
                return errorID(100, getClassName(this) + ".clone"), this;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                return !1;
            }
        }, {
            key: "set",
            value: function set(other) {
                errorID(100, getClassName(this) + ".set");
            }
        }, {
            key: "toString",
            value: function toString() {
                return "" + {};
            }
        } ]), ValueType;
    }();
    setClassName("cc.ValueType", ValueType), cc.ValueType = ValueType;
    function createAttrsSingle(owner, ownerConstructor, superAttrs) {
        var AttrsCtor;
        AttrsCtor = function AttrsCtor() {}, superAttrs && extend(AttrsCtor, superAttrs.constructor);
        var attrs = new AttrsCtor;
        return value(owner, "__attrs__", attrs), attrs;
    }
    function createAttrs(subclass) {
        for (var superClass, chains = cc.Class.getInheritanceChain(subclass), i = chains.length - 1; i >= 0; i--) {
            var cls = chains[i];
            cls.hasOwnProperty("__attrs__") && cls.__attrs__ || createAttrsSingle(cls, 0, (superClass = chains[i + 1]) && superClass.__attrs__);
        }
        return createAttrsSingle(subclass, 0, (superClass = chains[0]) && superClass.__attrs__), 
        subclass.__attrs__;
    }
    function attr(constructor, propertyName, newAttributes) {
        var attrs, setter;
        if ("function" == typeof constructor) setter = (attrs = getClassAttrs(constructor)).constructor.prototype; else {
            var instance = constructor;
            if (!(attrs = instance.__attrs__)) attrs = createAttrsSingle(instance, 0, getClassAttrs(constructor = instance.constructor));
            setter = attrs;
        }
        if (void 0 === newAttributes) {
            var prefix = propertyName + "$_$", ret = {};
            for (var key in attrs) key.startsWith(prefix) && (ret[key.slice(prefix.length)] = attrs[key]);
            return ret;
        }
        if ("object" === _typeof(newAttributes)) for (var _key in newAttributes) 95 !== _key.charCodeAt(0) && (setter[propertyName + "$_$" + _key] = newAttributes[_key]); else 0;
    }
    function getClassAttrs(constructor) {
        return constructor.hasOwnProperty("__attrs__") && constructor.__attrs__ || createAttrs(constructor);
    }
    function getClassAttrsProto(constructor) {
        return getClassAttrs(constructor).constructor.prototype;
    }
    function setClassAttr(ctor, propName, key, value) {
        getClassAttrsProto(ctor)[propName + "$_$" + key] = value;
    }
    var PrimitiveType = function() {
        function PrimitiveType(name, defaultValue) {
            _classCallCheck(this, PrimitiveType), this.name = name, this.default = defaultValue;
        }
        return _createClass(PrimitiveType, [ {
            key: "toString",
            value: function toString() {
                return this.name;
            }
        } ]), PrimitiveType;
    }(), CCInteger = new PrimitiveType("Integer", 0);
    cc.Integer = CCInteger, cc.CCInteger = CCInteger;
    var CCFloat = new PrimitiveType("Float", 0);
    cc.Float = CCFloat, cc.CCFloat = CCFloat;
    var CCBoolean = new PrimitiveType("Boolean", !1);
    cc.Boolean = CCBoolean, cc.CCBoolean = CCBoolean;
    var CCString = new PrimitiveType("String", "");
    function getTypeChecker(type, attributeName) {
        return function(constructor, mainPropertyName) {
            var propInfo = '"' + getClassName(constructor) + "." + mainPropertyName + '"', mainPropAttrs = attr(constructor, mainPropertyName);
            if (!mainPropAttrs.saveUrlAsAsset) {
                var mainPropAttrsType = mainPropAttrs.type;
                if (mainPropAttrsType === CCInteger || mainPropAttrsType === CCFloat ? mainPropAttrsType = "Number" : mainPropAttrsType !== CCString && mainPropAttrsType !== CCBoolean || (mainPropAttrsType = mainPropAttrsType.toString()), 
                mainPropAttrsType !== type) return void warnID(3604, propInfo);
            }
            if (mainPropAttrs.hasOwnProperty("default")) {
                var defaultVal = mainPropAttrs.default;
                if (void 0 !== defaultVal) if (!(Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal))) {
                    var defaultType = _typeof(defaultVal), type_lowerCase = type.toLowerCase();
                    if (defaultType === type_lowerCase) {
                        if (!mainPropAttrs.saveUrlAsAsset) if ("object" === type_lowerCase) {
                            if (!defaultVal || defaultVal instanceof mainPropAttrs.ctor) return;
                            warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
                        } else "Number" !== type && warnID(3606, attributeName, propInfo, type);
                    } else {
                        if ("function" === defaultType) return;
                        type === CCString.default && null == defaultVal ? isChildClassOf(mainPropAttrs.ctor, cc.RawAsset) || warnID(3607, propInfo) : warnID(3611, attributeName, propInfo, defaultType);
                    }
                    delete mainPropAttrs.type;
                }
            }
        };
    }
    function getObjTypeChecker(typeCtor) {
        return function(classCtor, mainPropName) {
            getTypeChecker("Object", "type")(classCtor, mainPropName);
            var defaultDef = getClassAttrs(classCtor)[mainPropName + "$_$default"], defaultVal = cc.Class.getDefault(defaultDef);
            if (!Array.isArray(defaultVal) && isChildClassOf(typeCtor, cc.ValueType)) {
                var typename = getClassName(typeCtor), info = formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', getClassName(classCtor), mainPropName, typename);
                defaultDef ? log(info) : warnID(3612, info, typename, getClassName(classCtor), mainPropName, typename);
            }
        };
    }
    cc.String = CCString, cc.CCString = CCString;
    var attributeUtils = Object.freeze({
        __proto__: null,
        DELIMETER: "$_$",
        createAttrsSingle: createAttrsSingle,
        createAttrs: createAttrs,
        attr: attr,
        getClassAttrs: getClassAttrs,
        getClassAttrsProto: getClassAttrsProto,
        setClassAttr: setClassAttr,
        PrimitiveType: PrimitiveType,
        CCInteger: CCInteger,
        CCFloat: CCFloat,
        CCBoolean: CCBoolean,
        CCString: CCString,
        getTypeChecker: getTypeChecker,
        getObjTypeChecker: getObjTypeChecker
    }), SerializableAttrs = {
        url: {
            canUsedInGet: !0
        },
        default: {},
        serializable: {},
        editorOnly: {},
        formerlySerializedAs: {}
    };
    function parseNotify(val, propName, notify, properties) {
        if (!val.get && !val.set) if (val.hasOwnProperty("default")) {
            var newKey = "_N$" + propName;
            val.get = function() {
                return this[newKey];
            }, val.set = function(value) {
                var oldValue = this[newKey];
                this[newKey] = value, notify.call(this, oldValue);
            };
            var newValue = {};
            for (var attr in properties[newKey] = newValue, SerializableAttrs) {
                var v = SerializableAttrs[attr];
                val.hasOwnProperty(attr) && (newValue[attr] = val[attr], v.canUsedInGet || delete val[attr]);
            }
        } else 0;
    }
    function checkUrl(val, className, propName, url) {
        Array.isArray(url) && url.length > 0 && (url = url[0]), val.type = url;
    }
    function parseType(val, type, className, propName) {
        if (Array.isArray(type)) {
            if (!(type.length > 0)) return errorID(5508, className, propName);
            if (cc.RawAsset.isRawAssetType(type[0])) return val.url = type[0], void delete val.type;
            val.type = type = type[0];
        }
    }
    function getFullFormOfProperty(options, propname_dev, classname_dev) {
        if (!(options && options.constructor === Object)) {
            if (Array.isArray(options) && options.length > 0) {
                options[0];
                return {
                    default: [],
                    type: options,
                    _short: !0
                };
            }
            if ("function" == typeof options) {
                var _type = options;
                return cc.RawAsset.isRawAssetType(_type) ? {
                    default: "",
                    url: _type,
                    _short: !0
                } : {
                    default: isChildClassOf(_type, cc.ValueType) ? new _type : null,
                    type: _type,
                    _short: !0
                };
            }
            return options instanceof PrimitiveType ? {
                default: options.default,
                _short: !0
            } : {
                default: options,
                _short: !0
            };
        }
        return null;
    }
    function validateMethodWithProps(func, funcName, className, cls, base) {
        return "function" == typeof func || null === func;
    }
    var requiringFrames = [];
    function peek() {
        return requiringFrames[requiringFrames.length - 1];
    }
    cc._RF = {
        push: function push(module, uuid, script, importMeta) {
            void 0 === script && (script = uuid, uuid = ""), requiringFrames.push({
                uuid: uuid,
                script: script,
                module: module,
                exports: module.exports,
                beh: null,
                importMeta: importMeta
            });
        },
        pop: function pop() {
            var frameInfo = requiringFrames.pop(), module = frameInfo.module, exports = module.exports;
            if (exports === frameInfo.exports) {
                for (var anykey in exports) return;
                module.exports = exports = frameInfo.cls;
            }
        },
        peek: peek
    };
    var BUILTIN_ENTRIES = [ "name", "extends", "mixins", "ctor", "__ctor__", "properties", "statics", "editor", "__ES6__" ];
    function pushUnique(array, item) {
        array.indexOf(item) < 0 && array.push(item);
    }
    var deferredInitializer = {
        datas: null,
        push: function push(data) {
            if (this.datas) this.datas.push(data); else {
                this.datas = [ data ];
                var self = this;
                setTimeout((function() {
                    self.init();
                }), 0);
            }
        },
        init: function init() {
            var datas = this.datas;
            if (datas) {
                for (var i = 0; i < datas.length; ++i) {
                    var data = datas[i], cls = data.cls, properties = data.props;
                    "function" == typeof properties && (properties = properties());
                    var _name = getClassName(cls);
                    properties ? declareProperties(cls, _name, properties, cls.$super, data.mixins) : errorID(3633, _name);
                }
                this.datas = null;
            }
        }
    };
    function appendProp(cls, name) {
        pushUnique(cls.__props__, name);
    }
    var tmpArray = [];
    function defineProp(cls, className, propName, val, es6) {
        var defaultValue = val.default;
        setClassAttr(cls, propName, "default", defaultValue), appendProp(cls, propName);
        var attrs = parseAttributes(cls, val, className, propName, !1);
        if (attrs) {
            for (var onAfterProp = tmpArray, i = 0; i < attrs.length; i++) {
                var attr$1 = attrs[i];
                attr(cls, propName, attr$1), !1 === attr$1.serializable && pushUnique(cls.__values__, propName), 
                attr$1._onAfterProp && onAfterProp.push(attr$1._onAfterProp);
            }
            for (var c = 0; c < onAfterProp.length; c++) onAfterProp[c](cls, propName);
            tmpArray.length = 0, attrs.length = 0;
        }
    }
    function defineGetSet(cls, name, propName, val, es6) {
        var getter = val.get, setter = val.set, proto = cls.prototype, d = Object.getOwnPropertyDescriptor(proto, propName), setterUndefined = !d;
        if (getter) {
            0;
            for (var attrs = parseAttributes(cls, val, name, propName, !0), i = 0; i < attrs.length; i++) attr(cls, propName, attrs[i]);
            attrs.length = 0, setClassAttr(cls, propName, "serializable", !1), es6 || get(proto, propName, getter, setterUndefined, setterUndefined);
        }
        setter && (es6 || set$1(proto, propName, setter, setterUndefined, setterUndefined));
    }
    function getDefault(defaultVal) {
        return "function" == typeof defaultVal ? defaultVal() : defaultVal;
    }
    function mixinWithInherited(dest, src, filter) {
        for (var prop in src) dest.hasOwnProperty(prop) || filter && !filter(prop) || Object.defineProperty(dest, prop, getPropertyDescriptor(src, prop));
    }
    function doDefine(className, baseClass, mixins, options) {
        var ctors, fireClass, __ctor__ = options.__ctor__, ctor = options.ctor, __es6__ = options.__ES6__;
        __es6__ ? (ctors = [ ctor ], fireClass = ctor) : (ctors = __ctor__ ? [ __ctor__ ] : function _getAllCtors(baseClass, mixins, options) {
            for (var ctors = [], baseOrMixins = [ baseClass ].concat(mixins), b = 0; b < baseOrMixins.length; b++) {
                var baseOrMixin = baseOrMixins[b];
                if (baseOrMixin) for (var baseCtors = (cls = baseOrMixin, CCClass._isCCClass(cls) ? cls.__ctors__ || [] : [ cls ]), c = 0; c < baseCtors.length; c++) pushUnique(ctors, baseCtors[c]);
            }
            var cls;
            var ctor = options.ctor;
            ctor && ctors.push(ctor);
            return ctors;
        }(baseClass, mixins, options), fireClass = _createCtor(ctors, baseClass, className, options), 
        value(fireClass, "extend", (function(options) {
            return options.extends = this, CCClass(options);
        }), !0)), value(fireClass, "__ctors__", ctors.length > 0 ? ctors : null, !0);
        var prototype = fireClass.prototype;
        if (baseClass && (__es6__ || (extend(fireClass, baseClass), prototype = fireClass.prototype), 
        fireClass.$super = baseClass), mixins) {
            for (var _loop = function _loop(m) {
                var mixin = mixins[m];
                mixinWithInherited(prototype, mixin.prototype), mixinWithInherited(fireClass, mixin, (function(prop) {
                    return mixin.hasOwnProperty(prop) && !0;
                })), CCClass._isCCClass(mixin) && mixinWithInherited(getClassAttrs(fireClass).constructor.prototype, getClassAttrs(mixin).constructor.prototype);
            }, m = mixins.length - 1; m >= 0; m--) _loop(m);
            prototype.constructor = fireClass;
        }
        return __es6__ || (prototype.__initProps__ = compileProps), setClassName(className, fireClass), 
        fireClass;
    }
    function escapeForJS(s) {
        return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    var IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;
    function compileProps(actualClass) {
        var attrs = getClassAttrs(actualClass), propList = actualClass.__props__;
        null === propList && (deferredInitializer.init(), propList = actualClass.__props__);
        var initProps = function getInitProps(attrs, propList) {
            for (var advancedProps = [], advancedValues = [], simpleProps = [], simpleValues = [], i = 0; i < propList.length; ++i) {
                var prop = propList[i], attrKey = prop + "$_$default";
                if (attrKey in attrs) {
                    var def = attrs[attrKey];
                    "object" === _typeof(def) && def || "function" == typeof def ? (advancedProps.push(prop), 
                    advancedValues.push(def)) : (simpleProps.push(prop), simpleValues.push(def));
                }
            }
            return function() {
                for (var _i = 0; _i < simpleProps.length; ++_i) this[simpleProps[_i]] = simpleValues[_i];
                for (var _i2 = 0; _i2 < advancedProps.length; _i2++) {
                    var _prop = advancedProps[_i2], expression = void 0, _def = advancedValues[_i2];
                    expression = "object" === _typeof(_def) ? _def instanceof cc.ValueType ? _def.clone() : Array.isArray(_def) ? [] : {} : _def(), 
                    this[_prop] = expression;
                }
            };
        }(attrs, propList);
        actualClass.prototype.__initProps__ = initProps, initProps.call(this);
    }
    var _createCtor = function(ctors, baseClass, className, options) {
        var _Class5, superCallBounded = baseClass && boundSuperCalls(baseClass, options, className), ctorLen = ctors.length;
        return _Class5 = ctorLen > 0 ? superCallBounded ? 2 === ctorLen ? function Class() {
            this._super = null, this.__initProps__(_Class5), ctors[0].apply(this, arguments), 
            ctors[1].apply(this, arguments);
        } : function _Class() {
            this._super = null, this.__initProps__(_Class5);
            for (var i = 0; i < ctors.length; ++i) ctors[i].apply(this, arguments);
        } : 3 === ctorLen ? function _Class2() {
            this.__initProps__(_Class5), ctors[0].apply(this, arguments), ctors[1].apply(this, arguments), 
            ctors[2].apply(this, arguments);
        } : function _Class3() {
            this.__initProps__(_Class5);
            for (var ctors = _Class5.__ctors__, i = 0; i < ctors.length; ++i) ctors[i].apply(this, arguments);
        } : function _Class4() {
            superCallBounded && (this._super = null), this.__initProps__(_Class5);
        };
    };
    var superCllRegCondition = /xyz/.test(function() {}.toString()), SuperCallReg = superCllRegCondition ? /\b\._super\b/ : /.*/;
    function boundSuperCalls(baseClass, options, className) {
        var hasSuperCall = !1;
        for (var funcName in options) if (!(BUILTIN_ENTRIES.indexOf(funcName) >= 0)) {
            var func = options[funcName];
            if ("function" == typeof func) {
                var pd = getPropertyDescriptor(baseClass.prototype, funcName);
                if (pd) {
                    var superFunc = pd.value;
                    if ("function" == typeof superFunc) {
                        SuperCallReg.test(func) && (hasSuperCall = !0, options[funcName] = function(superFunc, func) {
                            return function() {
                                var tmp = this._super;
                                this._super = superFunc;
                                var ret = func.apply(this, arguments);
                                return this._super = tmp, ret;
                            };
                        }(superFunc, func));
                        continue;
                    }
                }
                0;
            }
        }
        return hasSuperCall;
    }
    function declareProperties(cls, className, properties, baseClass, mixins, es6) {
        if (cls.__props__ = [], baseClass && baseClass.__props__ && (cls.__props__ = baseClass.__props__.slice()), 
        mixins) for (var m = 0; m < mixins.length; ++m) {
            var mixin = mixins[m];
            mixin.__props__ && (cls.__props__ = cls.__props__.concat(mixin.__props__.filter((function(x) {
                return cls.__props__.indexOf(x) < 0;
            }))));
        }
        if (properties) for (var propName in function preprocessAttrs(properties, className, cls, es6) {
            for (var propName in properties) {
                var val = properties[propName], fullForm = getFullFormOfProperty(val);
                if (fullForm && (val = properties[propName] = fullForm), val) {
                    var notify = val.notify;
                    notify && parseNotify(val, propName, notify, properties), "type" in val && parseType(val, val.type, className, propName), 
                    "url" in val && checkUrl(val, 0, 0, val.url), "type" in val && val.type;
                }
            }
        }(properties, className), properties) {
            var val = properties[propName];
            "default" in val ? defineProp(cls, className, propName, val) : defineGetSet(cls, className, propName, val, es6);
        }
        var attrs = getClassAttrs(cls);
        cls.__values__ = cls.__props__.filter((function(prop) {
            return !1 !== attrs[prop + "$_$serializable"];
        }));
    }
    function CCClass(options) {
        var name = (options = options || {}).name, base = options.extends, mixins = options.mixins, cls = function define(className, baseClass, mixins, options) {
            var Component = cc.Component, frame = peek();
            if (frame && isChildClassOf(baseClass, Component)) {
                if (isChildClassOf(frame.cls, Component)) return errorID(3615), null;
                0, className = className || frame.script;
            }
            var cls = doDefine(className, baseClass, mixins, options), isRenderPipeline = isChildClassOf(baseClass, cc.RenderPipeline), isRenderFlow = isChildClassOf(baseClass, cc.RenderFlow), isRenderStage = isChildClassOf(baseClass, cc.RenderStage);
            if (isRenderPipeline || isRenderFlow || isRenderStage || !1) {
                var renderName = "";
                isRenderPipeline ? renderName = "render_pipeline" : isRenderFlow ? renderName = "render_flow" : isRenderStage && (renderName = "render_stage"), 
                renderName && _setClassId(className, cls);
            }
            if (frame) if (isChildClassOf(baseClass, Component)) {
                var uuid = frame.uuid;
                uuid && _setClassId(uuid, cls), frame.cls = cls;
            } else isChildClassOf(frame.cls, Component) || (frame.cls = cls);
            return cls;
        }(name, base, mixins, options);
        name || (name = cc.js.getClassName(cls)), cls._sealed = !0, base && (base._sealed = !1);
        var properties = options.properties;
        "function" == typeof properties || base && null === base.__props__ || mixins && mixins.some((function(x) {
            return null === x.__props__;
        })) ? (deferredInitializer.push({
            cls: cls,
            props: properties,
            mixins: mixins
        }), cls.__props__ = cls.__values__ = null) : declareProperties(cls, name, properties, base, options.mixins, options.__ES6__);
        var staticPropName, statics = options.statics;
        if (statics) for (staticPropName in statics) cls[staticPropName] = statics[staticPropName];
        for (var funcName in options) if (!(BUILTIN_ENTRIES.indexOf(funcName) >= 0)) {
            var func = options[funcName];
            validateMethodWithProps(func) && value(cls.prototype, funcName, func, !0, !0);
        }
        var editor = options.editor;
        return editor && isChildClassOf(base, cc.Component) && cc.Component._registerEditorProps(cls, editor), 
        cls;
    }
    CCClass._isCCClass = function(constructor) {
        return constructor && constructor.hasOwnProperty && constructor.hasOwnProperty("__ctors__");
    }, CCClass.fastDefine = function(className, constructor, serializableFields) {
        setClassName(className, constructor);
        for (var props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields), attrProtos = getClassAttrsProto(constructor), i = 0; i < props.length; i++) {
            var key = props[i];
            attrProtos[key + "$_$visible"] = !1, attrProtos[key + "$_$default"] = serializableFields[key];
        }
    }, CCClass.Attr = attributeUtils, CCClass.attr = attr, CCClass.getInheritanceChain = function getInheritanceChain(constructor) {
        for (var chain = []; constructor = getSuper(constructor); ) constructor !== Object && chain.push(constructor);
        return chain;
    };
    var PrimitiveTypes = {
        Integer: "Number",
        Float: "Number",
        Boolean: "Boolean",
        String: "String"
    }, tmpAttrs = [];
    function parseAttributes(constructor, attributes, className, propertyName, usedInGetter) {
        var attrsProto = null, attrsProtoKey = "";
        function getAttrsProto() {
            return attrsProtoKey = propertyName + "$_$", attrsProto = getClassAttrsProto(constructor);
        }
        tmpAttrs.length = 0;
        var result = tmpAttrs;
        "type" in attributes && void 0 === attributes.type && warnID(3660, propertyName, className);
        var type = attributes.type;
        if (type) {
            var primitiveType = PrimitiveTypes[type];
            if (primitiveType) result.push({
                type: type,
                _onAfterProp: void 0
            }); else if ("Object" === type) 0; else if ("object" === _typeof(type)) Enum.isEnum(type) ? result.push({
                type: "Enum",
                enumList: Enum.getList(type)
            }) : BitMask.isBitMask(type) && result.push({
                type: "BitMask",
                bitmaskList: BitMask.getList(type)
            }); else if ("function" == typeof type) {
                var typeChecker;
                0, result.push({
                    type: "Object",
                    ctor: type,
                    _onAfterProp: typeChecker
                });
            } else 0;
        }
        var parseSimpleAttribute = function parseSimpleAttribute(attributeName, expectType) {
            if (attributeName in attributes) {
                var val = attributes[attributeName];
                _typeof(val) === expectType && ((attrsProto || getAttrsProto())[attrsProtoKey + attributeName] = val);
            }
        };
        attributes.editorOnly && ((attrsProto || getAttrsProto())[attrsProtoKey + "editorOnly"] = !0), 
        attributes.url && ((attrsProto || getAttrsProto())[attrsProtoKey + "saveUrlAsAsset"] = !0), 
        !1 === attributes.serializable && ((attrsProto || getAttrsProto())[attrsProtoKey + "serializable"] = !1), 
        parseSimpleAttribute("formerlySerializedAs", "string");
        var range = attributes.range;
        return range && Array.isArray(range) && range.length >= 2 && ((attrsProto || getAttrsProto())[attrsProtoKey + "min"] = range[0], 
        (attrsProto || getAttrsProto())[attrsProtoKey + "max"] = range[1], range.length > 2 && ((attrsProto || getAttrsProto())[attrsProtoKey + "step"] = range[2])), 
        parseSimpleAttribute("min", "number"), parseSimpleAttribute("max", "number"), parseSimpleAttribute("step", "number"), 
        result;
    }
    CCClass.isArray = function(defaultVal) {
        return defaultVal = getDefault(defaultVal), Array.isArray(defaultVal);
    }, CCClass.getDefault = getDefault, CCClass.escapeForJS = escapeForJS, CCClass.IDENTIFIER_RE = IDENTIFIER_RE, 
    CCClass.getNewValueTypeCode = !1, cc.Class = CCClass;
    var _d2r = Math.PI / 180, _r2d = 180 / Math.PI;
    function equals(a, b) {
        return Math.abs(a - b) <= 1e-6 * Math.max(1, Math.abs(a), Math.abs(b));
    }
    function approx(a, b, maxDiff) {
        return maxDiff = maxDiff || 1e-6, Math.abs(a - b) <= maxDiff;
    }
    function clamp(val, min, max) {
        if (min > max) {
            var temp = min;
            min = max, max = temp;
        }
        return val < min ? min : val > max ? max : val;
    }
    function clamp01(val) {
        return val < 0 ? 0 : val > 1 ? 1 : val;
    }
    function lerp(from, to, ratio) {
        return from + (to - from) * ratio;
    }
    function toRadian(a) {
        return a * _d2r;
    }
    function toDegree(a) {
        return a * _r2d;
    }
    var random = Math.random;
    function randomRange(min, max) {
        return Math.random() * (max - min) + min;
    }
    function randomRangeInt(min, max) {
        return Math.floor(randomRange(min, max));
    }
    function pseudoRandom(seed) {
        return (seed = (9301 * seed + 49297) % 233280) / 233280;
    }
    function pseudoRandomRange(seed, min, max) {
        return pseudoRandom(seed) * (max - min) + min;
    }
    function pseudoRandomRangeInt(seed, min, max) {
        return Math.floor(pseudoRandomRange(seed, min, max));
    }
    function nextPow2$1(val) {
        return --val, val |= val >> 1, val |= val >> 2, val |= val >> 4, val |= val >> 8, 
        val |= val >> 16, ++val;
    }
    function repeat(t, length) {
        return t - Math.floor(t / length) * length;
    }
    function pingPong(t, length) {
        return t = repeat(t, 2 * length), t = length - Math.abs(t - length);
    }
    function inverseLerp(from, to, value) {
        return (value - from) / (to - from);
    }
    function absMaxComponent(v) {
        return Math.abs(v.x) > Math.abs(v.y) ? Math.abs(v.x) > Math.abs(v.z) ? v.x : v.z : Math.abs(v.y) > Math.abs(v.z) ? v.y : v.z;
    }
    function absMax(a, b) {
        return Math.abs(a) > Math.abs(b) ? a : b;
    }
    var _x = 0, _y = 0, Vec2 = function(_ValueType) {
        function Vec2(x, y) {
            var _this;
            return _classCallCheck(this, Vec2), _this = _possibleConstructorReturn(this, _getPrototypeOf(Vec2).call(this)), 
            x && "object" === _typeof(x) ? (_this.x = x.x, _this.y = x.y) : (_this.x = x || 0, 
            _this.y = y || 0), _this;
        }
        return _inherits(Vec2, _ValueType), _createClass(Vec2, null, [ {
            key: "clone",
            value: function clone(a) {
                return new Vec2(a.x, a.y);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.x = a.x, out.y = a.y, out;
            }
        }, {
            key: "set",
            value: function set(out, x, y) {
                return out.x = x, out.y = y, out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.x = a.x + b.x, out.y = a.y + b.y, out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.x = a.x - b.x, out.y = a.y - b.y, out;
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                return out.x = a.x * b.x, out.y = a.y * b.y, out;
            }
        }, {
            key: "divide",
            value: function divide(out, a, b) {
                return out.x = a.x / b.x, out.y = a.y / b.y, out;
            }
        }, {
            key: "ceil",
            value: function ceil(out, a) {
                return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out;
            }
        }, {
            key: "floor",
            value: function floor(out, a) {
                return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out;
            }
        }, {
            key: "min",
            value: function min(out, a, b) {
                return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out;
            }
        }, {
            key: "max",
            value: function max(out, a, b) {
                return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out;
            }
        }, {
            key: "round",
            value: function round(out, a) {
                return out.x = Math.round(a.x), out.y = Math.round(a.y), out;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(out, a, b) {
                return out.x = a.x * b, out.y = a.y * b, out;
            }
        }, {
            key: "scaleAndAdd",
            value: function scaleAndAdd(out, a, b, scale) {
                return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out;
            }
        }, {
            key: "distance",
            value: function distance(a, b) {
                return _x = b.x - a.x, _y = b.y - a.y, Math.sqrt(_x * _x + _y * _y);
            }
        }, {
            key: "squaredDistance",
            value: function squaredDistance(a, b) {
                return _x = b.x - a.x, _y = b.y - a.y, _x * _x + _y * _y;
            }
        }, {
            key: "len",
            value: function len(a) {
                return _x = a.x, _y = a.y, Math.sqrt(_x * _x + _y * _y);
            }
        }, {
            key: "lengthSqr",
            value: function lengthSqr(a) {
                return _x = a.x, _y = a.y, _x * _x + _y * _y;
            }
        }, {
            key: "negate",
            value: function negate(out, a) {
                return out.x = -a.x, out.y = -a.y, out;
            }
        }, {
            key: "inverse",
            value: function inverse(out, a) {
                return out.x = 1 / a.x, out.y = 1 / a.y, out;
            }
        }, {
            key: "inverseSafe",
            value: function inverseSafe(out, a) {
                return _x = a.x, _y = a.y, Math.abs(_x) < 1e-6 ? out.x = 0 : out.x = 1 / _x, Math.abs(_y) < 1e-6 ? out.y = 0 : out.y = 1 / _y, 
                out;
            }
        }, {
            key: "normalize",
            value: function normalize(out, a) {
                _x = a.x, _y = a.y;
                var len = _x * _x + _y * _y;
                return len > 0 && (len = 1 / Math.sqrt(len), out.x = _x * len, out.y = _y * len), 
                out;
            }
        }, {
            key: "dot",
            value: function dot(a, b) {
                return a.x * b.x + a.y * b.y;
            }
        }, {
            key: "cross",
            value: function cross(out, a, b) {
                return out.x = out.y = 0, out.z = a.x * b.y - a.y * b.x, out;
            }
        }, {
            key: "lerp",
            value: function lerp(out, a, b, t) {
                return _x = a.x, _y = a.y, out.x = _x + t * (b.x - _x), out.y = _y + t * (b.y - _y), 
                out;
            }
        }, {
            key: "random",
            value: function random$1(out, scale) {
                scale = scale || 1;
                var r = 2 * random() * Math.PI;
                return out.x = Math.cos(r) * scale, out.y = Math.sin(r) * scale, out;
            }
        }, {
            key: "transformMat3",
            value: function transformMat3(out, a, m) {
                return _x = a.x, _y = a.y, out.x = m.m00 * _x + m.m03 * _y + m.m06, out.y = m.m01 * _x + m.m04 * _y + m.m07, 
                out;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(out, a, m) {
                return _x = a.x, _y = a.y, out.x = m.m00 * _x + m.m04 * _y + m.m12, out.y = m.m01 * _x + m.m05 * _y + m.m13, 
                out;
            }
        }, {
            key: "str",
            value: function str(a) {
                return "Vec2(".concat(a.x, ", ").concat(a.y, ")");
            }
        }, {
            key: "toArray",
            value: function toArray(out, v) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out;
            }
        }, {
            key: "fromArray",
            value: function fromArray(out, arr) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out;
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(a, b) {
                return a.x === b.x && a.y === b.y;
            }
        }, {
            key: "equals",
            value: function equals(a, b) {
                var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-6;
                return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y));
            }
        }, {
            key: "angle",
            value: function angle(a, b) {
                Vec2.normalize(v2_1, a), Vec2.normalize(v2_2, b);
                var cosine = Vec2.dot(v2_1, v2_2);
                return cosine > 1 ? 0 : cosine < -1 ? Math.PI : Math.acos(cosine);
            }
        } ]), _createClass(Vec2, [ {
            key: "clone",
            value: function clone() {
                return new Vec2(this.x, this.y);
            }
        }, {
            key: "set",
            value: function set(x, y) {
                return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y) : (this.x = x || 0, 
                this.y = y || 0), this;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e-6;
                return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y));
            }
        }, {
            key: "equals2f",
            value: function equals2f(x, y) {
                var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-6;
                return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y));
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(other) {
                return other && this.x === other.x && this.y === other.y;
            }
        }, {
            key: "strictEquals2f",
            value: function strictEquals2f(x, y) {
                return this.x === x && this.y === y;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ")");
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio) {
                return _x = this.x, _y = this.y, this.x = _x + ratio * (to.x - _x), this.y = _y + ratio * (to.y - _y), 
                this;
            }
        }, {
            key: "clampf",
            value: function clampf(minInclusive, maxInclusive) {
                return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
                this;
            }
        }, {
            key: "add",
            value: function add(other) {
                return this.x = this.x + other.x, this.y = this.y + other.y, this;
            }
        }, {
            key: "add2f",
            value: function add2f(x, y) {
                return this.x = this.x + x, this.y = this.y + y, this;
            }
        }, {
            key: "subtract",
            value: function subtract(other) {
                return this.x = this.x - other.x, this.y = this.y - other.y, this;
            }
        }, {
            key: "subtract2f",
            value: function subtract2f(x, y) {
                return this.x = this.x - x, this.y = this.y - y, this;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(scalar) {
                return "object" === _typeof(scalar) && console.warn("should use Vec2.multiply for vector * vector operation"), 
                this.x = this.x * scalar, this.y = this.y * scalar, this;
            }
        }, {
            key: "multiply",
            value: function multiply(other) {
                return "object" !== _typeof(other) && console.warn("should use Vec2.scale for vector * scalar operation"), 
                this.x = this.x * other.x, this.y = this.y * other.y, this;
            }
        }, {
            key: "multiply2f",
            value: function multiply2f(x, y) {
                return this.x = this.x * x, this.y = this.y * y, this;
            }
        }, {
            key: "divide",
            value: function divide(other) {
                return this.x = this.x / other.x, this.y = this.y / other.y, this;
            }
        }, {
            key: "divide2f",
            value: function divide2f(x, y) {
                return this.x = this.x / x, this.y = this.y / y, this;
            }
        }, {
            key: "negative",
            value: function negative() {
                return this.x = -this.x, this.y = -this.y, this;
            }
        }, {
            key: "dot",
            value: function dot(other) {
                return this.x * other.x + this.y * other.y;
            }
        }, {
            key: "cross",
            value: function cross(other) {
                return this.x * other.y - this.y * other.x;
            }
        }, {
            key: "length",
            value: function length() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }
        }, {
            key: "lengthSqr",
            value: function lengthSqr() {
                return this.x * this.x + this.y * this.y;
            }
        }, {
            key: "normalize",
            value: function normalize() {
                _x = this.x, _y = this.y;
                var len = _x * _x + _y * _y;
                return len > 0 && (len = 1 / Math.sqrt(len), this.x = this.x * len, this.y = this.y * len), 
                this;
            }
        }, {
            key: "angle",
            value: function angle(other) {
                var magSqr1 = this.lengthSqr(), magSqr2 = other.lengthSqr();
                if (0 === magSqr1 || 0 === magSqr2) return console.warn("Can't get angle between zero vector"), 
                0;
                var theta = this.dot(other) / Math.sqrt(magSqr1 * magSqr2);
                return theta = clamp(theta, -1, 1), Math.acos(theta);
            }
        }, {
            key: "signAngle",
            value: function signAngle(other) {
                var angle = this.angle(other);
                return this.cross(other) < 0 ? -angle : angle;
            }
        }, {
            key: "rotate",
            value: function rotate(radians) {
                _x = this.x, _y = this.y;
                var sin = Math.sin(radians), cos = Math.cos(radians);
                return this.x = cos * _x - sin * _y, this.y = sin * _x + cos * _y, this;
            }
        }, {
            key: "project",
            value: function project(other) {
                var scalar = this.dot(other) / other.dot(other);
                return this.x = other.x * scalar, this.y = other.y * scalar, this;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(matrix) {
                return _x = this.x, _y = this.y, this.x = matrix.m00 * _x + matrix.m04 * _y + matrix.m12, 
                this.y = matrix.m01 * _x + matrix.m05 * _y + matrix.m13, this;
            }
        } ]), Vec2;
    }(ValueType);
    Vec2.ZERO = Object.freeze(new Vec2(0, 0)), Vec2.ONE = Object.freeze(new Vec2(1, 1)), 
    Vec2.NEG_ONE = Object.freeze(new Vec2(-1, -1)), Vec2.UNIT_X = Object.freeze(new Vec2(1, 0)), 
    Vec2.UNIT_Y = Object.freeze(new Vec2(0, 1));
    var v2_1 = new Vec2, v2_2 = new Vec2;
    function v2(x, y) {
        return new Vec2(x, y);
    }
    CCClass.fastDefine("cc.Vec2", Vec2, {
        x: 0,
        y: 0
    }), cc.Vec2 = Vec2, cc.v2 = v2;
    var _x$1 = 0, _y$1 = 0, _z = 0, Vec3 = function(_ValueType) {
        function Vec3(x, y, z) {
            var _this;
            return _classCallCheck(this, Vec3), _this = _possibleConstructorReturn(this, _getPrototypeOf(Vec3).call(this)), 
            x && "object" === _typeof(x) ? (_this.x = x.x, _this.y = x.y, _this.z = x.z) : (_this.x = x || 0, 
            _this.y = y || 0, _this.z = z || 0), _this;
        }
        return _inherits(Vec3, _ValueType), _createClass(Vec3, null, [ {
            key: "zero",
            value: function zero(out) {
                return out.x = 0, out.y = 0, out.z = 0, out;
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new Vec3(a.x, a.y, a.z);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.x = a.x, out.y = a.y, out.z = a.z, out;
            }
        }, {
            key: "set",
            value: function set(out, x, y, z) {
                return out.x = x, out.y = y, out.z = z, out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z, out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.x = a.x - b.x, out.y = a.y - b.y, out.z = a.z - b.z, out;
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                return out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z, out;
            }
        }, {
            key: "divide",
            value: function divide(out, a, b) {
                return out.x = a.x / b.x, out.y = a.y / b.y, out.z = a.z / b.z, out;
            }
        }, {
            key: "ceil",
            value: function ceil(out, a) {
                return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out.z = Math.ceil(a.z), out;
            }
        }, {
            key: "floor",
            value: function floor(out, a) {
                return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out.z = Math.floor(a.z), 
                out;
            }
        }, {
            key: "min",
            value: function min(out, a, b) {
                return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z), 
                out;
            }
        }, {
            key: "max",
            value: function max(out, a, b) {
                return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z), 
                out;
            }
        }, {
            key: "round",
            value: function round(out, a) {
                return out.x = Math.round(a.x), out.y = Math.round(a.y), out.z = Math.round(a.z), 
                out;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(out, a, b) {
                return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out;
            }
        }, {
            key: "scaleAndAdd",
            value: function scaleAndAdd(out, a, b, scale) {
                return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
                out;
            }
        }, {
            key: "distance",
            value: function distance(a, b) {
                return _x$1 = b.x - a.x, _y$1 = b.y - a.y, _z = b.z - a.z, Math.sqrt(_x$1 * _x$1 + _y$1 * _y$1 + _z * _z);
            }
        }, {
            key: "squaredDistance",
            value: function squaredDistance(a, b) {
                return _x$1 = b.x - a.x, _y$1 = b.y - a.y, _z = b.z - a.z, _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
            }
        }, {
            key: "len",
            value: function len(a) {
                return _x$1 = a.x, _y$1 = a.y, _z = a.z, Math.sqrt(_x$1 * _x$1 + _y$1 * _y$1 + _z * _z);
            }
        }, {
            key: "lengthSqr",
            value: function lengthSqr(a) {
                return _x$1 = a.x, _y$1 = a.y, _z = a.z, _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
            }
        }, {
            key: "negate",
            value: function negate(out, a) {
                return out.x = -a.x, out.y = -a.y, out.z = -a.z, out;
            }
        }, {
            key: "invert",
            value: function invert(out, a) {
                return out.x = 1 / a.x, out.y = 1 / a.y, out.z = 1 / a.z, out;
            }
        }, {
            key: "invertSafe",
            value: function invertSafe(out, a) {
                return _x$1 = a.x, _y$1 = a.y, _z = a.z, Math.abs(_x$1) < 1e-6 ? out.x = 0 : out.x = 1 / _x$1, 
                Math.abs(_y$1) < 1e-6 ? out.y = 0 : out.y = 1 / _y$1, Math.abs(_z) < 1e-6 ? out.z = 0 : out.z = 1 / _z, 
                out;
            }
        }, {
            key: "normalize",
            value: function normalize(out, a) {
                _x$1 = a.x, _y$1 = a.y, _z = a.z;
                var len = _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
                return len > 0 && (len = 1 / Math.sqrt(len), out.x = _x$1 * len, out.y = _y$1 * len, 
                out.z = _z * len), out;
            }
        }, {
            key: "dot",
            value: function dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z;
            }
        }, {
            key: "cross",
            value: function cross(out, a, b) {
                var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
                return out.x = ay * bz - az * by, out.y = az * bx - ax * bz, out.z = ax * by - ay * bx, 
                out;
            }
        }, {
            key: "lerp",
            value: function lerp(out, a, b, t) {
                return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
                out;
            }
        }, {
            key: "random",
            value: function random$1(out, scale) {
                scale = scale || 1;
                var phi = 2 * random() * Math.PI, cosTheta = 2 * random() - 1, sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                return out.x = sinTheta * Math.cos(phi) * scale, out.y = sinTheta * Math.sin(phi) * scale, 
                out.z = cosTheta * scale, out;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(out, a, m) {
                _x$1 = a.x, _y$1 = a.y, _z = a.z;
                var rhw = m.m03 * _x$1 + m.m07 * _y$1 + m.m11 * _z + m.m15;
                return rhw = rhw ? 1 / rhw : 1, out.x = (m.m00 * _x$1 + m.m04 * _y$1 + m.m08 * _z + m.m12) * rhw, 
                out.y = (m.m01 * _x$1 + m.m05 * _y$1 + m.m09 * _z + m.m13) * rhw, out.z = (m.m02 * _x$1 + m.m06 * _y$1 + m.m10 * _z + m.m14) * rhw, 
                out;
            }
        }, {
            key: "transformMat4Normal",
            value: function transformMat4Normal(out, a, m) {
                _x$1 = a.x, _y$1 = a.y, _z = a.z;
                var rhw = m.m03 * _x$1 + m.m07 * _y$1 + m.m11 * _z;
                return rhw = rhw ? 1 / rhw : 1, out.x = (m.m00 * _x$1 + m.m04 * _y$1 + m.m08 * _z) * rhw, 
                out.y = (m.m01 * _x$1 + m.m05 * _y$1 + m.m09 * _z) * rhw, out.z = (m.m02 * _x$1 + m.m06 * _y$1 + m.m10 * _z) * rhw, 
                out;
            }
        }, {
            key: "transformMat3",
            value: function transformMat3(out, a, m) {
                return _x$1 = a.x, _y$1 = a.y, _z = a.z, out.x = _x$1 * m.m00 + _y$1 * m.m03 + _z * m.m06, 
                out.y = _x$1 * m.m01 + _y$1 * m.m04 + _z * m.m07, out.z = _x$1 * m.m02 + _y$1 * m.m05 + _z * m.m08, 
                out;
            }
        }, {
            key: "transformAffine",
            value: function transformAffine(out, v, m) {
                return _x$1 = v.x, _y$1 = v.y, _z = v.z, out.x = m.m00 * _x$1 + m.m01 * _y$1 + m.m02 * _z + m.m03, 
                out.y = m.m04 * _x$1 + m.m05 * _y$1 + m.m06 * _z + m.m07, out.x = m.m08 * _x$1 + m.m09 * _y$1 + m.m10 * _z + m.m11, 
                out;
            }
        }, {
            key: "transformQuat",
            value: function transformQuat(out, a, q) {
                var ix = q.w * a.x + q.y * a.z - q.z * a.y, iy = q.w * a.y + q.z * a.x - q.x * a.z, iz = q.w * a.z + q.x * a.y - q.y * a.x, iw = -q.x * a.x - q.y * a.y - q.z * a.z;
                return out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y, out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z, 
                out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x, out;
            }
        }, {
            key: "transformRTS",
            value: function transformRTS(out, a, r, t, s) {
                var x = a.x * s.x, y = a.y * s.y, z = a.z * s.z, ix = r.w * x + r.y * z - r.z * y, iy = r.w * y + r.z * x - r.x * z, iz = r.w * z + r.x * y - r.y * x, iw = -r.x * x - r.y * y - r.z * z;
                return out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x, out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y, 
                out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z, out;
            }
        }, {
            key: "transformInverseRTS",
            value: function transformInverseRTS(out, a, r, t, s) {
                var x = a.x - t.x, y = a.y - t.y, z = a.z - t.z, ix = r.w * x - r.y * z + r.z * y, iy = r.w * y - r.z * x + r.x * z, iz = r.w * z - r.x * y + r.y * x, iw = r.x * x + r.y * y + r.z * z;
                return out.x = (ix * r.w + iw * r.x + iy * r.z - iz * r.y) / s.x, out.y = (iy * r.w + iw * r.y + iz * r.x - ix * r.z) / s.y, 
                out.z = (iz * r.w + iw * r.z + ix * r.y - iy * r.x) / s.z, out;
            }
        }, {
            key: "rotateX",
            value: function rotateX(out, v, o, a) {
                _x$1 = v.x - o.x, _y$1 = v.y - o.y, _z = v.z - o.z;
                var cos = Math.cos(a), sin = Math.sin(a), rx = _x$1, ry = _y$1 * cos - _z * sin, rz = _y$1 * sin + _z * cos;
                return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
            }
        }, {
            key: "rotateY",
            value: function rotateY(out, v, o, a) {
                _x$1 = v.x - o.x, _y$1 = v.y - o.y, _z = v.z - o.z;
                var cos = Math.cos(a), sin = Math.sin(a), rx = _z * sin + _x$1 * cos, ry = _y$1, rz = _z * cos - _x$1 * sin;
                return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
            }
        }, {
            key: "rotateZ",
            value: function rotateZ(out, v, o, a) {
                _x$1 = v.x - o.x, _y$1 = v.y - o.y, _z = v.z - o.z;
                var cos = Math.cos(a), sin = Math.sin(a), rx = _x$1 * cos - _y$1 * sin, ry = _x$1 * sin + _y$1 * cos, rz = _z;
                return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
            }
        }, {
            key: "toArray",
            value: function toArray(out, v) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out[ofs + 2] = v.z, out;
            }
        }, {
            key: "fromArray",
            value: function fromArray(out, arr) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out.z = arr[ofs + 2], out;
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z;
            }
        }, {
            key: "equals",
            value: function equals(a, b) {
                var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-6, a0 = a.x, a1 = a.y, a2 = a.z, b0 = b.x, b1 = b.y, b2 = b.z;
                return Math.abs(a0 - b0) <= epsilon * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1, Math.abs(a2), Math.abs(b2));
            }
        }, {
            key: "angle",
            value: function angle(a, b) {
                Vec3.normalize(v3_1, a), Vec3.normalize(v3_2, b);
                var cosine = Vec3.dot(v3_1, v3_2);
                return cosine > 1 ? 0 : cosine < -1 ? Math.PI : Math.acos(cosine);
            }
        }, {
            key: "projectOnPlane",
            value: function projectOnPlane(out, a, n) {
                return Vec3.subtract(out, a, Vec3.project(out, a, n));
            }
        }, {
            key: "project",
            value: function project(out, a, b) {
                var sqrLen = Vec3.lengthSqr(b);
                return sqrLen < 1e-6 ? Vec3.set(out, 0, 0, 0) : Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
            }
        } ]), _createClass(Vec3, [ {
            key: "clone",
            value: function clone() {
                return new Vec3(this.x, this.y, this.z);
            }
        }, {
            key: "set",
            value: function set(x, y, z) {
                return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z) : (this.x = x || 0, 
                this.y = y || 0, this.z = z || 0), this;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e-6;
                return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z));
            }
        }, {
            key: "equals3f",
            value: function equals3f(x, y, z) {
                var epsilon = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e-6;
                return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(z));
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(other) {
                return this.x === other.x && this.y === other.y && this.z === other.z;
            }
        }, {
            key: "strictEquals3f",
            value: function strictEquals3f(x, y, z) {
                return this.x === x && this.y === y && this.z === z;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.z.toFixed(2), ")");
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio) {
                return this.x = this.x + ratio * (to.x - this.x), this.y = this.y + ratio * (to.y - this.y), 
                this.z = this.z + ratio * (to.z - this.z), this;
            }
        }, {
            key: "add",
            value: function add(other) {
                return this.x = this.x + other.x, this.y = this.y + other.y, this.z = this.z + other.z, 
                this;
            }
        }, {
            key: "add3f",
            value: function add3f(x, y, z) {
                return this.x = this.x + x, this.y = this.y + y, this.z = this.z + z, this;
            }
        }, {
            key: "subtract",
            value: function subtract(other) {
                return this.x = this.x - other.x, this.y = this.y - other.y, this.z = this.z - other.z, 
                this;
            }
        }, {
            key: "subtract3f",
            value: function subtract3f(x, y, z) {
                return this.x = this.x - x, this.y = this.y - y, this.z = this.z - z, this;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(scalar) {
                return "object" === _typeof(scalar) && console.warn("should use Vec3.multiply for vector * vector operation"), 
                this.x = this.x * scalar, this.y = this.y * scalar, this.z = this.z * scalar, this;
            }
        }, {
            key: "multiply",
            value: function multiply(other) {
                return "object" !== _typeof(other) && console.warn("should use Vec3.scale for vector * scalar operation"), 
                this.x = this.x * other.x, this.y = this.y * other.y, this.z = this.z * other.z, 
                this;
            }
        }, {
            key: "multiply3f",
            value: function multiply3f(x, y, z) {
                return this.x = this.x * x, this.y = this.y * y, this.z = this.z * z, this;
            }
        }, {
            key: "divide",
            value: function divide(other) {
                return this.x = this.x / other.x, this.y = this.y / other.y, this.z = this.z / other.z, 
                this;
            }
        }, {
            key: "divide3f",
            value: function divide3f(x, y, z) {
                return this.x = this.x / x, this.y = this.y / y, this.z = this.z / z, this;
            }
        }, {
            key: "negative",
            value: function negative() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
            }
        }, {
            key: "clampf",
            value: function clampf(minInclusive, maxInclusive) {
                return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
                this.z = clamp(this.z, minInclusive.z, maxInclusive.z), this;
            }
        }, {
            key: "dot",
            value: function dot(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
        }, {
            key: "cross",
            value: function cross(other) {
                var ax = this.x, ay = this.y, az = this.z, bx = other.x, by = other.y, bz = other.z;
                return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, 
                this;
            }
        }, {
            key: "length",
            value: function length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }
        }, {
            key: "lengthSqr",
            value: function lengthSqr() {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            }
        }, {
            key: "normalize",
            value: function normalize() {
                _x$1 = this.x, _y$1 = this.y, _z = this.z;
                var len = _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
                return len > 0 && (len = 1 / Math.sqrt(len), this.x = _x$1 * len, this.y = _y$1 * len, 
                this.z = _z * len), this;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(matrix) {
                _x$1 = this.x, _y$1 = this.y, _z = this.z;
                var rhw = matrix.m03 * _x$1 + matrix.m07 * _y$1 + matrix.m11 * _z + matrix.m15;
                return rhw = rhw ? 1 / rhw : 1, this.x = (matrix.m00 * _x$1 + matrix.m04 * _y$1 + matrix.m08 * _z + matrix.m12) * rhw, 
                this.y = (matrix.m01 * _x$1 + matrix.m05 * _y$1 + matrix.m09 * _z + matrix.m13) * rhw, 
                this.z = (matrix.m02 * _x$1 + matrix.m06 * _y$1 + matrix.m10 * _z + matrix.m14) * rhw, 
                this;
            }
        } ]), Vec3;
    }(ValueType);
    Vec3.UNIT_X = Object.freeze(new Vec3(1, 0, 0)), Vec3.UNIT_Y = Object.freeze(new Vec3(0, 1, 0)), 
    Vec3.UNIT_Z = Object.freeze(new Vec3(0, 0, 1)), Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0)), 
    Vec3.UP = Object.freeze(new Vec3(0, 1, 0)), Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1)), 
    Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0)), Vec3.ONE = Object.freeze(new Vec3(1, 1, 1)), 
    Vec3.NEG_ONE = Object.freeze(new Vec3(-1, -1, -1));
    var v3_1 = new Vec3, v3_2 = new Vec3;
    function v3(x, y, z) {
        return new Vec3(x, y, z);
    }
    CCClass.fastDefine("cc.Vec3", Vec3, {
        x: 0,
        y: 0,
        z: 0
    }), cc.Vec3 = Vec3, cc.v3 = v3;
    var _x$2 = 0, _y$2 = 0, _z$1 = 0, _w = 0, Vec4 = function(_ValueType) {
        function Vec4(x, y, z, w) {
            var _this;
            return _classCallCheck(this, Vec4), _this = _possibleConstructorReturn(this, _getPrototypeOf(Vec4).call(this)), 
            x && "object" === _typeof(x) ? (_this.x = x.x, _this.y = x.y, _this.z = x.z, _this.w = x.w) : (_this.x = x || 0, 
            _this.y = y || 0, _this.z = z || 0, _this.w = w || 0), _this;
        }
        return _inherits(Vec4, _ValueType), _createClass(Vec4, null, [ {
            key: "clone",
            value: function clone(a) {
                return new Vec4(a.x, a.y, a.z, a.w);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.x = a.x, out.y = a.y, out.z = a.z, out.w = a.w, out;
            }
        }, {
            key: "set",
            value: function set(out, x, y, z, w) {
                return out.x = x, out.y = y, out.z = z, out.w = w, out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z, out.w = a.w + b.w, 
                out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.x = a.x - b.x, out.y = a.y - b.y, out.z = a.z - b.z, out.w = a.w - b.w, 
                out;
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                return out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z, out.w = a.w * b.w, 
                out;
            }
        }, {
            key: "divide",
            value: function divide(out, a, b) {
                return out.x = a.x / b.x, out.y = a.y / b.y, out.z = a.z / b.z, out.w = a.w / b.w, 
                out;
            }
        }, {
            key: "ceil",
            value: function ceil(out, a) {
                return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out.z = Math.ceil(a.z), out.w = Math.ceil(a.w), 
                out;
            }
        }, {
            key: "floor",
            value: function floor(out, a) {
                return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out.z = Math.floor(a.z), 
                out.w = Math.floor(a.w), out;
            }
        }, {
            key: "min",
            value: function min(out, a, b) {
                return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z), 
                out.w = Math.min(a.w, b.w), out;
            }
        }, {
            key: "max",
            value: function max(out, a, b) {
                return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z), 
                out.w = Math.max(a.w, b.w), out;
            }
        }, {
            key: "round",
            value: function round(out, a) {
                return out.x = Math.round(a.x), out.y = Math.round(a.y), out.z = Math.round(a.z), 
                out.w = Math.round(a.w), out;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(out, a, b) {
                return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out.w = a.w * b, out;
            }
        }, {
            key: "scaleAndAdd",
            value: function scaleAndAdd(out, a, b, scale) {
                return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
                out.w = a.w + b.w * scale, out;
            }
        }, {
            key: "distance",
            value: function distance(a, b) {
                var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
            }
        }, {
            key: "squaredDistance",
            value: function squaredDistance(a, b) {
                var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
                return x * x + y * y + z * z + w * w;
            }
        }, {
            key: "len",
            value: function len(a) {
                return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, Math.sqrt(_x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w);
            }
        }, {
            key: "lengthSqr",
            value: function lengthSqr(a) {
                return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
            }
        }, {
            key: "negate",
            value: function negate(out, a) {
                return out.x = -a.x, out.y = -a.y, out.z = -a.z, out.w = -a.w, out;
            }
        }, {
            key: "inverse",
            value: function inverse(out, a) {
                return out.x = 1 / a.x, out.y = 1 / a.y, out.z = 1 / a.z, out.w = 1 / a.w, out;
            }
        }, {
            key: "inverseSafe",
            value: function inverseSafe(out, a) {
                return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, Math.abs(_x$2) < 1e-6 ? out.x = 0 : out.x = 1 / _x$2, 
                Math.abs(_y$2) < 1e-6 ? out.y = 0 : out.y = 1 / _y$2, Math.abs(_z$1) < 1e-6 ? out.z = 0 : out.z = 1 / _z$1, 
                Math.abs(_w) < 1e-6 ? out.w = 0 : out.w = 1 / _w, out;
            }
        }, {
            key: "normalize",
            value: function normalize(out, a) {
                _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w;
                var len = _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
                return len > 0 && (len = 1 / Math.sqrt(len), out.x = _x$2 * len, out.y = _y$2 * len, 
                out.z = _z$1 * len, out.w = _w * len), out;
            }
        }, {
            key: "dot",
            value: function dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
            }
        }, {
            key: "lerp",
            value: function lerp(out, a, b, t) {
                return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
                out.w = a.w + t * (b.w - a.w), out;
            }
        }, {
            key: "random",
            value: function random$1(out, scale) {
                scale = scale || 1;
                var phi = 2 * random() * Math.PI, cosTheta = 2 * random() - 1, sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                return out.x = sinTheta * Math.cos(phi) * scale, out.y = sinTheta * Math.sin(phi) * scale, 
                out.z = cosTheta * scale, out.w = 0, out;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(out, a, m) {
                return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, out.x = m.m00 * _x$2 + m.m04 * _y$2 + m.m08 * _z$1 + m.m12 * _w, 
                out.y = m.m01 * _x$2 + m.m05 * _y$2 + m.m09 * _z$1 + m.m13 * _w, out.z = m.m02 * _x$2 + m.m06 * _y$2 + m.m10 * _z$1 + m.m14 * _w, 
                out.w = m.m03 * _x$2 + m.m07 * _y$2 + m.m11 * _z$1 + m.m15 * _w, out;
            }
        }, {
            key: "transformAffine",
            value: function transformAffine(out, v, m) {
                return _x$2 = v.x, _y$2 = v.y, _z$1 = v.z, _w = v.w, out.x = m.m00 * _x$2 + m.m01 * _y$2 + m.m02 * _z$1 + m.m03 * _w, 
                out.y = m.m04 * _x$2 + m.m05 * _y$2 + m.m06 * _z$1 + m.m07 * _w, out.x = m.m08 * _x$2 + m.m09 * _y$2 + m.m10 * _z$1 + m.m11 * _w, 
                out.w = v.w, out;
            }
        }, {
            key: "transformQuat",
            value: function transformQuat(out, a, q) {
                var x = a.x, y = a.y, z = a.z;
                _x$2 = q.x, _y$2 = q.y, _z$1 = q.z;
                var ix = (_w = q.w) * x + _y$2 * z - _z$1 * y, iy = _w * y + _z$1 * x - _x$2 * z, iz = _w * z + _x$2 * y - _y$2 * x, iw = -_x$2 * x - _y$2 * y - _z$1 * z;
                return out.x = ix * _w + iw * -_x$2 + iy * -_z$1 - iz * -_y$2, out.y = iy * _w + iw * -_y$2 + iz * -_x$2 - ix * -_z$1, 
                out.z = iz * _w + iw * -_z$1 + ix * -_y$2 - iy * -_x$2, out.w = a.w, out;
            }
        }, {
            key: "toArray",
            value: function toArray(out, v) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out[ofs + 2] = v.z, out[ofs + 3] = v.w, 
                out;
            }
        }, {
            key: "fromArray",
            value: function fromArray(out, arr) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out.z = arr[ofs + 2], out.w = arr[ofs + 3], 
                out;
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
            }
        }, {
            key: "equals",
            value: function equals(a, b) {
                var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-6;
                return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1, Math.abs(a.w), Math.abs(b.w));
            }
        } ]), _createClass(Vec4, [ {
            key: "clone",
            value: function clone() {
                return new Vec4(this.x, this.y, this.z, this.w);
            }
        }, {
            key: "set",
            value: function set(x, y, z, w) {
                return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z, 
                this.w = x.w) : (this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = w || 0), 
                this;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e-6;
                return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(other.w));
            }
        }, {
            key: "equals4f",
            value: function equals4f(x, y, z, w) {
                var epsilon = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e-6;
                return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(z)) && Math.abs(this.w - w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(w));
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(other) {
                return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
            }
        }, {
            key: "strictEquals4f",
            value: function strictEquals4f(x, y, z, w) {
                return this.x === x && this.y === y && this.z === z && this.w === w;
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio) {
                return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, this.x = _x$2 + ratio * (to.x - _x$2), 
                this.y = _y$2 + ratio * (to.y - _y$2), this.z = _z$1 + ratio * (to.z - _z$1), this.w = _w + ratio * (to.w - _w), 
                this;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.z.toFixed(2), ", ").concat(this.w.toFixed(2), ")");
            }
        }, {
            key: "clampf",
            value: function clampf(minInclusive, maxInclusive) {
                return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
                this.z = clamp(this.z, minInclusive.z, maxInclusive.z), this.w = clamp(this.w, minInclusive.w, maxInclusive.w), 
                this;
            }
        }, {
            key: "add",
            value: function add(other) {
                return this.x = this.x + other.x, this.y = this.y + other.y, this.z = this.z + other.z, 
                this.w = this.w + other.w, this;
            }
        }, {
            key: "add4f",
            value: function add4f(x, y, z, w) {
                return this.x = this.x + x, this.y = this.y + y, this.z = this.z + z, this.w = this.w + w, 
                this;
            }
        }, {
            key: "subtract",
            value: function subtract(other) {
                return this.x = this.x - other.x, this.y = this.y - other.y, this.z = this.z - other.z, 
                this.w = this.w - other.w, this;
            }
        }, {
            key: "subtract4f",
            value: function subtract4f(x, y, z, w) {
                return this.x = this.x - x, this.y = this.y - y, this.z = this.z - z, this.w = this.w - w, 
                this;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(scalar) {
                return "object" === _typeof(scalar) && console.warn("should use Vec4.multiply for vector * vector operation"), 
                this.x = this.x * scalar, this.y = this.y * scalar, this.z = this.z * scalar, this.w = this.w * scalar, 
                this;
            }
        }, {
            key: "multiply",
            value: function multiply(other) {
                return "object" !== _typeof(other) && console.warn("should use Vec4.scale for vector * scalar operation"), 
                this.x = this.x * other.x, this.y = this.y * other.y, this.z = this.z * other.z, 
                this.w = this.w * other.w, this;
            }
        }, {
            key: "multiply4f",
            value: function multiply4f(x, y, z, w) {
                return this.x = this.x * x, this.y = this.y * y, this.z = this.z * z, this.w = this.w * w, 
                this;
            }
        }, {
            key: "divide",
            value: function divide(other) {
                return this.x = this.x / other.x, this.y = this.y / other.y, this.z = this.z / other.z, 
                this.w = this.w / other.w, this;
            }
        }, {
            key: "divide4f",
            value: function divide4f(x, y, z, w) {
                return this.x = this.x / x, this.y = this.y / y, this.z = this.z / z, this.w = this.w / w, 
                this;
            }
        }, {
            key: "negative",
            value: function negative() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
            }
        }, {
            key: "dot",
            value: function dot(vector) {
                return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
            }
        }, {
            key: "cross",
            value: function cross(vector) {
                var ax = this.x, ay = this.y, az = this.z, bx = vector.x, by = vector.y, bz = vector.z;
                return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, 
                this;
            }
        }, {
            key: "length",
            value: function length() {
                return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, Math.sqrt(_x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w);
            }
        }, {
            key: "lengthSqr",
            value: function lengthSqr() {
                return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
            }
        }, {
            key: "normalize",
            value: function normalize() {
                _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w;
                var len = _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
                return len > 0 && (len = 1 / Math.sqrt(len), this.x = _x$2 * len, this.y = _y$2 * len, 
                this.z = _z$1 * len, this.w = _w * len), this;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(matrix) {
                return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, this.x = matrix.m00 * _x$2 + matrix.m04 * _y$2 + matrix.m08 * _z$1 + matrix.m12 * _w, 
                this.y = matrix.m01 * _x$2 + matrix.m05 * _y$2 + matrix.m09 * _z$1 + matrix.m13 * _w, 
                this.z = matrix.m02 * _x$2 + matrix.m06 * _y$2 + matrix.m10 * _z$1 + matrix.m14 * _w, 
                this.w = matrix.m03 * _x$2 + matrix.m07 * _y$2 + matrix.m11 * _z$1 + matrix.m15 * _w, 
                this;
            }
        } ]), Vec4;
    }(ValueType);
    function v4(x, y, z, w) {
        return new Vec4(x, y, z, w);
    }
    Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0)), Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1)), 
    Vec4.NEG_ONE = Object.freeze(new Vec4(-1, -1, -1, -1)), CCClass.fastDefine("cc.Vec4", Vec4, {
        x: 0,
        y: 0,
        z: 0,
        w: 0
    }), cc.Vec4 = Vec4, cc.v4 = v4;
    var _a00 = 0, _a01 = 0, _a02 = 0, _a10 = 0, _a11 = 0, _a12 = 0, _a20 = 0, _a21 = 0, _a22 = 0, Mat3 = function(_ValueType) {
        function Mat3() {
            var _this, m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1;
            return _classCallCheck(this, Mat3), _this = _possibleConstructorReturn(this, _getPrototypeOf(Mat3).call(this)), 
            "object" === _typeof(m00) ? (_this.m00 = m00.m00, _this.m01 = m00.m01, _this.m02 = m00.m02, 
            _this.m03 = m00.m03, _this.m04 = m00.m04, _this.m05 = m00.m05, _this.m06 = m00.m06, 
            _this.m07 = m00.m07, _this.m08 = m00.m08) : (_this.m00 = m00, _this.m01 = m01, _this.m02 = m02, 
            _this.m03 = m03, _this.m04 = m04, _this.m05 = m05, _this.m06 = m06, _this.m07 = m07, 
            _this.m08 = m08), _this;
        }
        return _inherits(Mat3, _ValueType), _createClass(Mat3, null, [ {
            key: "clone",
            value: function clone(a) {
                return new Mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, out.m04 = a.m04, 
                out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, out;
            }
        }, {
            key: "set",
            value: function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
                return out.m00 = m00, out.m01 = m01, out.m02 = m02, out.m03 = m10, out.m04 = m11, 
                out.m05 = m12, out.m06 = m20, out.m07 = m21, out.m08 = m22, out;
            }
        }, {
            key: "identity",
            value: function identity(out) {
                return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 1, out.m05 = 0, 
                out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
            }
        }, {
            key: "transpose",
            value: function transpose(out, a) {
                return out === a ? (_a01 = a.m01, _a02 = a.m02, _a12 = a.m05, out.m01 = a.m03, out.m02 = a.m06, 
                out.m03 = _a01, out.m05 = a.m07, out.m06 = _a02, out.m07 = _a12) : (out.m00 = a.m00, 
                out.m01 = a.m03, out.m02 = a.m06, out.m03 = a.m01, out.m04 = a.m04, out.m05 = a.m07, 
                out.m06 = a.m02, out.m07 = a.m05, out.m08 = a.m08), out;
            }
        }, {
            key: "invert",
            value: function invert(out, a) {
                _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                _a20 = a.m06, _a21 = a.m07;
                var b01 = (_a22 = a.m08) * _a11 - _a12 * _a21, b11 = -_a22 * _a10 + _a12 * _a20, b21 = _a21 * _a10 - _a11 * _a20, det = _a00 * b01 + _a01 * b11 + _a02 * b21;
                return det ? (det = 1 / det, out.m00 = b01 * det, out.m01 = (-_a22 * _a01 + _a02 * _a21) * det, 
                out.m02 = (_a12 * _a01 - _a02 * _a11) * det, out.m03 = b11 * det, out.m04 = (_a22 * _a00 - _a02 * _a20) * det, 
                out.m05 = (-_a12 * _a00 + _a02 * _a10) * det, out.m06 = b21 * det, out.m07 = (-_a21 * _a00 + _a01 * _a20) * det, 
                out.m08 = (_a11 * _a00 - _a01 * _a10) * det, out) : out;
            }
        }, {
            key: "determinant",
            value: function determinant(a) {
                return _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                _a20 = a.m06, _a21 = a.m07, _a22 = a.m08, _a00 * (_a22 * _a11 - _a12 * _a21) + _a01 * (-_a22 * _a10 + _a12 * _a20) + _a02 * (_a21 * _a10 - _a11 * _a20);
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
                var b00 = b.m00, b01 = b.m01, b02 = b.m02, b10 = b.m03, b11 = b.m04, b12 = b.m05, b20 = b.m06, b21 = b.m07, b22 = b.m08;
                return out.m00 = b00 * _a00 + b01 * _a10 + b02 * _a20, out.m01 = b00 * _a01 + b01 * _a11 + b02 * _a21, 
                out.m02 = b00 * _a02 + b01 * _a12 + b02 * _a22, out.m03 = b10 * _a00 + b11 * _a10 + b12 * _a20, 
                out.m04 = b10 * _a01 + b11 * _a11 + b12 * _a21, out.m05 = b10 * _a02 + b11 * _a12 + b12 * _a22, 
                out.m06 = b20 * _a00 + b21 * _a10 + b22 * _a20, out.m07 = b20 * _a01 + b21 * _a11 + b22 * _a21, 
                out.m08 = b20 * _a02 + b21 * _a12 + b22 * _a22, out;
            }
        }, {
            key: "multiplyMat4",
            value: function multiplyMat4(out, a, b) {
                _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
                var b00 = b.m00, b01 = b.m01, b02 = b.m02, b10 = b.m04, b11 = b.m05, b12 = b.m06, b20 = b.m08, b21 = b.m09, b22 = b.m10;
                return out.m00 = b00 * _a00 + b01 * _a10 + b02 * _a20, out.m01 = b00 * _a01 + b01 * _a11 + b02 * _a21, 
                out.m02 = b00 * _a02 + b01 * _a12 + b02 * _a22, out.m03 = b10 * _a00 + b11 * _a10 + b12 * _a20, 
                out.m04 = b10 * _a01 + b11 * _a11 + b12 * _a21, out.m05 = b10 * _a02 + b11 * _a12 + b12 * _a22, 
                out.m06 = b20 * _a00 + b21 * _a10 + b22 * _a20, out.m07 = b20 * _a01 + b21 * _a11 + b22 * _a21, 
                out.m08 = b20 * _a02 + b21 * _a12 + b22 * _a22, out;
            }
        }, {
            key: "transfrom",
            value: function transfrom(out, a, v) {
                Mat3.transform(out, a, v);
            }
        }, {
            key: "transform",
            value: function transform(out, a, v) {
                _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
                var x = v.x, y = v.y;
                return out.m00 = _a00, out.m01 = _a01, out.m02 = _a02, out.m03 = _a10, out.m04 = _a11, 
                out.m05 = _a12, out.m06 = x * _a00 + y * _a10 + _a20, out.m07 = x * _a01 + y * _a11 + _a21, 
                out.m08 = x * _a02 + y * _a12 + _a22, out;
            }
        }, {
            key: "scale",
            value: function scale(out, a, v) {
                var x = v.x, y = v.y;
                return out.m00 = x * a.m00, out.m01 = x * a.m01, out.m02 = x * a.m02, out.m03 = y * a.m03, 
                out.m04 = y * a.m04, out.m05 = y * a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, 
                out;
            }
        }, {
            key: "rotate",
            value: function rotate(out, a, rad) {
                _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
                var s = Math.sin(rad), c = Math.cos(rad);
                return out.m00 = c * _a00 + s * _a10, out.m01 = c * _a01 + s * _a11, out.m02 = c * _a02 + s * _a12, 
                out.m03 = c * _a10 - s * _a00, out.m04 = c * _a11 - s * _a01, out.m05 = c * _a12 - s * _a02, 
                out.m06 = _a20, out.m07 = _a21, out.m08 = _a22, out;
            }
        }, {
            key: "fromMat4",
            value: function fromMat4(out, a) {
                return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m04, out.m04 = a.m05, 
                out.m05 = a.m06, out.m06 = a.m08, out.m07 = a.m09, out.m08 = a.m10, out;
            }
        }, {
            key: "fromViewUp",
            value: function fromViewUp(out, view, up) {
                return Vec3.lengthSqr(view) < 1e-12 ? (Mat3.identity(out), out) : (up = up || Vec3.UNIT_Y, 
                Vec3.normalize(v3_1$1, Vec3.cross(v3_1$1, up, view)), Vec3.lengthSqr(v3_1$1) < 1e-12 ? (Mat3.identity(out), 
                out) : (Vec3.cross(v3_2$1, view, v3_1$1), Mat3.set(out, v3_1$1.x, v3_1$1.y, v3_1$1.z, v3_2$1.x, v3_2$1.y, v3_2$1.z, view.x, view.y, view.z), 
                out));
            }
        }, {
            key: "fromTranslation",
            value: function fromTranslation(out, v) {
                return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 1, out.m05 = 0, 
                out.m06 = v.x, out.m07 = v.y, out.m08 = 1, out;
            }
        }, {
            key: "fromScaling",
            value: function fromScaling(out, v) {
                return out.m00 = v.x, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = v.y, out.m05 = 0, 
                out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
            }
        }, {
            key: "fromRotation",
            value: function fromRotation(out, rad) {
                var s = Math.sin(rad), c = Math.cos(rad);
                return out.m00 = c, out.m01 = s, out.m02 = 0, out.m03 = -s, out.m04 = c, out.m05 = 0, 
                out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
            }
        }, {
            key: "fromQuat",
            value: function fromQuat(out, q) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                return out.m00 = 1 - yy - zz, out.m03 = yx - wz, out.m06 = zx + wy, out.m01 = yx + wz, 
                out.m04 = 1 - xx - zz, out.m07 = zy - wx, out.m02 = zx - wy, out.m05 = zy + wx, 
                out.m08 = 1 - xx - yy, out;
            }
        }, {
            key: "inverseTransposeMat4",
            value: function inverseTransposeMat4(out, a) {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15, b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                return det ? (det = 1 / det, out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det, 
                out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det, out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det, 
                out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det, out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det, 
                out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det, out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det, 
                out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det, out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det, 
                out) : null;
            }
        }, {
            key: "toArray",
            value: function toArray(out, m) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = m.m00, out[ofs + 1] = m.m01, out[ofs + 2] = m.m02, out[ofs + 3] = m.m03, 
                out[ofs + 4] = m.m04, out[ofs + 5] = m.m05, out[ofs + 6] = m.m06, out[ofs + 7] = m.m07, 
                out[ofs + 8] = m.m08, out;
            }
        }, {
            key: "fromArray",
            value: function fromArray(out, arr) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out.m00 = arr[ofs + 0], out.m01 = arr[ofs + 1], out.m02 = arr[ofs + 2], out.m03 = arr[ofs + 3], 
                out.m04 = arr[ofs + 4], out.m05 = arr[ofs + 5], out.m06 = arr[ofs + 6], out.m07 = arr[ofs + 7], 
                out.m08 = arr[ofs + 8], out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.m00 = a.m00 + b.m00, out.m01 = a.m01 + b.m01, out.m02 = a.m02 + b.m02, 
                out.m03 = a.m03 + b.m03, out.m04 = a.m04 + b.m04, out.m05 = a.m05 + b.m05, out.m06 = a.m06 + b.m06, 
                out.m07 = a.m07 + b.m07, out.m08 = a.m08 + b.m08, out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.m00 = a.m00 - b.m00, out.m01 = a.m01 - b.m01, out.m02 = a.m02 - b.m02, 
                out.m03 = a.m03 - b.m03, out.m04 = a.m04 - b.m04, out.m05 = a.m05 - b.m05, out.m06 = a.m06 - b.m06, 
                out.m07 = a.m07 - b.m07, out.m08 = a.m08 - b.m08, out;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(out, a, b) {
                return out.m00 = a.m00 * b, out.m01 = a.m01 * b, out.m02 = a.m02 * b, out.m03 = a.m03 * b, 
                out.m04 = a.m04 * b, out.m05 = a.m05 * b, out.m06 = a.m06 * b, out.m07 = a.m07 * b, 
                out.m08 = a.m08 * b, out;
            }
        }, {
            key: "multiplyScalarAndAdd",
            value: function multiplyScalarAndAdd(out, a, b, scale) {
                return out.m00 = b.m00 * scale + a.m00, out.m01 = b.m01 * scale + a.m01, out.m02 = b.m02 * scale + a.m02, 
                out.m03 = b.m03 * scale + a.m03, out.m04 = b.m04 * scale + a.m04, out.m05 = b.m05 * scale + a.m05, 
                out.m06 = b.m06 * scale + a.m06, out.m07 = b.m07 * scale + a.m07, out.m08 = b.m08 * scale + a.m08, 
                out;
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(a, b) {
                return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
            }
        }, {
            key: "equals",
            value: function equals(a, b) {
                var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-6;
                return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1, Math.abs(a.m08), Math.abs(b.m08));
            }
        } ]), _createClass(Mat3, [ {
            key: "clone",
            value: function clone() {
                var t = this;
                return new Mat3(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08);
            }
        }, {
            key: "set",
            value: function set() {
                var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1;
                return "object" === _typeof(m00) ? (this.m00 = m00.m00, this.m01 = m00.m01, this.m02 = m00.m02, 
                this.m03 = m00.m03, this.m04 = m00.m04, this.m05 = m00.m05, this.m06 = m00.m06, 
                this.m07 = m00.m07, this.m08 = m00.m08) : (this.m00 = m00, this.m01 = m01, this.m02 = m02, 
                this.m03 = m03, this.m04 = m04, this.m05 = m05, this.m06 = m06, this.m07 = m07, 
                this.m08 = m08), this;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e-6;
                return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1, Math.abs(this.m08), Math.abs(other.m08));
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(other) {
                return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08;
            }
        }, {
            key: "toString",
            value: function toString() {
                var t = this;
                return "[\n" + t.m00 + ", " + t.m01 + ", " + t.m02 + ",\n" + t.m03 + ",\n" + t.m04 + ", " + t.m05 + ",\n" + t.m06 + ", " + t.m07 + ",\n" + t.m08 + "\n]";
            }
        }, {
            key: "identity",
            value: function identity() {
                return this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m04 = 1, this.m05 = 0, 
                this.m06 = 0, this.m07 = 0, this.m08 = 1, this;
            }
        }, {
            key: "transpose",
            value: function transpose() {
                var a01 = this.m01, a02 = this.m02, a12 = this.m05;
                return this.m01 = this.m03, this.m02 = this.m06, this.m03 = a01, this.m05 = this.m07, 
                this.m06 = a02, this.m07 = a12, this;
            }
        }, {
            key: "invert",
            value: function invert() {
                _a00 = this.m00, _a01 = this.m01, _a02 = this.m02, _a10 = this.m03, _a11 = this.m04, 
                _a12 = this.m05, _a20 = this.m06, _a21 = this.m07;
                var b01 = (_a22 = this.m08) * _a11 - _a12 * _a21, b11 = -_a22 * _a10 + _a12 * _a20, b21 = _a21 * _a10 - _a11 * _a20, det = _a00 * b01 + _a01 * b11 + _a02 * b21;
                return det ? (det = 1 / det, this.m00 = b01 * det, this.m01 = (-_a22 * _a01 + _a02 * _a21) * det, 
                this.m02 = (_a12 * _a01 - _a02 * _a11) * det, this.m03 = b11 * det, this.m04 = (_a22 * _a00 - _a02 * _a20) * det, 
                this.m05 = (-_a12 * _a00 + _a02 * _a10) * det, this.m06 = b21 * det, this.m07 = (-_a21 * _a00 + _a01 * _a20) * det, 
                this.m08 = (_a11 * _a00 - _a01 * _a10) * det, this) : null;
            }
        }, {
            key: "determinant",
            value: function determinant() {
                return _a00 = this.m00, _a01 = this.m01, _a02 = this.m02, _a10 = this.m03, _a11 = this.m04, 
                _a12 = this.m05, _a20 = this.m06, _a21 = this.m07, _a22 = this.m08, _a00 * (_a22 * _a11 - _a12 * _a21) + _a01 * (-_a22 * _a10 + _a12 * _a20) + _a02 * (_a21 * _a10 - _a11 * _a20);
            }
        }, {
            key: "add",
            value: function add(mat) {
                return this.m00 = this.m00 + mat.m00, this.m01 = this.m01 + mat.m01, this.m02 = this.m02 + mat.m02, 
                this.m03 = this.m03 + mat.m03, this.m04 = this.m04 + mat.m04, this.m05 = this.m05 + mat.m05, 
                this.m06 = this.m06 + mat.m06, this.m07 = this.m07 + mat.m07, this.m08 = this.m08 + mat.m08, 
                this;
            }
        }, {
            key: "subtract",
            value: function subtract(mat) {
                return this.m00 = this.m00 - mat.m00, this.m01 = this.m01 - mat.m01, this.m02 = this.m02 - mat.m02, 
                this.m03 = this.m03 - mat.m03, this.m04 = this.m04 - mat.m04, this.m05 = this.m05 - mat.m05, 
                this.m06 = this.m06 - mat.m06, this.m07 = this.m07 - mat.m07, this.m08 = this.m08 - mat.m08, 
                this;
            }
        }, {
            key: "multiply",
            value: function multiply(mat) {
                var a00 = this.m00, a01 = this.m01, a02 = this.m02, a10 = this.m03, a11 = this.m04, a12 = this.m05, a20 = this.m06, a21 = this.m07, a22 = this.m08, b00 = mat.m00, b01 = mat.m01, b02 = mat.m02, b10 = mat.m03, b11 = mat.m04, b12 = mat.m05, b20 = mat.m06, b21 = mat.m07, b22 = mat.m08;
                return this.m00 = b00 * a00 + b01 * a10 + b02 * a20, this.m01 = b00 * a01 + b01 * a11 + b02 * a21, 
                this.m02 = b00 * a02 + b01 * a12 + b02 * a22, this.m03 = b10 * a00 + b11 * a10 + b12 * a20, 
                this.m04 = b10 * a01 + b11 * a11 + b12 * a21, this.m05 = b10 * a02 + b11 * a12 + b12 * a22, 
                this.m06 = b20 * a00 + b21 * a10 + b22 * a20, this.m07 = b20 * a01 + b21 * a11 + b22 * a21, 
                this.m08 = b20 * a02 + b21 * a12 + b22 * a22, this;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(scalar) {
                return this.m00 = this.m00 * scalar, this.m01 = this.m01 * scalar, this.m02 = this.m02 * scalar, 
                this.m03 = this.m03 * scalar, this.m04 = this.m04 * scalar, this.m05 = this.m05 * scalar, 
                this.m06 = this.m06 * scalar, this.m07 = this.m07 * scalar, this.m08 = this.m08 * scalar, 
                this;
            }
        }, {
            key: "scale",
            value: function scale(vec) {
                var x = vec.x, y = vec.y;
                return this.m00 = x * this.m00, this.m01 = x * this.m01, this.m02 = x * this.m02, 
                this.m03 = y * this.m03, this.m04 = y * this.m04, this.m05 = y * this.m05, this.m06 = this.m06, 
                this.m07 = this.m07, this.m08 = this.m08, this;
            }
        }, {
            key: "rotate",
            value: function rotate(rad) {
                _a00 = this.m00, _a01 = this.m01, _a02 = this.m02, _a10 = this.m03, _a11 = this.m04, 
                _a12 = this.m05, _a20 = this.m06, _a21 = this.m07, _a22 = this.m08;
                var s = Math.sin(rad), c = Math.cos(rad);
                return this.m00 = c * _a00 + s * _a10, this.m01 = c * _a01 + s * _a11, this.m02 = c * _a02 + s * _a12, 
                this.m03 = c * _a10 - s * _a00, this.m04 = c * _a11 - s * _a01, this.m05 = c * _a12 - s * _a02, 
                this.m06 = _a20, this.m07 = _a21, this.m08 = _a22, this;
            }
        }, {
            key: "fromQuat",
            value: function fromQuat(q) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                return this.m00 = 1 - yy - zz, this.m03 = yx - wz, this.m06 = zx + wy, this.m01 = yx + wz, 
                this.m04 = 1 - xx - zz, this.m07 = zy - wx, this.m02 = zx - wy, this.m05 = zy + wx, 
                this.m08 = 1 - xx - yy, this;
            }
        } ]), Mat3;
    }(ValueType);
    Mat3.IDENTITY = Object.freeze(new Mat3);
    var v3_1$1 = new Vec3, v3_2$1 = new Vec3;
    CCClass.fastDefine("cc.Mat3", Mat3, {
        m00: 1,
        m01: 0,
        m02: 0,
        m03: 0,
        m04: 1,
        m05: 0,
        m06: 0,
        m07: 0,
        m08: 1
    }), cc.Mat3 = Mat3;
    var _x$3 = 0, _y$3 = 0, _z$2 = 0, _w$1 = 0, Quat = function(_ValueType) {
        function Quat(x, y, z, w) {
            var _this;
            return _classCallCheck(this, Quat), _this = _possibleConstructorReturn(this, _getPrototypeOf(Quat).call(this)), 
            x && "object" === _typeof(x) ? (_this.x = x.x, _this.y = x.y, _this.z = x.z, _this.w = x.w) : (_this.x = x || 0, 
            _this.y = y || 0, _this.z = z || 0, _this.w = null != w ? w : 1), _this;
        }
        return _inherits(Quat, _ValueType), _createClass(Quat, null, [ {
            key: "clone",
            value: function clone(a) {
                return new Quat(a.x, a.y, a.z, a.w);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.x = a.x, out.y = a.y, out.z = a.z, out.w = a.w, out;
            }
        }, {
            key: "set",
            value: function set(out, x, y, z, w) {
                return out.x = x, out.y = y, out.z = z, out.w = w, out;
            }
        }, {
            key: "identity",
            value: function identity(out) {
                return out.x = 0, out.y = 0, out.z = 0, out.w = 1, out;
            }
        }, {
            key: "rotationTo",
            value: function rotationTo(out, a, b) {
                var dot = Vec3.dot(a, b);
                return dot < -.999999 ? (Vec3.cross(v3_1$2, Vec3.UNIT_X, a), v3_1$2.length() < 1e-6 && Vec3.cross(v3_1$2, Vec3.UNIT_Y, a), 
                Vec3.normalize(v3_1$2, v3_1$2), Quat.fromAxisAngle(out, v3_1$2, Math.PI), out) : dot > .999999 ? (out.x = 0, 
                out.y = 0, out.z = 0, out.w = 1, out) : (Vec3.cross(v3_1$2, a, b), out.x = v3_1$2.x, 
                out.y = v3_1$2.y, out.z = v3_1$2.z, out.w = 1 + dot, Quat.normalize(out, out));
            }
        }, {
            key: "getAxisAngle",
            value: function getAxisAngle(outAxis, q) {
                var rad = 2 * Math.acos(q.w), s = Math.sin(rad / 2);
                return 0 !== s ? (outAxis.x = q.x / s, outAxis.y = q.y / s, outAxis.z = q.z / s) : (outAxis.x = 1, 
                outAxis.y = 0, outAxis.z = 0), rad;
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                return _x$3 = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y, _y$3 = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z, 
                _z$2 = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x, _w$1 = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z, 
                out.x = _x$3, out.y = _y$3, out.z = _z$2, out.w = _w$1, out;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(out, a, b) {
                return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out.w = a.w * b, out;
            }
        }, {
            key: "scaleAndAdd",
            value: function scaleAndAdd(out, a, b, scale) {
                return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
                out.w = a.w + b.w * scale, out;
            }
        }, {
            key: "rotateX",
            value: function rotateX(out, a, rad) {
                rad *= .5;
                var bx = Math.sin(rad), bw = Math.cos(rad);
                return out.x = a.x * bw + a.w * bx, out.y = a.y * bw + a.z * bx, out.z = a.z * bw - a.y * bx, 
                out.w = a.w * bw - a.x * bx, out;
            }
        }, {
            key: "rotateY",
            value: function rotateY(out, a, rad) {
                rad *= .5;
                var by = Math.sin(rad), bw = Math.cos(rad);
                return out.x = a.x * bw - a.z * by, out.y = a.y * bw + a.w * by, out.z = a.z * bw + a.x * by, 
                out.w = a.w * bw - a.y * by, out;
            }
        }, {
            key: "rotateZ",
            value: function rotateZ(out, a, rad) {
                rad *= .5;
                var bz = Math.sin(rad), bw = Math.cos(rad);
                return out.x = a.x * bw + a.y * bz, out.y = a.y * bw - a.x * bz, out.z = a.z * bw + a.w * bz, 
                out.w = a.w * bw - a.z * bz, out;
            }
        }, {
            key: "rotateAround",
            value: function rotateAround(out, rot, axis, rad) {
                return Quat.invert(qt_1, rot), Vec3.transformQuat(v3_1$2, axis, qt_1), Quat.fromAxisAngle(qt_1, v3_1$2, rad), 
                Quat.multiply(out, rot, qt_1), out;
            }
        }, {
            key: "rotateAroundLocal",
            value: function rotateAroundLocal(out, rot, axis, rad) {
                return Quat.fromAxisAngle(qt_1, axis, rad), Quat.multiply(out, rot, qt_1), out;
            }
        }, {
            key: "calculateW",
            value: function calculateW(out, a) {
                return out.x = a.x, out.y = a.y, out.z = a.z, out.w = Math.sqrt(Math.abs(1 - a.x * a.x - a.y * a.y - a.z * a.z)), 
                out;
            }
        }, {
            key: "dot",
            value: function dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
            }
        }, {
            key: "lerp",
            value: function lerp(out, a, b, t) {
                return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
                out.w = a.w + t * (b.w - a.w), out;
            }
        }, {
            key: "slerp",
            value: function slerp(out, a, b, t) {
                var scale0 = 0, scale1 = 0, cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
                if (cosom < 0 && (cosom = -cosom, b.x = -b.x, b.y = -b.y, b.z = -b.z, b.w = -b.w), 
                1 - cosom > 1e-6) {
                    var omega = Math.acos(cosom), sinom = Math.sin(omega);
                    scale0 = Math.sin((1 - t) * omega) / sinom, scale1 = Math.sin(t * omega) / sinom;
                } else scale0 = 1 - t, scale1 = t;
                return out.x = scale0 * a.x + scale1 * b.x, out.y = scale0 * a.y + scale1 * b.y, 
                out.z = scale0 * a.z + scale1 * b.z, out.w = scale0 * a.w + scale1 * b.w, out;
            }
        }, {
            key: "sqlerp",
            value: function sqlerp(out, a, b, c, d, t) {
                return Quat.slerp(qt_1, a, d, t), Quat.slerp(qt_2, b, c, t), Quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t)), 
                out;
            }
        }, {
            key: "invert",
            value: function invert(out, a) {
                var dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w, invDot = dot ? 1 / dot : 0;
                return out.x = -a.x * invDot, out.y = -a.y * invDot, out.z = -a.z * invDot, out.w = a.w * invDot, 
                out;
            }
        }, {
            key: "conjugate",
            value: function conjugate(out, a) {
                return out.x = -a.x, out.y = -a.y, out.z = -a.z, out.w = a.w, out;
            }
        }, {
            key: "len",
            value: function len(a) {
                return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
            }
        }, {
            key: "lengthSqr",
            value: function lengthSqr(a) {
                return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
            }
        }, {
            key: "normalize",
            value: function normalize(out, a) {
                var len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
                return len > 0 && (len = 1 / Math.sqrt(len), out.x = a.x * len, out.y = a.y * len, 
                out.z = a.z * len, out.w = a.w * len), out;
            }
        }, {
            key: "fromAxes",
            value: function fromAxes(out, xAxis, yAxis, zAxis) {
                return Mat3.set(m3_1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z), 
                Quat.normalize(out, Quat.fromMat3(out, m3_1));
            }
        }, {
            key: "fromViewUp",
            value: function fromViewUp(out, view, up) {
                return Mat3.fromViewUp(m3_1, view, up), Quat.normalize(out, Quat.fromMat3(out, m3_1));
            }
        }, {
            key: "fromAxisAngle",
            value: function fromAxisAngle(out, axis, rad) {
                rad *= .5;
                var s = Math.sin(rad);
                return out.x = s * axis.x, out.y = s * axis.y, out.z = s * axis.z, out.w = Math.cos(rad), 
                out;
            }
        }, {
            key: "fromMat3",
            value: function fromMat3(out, m) {
                var m00 = m.m00, m01 = m.m03, m02 = m.m06, m10 = m.m01, m11 = m.m04, m12 = m.m07, m20 = m.m02, m21 = m.m05, m22 = m.m08, trace = m00 + m11 + m22;
                if (trace > 0) {
                    var s = .5 / Math.sqrt(trace + 1);
                    out.w = .25 / s, out.x = (m21 - m12) * s, out.y = (m02 - m20) * s, out.z = (m10 - m01) * s;
                } else if (m00 > m11 && m00 > m22) {
                    var _s = 2 * Math.sqrt(1 + m00 - m11 - m22);
                    out.w = (m21 - m12) / _s, out.x = .25 * _s, out.y = (m01 + m10) / _s, out.z = (m02 + m20) / _s;
                } else if (m11 > m22) {
                    var _s2 = 2 * Math.sqrt(1 + m11 - m00 - m22);
                    out.w = (m02 - m20) / _s2, out.x = (m01 + m10) / _s2, out.y = .25 * _s2, out.z = (m12 + m21) / _s2;
                } else {
                    var _s3 = 2 * Math.sqrt(1 + m22 - m00 - m11);
                    out.w = (m10 - m01) / _s3, out.x = (m02 + m20) / _s3, out.y = (m12 + m21) / _s3, 
                    out.z = .25 * _s3;
                }
                return out;
            }
        }, {
            key: "fromEuler",
            value: function fromEuler(out, x, y, z) {
                x *= halfToRad, y *= halfToRad, z *= halfToRad;
                var sx = Math.sin(x), cx = Math.cos(x), sy = Math.sin(y), cy = Math.cos(y), sz = Math.sin(z), cz = Math.cos(z);
                return out.x = sx * cy * cz + cx * sy * sz, out.y = cx * sy * cz + sx * cy * sz, 
                out.z = cx * cy * sz - sx * sy * cz, out.w = cx * cy * cz - sx * sy * sz, out;
            }
        }, {
            key: "toAxisX",
            value: function toAxisX(out, q) {
                var fy = 2 * q.y, fz = 2 * q.z;
                return out.x = 1 - fy * q.y - fz * q.z, out.y = fy * q.x + fz * q.w, out.z = fz * q.x + fy * q.w, 
                out;
            }
        }, {
            key: "toAxisY",
            value: function toAxisY(out, q) {
                var fx = 2 * q.x, fy = 2 * q.y, fz = 2 * q.z;
                return out.x = fy * q.x - fz * q.w, out.y = 1 - fx * q.x - fz * q.z, out.z = fz * q.y + fx * q.w, 
                out;
            }
        }, {
            key: "toAxisZ",
            value: function toAxisZ(out, q) {
                var fx = 2 * q.x, fy = 2 * q.y, fz = 2 * q.z;
                return out.x = fz * q.x - fy * q.w, out.y = fz * q.y - fx * q.w, out.z = 1 - fx * q.x - fy * q.y, 
                out;
            }
        }, {
            key: "toEuler",
            value: function toEuler(out, q, outerZ) {
                var x = q.x, y = q.y, z = q.z, w = q.w, bank = 0, heading = 0, attitude = 0, test = x * y + z * w;
                if (test > .499999) bank = 0, heading = toDegree(2 * Math.atan2(x, w)), attitude = 90; else if (test < -.499999) bank = 0, 
                heading = -toDegree(2 * Math.atan2(x, w)), attitude = -90; else {
                    var sqx = x * x, sqy = y * y, sqz = z * z;
                    bank = toDegree(Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz)), heading = toDegree(Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz)), 
                    attitude = toDegree(Math.asin(2 * test)), outerZ && (bank = -180 * Math.sign(bank + 1e-6) + bank, 
                    heading = -180 * Math.sign(heading + 1e-6) + heading, attitude = 180 * Math.sign(attitude + 1e-6) - attitude);
                }
                return out.x = bank, out.y = heading, out.z = attitude, out;
            }
        }, {
            key: "toArray",
            value: function toArray(out, q) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = q.x, out[ofs + 1] = q.y, out[ofs + 2] = q.z, out[ofs + 3] = q.w, 
                out;
            }
        }, {
            key: "fromArray",
            value: function fromArray(out, arr) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out.z = arr[ofs + 2], out.w = arr[ofs + 3], 
                out;
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
            }
        }, {
            key: "equals",
            value: function equals(a, b) {
                var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-6;
                return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1, Math.abs(a.w), Math.abs(b.w));
            }
        } ]), _createClass(Quat, [ {
            key: "clone",
            value: function clone() {
                return new Quat(this.x, this.y, this.z, this.w);
            }
        }, {
            key: "set",
            value: function set(x, y, z, w) {
                return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z, 
                this.w = x.w) : (this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = w || 1), 
                this;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e-6;
                return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(other.w));
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(other) {
                return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
            }
        }, {
            key: "getEulerAngles",
            value: function getEulerAngles(out) {
                return Quat.toEuler(out, this);
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio) {
                var scale0 = 0, scale1 = 0, cosom = this.x * to.x + this.y * to.y + this.z * to.z + this.w * to.w;
                if (cosom < 0 && (cosom = -cosom, to.x = -to.x, to.y = -to.y, to.z = -to.z, to.w = -to.w), 
                1 - cosom > 1e-6) {
                    var omega = Math.acos(cosom), sinom = Math.sin(omega);
                    scale0 = Math.sin((1 - ratio) * omega) / sinom, scale1 = Math.sin(ratio * omega) / sinom;
                } else scale0 = 1 - ratio, scale1 = ratio;
                return this.x = scale0 * this.x + scale1 * to.x, this.y = scale0 * this.y + scale1 * to.y, 
                this.z = scale0 * this.z + scale1 * to.z, this.w = scale0 * this.w + scale1 * to.w, 
                this;
            }
        }, {
            key: "length",
            value: function length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "lengthSqr",
            value: function lengthSqr() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        } ]), Quat;
    }(ValueType);
    Quat.IDENTITY = Object.freeze(new Quat);
    var qt_1 = new Quat, qt_2 = new Quat, v3_1$2 = new Vec3, m3_1 = new Mat3, halfToRad = .5 * Math.PI / 180;
    function quat() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, w = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        return new Quat(x, y, z, w);
    }
    CCClass.fastDefine("cc.Quat", Quat, {
        x: 0,
        y: 0,
        z: 0,
        w: 1
    }), cc.Quat = Quat, cc.quat = quat;
    var _a00$1 = 0, _a01$1 = 0, _a02$1 = 0, _a03 = 0, _a10$1 = 0, _a11$1 = 0, _a12$1 = 0, _a13 = 0, _a20$1 = 0, _a21$1 = 0, _a22$1 = 0, _a23 = 0, _a30 = 0, _a31 = 0, _a32 = 0, _a33 = 0, Mat4 = function(_ValueType) {
        function Mat4() {
            var _this, m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, m09 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, m10 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1, m11 = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0, m12 = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0, m13 = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0, m14 = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0, m15 = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1;
            return _classCallCheck(this, Mat4), _this = _possibleConstructorReturn(this, _getPrototypeOf(Mat4).call(this)), 
            "object" === _typeof(m00) ? (_this.m01 = m00.m01, _this.m02 = m00.m02, _this.m03 = m00.m03, 
            _this.m04 = m00.m04, _this.m05 = m00.m05, _this.m06 = m00.m06, _this.m07 = m00.m07, 
            _this.m08 = m00.m08, _this.m09 = m00.m09, _this.m10 = m00.m10, _this.m11 = m00.m11, 
            _this.m12 = m00.m12, _this.m13 = m00.m13, _this.m14 = m00.m14, _this.m15 = m00.m15, 
            _this.m00 = m00.m00) : (_this.m01 = m01, _this.m02 = m02, _this.m03 = m03, _this.m04 = m04, 
            _this.m05 = m05, _this.m06 = m06, _this.m07 = m07, _this.m08 = m08, _this.m09 = m09, 
            _this.m10 = m10, _this.m11 = m11, _this.m12 = m12, _this.m13 = m13, _this.m14 = m14, 
            _this.m15 = m15, _this.m00 = m00), _this;
        }
        return _inherits(Mat4, _ValueType), _createClass(Mat4, null, [ {
            key: "clone",
            value: function clone(a) {
                return new Mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, out.m04 = a.m04, 
                out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, out.m09 = a.m09, 
                out.m10 = a.m10, out.m11 = a.m11, out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, 
                out.m15 = a.m15, out;
            }
        }, {
            key: "set",
            value: function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
                return out.m00 = m00, out.m01 = m01, out.m02 = m02, out.m03 = m03, out.m04 = m10, 
                out.m05 = m11, out.m06 = m12, out.m07 = m13, out.m08 = m20, out.m09 = m21, out.m10 = m22, 
                out.m11 = m23, out.m12 = m30, out.m13 = m31, out.m14 = m32, out.m15 = m33, out;
            }
        }, {
            key: "identity",
            value: function identity(out) {
                return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
                out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = 0, 
                out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "transpose",
            value: function transpose(out, a) {
                if (out === a) {
                    var a01 = a.m01, a02 = a.m02, a03 = a.m03, a12 = a.m06, a13 = a.m07, a23 = a.m11;
                    out.m01 = a.m04, out.m02 = a.m08, out.m03 = a.m12, out.m04 = a01, out.m06 = a.m09, 
                    out.m07 = a.m13, out.m08 = a02, out.m09 = a12, out.m11 = a.m14, out.m12 = a03, out.m13 = a13, 
                    out.m14 = a23;
                } else out.m00 = a.m00, out.m01 = a.m04, out.m02 = a.m08, out.m03 = a.m12, out.m04 = a.m01, 
                out.m05 = a.m05, out.m06 = a.m09, out.m07 = a.m13, out.m08 = a.m02, out.m09 = a.m06, 
                out.m10 = a.m10, out.m11 = a.m14, out.m12 = a.m03, out.m13 = a.m07, out.m14 = a.m11, 
                out.m15 = a.m15;
                return out;
            }
        }, {
            key: "invert",
            value: function invert(out, a) {
                _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
                _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, 
                _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15;
                var b00 = _a00$1 * _a11$1 - _a01$1 * _a10$1, b01 = _a00$1 * _a12$1 - _a02$1 * _a10$1, b02 = _a00$1 * _a13 - _a03 * _a10$1, b03 = _a01$1 * _a12$1 - _a02$1 * _a11$1, b04 = _a01$1 * _a13 - _a03 * _a11$1, b05 = _a02$1 * _a13 - _a03 * _a12$1, b06 = _a20$1 * _a31 - _a21$1 * _a30, b07 = _a20$1 * _a32 - _a22$1 * _a30, b08 = _a20$1 * _a33 - _a23 * _a30, b09 = _a21$1 * _a32 - _a22$1 * _a31, b10 = _a21$1 * _a33 - _a23 * _a31, b11 = _a22$1 * _a33 - _a23 * _a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                return 0 === det ? out : (det = 1 / det, out.m00 = (_a11$1 * b11 - _a12$1 * b10 + _a13 * b09) * det, 
                out.m01 = (_a02$1 * b10 - _a01$1 * b11 - _a03 * b09) * det, out.m02 = (_a31 * b05 - _a32 * b04 + _a33 * b03) * det, 
                out.m03 = (_a22$1 * b04 - _a21$1 * b05 - _a23 * b03) * det, out.m04 = (_a12$1 * b08 - _a10$1 * b11 - _a13 * b07) * det, 
                out.m05 = (_a00$1 * b11 - _a02$1 * b08 + _a03 * b07) * det, out.m06 = (_a32 * b02 - _a30 * b05 - _a33 * b01) * det, 
                out.m07 = (_a20$1 * b05 - _a22$1 * b02 + _a23 * b01) * det, out.m08 = (_a10$1 * b10 - _a11$1 * b08 + _a13 * b06) * det, 
                out.m09 = (_a01$1 * b08 - _a00$1 * b10 - _a03 * b06) * det, out.m10 = (_a30 * b04 - _a31 * b02 + _a33 * b00) * det, 
                out.m11 = (_a21$1 * b02 - _a20$1 * b04 - _a23 * b00) * det, out.m12 = (_a11$1 * b07 - _a10$1 * b09 - _a12$1 * b06) * det, 
                out.m13 = (_a00$1 * b09 - _a01$1 * b07 + _a02$1 * b06) * det, out.m14 = (_a31 * b01 - _a30 * b03 - _a32 * b00) * det, 
                out.m15 = (_a20$1 * b03 - _a21$1 * b01 + _a22$1 * b00) * det, out);
            }
        }, {
            key: "determinant",
            value: function determinant(a) {
                return _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, 
                _a11$1 = a.m05, _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, 
                _a23 = a.m11, _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15, (_a00$1 * _a11$1 - _a01$1 * _a10$1) * (_a22$1 * _a33 - _a23 * _a32) - (_a00$1 * _a12$1 - _a02$1 * _a10$1) * (_a21$1 * _a33 - _a23 * _a31) + (_a00$1 * _a13 - _a03 * _a10$1) * (_a21$1 * _a32 - _a22$1 * _a31) + (_a01$1 * _a12$1 - _a02$1 * _a11$1) * (_a20$1 * _a33 - _a23 * _a30) - (_a01$1 * _a13 - _a03 * _a11$1) * (_a20$1 * _a32 - _a22$1 * _a30) + (_a02$1 * _a13 - _a03 * _a12$1) * (_a20$1 * _a31 - _a21$1 * _a30);
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
                _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, 
                _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15;
                var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
                return out.m00 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, out.m01 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, 
                out.m02 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, out.m03 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, 
                b0 = b.m04, b1 = b.m05, b2 = b.m06, b3 = b.m07, out.m04 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                out.m05 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, out.m06 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                out.m07 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = b.m08, b1 = b.m09, 
                b2 = b.m10, b3 = b.m11, out.m08 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                out.m09 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, out.m10 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                out.m11 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = b.m12, b1 = b.m13, 
                b2 = b.m14, b3 = b.m15, out.m12 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                out.m13 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, out.m14 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                out.m15 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, out;
            }
        }, {
            key: "transform",
            value: function transform(out, a, v) {
                var x = v.x, y = v.y, z = v.z;
                return a === out ? (out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12, out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13, 
                out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14, out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15) : (_a00$1 = a.m00, 
                _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, _a12$1 = a.m06, 
                _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, _a30 = a.m12, 
                _a31 = a.m13, _a32 = a.m14, _a33 = a.m15, out.m00 = _a00$1, out.m01 = _a01$1, out.m02 = _a02$1, 
                out.m03 = _a03, out.m04 = _a10$1, out.m05 = _a11$1, out.m06 = _a12$1, out.m07 = _a13, 
                out.m08 = _a20$1, out.m09 = _a21$1, out.m10 = _a22$1, out.m11 = _a23, out.m12 = _a00$1 * x + _a10$1 * y + _a20$1 * z + a.m12, 
                out.m13 = _a01$1 * x + _a11$1 * y + _a21$1 * z + a.m13, out.m14 = _a02$1 * x + _a12$1 * y + _a22$1 * z + a.m14, 
                out.m15 = _a03 * x + _a13 * y + _a23 * z + a.m15), out;
            }
        }, {
            key: "translate",
            value: function translate(out, a, v) {
                return console.warn("function changed"), a === out ? (out.m12 += v.x, out.m13 += v.y, 
                out.m14 += v.y) : (out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, 
                out.m04 = a.m04, out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, 
                out.m09 = a.m09, out.m10 = a.m10, out.m11 = a.m11, out.m12 += v.x, out.m13 += v.y, 
                out.m14 += v.z, out.m15 = a.m15), out;
            }
        }, {
            key: "scale",
            value: function scale(out, a, v) {
                var x = v.x, y = v.y, z = v.z;
                return out.m00 = a.m00 * x, out.m01 = a.m01 * x, out.m02 = a.m02 * x, out.m03 = a.m03 * x, 
                out.m04 = a.m04 * y, out.m05 = a.m05 * y, out.m06 = a.m06 * y, out.m07 = a.m07 * y, 
                out.m08 = a.m08 * z, out.m09 = a.m09 * z, out.m10 = a.m10 * z, out.m11 = a.m11 * z, 
                out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15, out;
            }
        }, {
            key: "rotate",
            value: function rotate(out, a, rad, axis) {
                var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
                if (Math.abs(len) < 1e-6) return null;
                x *= len = 1 / len, y *= len, z *= len;
                var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
                _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
                _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11;
                var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
                return out.m00 = _a00$1 * b00 + _a10$1 * b01 + _a20$1 * b02, out.m01 = _a01$1 * b00 + _a11$1 * b01 + _a21$1 * b02, 
                out.m02 = _a02$1 * b00 + _a12$1 * b01 + _a22$1 * b02, out.m03 = _a03 * b00 + _a13 * b01 + _a23 * b02, 
                out.m04 = _a00$1 * b10 + _a10$1 * b11 + _a20$1 * b12, out.m05 = _a01$1 * b10 + _a11$1 * b11 + _a21$1 * b12, 
                out.m06 = _a02$1 * b10 + _a12$1 * b11 + _a22$1 * b12, out.m07 = _a03 * b10 + _a13 * b11 + _a23 * b12, 
                out.m08 = _a00$1 * b20 + _a10$1 * b21 + _a20$1 * b22, out.m09 = _a01$1 * b20 + _a11$1 * b21 + _a21$1 * b22, 
                out.m10 = _a02$1 * b20 + _a12$1 * b21 + _a22$1 * b22, out.m11 = _a03 * b20 + _a13 * b21 + _a23 * b22, 
                a !== out && (out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), 
                out;
            }
        }, {
            key: "rotateX",
            value: function rotateX(out, a, rad) {
                var s = Math.sin(rad), c = Math.cos(rad), a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
                return a !== out && (out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, 
                out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m04 = a10 * c + a20 * s, 
                out.m05 = a11 * c + a21 * s, out.m06 = a12 * c + a22 * s, out.m07 = a13 * c + a23 * s, 
                out.m08 = a20 * c - a10 * s, out.m09 = a21 * c - a11 * s, out.m10 = a22 * c - a12 * s, 
                out.m11 = a23 * c - a13 * s, out;
            }
        }, {
            key: "rotateY",
            value: function rotateY(out, a, rad) {
                var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
                return a !== out && (out.m04 = a.m04, out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, 
                out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m00 = a00 * c - a20 * s, 
                out.m01 = a01 * c - a21 * s, out.m02 = a02 * c - a22 * s, out.m03 = a03 * c - a23 * s, 
                out.m08 = a00 * s + a20 * c, out.m09 = a01 * s + a21 * c, out.m10 = a02 * s + a22 * c, 
                out.m11 = a03 * s + a23 * c, out;
            }
        }, {
            key: "rotateZ",
            value: function rotateZ(out, a, rad) {
                var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07;
                return a !== out && (out.m08 = a.m08, out.m09 = a.m09, out.m10 = a.m10, out.m11 = a.m11, 
                out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m00 = a00 * c + a10 * s, 
                out.m01 = a01 * c + a11 * s, out.m02 = a02 * c + a12 * s, out.m03 = a03 * c + a13 * s, 
                out.m04 = a10 * c - a00 * s, out.m05 = a11 * c - a01 * s, out.m06 = a12 * c - a02 * s, 
                out.m07 = a13 * c - a03 * s, out;
            }
        }, {
            key: "fromTranslation",
            value: function fromTranslation(out, v) {
                return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
                out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = v.x, 
                out.m13 = v.y, out.m14 = v.z, out.m15 = 1, out;
            }
        }, {
            key: "fromScaling",
            value: function fromScaling(out, v) {
                return out.m00 = v.x, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = v.y, 
                out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = v.z, out.m11 = 0, 
                out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "fromRotation",
            value: function fromRotation(out, rad, axis) {
                var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
                if (Math.abs(len) < 1e-6) return null;
                x *= len = 1 / len, y *= len, z *= len;
                var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
                return out.m00 = x * x * t + c, out.m01 = y * x * t + z * s, out.m02 = z * x * t - y * s, 
                out.m03 = 0, out.m04 = x * y * t - z * s, out.m05 = y * y * t + c, out.m06 = z * y * t + x * s, 
                out.m07 = 0, out.m08 = x * z * t + y * s, out.m09 = y * z * t - x * s, out.m10 = z * z * t + c, 
                out.m11 = 0, out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "fromXRotation",
            value: function fromXRotation(out, rad) {
                var s = Math.sin(rad), c = Math.cos(rad);
                return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = c, 
                out.m06 = s, out.m07 = 0, out.m08 = 0, out.m09 = -s, out.m10 = c, out.m11 = 0, out.m12 = 0, 
                out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "fromYRotation",
            value: function fromYRotation(out, rad) {
                var s = Math.sin(rad), c = Math.cos(rad);
                return out.m00 = c, out.m01 = 0, out.m02 = -s, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
                out.m06 = 0, out.m07 = 0, out.m08 = s, out.m09 = 0, out.m10 = c, out.m11 = 0, out.m12 = 0, 
                out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "fromZRotation",
            value: function fromZRotation(out, rad) {
                var s = Math.sin(rad), c = Math.cos(rad);
                return out.m00 = c, out.m01 = s, out.m02 = 0, out.m03 = 0, out.m04 = -s, out.m05 = c, 
                out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = 0, 
                out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "fromRT",
            value: function fromRT(out, q, v) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                return out.m00 = 1 - (yy + zz), out.m01 = xy + wz, out.m02 = xz - wy, out.m03 = 0, 
                out.m04 = xy - wz, out.m05 = 1 - (xx + zz), out.m06 = yz + wx, out.m07 = 0, out.m08 = xz + wy, 
                out.m09 = yz - wx, out.m10 = 1 - (xx + yy), out.m11 = 0, out.m12 = v.x, out.m13 = v.y, 
                out.m14 = v.z, out.m15 = 1, out;
            }
        }, {
            key: "getTranslation",
            value: function getTranslation(out, mat) {
                return out.x = mat.m12, out.y = mat.m13, out.z = mat.m14, out;
            }
        }, {
            key: "getScaling",
            value: function getScaling(out, mat) {
                var m00 = m3_1$1.m00 = mat.m00, m01 = m3_1$1.m01 = mat.m01, m02 = m3_1$1.m02 = mat.m02, m04 = m3_1$1.m03 = mat.m04, m05 = m3_1$1.m04 = mat.m05, m06 = m3_1$1.m05 = mat.m06, m08 = m3_1$1.m06 = mat.m08, m09 = m3_1$1.m07 = mat.m09, m10 = m3_1$1.m08 = mat.m10;
                return out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02), out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06), 
                out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10), Mat3.determinant(m3_1$1) < 0 && (out.x *= -1), 
                out;
            }
        }, {
            key: "getRotation",
            value: function getRotation(out, mat) {
                var trace = mat.m00 + mat.m05 + mat.m10, S = 0;
                return trace > 0 ? (S = 2 * Math.sqrt(trace + 1), out.w = .25 * S, out.x = (mat.m06 - mat.m09) / S, 
                out.y = (mat.m08 - mat.m02) / S, out.z = (mat.m01 - mat.m04) / S) : mat.m00 > mat.m05 && mat.m00 > mat.m10 ? (S = 2 * Math.sqrt(1 + mat.m00 - mat.m05 - mat.m10), 
                out.w = (mat.m06 - mat.m09) / S, out.x = .25 * S, out.y = (mat.m01 + mat.m04) / S, 
                out.z = (mat.m08 + mat.m02) / S) : mat.m05 > mat.m10 ? (S = 2 * Math.sqrt(1 + mat.m05 - mat.m00 - mat.m10), 
                out.w = (mat.m08 - mat.m02) / S, out.x = (mat.m01 + mat.m04) / S, out.y = .25 * S, 
                out.z = (mat.m06 + mat.m09) / S) : (S = 2 * Math.sqrt(1 + mat.m10 - mat.m00 - mat.m05), 
                out.w = (mat.m01 - mat.m04) / S, out.x = (mat.m08 + mat.m02) / S, out.y = (mat.m06 + mat.m09) / S, 
                out.z = .25 * S), out;
            }
        }, {
            key: "toRTS",
            value: function toRTS(m, q, v, s) {
                s.x = Vec3.set(v3_1$3, m.m00, m.m01, m.m02).length(), m3_1$1.m00 = m.m00 / s.x, 
                m3_1$1.m01 = m.m01 / s.x, m3_1$1.m02 = m.m02 / s.x, s.y = Vec3.set(v3_1$3, m.m04, m.m05, m.m06).length(), 
                m3_1$1.m03 = m.m04 / s.y, m3_1$1.m04 = m.m05 / s.y, m3_1$1.m05 = m.m06 / s.y, s.z = Vec3.set(v3_1$3, m.m08, m.m09, m.m10).length(), 
                m3_1$1.m06 = m.m08 / s.z, m3_1$1.m07 = m.m09 / s.z, m3_1$1.m08 = m.m10 / s.z, Mat3.determinant(m3_1$1) < 0 && (s.x *= -1, 
                m3_1$1.m00 *= -1, m3_1$1.m01 *= -1, m3_1$1.m02 *= -1), Quat.fromMat3(q, m3_1$1), 
                Vec3.set(v, m.m12, m.m13, m.m14);
            }
        }, {
            key: "fromRTS",
            value: function fromRTS(out, q, v, s) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z;
                return out.m00 = (1 - (yy + zz)) * sx, out.m01 = (xy + wz) * sx, out.m02 = (xz - wy) * sx, 
                out.m03 = 0, out.m04 = (xy - wz) * sy, out.m05 = (1 - (xx + zz)) * sy, out.m06 = (yz + wx) * sy, 
                out.m07 = 0, out.m08 = (xz + wy) * sz, out.m09 = (yz - wx) * sz, out.m10 = (1 - (xx + yy)) * sz, 
                out.m11 = 0, out.m12 = v.x, out.m13 = v.y, out.m14 = v.z, out.m15 = 1, out;
            }
        }, {
            key: "fromRTSOrigin",
            value: function fromRTSOrigin(out, q, v, s, o) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z, ox = o.x, oy = o.y, oz = o.z;
                return out.m00 = (1 - (yy + zz)) * sx, out.m01 = (xy + wz) * sx, out.m02 = (xz - wy) * sx, 
                out.m03 = 0, out.m04 = (xy - wz) * sy, out.m05 = (1 - (xx + zz)) * sy, out.m06 = (yz + wx) * sy, 
                out.m07 = 0, out.m08 = (xz + wy) * sz, out.m09 = (yz - wx) * sz, out.m10 = (1 - (xx + yy)) * sz, 
                out.m11 = 0, out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz), 
                out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz), out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz), 
                out.m15 = 1, out;
            }
        }, {
            key: "fromQuat",
            value: function fromQuat(out, q) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                return out.m00 = 1 - yy - zz, out.m01 = yx + wz, out.m02 = zx - wy, out.m03 = 0, 
                out.m04 = yx - wz, out.m05 = 1 - xx - zz, out.m06 = zy + wx, out.m07 = 0, out.m08 = zx + wy, 
                out.m09 = zy - wx, out.m10 = 1 - xx - yy, out.m11 = 0, out.m12 = 0, out.m13 = 0, 
                out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "frustum",
            value: function frustum(out, left, right, bottom, top, near, far) {
                var rl = 1 / (right - left), tb = 1 / (top - bottom), nf = 1 / (near - far);
                return out.m00 = 2 * near * rl, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, 
                out.m05 = 2 * near * tb, out.m06 = 0, out.m07 = 0, out.m08 = (right + left) * rl, 
                out.m09 = (top + bottom) * tb, out.m10 = (far + near) * nf, out.m11 = -1, out.m12 = 0, 
                out.m13 = 0, out.m14 = far * near * 2 * nf, out.m15 = 0, out;
            }
        }, {
            key: "perspective",
            value: function perspective(out, fovy, aspect, near, far) {
                var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
                return out.m00 = f / aspect, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, 
                out.m05 = f, out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = (far + near) * nf, 
                out.m11 = -1, out.m12 = 0, out.m13 = 0, out.m14 = 2 * far * near * nf, out.m15 = 0, 
                out;
            }
        }, {
            key: "ortho",
            value: function ortho(out, left, right, bottom, top, near, far) {
                var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
                return out.m00 = -2 * lr, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = -2 * bt, 
                out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 2 * nf, out.m11 = 0, 
                out.m12 = (left + right) * lr, out.m13 = (top + bottom) * bt, out.m14 = (far + near) * nf, 
                out.m15 = 1, out;
            }
        }, {
            key: "lookAt",
            value: function lookAt(out, eye, center, up) {
                var eyex = eye.x, eyey = eye.y, eyez = eye.z, upx = up.x, upy = up.y, upz = up.z, z0 = eyex - center.x, z1 = eyey - center.y, z2 = eyez - center.z, len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2), x0 = upy * (z2 *= len) - upz * (z1 *= len), x1 = upz * (z0 *= len) - upx * z2, x2 = upx * z1 - upy * z0, y0 = z1 * (x2 *= len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2)) - z2 * (x1 *= len), y1 = z2 * (x0 *= len) - z0 * x2, y2 = z0 * x1 - z1 * x0;
                return out.m00 = x0, out.m01 = y0, out.m02 = z0, out.m03 = 0, out.m04 = x1, out.m05 = y1, 
                out.m06 = z1, out.m07 = 0, out.m08 = x2, out.m09 = y2, out.m10 = z2, out.m11 = 0, 
                out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez), out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez), 
                out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez), out.m15 = 1, out;
            }
        }, {
            key: "inverseTranspose",
            value: function inverseTranspose(out, a) {
                _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
                _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, 
                _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15;
                var b00 = _a00$1 * _a11$1 - _a01$1 * _a10$1, b01 = _a00$1 * _a12$1 - _a02$1 * _a10$1, b02 = _a00$1 * _a13 - _a03 * _a10$1, b03 = _a01$1 * _a12$1 - _a02$1 * _a11$1, b04 = _a01$1 * _a13 - _a03 * _a11$1, b05 = _a02$1 * _a13 - _a03 * _a12$1, b06 = _a20$1 * _a31 - _a21$1 * _a30, b07 = _a20$1 * _a32 - _a22$1 * _a30, b08 = _a20$1 * _a33 - _a23 * _a30, b09 = _a21$1 * _a32 - _a22$1 * _a31, b10 = _a21$1 * _a33 - _a23 * _a31, b11 = _a22$1 * _a33 - _a23 * _a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                return det ? (det = 1 / det, out.m00 = (_a11$1 * b11 - _a12$1 * b10 + _a13 * b09) * det, 
                out.m01 = (_a12$1 * b08 - _a10$1 * b11 - _a13 * b07) * det, out.m02 = (_a10$1 * b10 - _a11$1 * b08 + _a13 * b06) * det, 
                out.m03 = 0, out.m04 = (_a02$1 * b10 - _a01$1 * b11 - _a03 * b09) * det, out.m05 = (_a00$1 * b11 - _a02$1 * b08 + _a03 * b07) * det, 
                out.m06 = (_a01$1 * b08 - _a00$1 * b10 - _a03 * b06) * det, out.m07 = 0, out.m08 = (_a31 * b05 - _a32 * b04 + _a33 * b03) * det, 
                out.m09 = (_a32 * b02 - _a30 * b05 - _a33 * b01) * det, out.m10 = (_a30 * b04 - _a31 * b02 + _a33 * b00) * det, 
                out.m11 = 0, out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out) : null;
            }
        }, {
            key: "toArray",
            value: function toArray(out, m) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = m.m00, out[ofs + 1] = m.m01, out[ofs + 2] = m.m02, out[ofs + 3] = m.m03, 
                out[ofs + 4] = m.m04, out[ofs + 5] = m.m05, out[ofs + 6] = m.m06, out[ofs + 7] = m.m07, 
                out[ofs + 8] = m.m08, out[ofs + 9] = m.m09, out[ofs + 10] = m.m10, out[ofs + 11] = m.m11, 
                out[ofs + 12] = m.m12, out[ofs + 13] = m.m13, out[ofs + 14] = m.m14, out[ofs + 15] = m.m15, 
                out;
            }
        }, {
            key: "fromArray",
            value: function fromArray(out, arr) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out.m00 = arr[ofs + 0], out.m01 = arr[ofs + 1], out.m02 = arr[ofs + 2], out.m03 = arr[ofs + 3], 
                out.m04 = arr[ofs + 4], out.m05 = arr[ofs + 5], out.m06 = arr[ofs + 6], out.m07 = arr[ofs + 7], 
                out.m08 = arr[ofs + 8], out.m09 = arr[ofs + 9], out.m10 = arr[ofs + 10], out.m11 = arr[ofs + 11], 
                out.m12 = arr[ofs + 12], out.m13 = arr[ofs + 13], out.m14 = arr[ofs + 14], out.m15 = arr[ofs + 15], 
                out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.m00 = a.m00 + b.m00, out.m01 = a.m01 + b.m01, out.m02 = a.m02 + b.m02, 
                out.m03 = a.m03 + b.m03, out.m04 = a.m04 + b.m04, out.m05 = a.m05 + b.m05, out.m06 = a.m06 + b.m06, 
                out.m07 = a.m07 + b.m07, out.m08 = a.m08 + b.m08, out.m09 = a.m09 + b.m09, out.m10 = a.m10 + b.m10, 
                out.m11 = a.m11 + b.m11, out.m12 = a.m12 + b.m12, out.m13 = a.m13 + b.m13, out.m14 = a.m14 + b.m14, 
                out.m15 = a.m15 + b.m15, out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.m00 = a.m00 - b.m00, out.m01 = a.m01 - b.m01, out.m02 = a.m02 - b.m02, 
                out.m03 = a.m03 - b.m03, out.m04 = a.m04 - b.m04, out.m05 = a.m05 - b.m05, out.m06 = a.m06 - b.m06, 
                out.m07 = a.m07 - b.m07, out.m08 = a.m08 - b.m08, out.m09 = a.m09 - b.m09, out.m10 = a.m10 - b.m10, 
                out.m11 = a.m11 - b.m11, out.m12 = a.m12 - b.m12, out.m13 = a.m13 - b.m13, out.m14 = a.m14 - b.m14, 
                out.m15 = a.m15 - b.m15, out;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(out, a, b) {
                return out.m00 = a.m00 * b, out.m01 = a.m01 * b, out.m02 = a.m02 * b, out.m03 = a.m03 * b, 
                out.m04 = a.m04 * b, out.m05 = a.m05 * b, out.m06 = a.m06 * b, out.m07 = a.m07 * b, 
                out.m08 = a.m08 * b, out.m09 = a.m09 * b, out.m10 = a.m10 * b, out.m11 = a.m11 * b, 
                out.m12 = a.m12 * b, out.m13 = a.m13 * b, out.m14 = a.m14 * b, out.m15 = a.m15 * b, 
                out;
            }
        }, {
            key: "multiplyScalarAndAdd",
            value: function multiplyScalarAndAdd(out, a, b, scale) {
                return out.m00 = a.m00 + b.m00 * scale, out.m01 = a.m01 + b.m01 * scale, out.m02 = a.m02 + b.m02 * scale, 
                out.m03 = a.m03 + b.m03 * scale, out.m04 = a.m04 + b.m04 * scale, out.m05 = a.m05 + b.m05 * scale, 
                out.m06 = a.m06 + b.m06 * scale, out.m07 = a.m07 + b.m07 * scale, out.m08 = a.m08 + b.m08 * scale, 
                out.m09 = a.m09 + b.m09 * scale, out.m10 = a.m10 + b.m10 * scale, out.m11 = a.m11 + b.m11 * scale, 
                out.m12 = a.m12 + b.m12 * scale, out.m13 = a.m13 + b.m13 * scale, out.m14 = a.m14 + b.m14 * scale, 
                out.m15 = a.m15 + b.m15 * scale, out;
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(a, b) {
                return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
            }
        }, {
            key: "equals",
            value: function equals(a, b) {
                var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-6;
                return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1, Math.abs(a.m08), Math.abs(b.m08)) && Math.abs(a.m09 - b.m09) <= epsilon * Math.max(1, Math.abs(a.m09), Math.abs(b.m09)) && Math.abs(a.m10 - b.m10) <= epsilon * Math.max(1, Math.abs(a.m10), Math.abs(b.m10)) && Math.abs(a.m11 - b.m11) <= epsilon * Math.max(1, Math.abs(a.m11), Math.abs(b.m11)) && Math.abs(a.m12 - b.m12) <= epsilon * Math.max(1, Math.abs(a.m12), Math.abs(b.m12)) && Math.abs(a.m13 - b.m13) <= epsilon * Math.max(1, Math.abs(a.m13), Math.abs(b.m13)) && Math.abs(a.m14 - b.m14) <= epsilon * Math.max(1, Math.abs(a.m14), Math.abs(b.m14)) && Math.abs(a.m15 - b.m15) <= epsilon * Math.max(1, Math.abs(a.m15), Math.abs(b.m15));
            }
        } ]), _createClass(Mat4, [ {
            key: "clone",
            value: function clone() {
                var t = this;
                return new Mat4(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08, t.m09, t.m10, t.m11, t.m12, t.m13, t.m14, t.m15);
            }
        }, {
            key: "set",
            value: function set() {
                var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, m09 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, m10 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1, m11 = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0, m12 = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0, m13 = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0, m14 = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0, m15 = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1;
                return "object" === _typeof(m00) ? (this.m01 = m00.m01, this.m02 = m00.m02, this.m03 = m00.m03, 
                this.m04 = m00.m04, this.m05 = m00.m05, this.m06 = m00.m06, this.m07 = m00.m07, 
                this.m08 = m00.m08, this.m09 = m00.m09, this.m10 = m00.m10, this.m11 = m00.m11, 
                this.m12 = m00.m12, this.m13 = m00.m13, this.m14 = m00.m14, this.m15 = m00.m15, 
                this.m00 = m00.m00) : (this.m01 = m01, this.m02 = m02, this.m03 = m03, this.m04 = m04, 
                this.m05 = m05, this.m06 = m06, this.m07 = m07, this.m08 = m08, this.m09 = m09, 
                this.m10 = m10, this.m11 = m11, this.m12 = m12, this.m13 = m13, this.m14 = m14, 
                this.m15 = m15, this.m00 = m00), this;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e-6;
                return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1, Math.abs(this.m08), Math.abs(other.m08)) && Math.abs(this.m09 - other.m09) <= epsilon * Math.max(1, Math.abs(this.m09), Math.abs(other.m09)) && Math.abs(this.m10 - other.m10) <= epsilon * Math.max(1, Math.abs(this.m10), Math.abs(other.m10)) && Math.abs(this.m11 - other.m11) <= epsilon * Math.max(1, Math.abs(this.m11), Math.abs(other.m11)) && Math.abs(this.m12 - other.m12) <= epsilon * Math.max(1, Math.abs(this.m12), Math.abs(other.m12)) && Math.abs(this.m13 - other.m13) <= epsilon * Math.max(1, Math.abs(this.m13), Math.abs(other.m13)) && Math.abs(this.m14 - other.m14) <= epsilon * Math.max(1, Math.abs(this.m14), Math.abs(other.m14)) && Math.abs(this.m15 - other.m15) <= epsilon * Math.max(1, Math.abs(this.m15), Math.abs(other.m15));
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(other) {
                return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08 && this.m09 === other.m09 && this.m10 === other.m10 && this.m11 === other.m11 && this.m12 === other.m12 && this.m13 === other.m13 && this.m14 === other.m14 && this.m15 === other.m15;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "[\n" + this.m00 + ", " + this.m01 + ", " + this.m02 + ", " + this.m03 + ",\n" + this.m04 + ", " + this.m05 + ", " + this.m06 + ", " + this.m07 + ",\n" + this.m08 + ", " + this.m09 + ", " + this.m10 + ", " + this.m11 + ",\n" + this.m12 + ", " + this.m13 + ", " + this.m14 + ", " + this.m15 + "\n]";
            }
        }, {
            key: "identity",
            value: function identity() {
                return this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m04 = 0, this.m05 = 1, 
                this.m06 = 0, this.m07 = 0, this.m08 = 0, this.m09 = 0, this.m10 = 1, this.m11 = 0, 
                this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m15 = 1, this;
            }
        }, {
            key: "transpose",
            value: function transpose() {
                var a01 = this.m01, a02 = this.m02, a03 = this.m03, a12 = this.m06, a13 = this.m07, a23 = this.m11;
                return this.m01 = this.m04, this.m02 = this.m08, this.m03 = this.m12, this.m04 = a01, 
                this.m06 = this.m09, this.m07 = this.m13, this.m08 = a02, this.m09 = a12, this.m11 = this.m14, 
                this.m12 = a03, this.m13 = a13, this.m14 = a23, this;
            }
        }, {
            key: "invert",
            value: function invert() {
                _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, _a10$1 = this.m04, 
                _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, _a21$1 = this.m09, 
                _a22$1 = this.m10, _a23 = this.m11, _a30 = this.m12, _a31 = this.m13, _a32 = this.m14, 
                _a33 = this.m15;
                var b00 = _a00$1 * _a11$1 - _a01$1 * _a10$1, b01 = _a00$1 * _a12$1 - _a02$1 * _a10$1, b02 = _a00$1 * _a13 - _a03 * _a10$1, b03 = _a01$1 * _a12$1 - _a02$1 * _a11$1, b04 = _a01$1 * _a13 - _a03 * _a11$1, b05 = _a02$1 * _a13 - _a03 * _a12$1, b06 = _a20$1 * _a31 - _a21$1 * _a30, b07 = _a20$1 * _a32 - _a22$1 * _a30, b08 = _a20$1 * _a33 - _a23 * _a30, b09 = _a21$1 * _a32 - _a22$1 * _a31, b10 = _a21$1 * _a33 - _a23 * _a31, b11 = _a22$1 * _a33 - _a23 * _a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                return 0 === det ? null : (det = 1 / det, this.m00 = (_a11$1 * b11 - _a12$1 * b10 + _a13 * b09) * det, 
                this.m01 = (_a02$1 * b10 - _a01$1 * b11 - _a03 * b09) * det, this.m02 = (_a31 * b05 - _a32 * b04 + _a33 * b03) * det, 
                this.m03 = (_a22$1 * b04 - _a21$1 * b05 - _a23 * b03) * det, this.m04 = (_a12$1 * b08 - _a10$1 * b11 - _a13 * b07) * det, 
                this.m05 = (_a00$1 * b11 - _a02$1 * b08 + _a03 * b07) * det, this.m06 = (_a32 * b02 - _a30 * b05 - _a33 * b01) * det, 
                this.m07 = (_a20$1 * b05 - _a22$1 * b02 + _a23 * b01) * det, this.m08 = (_a10$1 * b10 - _a11$1 * b08 + _a13 * b06) * det, 
                this.m09 = (_a01$1 * b08 - _a00$1 * b10 - _a03 * b06) * det, this.m10 = (_a30 * b04 - _a31 * b02 + _a33 * b00) * det, 
                this.m11 = (_a21$1 * b02 - _a20$1 * b04 - _a23 * b00) * det, this.m12 = (_a11$1 * b07 - _a10$1 * b09 - _a12$1 * b06) * det, 
                this.m13 = (_a00$1 * b09 - _a01$1 * b07 + _a02$1 * b06) * det, this.m14 = (_a31 * b01 - _a30 * b03 - _a32 * b00) * det, 
                this.m15 = (_a20$1 * b03 - _a21$1 * b01 + _a22$1 * b00) * det, this);
            }
        }, {
            key: "determinant",
            value: function determinant() {
                return _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, 
                _a10$1 = this.m04, _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, 
                _a21$1 = this.m09, _a22$1 = this.m10, _a23 = this.m11, _a30 = this.m12, _a31 = this.m13, 
                _a32 = this.m14, _a33 = this.m15, (_a00$1 * _a11$1 - _a01$1 * _a10$1) * (_a22$1 * _a33 - _a23 * _a32) - (_a00$1 * _a12$1 - _a02$1 * _a10$1) * (_a21$1 * _a33 - _a23 * _a31) + (_a00$1 * _a13 - _a03 * _a10$1) * (_a21$1 * _a32 - _a22$1 * _a31) + (_a01$1 * _a12$1 - _a02$1 * _a11$1) * (_a20$1 * _a33 - _a23 * _a30) - (_a01$1 * _a13 - _a03 * _a11$1) * (_a20$1 * _a32 - _a22$1 * _a30) + (_a02$1 * _a13 - _a03 * _a12$1) * (_a20$1 * _a31 - _a21$1 * _a30);
            }
        }, {
            key: "add",
            value: function add(mat) {
                return this.m00 = this.m00 + mat.m00, this.m01 = this.m01 + mat.m01, this.m02 = this.m02 + mat.m02, 
                this.m03 = this.m03 + mat.m03, this.m04 = this.m04 + mat.m04, this.m05 = this.m05 + mat.m05, 
                this.m06 = this.m06 + mat.m06, this.m07 = this.m07 + mat.m07, this.m08 = this.m08 + mat.m08, 
                this.m09 = this.m09 + mat.m09, this.m10 = this.m10 + mat.m10, this.m11 = this.m11 + mat.m11, 
                this.m12 = this.m12 + mat.m12, this.m13 = this.m13 + mat.m13, this.m14 = this.m14 + mat.m14, 
                this.m15 = this.m15 + mat.m15, this;
            }
        }, {
            key: "subtract",
            value: function subtract(mat) {
                return this.m00 = this.m00 - mat.m00, this.m01 = this.m01 - mat.m01, this.m02 = this.m02 - mat.m02, 
                this.m03 = this.m03 - mat.m03, this.m04 = this.m04 - mat.m04, this.m05 = this.m05 - mat.m05, 
                this.m06 = this.m06 - mat.m06, this.m07 = this.m07 - mat.m07, this.m08 = this.m08 - mat.m08, 
                this.m09 = this.m09 - mat.m09, this.m10 = this.m10 - mat.m10, this.m11 = this.m11 - mat.m11, 
                this.m12 = this.m12 - mat.m12, this.m13 = this.m13 - mat.m13, this.m14 = this.m14 - mat.m14, 
                this.m15 = this.m15 - mat.m15, this;
            }
        }, {
            key: "multiply",
            value: function multiply(mat) {
                _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, _a10$1 = this.m04, 
                _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, _a21$1 = this.m09, 
                _a22$1 = this.m10, _a23 = this.m11, _a30 = this.m12, _a31 = this.m13, _a32 = this.m14, 
                _a33 = this.m15;
                var b0 = mat.m00, b1 = mat.m01, b2 = mat.m02, b3 = mat.m03;
                return this.m00 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, this.m01 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, 
                this.m02 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, this.m03 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, 
                b0 = mat.m04, b1 = mat.m05, b2 = mat.m06, b3 = mat.m07, this.m04 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                this.m05 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, this.m06 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                this.m07 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = mat.m08, b1 = mat.m09, 
                b2 = mat.m10, b3 = mat.m11, this.m08 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                this.m09 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, this.m10 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                this.m11 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = mat.m12, b1 = mat.m13, 
                b2 = mat.m14, b3 = mat.m15, this.m12 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                this.m13 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, this.m14 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                this.m15 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, this;
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(scalar) {
                return this.m00 = this.m00 * scalar, this.m01 = this.m01 * scalar, this.m02 = this.m02 * scalar, 
                this.m03 = this.m03 * scalar, this.m04 = this.m04 * scalar, this.m05 = this.m05 * scalar, 
                this.m06 = this.m06 * scalar, this.m07 = this.m07 * scalar, this.m08 = this.m08 * scalar, 
                this.m09 = this.m09 * scalar, this.m10 = this.m10 * scalar, this.m11 = this.m11 * scalar, 
                this.m12 = this.m12 * scalar, this.m13 = this.m13 * scalar, this.m14 = this.m14 * scalar, 
                this.m15 = this.m15 * scalar, this;
            }
        }, {
            key: "translate",
            value: function translate(vec) {
                return console.warn("function changed"), this.m12 += vec.x, this.m13 += vec.y, this.m14 += vec.y, 
                this;
            }
        }, {
            key: "scale",
            value: function scale(vec) {
                var x = vec.x, y = vec.y, z = vec.z;
                return this.m00 = this.m00 * x, this.m01 = this.m01 * x, this.m02 = this.m02 * x, 
                this.m03 = this.m03 * x, this.m04 = this.m04 * y, this.m05 = this.m05 * y, this.m06 = this.m06 * y, 
                this.m07 = this.m07 * y, this.m08 = this.m08 * z, this.m09 = this.m09 * z, this.m10 = this.m10 * z, 
                this.m11 = this.m11 * z, this.m12 = this.m12, this.m13 = this.m13, this.m14 = this.m14, 
                this.m15 = this.m15, this;
            }
        }, {
            key: "rotate",
            value: function rotate(rad, axis) {
                var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
                if (Math.abs(len) < 1e-6) return null;
                x *= len = 1 / len, y *= len, z *= len;
                var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
                _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, _a10$1 = this.m04, 
                _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, _a21$1 = this.m09, 
                _a22$1 = this.m10, _a23 = this.m11;
                var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
                return this.m00 = _a00$1 * b00 + _a10$1 * b01 + _a20$1 * b02, this.m01 = _a01$1 * b00 + _a11$1 * b01 + _a21$1 * b02, 
                this.m02 = _a02$1 * b00 + _a12$1 * b01 + _a22$1 * b02, this.m03 = _a03 * b00 + _a13 * b01 + _a23 * b02, 
                this.m04 = _a00$1 * b10 + _a10$1 * b11 + _a20$1 * b12, this.m05 = _a01$1 * b10 + _a11$1 * b11 + _a21$1 * b12, 
                this.m06 = _a02$1 * b10 + _a12$1 * b11 + _a22$1 * b12, this.m07 = _a03 * b10 + _a13 * b11 + _a23 * b12, 
                this.m08 = _a00$1 * b20 + _a10$1 * b21 + _a20$1 * b22, this.m09 = _a01$1 * b20 + _a11$1 * b21 + _a21$1 * b22, 
                this.m10 = _a02$1 * b20 + _a12$1 * b21 + _a22$1 * b22, this.m11 = _a03 * b20 + _a13 * b21 + _a23 * b22, 
                this;
            }
        }, {
            key: "getTranslation",
            value: function getTranslation(out) {
                return out.x = this.m12, out.y = this.m13, out.z = this.m14, out;
            }
        }, {
            key: "getScale",
            value: function getScale(out) {
                var m00 = m3_1$1.m00 = this.m00, m01 = m3_1$1.m01 = this.m01, m02 = m3_1$1.m02 = this.m02, m04 = m3_1$1.m03 = this.m04, m05 = m3_1$1.m04 = this.m05, m06 = m3_1$1.m05 = this.m06, m08 = m3_1$1.m06 = this.m08, m09 = m3_1$1.m07 = this.m09, m10 = m3_1$1.m08 = this.m10;
                return out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02), out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06), 
                out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10), Mat3.determinant(m3_1$1) < 0 && (out.x *= -1), 
                out;
            }
        }, {
            key: "getRotation",
            value: function getRotation(out) {
                var trace = this.m00 + this.m05 + this.m10, S = 0;
                return trace > 0 ? (S = 2 * Math.sqrt(trace + 1), out.w = .25 * S, out.x = (this.m06 - this.m09) / S, 
                out.y = (this.m08 - this.m02) / S, out.z = (this.m01 - this.m04) / S) : this.m00 > this.m05 && this.m00 > this.m10 ? (S = 2 * Math.sqrt(1 + this.m00 - this.m05 - this.m10), 
                out.w = (this.m06 - this.m09) / S, out.x = .25 * S, out.y = (this.m01 + this.m04) / S, 
                out.z = (this.m08 + this.m02) / S) : this.m05 > this.m10 ? (S = 2 * Math.sqrt(1 + this.m05 - this.m00 - this.m10), 
                out.w = (this.m08 - this.m02) / S, out.x = (this.m01 + this.m04) / S, out.y = .25 * S, 
                out.z = (this.m06 + this.m09) / S) : (S = 2 * Math.sqrt(1 + this.m10 - this.m00 - this.m05), 
                out.w = (this.m01 - this.m04) / S, out.x = (this.m08 + this.m02) / S, out.y = (this.m06 + this.m09) / S, 
                out.z = .25 * S), out;
            }
        }, {
            key: "fromRTS",
            value: function fromRTS(q, v, s) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z;
                return this.m00 = (1 - (yy + zz)) * sx, this.m01 = (xy + wz) * sx, this.m02 = (xz - wy) * sx, 
                this.m03 = 0, this.m04 = (xy - wz) * sy, this.m05 = (1 - (xx + zz)) * sy, this.m06 = (yz + wx) * sy, 
                this.m07 = 0, this.m08 = (xz + wy) * sz, this.m09 = (yz - wx) * sz, this.m10 = (1 - (xx + yy)) * sz, 
                this.m11 = 0, this.m12 = v.x, this.m13 = v.y, this.m14 = v.z, this.m15 = 1, this;
            }
        }, {
            key: "fromQuat",
            value: function fromQuat(q) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                return this.m00 = 1 - yy - zz, this.m01 = yx + wz, this.m02 = zx - wy, this.m03 = 0, 
                this.m04 = yx - wz, this.m05 = 1 - xx - zz, this.m06 = zy + wx, this.m07 = 0, this.m08 = zx + wy, 
                this.m09 = zy - wx, this.m10 = 1 - xx - yy, this.m11 = 0, this.m12 = 0, this.m13 = 0, 
                this.m14 = 0, this.m15 = 1, this;
            }
        } ]), Mat4;
    }(ValueType);
    Mat4.IDENTITY = Object.freeze(new Mat4);
    var v3_1$3 = new Vec3, m3_1$1 = new Mat3;
    function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
    CCClass.fastDefine("cc.Mat4", Mat4, {
        m00: 1,
        m01: 0,
        m02: 0,
        m03: 0,
        m04: 0,
        m05: 1,
        m06: 0,
        m07: 0,
        m08: 0,
        m09: 0,
        m10: 1,
        m11: 0,
        m12: 0,
        m13: 0,
        m14: 0,
        m15: 1
    }), cc.Mat4 = Mat4, cc.mat4 = mat4;
    var _a = 0, _b = 0, _c = 0, _d = 0, _tx = 0, _ty = 0, AffineTransform = function() {
        function AffineTransform() {
            var a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, b = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, c = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, d = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, tx = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, ty = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
            _classCallCheck(this, AffineTransform), this.a = a, this.b = b, this.c = c, this.d = d, 
            this.tx = tx, this.ty = ty;
        }
        return _createClass(AffineTransform, null, [ {
            key: "identity",
            value: function identity() {
                return new AffineTransform;
            }
        }, {
            key: "clone",
            value: function clone(affineTransform) {
                return new AffineTransform(affineTransform.a, affineTransform.b, affineTransform.c, affineTransform.d, affineTransform.tx, affineTransform.ty);
            }
        }, {
            key: "concat",
            value: function concat(out, t1, t2) {
                _a = t1.a, _b = t1.b, _c = t1.c, _d = t1.d, _tx = t1.tx, _ty = t1.ty, out.a = _a * t2.a + _b * t2.c, 
                out.b = _a * t2.b + _b * t2.d, out.c = _c * t2.a + _d * t2.c, out.d = _c * t2.b + _d * t2.d, 
                out.tx = _tx * t2.a + _ty * t2.c + t2.tx, out.ty = _tx * t2.b + _ty * t2.d + t2.ty;
            }
        }, {
            key: "invert",
            value: function invert(out, t) {
                var determinant = 1 / (t.a * t.d - t.b * t.c);
                out.a = determinant * t.d, out.b = -determinant * t.b, out.c = -determinant * t.c, 
                out.d = determinant * t.a, out.tx = determinant * (t.c * t.ty - t.d * t.tx), out.ty = determinant * (t.b * t.tx - t.a * t.ty);
            }
        }, {
            key: "fromMat4",
            value: function fromMat4(out, mat) {
                out.a = mat.m00, out.b = mat.m01, out.c = mat.m04, out.d = mat.m05, out.tx = mat.m12, 
                out.ty = mat.m13;
            }
        }, {
            key: "transformVec2",
            value: function transformVec2(out, point, transOrY, t) {
                var x, y;
                void 0 === t ? (t = transOrY, x = point.x, y = point.y) : (x = point, y = transOrY), 
                out.x = t.a * x + t.c * y + t.tx, out.y = t.b * x + t.d * y + t.ty;
            }
        }, {
            key: "transformSize",
            value: function transformSize(out, size, t) {
                out.width = t.a * size.width + t.c * size.height, out.height = t.b * size.width + t.d * size.height;
            }
        }, {
            key: "transformRect",
            value: function transformRect(out, rect, t) {
                var or = rect.x + rect.width, ot = rect.y + rect.height, lbx = t.a * rect.x + t.c * rect.y + t.tx, lby = t.b * rect.x + t.d * rect.y + t.ty, rbx = t.a * or + t.c * rect.y + t.tx, rby = t.b * or + t.d * rect.y + t.ty, ltx = t.a * rect.x + t.c * ot + t.tx, lty = t.b * rect.x + t.d * ot + t.ty, rtx = t.a * or + t.c * ot + t.tx, rty = t.b * or + t.d * ot + t.ty, minX = Math.min(lbx, rbx, ltx, rtx), maxX = Math.max(lbx, rbx, ltx, rtx), minY = Math.min(lby, rby, lty, rty), maxY = Math.max(lby, rby, lty, rty);
                out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY;
            }
        }, {
            key: "transformObb",
            value: function transformObb(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
                var tx = anAffineTransform.a * rect.x + anAffineTransform.c * rect.y + anAffineTransform.tx, ty = anAffineTransform.b * rect.x + anAffineTransform.d * rect.y + anAffineTransform.ty, xa = anAffineTransform.a * rect.width, xb = anAffineTransform.b * rect.width, yc = anAffineTransform.c * rect.height, yd = anAffineTransform.d * rect.height;
                out_tl.x = tx, out_tl.y = ty, out_tr.x = xa + tx, out_tr.y = xb + ty, out_bl.x = yc + tx, 
                out_bl.y = yd + ty, out_br.x = xa + yc + tx, out_br.y = xb + yd + ty;
            }
        } ]), AffineTransform;
    }();
    cc.AffineTransform = AffineTransform;
    var Size = function(_ValueType) {
        function Size(width, height) {
            var _this;
            return _classCallCheck(this, Size), _this = _possibleConstructorReturn(this, _getPrototypeOf(Size).call(this)), 
            width && "object" === _typeof(width) ? (_this.height = width.height, _this.width = width.width) : (_this.width = width || 0, 
            _this.height = height || 0), _this;
        }
        return _inherits(Size, _ValueType), _createClass(Size, [ {
            key: "x",
            set: function set(val) {
                this.width = val;
            },
            get: function get() {
                return this.width;
            }
        }, {
            key: "y",
            set: function set(val) {
                this.height = val;
            },
            get: function get() {
                return this.height;
            }
        } ], [ {
            key: "lerp",
            value: function lerp(out, from, to, ratio) {
                return out.width = from.width + (to.width - from.width) * ratio, out.height = from.height + (to.height - from.height) * ratio, 
                out;
            }
        }, {
            key: "ZERO",
            get: function get() {
                return new Size(0, 0);
            }
        } ]), _createClass(Size, [ {
            key: "clone",
            value: function clone() {
                return new Size(this.width, this.height);
            }
        }, {
            key: "set",
            value: function set(width, height) {
                return width && "object" === _typeof(width) ? (this.height = width.height, this.width = width.width) : (this.width = width || 0, 
                this.height = height || 0), this;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                return this.width === other.width && this.height === other.height;
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio) {
                return this.width = this.width + (to.width - this.width) * ratio, this.height = this.height + (to.height - this.height) * ratio, 
                this;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "(".concat(this.width.toFixed(2), ", ").concat(this.height.toFixed(2), ")");
            }
        } ]), Size;
    }(ValueType);
    function size() {
        var width = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, height = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        return new Size(width, height);
    }
    CCClass.fastDefine("cc.Size", Size, {
        width: 0,
        height: 0
    }), cc.size = size, cc.Size = Size;
    var _x$4 = 0, _y$4 = 0, _w$2 = 0, _h = 0, Rect = function(_ValueType) {
        function Rect(x, y, width, height) {
            var _this;
            return _classCallCheck(this, Rect), _this = _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this)), 
            x && "object" === _typeof(x) ? (_this.y = x.y, _this.width = x.width, _this.height = x.height, 
            _this.x = x.x) : (_this.x = x || 0, _this.y = y || 0, _this.width = width || 0, 
            _this.height = height || 0), _this;
        }
        return _inherits(Rect, _ValueType), _createClass(Rect, [ {
            key: "xMin",
            get: function get() {
                return this.x;
            },
            set: function set(value) {
                this.width += this.x - value, this.x = value;
            }
        }, {
            key: "yMin",
            get: function get() {
                return this.y;
            },
            set: function set(value) {
                this.height += this.y - value, this.y = value;
            }
        }, {
            key: "xMax",
            get: function get() {
                return this.x + this.width;
            },
            set: function set(value) {
                this.width = value - this.x;
            }
        }, {
            key: "yMax",
            get: function get() {
                return this.y + this.height;
            },
            set: function set(value) {
                this.height = value - this.y;
            }
        }, {
            key: "center",
            get: function get() {
                return new Vec2(this.x + .5 * this.width, this.y + .5 * this.height);
            },
            set: function set(value) {
                this.x = value.x - .5 * this.width, this.y = value.y - .5 * this.height;
            }
        }, {
            key: "origin",
            get: function get() {
                return new cc.Vec2(this.x, this.y);
            },
            set: function set(value) {
                this.x = value.x, this.y = value.y;
            }
        }, {
            key: "size",
            get: function get() {
                return new Size(this.width, this.height);
            },
            set: function set(value) {
                this.width = value.width, this.height = value.height;
            }
        }, {
            key: "z",
            set: function set(val) {
                this.width = val;
            },
            get: function get() {
                return this.width;
            }
        }, {
            key: "w",
            set: function set(val) {
                this.height = val;
            },
            get: function get() {
                return this.height;
            }
        } ], [ {
            key: "fromMinMax",
            value: function fromMinMax(out, v1, v2) {
                var minX = Math.min(v1.x, v2.x), minY = Math.min(v1.y, v2.y), maxX = Math.max(v1.x, v2.x), maxY = Math.max(v1.y, v2.y);
                return out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY, 
                out;
            }
        }, {
            key: "lerp",
            value: function lerp(out, from, to, ratio) {
                return _x$4 = from.x, _y$4 = from.y, _w$2 = from.width, _h = from.height, out.x = _x$4 + (to.x - _x$4) * ratio, 
                out.y = _y$4 + (to.y - _y$4) * ratio, out.width = _w$2 + (to.width - _w$2) * ratio, 
                out.height = _h + (to.height - _h) * ratio, out;
            }
        }, {
            key: "intersection",
            value: function intersection(out, one, other) {
                var axMin = one.x, ayMin = one.y, axMax = one.x + one.width, ayMax = one.y + one.height, bxMin = other.x, byMin = other.y, bxMax = other.x + other.width, byMax = other.y + other.height;
                return out.x = Math.max(axMin, bxMin), out.y = Math.max(ayMin, byMin), out.width = Math.min(axMax, bxMax) - out.x, 
                out.height = Math.min(ayMax, byMax) - out.y, out;
            }
        }, {
            key: "union",
            value: function union(out, one, other) {
                _x$4 = one.x, _y$4 = one.y, _w$2 = one.width, _h = one.height;
                var bx = other.x, by = other.y, bw = other.width, bh = other.height;
                return out.x = Math.min(_x$4, bx), out.y = Math.min(_y$4, by), out.width = Math.max(_x$4 + _w$2, bx + bw) - out.x, 
                out.height = Math.max(_y$4 + _h, by + bh) - out.y, out;
            }
        } ]), _createClass(Rect, [ {
            key: "clone",
            value: function clone() {
                return new Rect(this.x, this.y, this.width, this.height);
            }
        }, {
            key: "set",
            value: function set(x, y, width, height) {
                return x && "object" === _typeof(x) ? (this.y = x.y, this.width = x.width, this.height = x.height, 
                this.x = x.x) : (this.x = x || 0, this.y = y || 0, this.width = width || 0, this.height = height || 0), 
                this;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio) {
                return _x$4 = this.x, _y$4 = this.y, _w$2 = this.width, _h = this.height, this.x = _x$4 + (to.x - _x$4) * ratio, 
                this.y = _y$4 + (to.y - _y$4) * ratio, this.width = _w$2 + (to.width - _w$2) * ratio, 
                this.height = _h + (to.height - _h) * ratio, this;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.width.toFixed(2), ", ").concat(this.height.toFixed(2), ")");
            }
        }, {
            key: "intersects",
            value: function intersects(other) {
                var maxax = this.x + this.width, maxay = this.y + this.height, maxbx = other.x + other.width, maxby = other.y + other.height;
                return !(maxax < other.x || maxbx < this.x || maxay < other.y || maxby < this.y);
            }
        }, {
            key: "contains",
            value: function contains(point) {
                return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
            }
        }, {
            key: "containsRect",
            value: function containsRect(other) {
                return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(mat) {
                var ol = this.x, ob = this.y, or = ol + this.width, ot = ob + this.height, lbx = mat.m00 * ol + mat.m04 * ob + mat.m12, lby = mat.m01 * ol + mat.m05 * ob + mat.m13, rbx = mat.m00 * or + mat.m04 * ob + mat.m12, rby = mat.m01 * or + mat.m05 * ob + mat.m13, ltx = mat.m00 * ol + mat.m04 * ot + mat.m12, lty = mat.m01 * ol + mat.m05 * ot + mat.m13, rtx = mat.m00 * or + mat.m04 * ot + mat.m12, rty = mat.m01 * or + mat.m05 * ot + mat.m13, minX = Math.min(lbx, rbx, ltx, rtx), maxX = Math.max(lbx, rbx, ltx, rtx), minY = Math.min(lby, rby, lty, rty), maxY = Math.max(lby, rby, lty, rty);
                return this.x = minX, this.y = minY, this.width = maxX - minX, this.height = maxY - minY, 
                this;
            }
        } ]), Rect;
    }(ValueType);
    function rect() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, width = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, height = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        return new Rect(x, y, width, height);
    }
    CCClass.fastDefine("cc.Rect", Rect, {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    }), cc.Rect = Rect, cc.rect = rect;
    var _r = 0, _g = 0, _b$1 = 0, _a$1 = 0, Color = function(_ValueType) {
        function Color(r, g, b, a) {
            var _this;
            return _classCallCheck(this, Color), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Color).call(this)))._val = 0, 
            "string" == typeof r ? _this.fromHEX(r) : ("object" === _typeof(r) && (g = r.g, 
            b = r.b, a = r.a, r = r.r), r = r || 0, g = g || 0, b = b || 0, a = "number" == typeof a ? a : 255, 
            _this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r), _this;
        }
        return _inherits(Color, _ValueType), _createClass(Color, [ {
            key: "r",
            get: function get() {
                return 255 & this._val;
            },
            set: function set(red) {
                red = ~~clamp(red, 0, 255), this._val = (4294967040 & this._val | red) >>> 0;
            }
        }, {
            key: "g",
            get: function get() {
                return (65280 & this._val) >> 8;
            },
            set: function set(green) {
                green = ~~clamp(green, 0, 255), this._val = (4294902015 & this._val | green << 8) >>> 0;
            }
        }, {
            key: "b",
            get: function get() {
                return (16711680 & this._val) >> 16;
            },
            set: function set(blue) {
                blue = ~~clamp(blue, 0, 255), this._val = (4278255615 & this._val | blue << 16) >>> 0;
            }
        }, {
            key: "a",
            get: function get() {
                return (4278190080 & this._val) >>> 24;
            },
            set: function set(alpha) {
                alpha = ~~clamp(alpha, 0, 255), this._val = (16777215 & this._val | alpha << 24 >>> 0) >>> 0;
            }
        }, {
            key: "x",
            get: function get() {
                return this.r * (1 / 255);
            },
            set: function set(value) {
                this.r = 255 * value;
            }
        }, {
            key: "y",
            get: function get() {
                return this.g * (1 / 255);
            },
            set: function set(value) {
                this.g = 255 * value;
            }
        }, {
            key: "z",
            get: function get() {
                return this.b * (1 / 255);
            },
            set: function set(value) {
                this.b = 255 * value;
            }
        }, {
            key: "w",
            get: function get() {
                return this.a * (1 / 255);
            },
            set: function set(value) {
                this.a = 255 * value;
            }
        } ], [ {
            key: "clone",
            value: function clone(a) {
                var out = new Color;
                return a._val ? out._val = a._val : out._val = (a.a << 24 >>> 0) + (a.b << 16) + (a.g << 8) + a.r, 
                out;
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.r = a.r, out.g = a.g, out.b = a.b, out.a = a.a, out;
            }
        }, {
            key: "set",
            value: function set(out, r, g, b, a) {
                return out.r = r, out.g = g, out.b = b, out.a = a, out;
            }
        }, {
            key: "fromHEX",
            value: function fromHEX(out, hexString) {
                return hexString = 0 === hexString.indexOf("#") ? hexString.substring(1) : hexString, 
                out.r = parseInt(hexString.substr(0, 2), 16) || 0, out.g = parseInt(hexString.substr(2, 2), 16) || 0, 
                out.b = parseInt(hexString.substr(4, 2), 16) || 0, out.a = parseInt(hexString.substr(6, 2), 16) || 255, 
                out._val = (out.a << 24 >>> 0) + (out.b << 16) + (out.g << 8) + out.r, out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.r = a.r + b.r, out.g = a.g + b.g, out.b = a.b + b.b, out.a = a.a + b.a, 
                out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.r = a.r - b.r, out.g = a.g - b.g, out.b = a.b - b.b, out.a = a.a - b.a, 
                out;
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                return out.r = a.r * b.r, out.g = a.g * b.g, out.b = a.b * b.b, out.a = a.a * b.a, 
                out;
            }
        }, {
            key: "divide",
            value: function divide(out, a, b) {
                return out.r = a.r / b.r, out.g = a.g / b.g, out.b = a.b / b.b, out.a = a.a / b.a, 
                out;
            }
        }, {
            key: "scale",
            value: function scale(out, a, b) {
                return out.r = a.r * b, out.g = a.g * b, out.b = a.b * b, out.a = a.a * b, out;
            }
        }, {
            key: "lerp",
            value: function lerp(out, from, to, ratio) {
                return _r = from.r, _g = from.g, _b$1 = from.b, _a$1 = from.a, _r += (to.r - _r) * ratio, 
                _g += (to.g - _g) * ratio, _b$1 += (to.b - _b$1) * ratio, _a$1 += (to.a - _a$1) * ratio, 
                out._val = Math.floor((_a$1 << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r), out;
            }
        }, {
            key: "toArray",
            value: function toArray(out, a) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, scale = a instanceof Color || a.a > 1 ? 1 / 255 : 1;
                return out[ofs + 0] = a.r * scale, out[ofs + 1] = a.g * scale, out[ofs + 2] = a.b * scale, 
                out[ofs + 3] = a.a * scale, out;
            }
        }, {
            key: "fromArray",
            value: function fromArray(arr, out) {
                var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return out.r = 255 * arr[ofs + 0], out.g = 255 * arr[ofs + 1], out.b = 255 * arr[ofs + 2], 
                out.a = 255 * arr[ofs + 3], out;
            }
        }, {
            key: "strictEquals",
            value: function strictEquals(a, b) {
                return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
            }
        }, {
            key: "equals",
            value: function equals(a, b) {
                var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-6;
                return Math.abs(a.r - b.r) <= epsilon * Math.max(1, Math.abs(a.r), Math.abs(b.r)) && Math.abs(a.g - b.g) <= epsilon * Math.max(1, Math.abs(a.g), Math.abs(b.g)) && Math.abs(a.b - b.b) <= epsilon * Math.max(1, Math.abs(a.b), Math.abs(b.b)) && Math.abs(a.a - b.a) <= epsilon * Math.max(1, Math.abs(a.a), Math.abs(b.a));
            }
        }, {
            key: "hex",
            value: function hex(a) {
                return (255 * a.r << 24 | 255 * a.g << 16 | 255 * a.b << 8 | 255 * a.a) >>> 0;
            }
        } ]), _createClass(Color, [ {
            key: "clone",
            value: function clone() {
                var ret = new Color;
                return ret._val = this._val, ret;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                return other && this._val === other._val;
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio) {
                return _r = this.r, _g = this.g, _b$1 = this.b, _a$1 = this.a, _r += (to.r - _r) * ratio, 
                _g += (to.g - _g) * ratio, _b$1 += (to.b - _b$1) * ratio, _a$1 += (to.a - _a$1) * ratio, 
                this._val = Math.floor((_a$1 << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r), this;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
            }
        }, {
            key: "toCSS",
            value: function toCSS(opt) {
                return "rgba" === opt ? "rgba(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + "," + (this.a * (1 / 255)).toFixed(2) + ")" : "rgb" === opt ? "rgb(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + ")" : "#" + this.toHEX(opt);
            }
        }, {
            key: "fromHEX",
            value: function fromHEX(hexString) {
                return hexString = 0 === hexString.indexOf("#") ? hexString.substring(1) : hexString, 
                _r = parseInt(hexString.substr(0, 2), 16) || 0, _g = parseInt(hexString.substr(2, 2), 16) || 0, 
                _b$1 = parseInt(hexString.substr(4, 2), 16) || 0, _a$1 = parseInt(hexString.substr(6, 2), 16) || 255, 
                this._val = (_a$1 << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r, this;
            }
        }, {
            key: "toHEX",
            value: function toHEX(fmt) {
                var hex = [ (0 | this.r).toString(16), (0 | this.g).toString(16), (0 | this.b).toString(16) ], i = -1;
                if ("#rrggbb" === fmt) for (i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]); else if ("#rrggbbaa" === fmt) for (hex.push((0 | this.a).toString(16)), 
                i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]);
                return hex.join("");
            }
        }, {
            key: "toRGBValue",
            value: function toRGBValue() {
                return 16777215 & this._val;
            }
        }, {
            key: "fromHSV",
            value: function fromHSV(h, s, v) {
                if (_r = 0, _g = 0, _b$1 = 0, 0 === s) _r = _g = _b$1 = v; else if (0 === v) _r = _g = _b$1 = 0; else {
                    1 === h && (h = 0), h *= 6, s = s, v = v;
                    var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - s * f), t = v * (1 - s * (1 - f));
                    switch (i) {
                      case 0:
                        _r = v, _g = t, _b$1 = p;
                        break;

                      case 1:
                        _r = q, _g = v, _b$1 = p;
                        break;

                      case 2:
                        _r = p, _g = v, _b$1 = t;
                        break;

                      case 3:
                        _r = p, _g = q, _b$1 = v;
                        break;

                      case 4:
                        _r = t, _g = p, _b$1 = v;
                        break;

                      case 5:
                        _r = v, _g = p, _b$1 = q;
                    }
                }
                return _r *= 255, _g *= 255, _b$1 *= 255, this._val = (this.a << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r, 
                this;
            }
        }, {
            key: "toHSV",
            value: function toHSV() {
                _r = this.r * (1 / 255), _g = this.g * (1 / 255), _b$1 = this.b * (1 / 255);
                var hsv = {
                    h: 0,
                    s: 0,
                    v: 0
                }, max = Math.max(_r, _g, _b$1), min = Math.min(_r, _g, _b$1), delta = 0;
                return hsv.v = max, hsv.s = max ? (max - min) / max : 0, hsv.s ? (delta = max - min, 
                hsv.h = _r === max ? (_g - _b$1) / delta : _g === max ? 2 + (_b$1 - _r) / delta : 4 + (_r - _g) / delta, 
                hsv.h /= 6, hsv.h < 0 && (hsv.h += 1)) : hsv.h = 0, hsv;
            }
        }, {
            key: "set",
            value: function set(r, g, b, a) {
                return "object" === _typeof(r) && (g = r.g, b = r.b, a = r.a, r = r.r), r = r || 0, 
                g = g || 0, b = b || 0, a = "number" == typeof a ? a : 255, this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r, 
                this;
            }
        }, {
            key: "multiply",
            value: function multiply(other) {
                return _r = (255 & this._val) * other.r >> 8, _g = (65280 & this._val) * other.g >> 8, 
                _b$1 = (16711680 & this._val) * other.b >> 8, _a$1 = ((4278190080 & this._val) >>> 8) * other.a, 
                this._val = 4278190080 & _a$1 | 16711680 & _b$1 | 65280 & _g | 255 & _r, this;
            }
        }, {
            key: "_set_r_unsafe",
            value: function _set_r_unsafe(red) {
                return this._val = (4294967040 & this._val | red) >>> 0, this;
            }
        }, {
            key: "_set_g_unsafe",
            value: function _set_g_unsafe(green) {
                return this._val = (4294902015 & this._val | green << 8) >>> 0, this;
            }
        }, {
            key: "_set_b_unsafe",
            value: function _set_b_unsafe(blue) {
                return this._val = (4278255615 & this._val | blue << 16) >>> 0, this;
            }
        }, {
            key: "_set_a_unsafe",
            value: function _set_a_unsafe(alpha) {
                return this._val = (16777215 & this._val | alpha << 24 >>> 0) >>> 0, this;
            }
        } ]), Color;
    }(ValueType);
    function color(r, g, b, a) {
        return new Color(r, g, b, a);
    }
    Color.WHITE = Object.freeze(new Color(255, 255, 255, 255)), Color.GRAY = Object.freeze(new Color(127, 127, 127, 255)), 
    Color.BLACK = Object.freeze(new Color(0, 0, 0, 255)), Color.TRANSPARENT = Object.freeze(new Color(0, 0, 0, 0)), 
    Color.RED = Object.freeze(new Color(255, 0, 0, 255)), Color.GREEN = Object.freeze(new Color(0, 255, 0, 255)), 
    Color.BLUE = Object.freeze(new Color(0, 0, 255, 255)), Color.CYAN = Object.freeze(new Color(0, 255, 255, 255)), 
    Color.MAGENTA = Object.freeze(new Color(255, 0, 255, 255)), Color.YELLOW = Object.freeze(new Color(255, 255, 0, 255)), 
    CCClass.fastDefine("cc.Color", Color, {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    }), cc.Color = Color, cc.color = color;
    var replacePropertyLog, markAsWarningLog, removePropertyLog, defaultLogTimes = 10;
    var messageID = 0, messageMap = new Map;
    replacePropertyLog = function replacePropertyLog(n, dp, n2, newp, f, id) {
        var item = messageMap.get(id);
        item && item.logTimes > item.count && (f("'%s' is deprecated, please use '%s' instead.", "".concat(n, ".").concat(dp), "".concat(n2, ".").concat(newp)), 
        item.count++);
    }, exports.replaceProperty = function replaceProperty(owner, ownerName, properties) {
        null != owner && properties.forEach((function(item) {
            var id = messageID++;
            messageMap.set(id, {
                id: id,
                count: 0,
                logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
            });
            var target = null != item.target ? item.target : owner, newName = null != item.newName ? item.newName : item.name, targetName = null != item.targetName ? item.targetName : ownerName;
            if (null != item.customFunction) owner[item.name] = function() {
                return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                item.customFunction.call(this, arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 4 ? void 0 : arguments[4], arguments.length <= 5 ? void 0 : arguments[5], arguments.length <= 6 ? void 0 : arguments[6], arguments.length <= 7 ? void 0 : arguments[7], arguments.length <= 8 ? void 0 : arguments[8], arguments.length <= 9 ? void 0 : arguments[9], arguments.length <= 10 ? void 0 : arguments[10], arguments.length <= 11 ? void 0 : arguments[11]);
            }; else if (null != item.customSetter || null != item.customGetter) {
                var hasSetter = null != item.customSetter, hasGetter = null != item.customGetter;
                hasSetter && hasGetter ? Object.defineProperty(owner, item.name, {
                    get: function get() {
                        return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                        item.customGetter.call(this);
                    },
                    set: function set(v) {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), item.customSetter.call(this, v);
                    }
                }) : hasSetter ? Object.defineProperty(owner, item.name, {
                    set: function set(v) {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), item.customSetter.call(this, v);
                    }
                }) : hasGetter && Object.defineProperty(owner, item.name, {
                    get: function get() {
                        return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                        item.customGetter.call(this);
                    }
                });
            } else Object.defineProperty(owner, item.name, {
                get: function get() {
                    return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                    target[newName];
                },
                set: function set(v) {
                    replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), target[newName] = v;
                }
            });
        }));
    }, removePropertyLog = function removePropertyLog(n, dp, f, id) {
        var item = messageMap.get(id);
        item && item.logTimes > item.count && (f("'%s' has been removed.", "".concat(n, ".").concat(dp)), 
        item.count++);
    }, exports.removeProperty = function removeProperty(owner, ownerName, properties) {
        null != owner && properties.forEach((function(item) {
            var id = messageID++;
            messageMap.set(id, {
                id: id,
                count: 0,
                logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
            }), Object.defineProperty(owner, item.name, {
                get: function get() {
                    return removePropertyLog(ownerName, item.name, error, id);
                },
                set: function set() {
                    removePropertyLog(ownerName, item.name, error, id);
                }
            });
        }));
    }, markAsWarningLog = function markAsWarningLog(n, dp, f, id) {
        var item = messageMap.get(id);
        item && item.logTimes > item.count && (f("'%s' is deprecated.", "".concat(n, ".").concat(dp)), 
        item.count++);
    }, exports.markAsWarning = function markAsWarning(owner, ownerName, properties) {
        if (null != owner) {
            var _defaultGetSet = function _defaultGetSet(o, p, d, n, dp, f, id) {
                if (d.get) {
                    var oldGet = d.get();
                    d.get = function() {
                        return markAsWarningLog(n, dp, f, id), oldGet.call(this);
                    };
                }
                if (d.set) {
                    var oldSet = Object.create(d.set);
                    d.set = function(v) {
                        markAsWarningLog(n, dp, f, id), oldSet.call(this, v);
                    };
                }
            };
            properties.forEach((function(item) {
                var deprecatedProp = item.name, descriptor = Object.getOwnPropertyDescriptor(owner, deprecatedProp);
                if (descriptor) {
                    var id = messageID++;
                    if (messageMap.set(id, {
                        id: id,
                        count: 0,
                        logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
                    }), null != descriptor.value) if ("function" == typeof descriptor.value) {
                        var oldValue = descriptor.value;
                        owner[deprecatedProp] = function() {
                            return markAsWarningLog(ownerName, deprecatedProp, warn, id), oldValue.call(this);
                        };
                    } else _defaultGetSet(0, 0, descriptor, ownerName, deprecatedProp, warn, id); else _defaultGetSet(0, 0, descriptor, ownerName, deprecatedProp, warn, id);
                }
            }));
        }
    }, exports.replaceProperty(Vec2, "Vec2", [ {
        name: "sub",
        newName: "subtract",
        target: Vec2,
        targetName: "Vec2"
    }, {
        name: "mul",
        newName: "multiply",
        target: Vec2,
        targetName: "Vec2"
    }, {
        name: "div",
        newName: "divide",
        target: Vec2,
        targetName: "Vec2"
    }, {
        name: "dist",
        newName: "distance",
        target: Vec2,
        targetName: "Vec2"
    }, {
        name: "sqrDist",
        newName: "squaredDistance",
        target: Vec2,
        targetName: "Vec2"
    }, {
        name: "mag",
        newName: "len",
        target: Vec2,
        targetName: "Vec2"
    }, {
        name: "sqrMag",
        newName: "lengthSqr",
        target: Vec2,
        targetName: "Vec2"
    }, {
        name: "scale",
        newName: "multiplyScalar",
        target: Vec2,
        targetName: "Vec2"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Vec2,
        targetName: "Vec2"
    } ]), exports.replaceProperty(Vec2.prototype, "Vec2", [ {
        name: "mag",
        newName: "length",
        target: Vec2.prototype,
        targetName: "Vec2"
    }, {
        name: "magSqr",
        newName: "lengthSqr",
        target: Vec2.prototype,
        targetName: "Vec2"
    }, {
        name: "scale",
        newName: "multiplyScalar",
        target: Vec2.prototype,
        targetName: "Vec2"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Vec2.prototype,
        targetName: "Vec2"
    } ]), exports.removeProperty(Vec2.prototype, "vmath", [ {
        name: "divide"
    } ]), exports.replaceProperty(Vec3, "Vec3", [ {
        name: "sub",
        newName: "subtract",
        target: Vec3,
        targetName: "Vec3"
    }, {
        name: "mul",
        newName: "multiply",
        target: Vec3,
        targetName: "Vec3"
    }, {
        name: "div",
        newName: "divide",
        target: Vec3,
        targetName: "Vec3"
    }, {
        name: "dist",
        newName: "distance",
        target: Vec3,
        targetName: "Vec3"
    }, {
        name: "sqrDist",
        newName: "squaredDistance",
        target: Vec3,
        targetName: "Vec3"
    }, {
        name: "mag",
        newName: "len",
        target: Vec3,
        targetName: "Vec3"
    }, {
        name: "sqrMag",
        newName: "lengthSqr",
        target: Vec3,
        targetName: "Vec3"
    }, {
        name: "scale",
        newName: "multiplyScalar",
        target: Vec3,
        targetName: "Vec3"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Vec3,
        targetName: "Vec3"
    } ]), exports.replaceProperty(Vec3.prototype, "Vec3", [ {
        name: "mag",
        newName: "length",
        target: Vec3.prototype,
        targetName: "Vec3"
    }, {
        name: "magSqr",
        newName: "lengthSqr",
        target: Vec3.prototype,
        targetName: "Vec3"
    }, {
        name: "scale",
        newName: "multiplyScalar",
        target: Vec3.prototype,
        targetName: "Vec3"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Vec3.prototype,
        targetName: "Vec3"
    } ]), exports.removeProperty(Vec3.prototype, "vmath", [ {
        name: "divide"
    } ]), exports.replaceProperty(Vec4, "Vec4", [ {
        name: "sub",
        newName: "subtract",
        target: Vec4,
        targetName: "Vec4"
    }, {
        name: "mul",
        newName: "multiply",
        target: Vec4,
        targetName: "Vec4"
    }, {
        name: "div",
        newName: "divide",
        target: Vec4,
        targetName: "Vec4"
    }, {
        name: "dist",
        newName: "distance",
        target: Vec4,
        targetName: "Vec4"
    }, {
        name: "sqrDist",
        newName: "squaredDistance",
        target: Vec4,
        targetName: "Vec4"
    }, {
        name: "mag",
        newName: "len",
        target: Vec4,
        targetName: "Vec4"
    }, {
        name: "sqrMag",
        newName: "lengthSqr",
        target: Vec4,
        targetName: "Vec4"
    }, {
        name: "scale",
        newName: "multiplyScalar",
        target: Vec4,
        targetName: "Vec4"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Vec4,
        targetName: "Vec4"
    } ]), exports.replaceProperty(Vec4.prototype, "Vec4", [ {
        name: "mag",
        newName: "length",
        target: Vec4.prototype,
        targetName: "Vec4"
    }, {
        name: "magSqr",
        newName: "lengthSqr",
        target: Vec4.prototype,
        targetName: "Vec4"
    }, {
        name: "scale",
        newName: "multiplyScalar",
        target: Vec4.prototype,
        targetName: "Vec4"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Vec4.prototype,
        targetName: "Vec4"
    } ]), exports.removeProperty(Vec4.prototype, "vmath", [ {
        name: "divide"
    } ]), exports.replaceProperty(Quat, "Quat", [ {
        name: "mag",
        newName: "len",
        target: Quat,
        targetName: "Quat"
    }, {
        name: "mul",
        newName: "multiply",
        target: Quat,
        targetName: "Quat"
    }, {
        name: "sqrMag",
        newName: "lengthSqr",
        target: Quat,
        targetName: "Quat"
    }, {
        name: "scale",
        newName: "multiplyScalar",
        target: Quat,
        targetName: "Quat"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Quat,
        targetName: "Quat"
    } ]), exports.replaceProperty(Quat.prototype, "Quat", [ {
        name: "scale",
        newName: "multiplyScalar",
        target: Quat.prototype,
        targetName: "Quat"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Quat.prototype,
        targetName: "Quat"
    } ]), exports.replaceProperty(Color, "Color", [ {
        name: "sub",
        newName: "subtract",
        target: Color,
        targetName: "Color"
    }, {
        name: "mul",
        newName: "multiply",
        target: Color,
        targetName: "Color"
    }, {
        name: "div",
        newName: "divide",
        target: Color,
        targetName: "Color"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Color,
        targetName: "Color"
    }, {
        name: "fromHex",
        newName: "fromHEX",
        customFunction: function customFunction() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            var arg1 = args[1].toString(16);
            return cc.Color.fromHEX(args[0], arg1);
        }
    } ]), exports.replaceProperty(Mat3, "Mat3", [ {
        name: "sub",
        newName: "subtract",
        target: Mat3,
        targetName: "Mat3"
    }, {
        name: "mul",
        newName: "multiply",
        target: Mat3,
        targetName: "Mat3"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Mat3,
        targetName: "Mat3"
    } ]), exports.replaceProperty(Mat3.prototype, "Mat3", [ {
        name: "sub",
        newName: "subtract",
        target: Mat3.prototype,
        targetName: "Mat3"
    }, {
        name: "mul",
        newName: "multiply",
        target: Mat3.prototype,
        targetName: "Mat3"
    }, {
        name: "mulScalar",
        newName: "multiplyScalar",
        target: Mat3.prototype,
        targetName: "Mat3"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Mat3.prototype,
        targetName: "Mat3"
    } ]), exports.replaceProperty(Mat4, "Mat4", [ {
        name: "sub",
        newName: "subtract",
        target: Mat4,
        targetName: "Mat4"
    }, {
        name: "mul",
        newName: "multiply",
        target: Mat4,
        targetName: "Mat4"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Mat4,
        targetName: "Mat4"
    } ]), exports.replaceProperty(Mat4.prototype, "Mat4", [ {
        name: "sub",
        newName: "subtract",
        target: Mat4.prototype,
        targetName: "Mat4"
    }, {
        name: "mul",
        newName: "multiply",
        target: Mat4.prototype,
        targetName: "Mat4"
    }, {
        name: "mulScalar",
        newName: "multiplyScalar",
        target: Mat4.prototype,
        targetName: "Mat4"
    }, {
        name: "exactEquals",
        newName: "strictEquals",
        target: Mat4.prototype,
        targetName: "Mat4"
    } ]);
    var math = Object.freeze({
        __proto__: null,
        bits: bits,
        Vec2: Vec2,
        v2: v2,
        Vec3: Vec3,
        v3: v3,
        Vec4: Vec4,
        v4: v4,
        Quat: Quat,
        quat: quat,
        Mat3: Mat3,
        Mat4: Mat4,
        mat4: mat4,
        AffineTransform: AffineTransform,
        Size: Size,
        size: size,
        Rect: Rect,
        rect: rect,
        Color: Color,
        color: color,
        EPSILON: 1e-6,
        equals: equals,
        approx: approx,
        clamp: clamp,
        clamp01: clamp01,
        lerp: lerp,
        toRadian: toRadian,
        toDegree: toDegree,
        random: random,
        randomRange: randomRange,
        randomRangeInt: randomRangeInt,
        pseudoRandom: pseudoRandom,
        pseudoRandomRange: pseudoRandomRange,
        pseudoRandomRangeInt: pseudoRandomRangeInt,
        nextPow2: nextPow2$1,
        repeat: repeat,
        pingPong: pingPong,
        inverseLerp: inverseLerp,
        absMaxComponent: absMaxComponent,
        absMax: absMax
    }), X = new Vec3, Y = new Vec3, Z = new Vec3, d = new Vec3, min$1 = new Vec3, max$1 = new Vec3, u = new Array(3), e = new Array(3);
    function point_plane(point, plane_) {
        return Vec3.dot(plane_.n, point) - plane_.d;
    }
    function pt_point_aabb(out, point, aabb_) {
        return Vec3.copy(out, point), Vec3.subtract(min$1, aabb_.center, aabb_.halfExtents), 
        Vec3.add(max$1, aabb_.center, aabb_.halfExtents), out.x = out.x < min$1.x ? min$1.x : out.x, 
        out.y = out.y < min$1.x ? min$1.y : out.y, out.z = out.z < min$1.x ? min$1.z : out.z, 
        out.x = out.x > max$1.x ? max$1.x : out.x, out.y = out.y > max$1.x ? max$1.y : out.y, 
        out.z = out.z > max$1.x ? max$1.z : out.z, out;
    }
    function pt_point_obb(out, point, obb_) {
        Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02), Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05), 
        Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08), u[0] = X, 
        u[1] = Y, u[2] = Z, e[0] = obb_.halfExtents.x, e[1] = obb_.halfExtents.y, e[2] = obb_.halfExtents.z, 
        Vec3.subtract(d, point, obb_.center), Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);
        for (var i = 0; i < 3; i++) {
            var dist = Vec3.dot(d, u[i]);
            dist > e[i] && (dist = e[i]), dist < -e[i] && (dist = -e[i]), out.x += dist * u[i].x, 
            out.y += dist * u[i].y, out.z += dist * u[i].z;
        }
        return out;
    }
    var distance = Object.freeze({
        __proto__: null,
        point_plane: point_plane,
        pt_point_plane: function pt_point_plane(out, point, plane_) {
            var t = point_plane(point, plane_);
            return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
        },
        pt_point_aabb: pt_point_aabb,
        pt_point_obb: pt_point_obb,
        pt_point_line: function pt_point_line(out, point, start, end) {
            Vec3.subtract(X, start, end);
            var dir = X, dirSquaredLength = Vec3.lengthSqr(dir);
            if (0 == dirSquaredLength) Vec3.copy(out, start); else {
                Vec3.subtract(X, point, start);
                var t = Vec3.dot(X, dir) / dirSquaredLength;
                t < 0 ? Vec3.copy(out, start) : t > 1 ? Vec3.copy(out, end) : Vec3.scaleAndAdd(out, start, dir, t);
            }
        }
    }), ray = function() {
        function ray() {
            var ox = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, oy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, oz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, dx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, dy = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, dz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : -1;
            _classCallCheck(this, ray), this._type = enums.SHAPE_RAY, this.o = new Vec3(ox, oy, oz), 
            this.d = new Vec3(dx, dy, dz);
        }
        return _createClass(ray, null, [ {
            key: "create",
            value: function create() {
                var ox = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, oy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, oz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, dx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, dy = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, dz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
                return new ray(ox, oy, oz, dx, dy, dz);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return Vec3.copy(out.o, a.o), Vec3.copy(out.d, a.d), out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, origin, target) {
                return Vec3.copy(out.o, origin), Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin)), 
                out;
            }
        }, {
            key: "set",
            value: function set(out, ox, oy, oz, dx, dy, dz) {
                return out.o.x = ox, out.o.y = oy, out.o.z = oz, out.d.x = dx, out.d.y = dy, out.d.z = dz, 
                out;
            }
        } ]), _createClass(ray, [ {
            key: "computeHit",
            value: function computeHit(out, distance) {
                Vec3.normalize(out, this.d), Vec3.scaleAndAdd(out, this.o, out, distance);
            }
        } ]), ray;
    }(), _v3_tmp = new Vec3;
    function maxComponent(v) {
        return Math.max(Math.max(v.x, v.y), v.z);
    }
    var pt, ab, ac, pvec, tvec, qvec, sphere = function() {
        function sphere() {
            var cx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, cy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, cz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
            _classCallCheck(this, sphere), this._type = enums.SHAPE_SPHERE, this.center = new Vec3(cx, cy, cz), 
            this.radius = r;
        }
        return _createClass(sphere, null, [ {
            key: "create",
            value: function create(cx, cy, cz, r) {
                return new sphere(cx, cy, cz, r);
            }
        }, {
            key: "clone",
            value: function clone(p) {
                return new sphere(p.center.x, p.center.y, p.center.z, p.radius);
            }
        }, {
            key: "copy",
            value: function copy(out, p) {
                return Vec3.copy(out.center, p.center), out.radius = p.radius, out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, minPos, maxPos) {
                return Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), .5), out.radius = .5 * Vec3.subtract(_v3_tmp, maxPos, minPos).length(), 
                out;
            }
        }, {
            key: "set",
            value: function set(out, cx, cy, cz, r) {
                return out.center.x = cx, out.center.y = cy, out.center.z = cz, out.radius = r, 
                out;
            }
        } ]), _createClass(sphere, [ {
            key: "clone",
            value: function clone() {
                return sphere.clone(this);
            }
        }, {
            key: "copy",
            value: function copy(a) {
                return sphere.copy(this, a);
            }
        }, {
            key: "getBoundary",
            value: function getBoundary(minPos, maxPos) {
                Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius), 
                Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
            }
        }, {
            key: "transform",
            value: function transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m), out.radius = this.radius * maxComponent(scale);
            }
        }, {
            key: "translateAndRotate",
            value: function translateAndRotate(m, rot, out) {
                Vec3.transformMat4(out.center, this.center, m);
            }
        }, {
            key: "setScale",
            value: function setScale(scale, out) {
                out.radius = this.radius * maxComponent(scale);
            }
        } ]), sphere;
    }(), ray_plane = (pt = new Vec3(0, 0, 0), function(ray, plane) {
        var denom = Vec3.dot(ray.d, plane.n);
        if (Math.abs(denom) < Number.EPSILON) return 0;
        Vec3.multiplyScalar(pt, plane.n, plane.d);
        var t = Vec3.dot(Vec3.subtract(pt, pt, ray.o), plane.n) / denom;
        return t < 0 ? 0 : t;
    }), ray_triangle = (ab = new Vec3(0, 0, 0), ac = new Vec3(0, 0, 0), pvec = new Vec3(0, 0, 0), 
    tvec = new Vec3(0, 0, 0), qvec = new Vec3(0, 0, 0), function(ray, triangle, doubleSided) {
        Vec3.subtract(ab, triangle.b, triangle.a), Vec3.subtract(ac, triangle.c, triangle.a), 
        Vec3.cross(pvec, ray.d, ac);
        var det = Vec3.dot(ab, pvec);
        if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) return 0;
        var inv_det = 1 / det;
        Vec3.subtract(tvec, ray.o, triangle.a);
        var u = Vec3.dot(tvec, pvec) * inv_det;
        if (u < 0 || u > 1) return 0;
        Vec3.cross(qvec, tvec, ab);
        var v = Vec3.dot(ray.d, qvec) * inv_det;
        if (v < 0 || u + v > 1) return 0;
        var t = Vec3.dot(ac, qvec) * inv_det;
        return t < 0 ? 0 : t;
    }), ray_sphere = function() {
        var e = new Vec3(0, 0, 0);
        return function(ray, sphere) {
            var r = sphere.radius, c = sphere.center, o = ray.o, d = ray.d, rSq = r * r;
            Vec3.subtract(e, c, o);
            var eSq = e.lengthSqr(), aLength = Vec3.dot(e, d), fSq = rSq - (eSq - aLength * aLength);
            if (fSq < 0) return 0;
            var f = Math.sqrt(fSq), t = eSq < rSq ? aLength + f : aLength - f;
            return t < 0 ? 0 : t;
        };
    }(), ray_aabb = function() {
        var min = new Vec3, max = new Vec3;
        return function(ray, aabb) {
            var o = ray.o, d = ray.d, ix = 1 / d.x, iy = 1 / d.y, iz = 1 / d.z;
            Vec3.subtract(min, aabb.center, aabb.halfExtents), Vec3.add(max, aabb.center, aabb.halfExtents);
            var t1 = (min.x - o.x) * ix, t2 = (max.x - o.x) * ix, t3 = (min.y - o.y) * iy, t4 = (max.y - o.y) * iy, t5 = (min.z - o.z) * iz, t6 = (max.z - o.z) * iz, tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6)), tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
            return tmax < 0 || tmin > tmax ? 0 : tmin > 0 ? tmin : tmax;
        };
    }(), ray_obb = function() {
        var center = new Vec3, o = new Vec3, d = new Vec3, X = new Vec3, Y = new Vec3, Z = new Vec3, p = new Vec3, size = new Array(3), f = new Array(3), e = new Array(3), t = new Array(6);
        return function(ray, obb) {
            size[0] = obb.halfExtents.x, size[1] = obb.halfExtents.y, size[2] = obb.halfExtents.z, 
            center = obb.center, o = ray.o, d = ray.d, Vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02), 
            Vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05), Vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08), 
            Vec3.subtract(p, center, o), f[0] = Vec3.dot(X, d), f[1] = Vec3.dot(Y, d), f[2] = Vec3.dot(Z, d), 
            e[0] = Vec3.dot(X, p), e[1] = Vec3.dot(Y, p), e[2] = Vec3.dot(Z, p);
            for (var i = 0; i < 3; ++i) {
                if (0 === f[i]) {
                    if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) return 0;
                    f[i] = 1e-7;
                }
                t[2 * i + 0] = (e[i] + size[i]) / f[i], t[2 * i + 1] = (e[i] - size[i]) / f[i];
            }
            var tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5])), tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));
            return tmax < 0 || tmin > tmax ? 0 : tmin > 0 ? tmin : tmax;
        };
    }(), ray_capsule = function() {
        var v3_0 = new Vec3, v3_1 = new Vec3, v3_2 = new Vec3, v3_3 = new Vec3, v3_4 = new Vec3, v3_5 = new Vec3, v3_6 = new Vec3, sphere_0 = new sphere;
        return function(ray, capsule) {
            var radiusSqr = capsule.radius * capsule.radius, vRayNorm = Vec3.normalize(v3_0, ray.d), A = capsule.ellipseCenter0, B = capsule.ellipseCenter1, BA = Vec3.subtract(v3_1, B, A);
            if (BA.equals(Vec3.ZERO)) return sphere_0.radius = capsule.radius, sphere_0.center.set(capsule.ellipseCenter0), 
            intersect.ray_sphere(ray, sphere_0);
            var O = ray.o, OA = Vec3.subtract(v3_2, O, A), VxBA = Vec3.cross(v3_3, vRayNorm, BA), a = VxBA.lengthSqr();
            if (0 === a) {
                sphere_0.radius = capsule.radius;
                var BO = Vec3.subtract(v3_4, B, O);
                return OA.lengthSqr() < BO.lengthSqr() ? sphere_0.center.set(capsule.ellipseCenter0) : sphere_0.center.set(capsule.ellipseCenter1), 
                intersect.ray_sphere(ray, sphere_0);
            }
            var OAxBA = Vec3.cross(v3_4, OA, BA), ab2 = BA.lengthSqr(), b = 2 * Vec3.dot(VxBA, OAxBA), d = b * b - 4 * a * (OAxBA.lengthSqr() - radiusSqr * ab2);
            if (d < 0) return 0;
            var t = (-b - Math.sqrt(d)) / (2 * a);
            if (t < 0) {
                sphere_0.radius = capsule.radius;
                var _BO = Vec3.subtract(v3_5, B, O);
                return OA.lengthSqr() < _BO.lengthSqr() ? sphere_0.center.set(capsule.ellipseCenter0) : sphere_0.center.set(capsule.ellipseCenter1), 
                intersect.ray_sphere(ray, sphere_0);
            }
            var iPos = Vec3.scaleAndAdd(v3_5, ray.o, vRayNorm, t), iPosLen = Vec3.subtract(v3_6, iPos, A), tLimit = Vec3.dot(iPosLen, BA) / ab2;
            return tLimit >= 0 && tLimit <= 1 ? t : tLimit < 0 ? (sphere_0.radius = capsule.radius, 
            sphere_0.center.set(capsule.ellipseCenter0), intersect.ray_sphere(ray, sphere_0)) : tLimit > 1 ? (sphere_0.radius = capsule.radius, 
            sphere_0.center.set(capsule.ellipseCenter1), intersect.ray_sphere(ray, sphere_0)) : 0;
        };
    }(), line_plane = function() {
        var ab = new Vec3(0, 0, 0);
        return function(line, plane) {
            Vec3.subtract(ab, line.e, line.s);
            var t = (plane.d - Vec3.dot(line.s, plane.n)) / Vec3.dot(ab, plane.n);
            return t < 0 || t > 1 ? 0 : t;
        };
    }(), line_triangle = function() {
        var ab = new Vec3(0, 0, 0), ac = new Vec3(0, 0, 0), qp = new Vec3(0, 0, 0), ap = new Vec3(0, 0, 0), n = new Vec3(0, 0, 0), e = new Vec3(0, 0, 0);
        return function(line, triangle, outPt) {
            Vec3.subtract(ab, triangle.b, triangle.a), Vec3.subtract(ac, triangle.c, triangle.a), 
            Vec3.subtract(qp, line.s, line.e), Vec3.cross(n, ab, ac);
            var det = Vec3.dot(qp, n);
            if (det <= 0) return 0;
            Vec3.subtract(ap, line.s, triangle.a);
            var t = Vec3.dot(ap, n);
            if (t < 0 || t > det) return 0;
            Vec3.cross(e, qp, ap);
            var v = Vec3.dot(ac, e);
            if (v < 0 || v > det) return 0;
            var w = -Vec3.dot(ab, e);
            if (w < 0 || v + w > det) return 0;
            if (outPt) {
                var invDet = 1 / det, u = 1 - (v *= invDet) - (w *= invDet);
                Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
            }
            return 1;
        };
    }(), r_t = new ray;
    function line_aabb(line, aabb) {
        r_t.o.set(line.s), Vec3.subtract(r_t.d, line.e, line.s), r_t.d.normalize();
        var min = ray_aabb(r_t, aabb);
        return min <= line.length() ? min : 0;
    }
    function line_obb(line, obb) {
        r_t.o.set(line.s), Vec3.subtract(r_t.d, line.e, line.s), r_t.d.normalize();
        var min = ray_obb(r_t, obb);
        return min <= line.length() ? min : 0;
    }
    function line_sphere(line, sphere) {
        r_t.o.set(line.s), Vec3.subtract(r_t.d, line.e, line.s), r_t.d.normalize();
        var min = ray_sphere(r_t, sphere);
        return min <= line.length() ? min : 0;
    }
    var aMin, aMax, bMin, bMax, aabb_aabb = (aMin = new Vec3, aMax = new Vec3, bMin = new Vec3, 
    bMax = new Vec3, function(aabb1, aabb2) {
        return Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents), Vec3.add(aMax, aabb1.center, aabb1.halfExtents), 
        Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents), Vec3.add(bMax, aabb2.center, aabb2.halfExtents), 
        aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
    });
    function getOBBVertices(c, e, a1, a2, a3, out) {
        Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z), 
        Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z), 
        Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z), 
        Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z), 
        Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z), 
        Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z), 
        Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z), 
        Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
    }
    function getInterval(vertices, axis) {
        for (var min = Vec3.dot(axis, vertices[0]), max = min, i = 1; i < 8; ++i) {
            var projection = Vec3.dot(axis, vertices[i]);
            min = projection < min ? projection : min, max = projection > max ? projection : max;
        }
        return [ min, max ];
    }
    var tmp, m3, absDot, aabb_obb = function() {
        for (var test = new Array(15), i = 0; i < 15; i++) test[i] = new Vec3(0, 0, 0);
        for (var vertices = new Array(8), vertices2 = new Array(8), _i = 0; _i < 8; _i++) vertices[_i] = new Vec3(0, 0, 0), 
        vertices2[_i] = new Vec3(0, 0, 0);
        var min = new Vec3, max = new Vec3;
        return function(aabb, obb) {
            Vec3.set(test[0], 1, 0, 0), Vec3.set(test[1], 0, 1, 0), Vec3.set(test[2], 0, 0, 1), 
            Vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02), 
            Vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05), 
            Vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
            for (var _i2 = 0; _i2 < 3; ++_i2) Vec3.cross(test[6 + 3 * _i2 + 0], test[_i2], test[0]), 
            Vec3.cross(test[6 + 3 * _i2 + 1], test[_i2], test[1]), Vec3.cross(test[6 + 3 * _i2 + 1], test[_i2], test[2]);
            Vec3.subtract(min, aabb.center, aabb.halfExtents), Vec3.add(max, aabb.center, aabb.halfExtents), 
            function getAABBVertices(min, max, out) {
                Vec3.set(out[0], min.x, max.y, max.z), Vec3.set(out[1], min.x, max.y, min.z), Vec3.set(out[2], min.x, min.y, max.z), 
                Vec3.set(out[3], min.x, min.y, min.z), Vec3.set(out[4], max.x, max.y, max.z), Vec3.set(out[5], max.x, max.y, min.z), 
                Vec3.set(out[6], max.x, min.y, max.z), Vec3.set(out[7], max.x, min.y, min.z);
            }(min, max, vertices), getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);
            for (var j = 0; j < 15; ++j) {
                var a = getInterval(vertices, test[j]), b = getInterval(vertices2, test[j]);
                if (b[0] > a[1] || a[0] > b[1]) return 0;
            }
            return 1;
        };
    }(), aabb_plane = function aabb_plane(aabb, plane) {
        var r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z), dot = Vec3.dot(plane.n, aabb.center);
        return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
    }, aabb_frustum = function aabb_frustum(aabb, frustum) {
        for (var i = 0; i < frustum.planes.length; i++) if (-1 === aabb_plane(aabb, frustum.planes[i])) return 0;
        return 1;
    }, aabb_frustum_accurate = function() {
        for (var tmp = new Array(8), out1 = 0, out2 = 0, i = 0; i < tmp.length; i++) tmp[i] = new Vec3(0, 0, 0);
        return function(aabb, frustum) {
            for (var result = 0, intersects = !1, _i3 = 0; _i3 < frustum.planes.length; _i3++) {
                if (-1 === (result = aabb_plane(aabb, frustum.planes[_i3]))) return 0;
                1 === result && (intersects = !0);
            }
            if (!intersects) return 1;
            for (var _i4 = 0; _i4 < frustum.vertices.length; _i4++) Vec3.subtract(tmp[_i4], frustum.vertices[_i4], aabb.center);
            out1 = 0, out2 = 0;
            for (var _i5 = 0; _i5 < frustum.vertices.length; _i5++) tmp[_i5].x > aabb.halfExtents.x ? out1++ : tmp[_i5].x < -aabb.halfExtents.x && out2++;
            if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
            out1 = 0, out2 = 0;
            for (var _i6 = 0; _i6 < frustum.vertices.length; _i6++) tmp[_i6].y > aabb.halfExtents.y ? out1++ : tmp[_i6].y < -aabb.halfExtents.y && out2++;
            if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
            out1 = 0, out2 = 0;
            for (var _i7 = 0; _i7 < frustum.vertices.length; _i7++) tmp[_i7].z > aabb.halfExtents.z ? out1++ : tmp[_i7].z < -aabb.halfExtents.z && out2++;
            return out1 === frustum.vertices.length || out2 === frustum.vertices.length ? 0 : 1;
        };
    }(), obb_point = (tmp = new Vec3(0, 0, 0), m3 = new Mat3, function(obb, point) {
        return Vec3.subtract(tmp, point, obb.center), Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation)), 
        function lessThan(a, b) {
            return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
        }(tmp, obb.halfExtents);
    }), obb_plane = (absDot = function absDot(n, x, y, z) {
        return Math.abs(n.x * x + n.y * y + n.z * z);
    }, function(obb, plane) {
        var r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08), dot = Vec3.dot(plane.n, obb.center);
        return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
    }), obb_frustum = function obb_frustum(obb, frustum) {
        for (var i = 0; i < frustum.planes.length; i++) if (-1 === obb_plane(obb, frustum.planes[i])) return 0;
        return 1;
    }, obb_frustum_accurate = function() {
        for (var tmp = new Array(8), dist = 0, out1 = 0, out2 = 0, i = 0; i < tmp.length; i++) tmp[i] = new Vec3(0, 0, 0);
        var dot = function dot(n, x, y, z) {
            return n.x * x + n.y * y + n.z * z;
        };
        return function(obb, frustum) {
            for (var result = 0, intersects = !1, _i8 = 0; _i8 < frustum.planes.length; _i8++) {
                if (-1 === (result = obb_plane(obb, frustum.planes[_i8]))) return 0;
                1 === result && (intersects = !0);
            }
            if (!intersects) return 1;
            for (var _i9 = 0; _i9 < frustum.vertices.length; _i9++) Vec3.subtract(tmp[_i9], frustum.vertices[_i9], obb.center);
            out1 = 0, out2 = 0;
            for (var _i10 = 0; _i10 < frustum.vertices.length; _i10++) (dist = dot(tmp[_i10], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02)) > obb.halfExtents.x ? out1++ : dist < -obb.halfExtents.x && out2++;
            if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
            out1 = 0, out2 = 0;
            for (var _i11 = 0; _i11 < frustum.vertices.length; _i11++) (dist = dot(tmp[_i11], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05)) > obb.halfExtents.y ? out1++ : dist < -obb.halfExtents.y && out2++;
            if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
            out1 = 0, out2 = 0;
            for (var _i12 = 0; _i12 < frustum.vertices.length; _i12++) (dist = dot(tmp[_i12], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08)) > obb.halfExtents.z ? out1++ : dist < -obb.halfExtents.z && out2++;
            return out1 === frustum.vertices.length || out2 === frustum.vertices.length ? 0 : 1;
        };
    }(), obb_obb = function() {
        for (var test = new Array(15), i = 0; i < 15; i++) test[i] = new Vec3(0, 0, 0);
        for (var vertices = new Array(8), vertices2 = new Array(8), _i13 = 0; _i13 < 8; _i13++) vertices[_i13] = new Vec3(0, 0, 0), 
        vertices2[_i13] = new Vec3(0, 0, 0);
        return function(obb1, obb2) {
            Vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02), 
            Vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05), 
            Vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08), 
            Vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02), 
            Vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05), 
            Vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);
            for (var _i14 = 0; _i14 < 3; ++_i14) Vec3.cross(test[6 + 3 * _i14 + 0], test[_i14], test[0]), 
            Vec3.cross(test[6 + 3 * _i14 + 1], test[_i14], test[1]), Vec3.cross(test[6 + 3 * _i14 + 1], test[_i14], test[2]);
            getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices), 
            getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);
            for (var _i15 = 0; _i15 < 15; ++_i15) {
                var a = getInterval(vertices, test[_i15]), b = getInterval(vertices2, test[_i15]);
                if (b[0] > a[1] || a[0] > b[1]) return 0;
            }
            return 1;
        };
    }(), obb_capsule = function() {
        for (var sphere_0 = new sphere, v3_0 = new Vec3, v3_1 = new Vec3, v3_2 = new Vec3, v3_verts8 = new Array(8), i = 0; i < 8; i++) v3_verts8[i] = new Vec3;
        for (var v3_axis8 = new Array(8), _i16 = 0; _i16 < 8; _i16++) v3_axis8[_i16] = new Vec3;
        return function(obb, capsule) {
            if (0 === Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1)) return sphere_0.radius = capsule.radius, 
            sphere_0.center.set(capsule.ellipseCenter0), intersect.sphere_obb(sphere_0, obb);
            v3_0.x = obb.orientation.m00, v3_0.y = obb.orientation.m01, v3_0.z = obb.orientation.m02, 
            v3_1.x = obb.orientation.m03, v3_1.y = obb.orientation.m04, v3_1.z = obb.orientation.m05, 
            v3_2.x = obb.orientation.m06, v3_2.y = obb.orientation.m07, v3_2.z = obb.orientation.m08, 
            getOBBVertices(obb.center, obb.halfExtents, v3_0, v3_1, v3_2, v3_verts8);
            var axes = v3_axis8, a0 = Vec3.copy(axes[0], v3_0), a1 = Vec3.copy(axes[1], v3_1), a2 = Vec3.copy(axes[2], v3_2);
            Vec3.subtract(axes[3], capsule.center, obb.center).normalize();
            var B = Vec3.subtract(axes[4], capsule.ellipseCenter0, capsule.ellipseCenter1);
            B.normalize(), Vec3.cross(axes[5], a0, B), Vec3.cross(axes[6], a1, B), Vec3.cross(axes[7], a2, B);
            for (var _i17 = 0; _i17 < 8; ++_i17) {
                var a = getInterval(v3_verts8, axes[_i17]), d0 = Vec3.dot(axes[_i17], capsule.ellipseCenter0), d1 = Vec3.dot(axes[_i17], capsule.ellipseCenter1), max_d = Math.max(d0, d1), d_min = Math.min(d0, d1) - capsule.radius, d_max = max_d + capsule.radius;
                if (d_min > a[1] || a[0] > d_max) return 0;
            }
            return 1;
        };
    }(), sphere_plane = function sphere_plane(sphere, plane) {
        var dot = Vec3.dot(plane.n, sphere.center), r = sphere.radius * plane.n.length();
        return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
    }, sphere_frustum = function sphere_frustum(sphere, frustum) {
        for (var i = 0; i < frustum.planes.length; i++) if (-1 === sphere_plane(sphere, frustum.planes[i])) return 0;
        return 1;
    }, sphere_frustum_accurate = function() {
        var pt = new Vec3(0, 0, 0), map = [ 1, -1, 1, -1, 1, -1 ];
        return function(sphere, frustum) {
            for (var i = 0; i < 6; i++) {
                var plane = frustum.planes[i], r = sphere.radius, c = sphere.center, n = plane.n, d = plane.d, dot = Vec3.dot(n, c);
                if (dot + r < d) return 0;
                if (!(dot - r > d)) {
                    Vec3.add(pt, c, Vec3.multiplyScalar(pt, n, r));
                    for (var j = 0; j < 6; j++) if (j !== i && j !== i + map[i]) {
                        var test = frustum.planes[j];
                        if (Vec3.dot(test.n, pt) < test.d) return 0;
                    }
                }
            }
            return 1;
        };
    }(), sphere_sphere = function sphere_sphere(sphere0, sphere1) {
        var r = sphere0.radius + sphere1.radius;
        return Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
    }, sphere_aabb = function() {
        var pt = new Vec3;
        return function(sphere, aabb) {
            return pt_point_aabb(pt, sphere.center, aabb), Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
        };
    }(), sphere_obb = function() {
        var pt = new Vec3;
        return function(sphere, obb) {
            return pt_point_obb(pt, sphere.center, obb), Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
        };
    }(), sphere_capsule = function() {
        var v3_0 = new Vec3, v3_1 = new Vec3;
        return function(sphere, capsule) {
            var r = sphere.radius + capsule.radius, squaredR = r * r, h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);
            if (0 === h) return Vec3.squaredDistance(sphere.center, capsule.center) < squaredR;
            Vec3.subtract(v3_0, sphere.center, capsule.ellipseCenter0), Vec3.subtract(v3_1, capsule.ellipseCenter1, capsule.ellipseCenter0);
            var t = Vec3.dot(v3_0, v3_1) / h;
            return t < 0 ? Vec3.squaredDistance(sphere.center, capsule.ellipseCenter0) < squaredR : t > 1 ? Vec3.squaredDistance(sphere.center, capsule.ellipseCenter1) < squaredR : (Vec3.scaleAndAdd(v3_0, capsule.ellipseCenter0, v3_1, t), 
            Vec3.squaredDistance(sphere.center, v3_0) < squaredR);
        };
    }(), capsule_capsule = function() {
        var v3_0 = new Vec3, v3_1 = new Vec3, v3_2 = new Vec3, v3_3 = new Vec3, v3_4 = new Vec3, v3_5 = new Vec3;
        return function capsule_capsule(capsuleA, capsuleB) {
            var sc, sN, tc, tN, u = Vec3.subtract(v3_0, capsuleA.ellipseCenter1, capsuleA.ellipseCenter0), v = Vec3.subtract(v3_1, capsuleB.ellipseCenter1, capsuleB.ellipseCenter0), w = Vec3.subtract(v3_2, capsuleA.ellipseCenter0, capsuleB.ellipseCenter0), a = Vec3.dot(u, u), b = Vec3.dot(u, v), c = Vec3.dot(v, v), d = Vec3.dot(u, w), e = Vec3.dot(v, w), D = a * c - b * b, sD = D, tD = D;
            D < 1e-6 ? (sN = 0, sD = 1, tN = e, tD = c) : (tN = a * e - b * d, (sN = b * e - c * d) < 0 ? (sN = 0, 
            tN = e, tD = c) : sN > sD && (sN = sD, tN = e + b, tD = c)), tN < 0 ? (tN = 0, -d < 0 ? sN = 0 : -d > a ? sN = sD : (sN = -d, 
            sD = a)) : tN > tD && (tN = tD, -d + b < 0 ? sN = 0 : -d + b > a ? sN = sD : (sN = -d + b, 
            sD = a)), sc = Math.abs(sN) < 1e-6 ? 0 : sN / sD, tc = Math.abs(tN) < 1e-6 ? 0 : tN / tD;
            var dP = v3_3;
            dP.set(w), dP.add(Vec3.multiplyScalar(v3_4, u, sc)), dP.subtract(Vec3.multiplyScalar(v3_5, v, tc));
            var radius = capsuleA.radius + capsuleB.radius;
            return dP.lengthSqr() < radius * radius;
        };
    }(), intersect = {
        ray_sphere: ray_sphere,
        ray_aabb: ray_aabb,
        ray_obb: ray_obb,
        ray_plane: ray_plane,
        ray_triangle: ray_triangle,
        ray_capsule: ray_capsule,
        line_sphere: line_sphere,
        line_aabb: line_aabb,
        line_obb: line_obb,
        line_plane: line_plane,
        line_triangle: line_triangle,
        sphere_sphere: sphere_sphere,
        sphere_aabb: sphere_aabb,
        sphere_obb: sphere_obb,
        sphere_plane: sphere_plane,
        sphere_frustum: sphere_frustum,
        sphere_frustum_accurate: sphere_frustum_accurate,
        sphere_capsule: sphere_capsule,
        aabb_aabb: aabb_aabb,
        aabb_obb: aabb_obb,
        aabb_plane: aabb_plane,
        aabb_frustum: aabb_frustum,
        aabb_frustum_accurate: aabb_frustum_accurate,
        obb_obb: obb_obb,
        obb_plane: obb_plane,
        obb_frustum: obb_frustum,
        obb_frustum_accurate: obb_frustum_accurate,
        obb_point: obb_point,
        obb_capsule: obb_capsule,
        capsule_capsule: capsule_capsule,
        resolve: function resolve(g1, g2) {
            var outPt = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, type1 = g1._type, type2 = g2._type, resolver = this[type1 | type2];
            return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
        }
    };
    intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = ray_sphere, intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = ray_aabb, 
    intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = ray_obb, intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = ray_plane, 
    intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = ray_triangle, intersect[enums.SHAPE_RAY | enums.SHAPE_CAPSULE] = ray_capsule, 
    intersect[enums.SHAPE_LINE | enums.SHAPE_SPHERE] = line_sphere, intersect[enums.SHAPE_LINE | enums.SHAPE_AABB] = line_aabb, 
    intersect[enums.SHAPE_LINE | enums.SHAPE_OBB] = line_obb, intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = line_plane, 
    intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = line_triangle, intersect[enums.SHAPE_SPHERE] = sphere_sphere, 
    intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphere_aabb, intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphere_obb, 
    intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = sphere_plane, intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphere_frustum, 
    intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphere_frustum_accurate, 
    intersect[enums.SHAPE_SPHERE | enums.SHAPE_CAPSULE] = sphere_capsule, intersect[enums.SHAPE_AABB] = aabb_aabb, 
    intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabb_obb, intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabb_plane, 
    intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabb_frustum, intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabb_frustum_accurate, 
    intersect[enums.SHAPE_OBB] = obb_obb, intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obb_plane, 
    intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obb_frustum, intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obb_frustum_accurate, 
    intersect[enums.SHAPE_OBB | enums.SHAPE_CAPSULE] = obb_capsule, intersect[enums.SHAPE_CAPSULE] = capsule_capsule;
    var line = function() {
        function line() {
            var sx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, sy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, sz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, ex = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, ey = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, ez = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : -1;
            _classCallCheck(this, line), this._type = enums.SHAPE_LINE, this.s = new Vec3(sx, sy, sz), 
            this.e = new Vec3(ex, ey, ez);
        }
        return _createClass(line, null, [ {
            key: "create",
            value: function create(sx, sy, sz, ex, ey, ez) {
                return new line(sx, sy, sz, ex, ey, ez);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return Vec3.copy(out.s, a.s), Vec3.copy(out.e, a.e), out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, start, end) {
                return Vec3.copy(out.s, start), Vec3.copy(out.e, end), out;
            }
        }, {
            key: "set",
            value: function set(out, sx, sy, sz, ex, ey, ez) {
                return out.s.x = sx, out.s.y = sy, out.s.z = sz, out.e.x = ex, out.e.y = ey, out.e.z = ez, 
                out;
            }
        }, {
            key: "len",
            value: function len(a) {
                return Vec3.distance(a.s, a.e);
            }
        } ]), _createClass(line, [ {
            key: "length",
            value: function length() {
                return Vec3.distance(this.s, this.e);
            }
        } ]), line;
    }(), v1 = new Vec3(0, 0, 0), v2$1 = new Vec3(0, 0, 0), temp_mat = cc.mat4(), temp_vec4 = cc.v4(), plane = function() {
        function plane() {
            var nx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, ny = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, nz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, d = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            _classCallCheck(this, plane), this._type = enums.SHAPE_PLANE, this.n = new Vec3(nx, ny, nz), 
            this.d = d;
        }
        return _createClass(plane, null, [ {
            key: "create",
            value: function create(nx, ny, nz, d) {
                return new plane(nx, ny, nz, d);
            }
        }, {
            key: "clone",
            value: function clone(p) {
                return new plane(p.n.x, p.n.y, p.n.z, p.d);
            }
        }, {
            key: "copy",
            value: function copy(out, p) {
                return Vec3.copy(out.n, p.n), out.d = p.d, out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, a, b, c) {
                return Vec3.subtract(v1, b, a), Vec3.subtract(v2$1, c, a), Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2$1)), 
                out.d = Vec3.dot(out.n, a), out;
            }
        }, {
            key: "set",
            value: function set(out, nx, ny, nz, d) {
                return out.n.x = nx, out.n.y = ny, out.n.z = nz, out.d = d, out;
            }
        }, {
            key: "fromNormalAndPoint",
            value: function fromNormalAndPoint(out, normal, point) {
                return Vec3.copy(out.n, normal), out.d = Vec3.dot(normal, point), out;
            }
        }, {
            key: "normalize",
            value: function normalize(out, a) {
                var len = a.n.length();
                return Vec3.normalize(out.n, a.n), len > 0 && (out.d = a.d / len), out;
            }
        } ]), _createClass(plane, [ {
            key: "transform",
            value: function transform(mat) {
                Mat4.invert(temp_mat, mat), Mat4.transpose(temp_mat, temp_mat), Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, this.d), 
                Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat), Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z), 
                this.d = temp_vec4.w;
            }
        } ]), plane;
    }(), triangle = function() {
        function triangle() {
            var ax = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, ay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, az = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, bx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, by = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, bz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, cx = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, cy = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 1, cz = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0;
            _classCallCheck(this, triangle), this._type = enums.SHAPE_TRIANGLE, this.a = new Vec3(ax, ay, az), 
            this.b = new Vec3(bx, by, bz), this.c = new Vec3(cx, cy, cz);
        }
        return _createClass(triangle, null, [ {
            key: "create",
            value: function create() {
                var ax = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, ay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, az = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, bx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, by = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, bz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, cx = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, cy = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, cz = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1;
                return new triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
            }
        }, {
            key: "clone",
            value: function clone(t) {
                return new triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
            }
        }, {
            key: "copy",
            value: function copy(out, t) {
                return Vec3.copy(out.a, t.a), Vec3.copy(out.b, t.b), Vec3.copy(out.c, t.c), out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, a, b, c) {
                return Vec3.copy(out.a, a), Vec3.copy(out.b, b), Vec3.copy(out.c, c), out;
            }
        }, {
            key: "set",
            value: function set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
                return out.a.x = ax, out.a.y = ay, out.a.z = az, out.b.x = bx, out.b.y = by, out.b.z = bz, 
                out.c.x = cx, out.c.y = cy, out.c.z = cz, out;
            }
        } ]), triangle;
    }(), _v3_tmp$1 = new Vec3, _v3_tmp2 = new Vec3, _v3_tmp3 = new Vec3, _v3_tmp4 = new Vec3, _m3_tmp = new Mat3, transform_extent_m4 = function transform_extent_m4(out, extent, m4) {
        _m3_tmp.m00 = Math.abs(m4.m00), _m3_tmp.m01 = Math.abs(m4.m01), _m3_tmp.m02 = Math.abs(m4.m02), 
        _m3_tmp.m03 = Math.abs(m4.m04), _m3_tmp.m04 = Math.abs(m4.m05), _m3_tmp.m05 = Math.abs(m4.m06), 
        _m3_tmp.m06 = Math.abs(m4.m08), _m3_tmp.m07 = Math.abs(m4.m09), _m3_tmp.m08 = Math.abs(m4.m10), 
        Vec3.transformMat3(out, extent, _m3_tmp);
    }, aabb = function() {
        function aabb() {
            var px = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, py = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, pz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, hw = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, hh = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, hl = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
            _classCallCheck(this, aabb), this._type = enums.SHAPE_AABB, this.center = new Vec3(px, py, pz), 
            this.halfExtents = new Vec3(hw, hh, hl);
        }
        return _createClass(aabb, [ {
            key: "type",
            get: function get() {
                return this._type;
            }
        } ], [ {
            key: "create",
            value: function create(px, py, pz, hw, hh, hl) {
                return new aabb(px, py, pz, hw, hh, hl);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new aabb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return Vec3.copy(out.center, a.center), Vec3.copy(out.halfExtents, a.halfExtents), 
                out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, minPos, maxPos) {
                return Vec3.add(_v3_tmp$1, maxPos, minPos), Vec3.subtract(_v3_tmp2, maxPos, minPos), 
                Vec3.multiplyScalar(out.center, _v3_tmp$1, .5), Vec3.multiplyScalar(out.halfExtents, _v3_tmp2, .5), 
                out;
            }
        }, {
            key: "set",
            value: function set(out, px, py, pz, hw, hh, hl) {
                return Vec3.set(out.center, px, py, pz), Vec3.set(out.halfExtents, hw, hh, hl), 
                out;
            }
        }, {
            key: "merge",
            value: function merge(out, a, b) {
                return Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents), Vec3.subtract(_v3_tmp2, b.center, b.halfExtents), 
                Vec3.add(_v3_tmp3, a.center, a.halfExtents), Vec3.add(_v3_tmp4, b.center, b.halfExtents), 
                Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4), Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2), 
                aabb.fromPoints(out, _v3_tmp3, _v3_tmp4);
            }
        }, {
            key: "transform",
            value: function transform(out, a, matrix) {
                return Vec3.transformMat4(out.center, a.center, matrix), transform_extent_m4(out.halfExtents, a.halfExtents, matrix), 
                out;
            }
        } ]), _createClass(aabb, [ {
            key: "getBoundary",
            value: function getBoundary(minPos, maxPos) {
                Vec3.subtract(minPos, this.center, this.halfExtents), Vec3.add(maxPos, this.center, this.halfExtents);
            }
        }, {
            key: "transform",
            value: function transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m), transform_extent_m4(out.halfExtents, this.halfExtents, m);
            }
        }, {
            key: "clone",
            value: function clone() {
                return aabb.clone(this);
            }
        }, {
            key: "copy",
            value: function copy(a) {
                return aabb.copy(this, a);
            }
        } ]), aabb;
    }(), _v3_tmp$2 = new Vec3, _v3_tmp2$1 = new Vec3, _m3_tmp$1 = new Mat3, obb = function() {
        function obb() {
            var cx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, cy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, cz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, hw = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, hh = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, hl = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, ox_1 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, ox_2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, ox_3 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, oy_1 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, oy_2 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1, oy_3 = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0, oz_1 = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0, oz_2 = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0, oz_3 = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 1;
            _classCallCheck(this, obb), this._type = enums.SHAPE_OBB, this.center = new Vec3(cx, cy, cz), 
            this.halfExtents = new Vec3(hw, hh, hl), this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
        }
        return _createClass(obb, [ {
            key: "type",
            get: function get() {
                return this._type;
            }
        } ], [ {
            key: "create",
            value: function create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                return new obb(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new obb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return Vec3.copy(out.center, a.center), Vec3.copy(out.halfExtents, a.halfExtents), 
                Mat3.copy(out.orientation, a.orientation), out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, minPos, maxPos) {
                return Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), .5), 
                Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2$1, maxPos, minPos), .5), 
                Mat3.identity(out.orientation), out;
            }
        }, {
            key: "set",
            value: function set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                return Vec3.set(out.center, cx, cy, cz), Vec3.set(out.halfExtents, hw, hh, hl), 
                Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3), 
                out;
            }
        } ]), _createClass(obb, [ {
            key: "getBoundary",
            value: function getBoundary(minPos, maxPos) {
                !function transform_extent_m3(out, extent, m3) {
                    _m3_tmp$1.m00 = Math.abs(m3.m00), _m3_tmp$1.m01 = Math.abs(m3.m01), _m3_tmp$1.m02 = Math.abs(m3.m02), 
                    _m3_tmp$1.m03 = Math.abs(m3.m03), _m3_tmp$1.m04 = Math.abs(m3.m04), _m3_tmp$1.m05 = Math.abs(m3.m05), 
                    _m3_tmp$1.m06 = Math.abs(m3.m06), _m3_tmp$1.m07 = Math.abs(m3.m07), _m3_tmp$1.m08 = Math.abs(m3.m08), 
                    Vec3.transformMat3(out, extent, _m3_tmp$1);
                }(_v3_tmp$2, this.halfExtents, this.orientation), Vec3.subtract(minPos, this.center, _v3_tmp$2), 
                Vec3.add(maxPos, this.center, _v3_tmp$2);
            }
        }, {
            key: "transform",
            value: function transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m), Mat3.fromQuat(out.orientation, rot), 
                Vec3.multiply(out.halfExtents, this.halfExtents, scale);
            }
        }, {
            key: "translateAndRotate",
            value: function translateAndRotate(m, rot, out) {
                Vec3.transformMat4(out.center, this.center, m), Mat3.fromQuat(out.orientation, rot);
            }
        }, {
            key: "setScale",
            value: function setScale(scale, out) {
                Vec3.multiply(out.halfExtents, this.halfExtents, scale);
            }
        } ]), obb;
    }(), capsule = function() {
        function capsule() {
            var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, halfHeight = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .5, axis = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            _classCallCheck(this, capsule), this._type = enums.SHAPE_CAPSULE, this.radius = radius, 
            this.halfHeight = halfHeight, this.axis = axis, this.center = new Vec3, this.rotation = new Quat, 
            this.ellipseCenter0 = new Vec3(0, halfHeight, 0), this.ellipseCenter1 = new Vec3(0, -halfHeight, 0), 
            this.updateCache();
        }
        return _createClass(capsule, [ {
            key: "transform",
            value: function transform(m, pos, rot, scale, out) {
                var ws = scale, s = absMaxComponent(ws);
                out.radius = this.radius * Math.abs(s);
                var halfWorldHeight = (this.halfHeight + this.radius) * Math.abs(ws.y) - out.radius;
                halfWorldHeight < 0 && (halfWorldHeight = 0), out.halfHeight = halfWorldHeight, 
                Vec3.transformMat4(out.center, this.center, m), Quat.multiply(out.rotation, this.rotation, rot), 
                out.updateCache();
            }
        }, {
            key: "updateCache",
            value: function updateCache() {
                this.updateLocalCenter(), Vec3.transformQuat(this.ellipseCenter0, this.ellipseCenter0, this.rotation), 
                Vec3.transformQuat(this.ellipseCenter1, this.ellipseCenter1, this.rotation), this.ellipseCenter0.add(this.center), 
                this.ellipseCenter1.add(this.center);
            }
        }, {
            key: "updateLocalCenter",
            value: function updateLocalCenter() {
                var halfHeight = this.halfHeight;
                switch (this.axis) {
                  case 0:
                    this.ellipseCenter0.set(halfHeight, 0, 0), this.ellipseCenter1.set(-halfHeight, 0, 0);
                    break;

                  case 1:
                    this.ellipseCenter0.set(0, halfHeight, 0), this.ellipseCenter1.set(0, -halfHeight, 0);
                    break;

                  case 2:
                    this.ellipseCenter0.set(0, 0, halfHeight), this.ellipseCenter1.set(0, 0, -halfHeight);
                }
            }
        } ]), capsule;
    }(), _v = new Array(8);
    _v[0] = new Vec3(1, 1, 1), _v[1] = new Vec3(-1, 1, 1), _v[2] = new Vec3(-1, -1, 1), 
    _v[3] = new Vec3(1, -1, 1), _v[4] = new Vec3(1, 1, -1), _v[5] = new Vec3(-1, 1, -1), 
    _v[6] = new Vec3(-1, -1, -1), _v[7] = new Vec3(1, -1, -1);
    var frustum = function() {
        function frustum() {
            _classCallCheck(this, frustum), this._type = enums.SHAPE_FRUSTUM, this.planes = new Array(6);
            for (var i = 0; i < 6; ++i) this.planes[i] = plane.create(0, 0, 0, 0);
            this.vertices = new Array(8);
            for (var _i2 = 0; _i2 < 8; ++_i2) this.vertices[_i2] = new Vec3;
        }
        return _createClass(frustum, [ {
            key: "accurate",
            set: function set(b) {
                this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
            }
        } ], [ {
            key: "create",
            value: function create() {
                return new frustum;
            }
        }, {
            key: "clone",
            value: function clone(f) {
                return frustum.copy(new frustum, f);
            }
        }, {
            key: "copy",
            value: function copy(out, f) {
                out._type = f._type;
                for (var i = 0; i < 6; ++i) plane.copy(out.planes[i], f.planes[i]);
                for (var _i = 0; _i < 8; ++_i) Vec3.copy(out.vertices[_i], f.vertices[_i]);
                return out;
            }
        } ]), _createClass(frustum, [ {
            key: "update",
            value: function update(m, inv) {
                if (Vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08), this.planes[0].d = -(m.m15 + m.m12), 
                Vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08), this.planes[1].d = -(m.m15 - m.m12), 
                Vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09), this.planes[2].d = -(m.m15 + m.m13), 
                Vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09), this.planes[3].d = -(m.m15 - m.m13), 
                Vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10), this.planes[4].d = -(m.m15 + m.m14), 
                Vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10), this.planes[5].d = -(m.m15 - m.m14), 
                this._type === enums.SHAPE_FRUSTUM_ACCURATE) {
                    for (var i = 0; i < 6; i++) {
                        var pl = this.planes[i], invDist = 1 / pl.n.length();
                        Vec3.multiplyScalar(pl.n, pl.n, invDist), pl.d *= invDist;
                    }
                    for (var _i3 = 0; _i3 < 8; _i3++) Vec3.transformMat4(this.vertices[_i3], _v[_i3], inv);
                }
            }
        }, {
            key: "transform",
            value: function transform(mat) {
                if (this._type === enums.SHAPE_FRUSTUM_ACCURATE) {
                    for (var i = 0; i < 8; i++) Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
                    plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[5], this.vertices[6]), 
                    plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[7], this.vertices[4]), 
                    plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[7], this.vertices[3]), 
                    plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[4], this.vertices[5]), 
                    plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[3], this.vertices[0]), 
                    plane.fromPoints(this.planes[0], this.vertices[7], this.vertices[6], this.vertices[5]);
                }
            }
        } ]), frustum;
    }();
    frustum.createOrtho = function() {
        var _temp_v3 = new Vec3;
        return function(out, width, height, near, far, transform) {
            var halfWidth = width / 2, halfHeight = height / 2;
            Vec3.set(_temp_v3, halfWidth, halfHeight, near), Vec3.transformMat4(out.vertices[0], _temp_v3, transform), 
            Vec3.set(_temp_v3, -halfWidth, halfHeight, near), Vec3.transformMat4(out.vertices[1], _temp_v3, transform), 
            Vec3.set(_temp_v3, -halfWidth, -halfHeight, near), Vec3.transformMat4(out.vertices[2], _temp_v3, transform), 
            Vec3.set(_temp_v3, halfWidth, -halfHeight, near), Vec3.transformMat4(out.vertices[3], _temp_v3, transform), 
            Vec3.set(_temp_v3, halfWidth, halfHeight, far), Vec3.transformMat4(out.vertices[4], _temp_v3, transform), 
            Vec3.set(_temp_v3, -halfWidth, halfHeight, far), Vec3.transformMat4(out.vertices[5], _temp_v3, transform), 
            Vec3.set(_temp_v3, -halfWidth, -halfHeight, far), Vec3.transformMat4(out.vertices[6], _temp_v3, transform), 
            Vec3.set(_temp_v3, halfWidth, -halfHeight, far), Vec3.transformMat4(out.vertices[7], _temp_v3, transform), 
            plane.fromPoints(out.planes[0], out.vertices[1], out.vertices[6], out.vertices[5]), 
            plane.fromPoints(out.planes[1], out.vertices[3], out.vertices[4], out.vertices[7]), 
            plane.fromPoints(out.planes[2], out.vertices[6], out.vertices[3], out.vertices[7]), 
            plane.fromPoints(out.planes[3], out.vertices[0], out.vertices[5], out.vertices[4]), 
            plane.fromPoints(out.planes[4], out.vertices[2], out.vertices[0], out.vertices[3]), 
            plane.fromPoints(out.planes[0], out.vertices[7], out.vertices[5], out.vertices[6]);
        };
    }();
    var WrapMode = Enum({
        Default: 0,
        Once: 1,
        Loop: 2,
        PingPong: 3,
        ClampForever: 4
    }), Keyframe = function Keyframe() {
        _classCallCheck(this, Keyframe), this.time = 0, this.value = 0, this.inTangent = 0, 
        this.outTangent = 0;
    };
    CCClass.fastDefine("cc.Keyframe", Keyframe, {
        time: 0,
        value: 0,
        inTangent: 0,
        outTangent: 0
    });
    var OptimizedKey = function() {
        function OptimizedKey() {
            _classCallCheck(this, OptimizedKey), this.index = -1, this.time = 0, this.endTime = 0, 
            this.coefficient = new Float32Array(4);
        }
        return _createClass(OptimizedKey, [ {
            key: "evaluate",
            value: function evaluate(T) {
                return function evalOptCurve(t, coefs) {
                    return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
                }(T - this.time, this.coefficient);
            }
        } ]), OptimizedKey;
    }();
    var AnimationCurve = function() {
        function AnimationCurve() {
            var keyFrames = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            _classCallCheck(this, AnimationCurve), this.preWrapMode = WrapMode.Loop, this.postWrapMode = WrapMode.Loop, 
            this.keyFrames = keyFrames || [].concat(AnimationCurve.defaultKF), this.cachedKey = new OptimizedKey;
        }
        return _createClass(AnimationCurve, [ {
            key: "addKey",
            value: function addKey(keyFrame) {
                null == this.keyFrames && (this.keyFrames = []), this.keyFrames.push(keyFrame);
            }
        }, {
            key: "evaluate_slow",
            value: function evaluate_slow(time) {
                var wrappedTime = time, wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode, startTime = this.keyFrames[0].time, endTime = this.keyFrames[this.keyFrames.length - 1].time;
                switch (wrapMode) {
                  case WrapMode.Loop:
                    wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                    break;

                  case WrapMode.PingPong:
                    wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                    break;

                  case WrapMode.ClampForever:
                    wrappedTime = clamp(time, startTime, endTime);
                }
                var preKFIndex = 0;
                if (wrappedTime > this.keyFrames[0].time) if (wrappedTime >= this.keyFrames[this.keyFrames.length - 1].time) preKFIndex = this.keyFrames.length - 2; else for (var i = 0; i < this.keyFrames.length - 1; i++) if (wrappedTime >= this.keyFrames[0].time && wrappedTime <= this.keyFrames[i + 1].time) {
                    preKFIndex = i;
                    break;
                }
                var keyframe0 = this.keyFrames[preKFIndex], keyframe1 = this.keyFrames[preKFIndex + 1], t = inverseLerp(keyframe0.time, keyframe1.time, wrappedTime), dt = keyframe1.time - keyframe0.time, m0 = keyframe0.outTangent * dt, m1 = keyframe1.inTangent * dt, t2 = t * t, t3 = t2 * t, b = t3 - 2 * t2 + t, c = t3 - t2, d = -2 * t3 + 3 * t2;
                return (2 * t3 - 3 * t2 + 1) * keyframe0.value + b * m0 + c * m1 + d * keyframe1.value;
            }
        }, {
            key: "evaluate",
            value: function evaluate(time) {
                var wrappedTime = time, wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode, startTime = this.keyFrames[0].time, endTime = this.keyFrames[this.keyFrames.length - 1].time;
                switch (wrapMode) {
                  case WrapMode.Loop:
                    wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                    break;

                  case WrapMode.PingPong:
                    wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                    break;

                  case WrapMode.ClampForever:
                    wrappedTime = clamp(time, startTime, endTime);
                }
                if (wrappedTime >= this.cachedKey.time && wrappedTime < this.cachedKey.endTime) return this.cachedKey.evaluate(wrappedTime);
                var leftIndex = this.findIndex(this.cachedKey, wrappedTime), rightIndex = leftIndex + 1;
                return rightIndex === this.keyFrames.length && (rightIndex -= 1), this.calcOptimizedKey(this.cachedKey, leftIndex, rightIndex), 
                this.cachedKey.evaluate(wrappedTime);
            }
        }, {
            key: "calcOptimizedKey",
            value: function calcOptimizedKey(optKey, leftIndex, rightIndex) {
                var lhs = this.keyFrames[leftIndex], rhs = this.keyFrames[rightIndex];
                optKey.index = leftIndex, optKey.time = lhs.time, optKey.endTime = rhs.time;
                var dx = rhs.time - lhs.time, dy = rhs.value - lhs.value, length = 1 / (dx * dx), d1 = lhs.outTangent * dx, d2 = rhs.inTangent * dx;
                optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx, optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length, 
                optKey.coefficient[2] = lhs.outTangent, optKey.coefficient[3] = lhs.value;
            }
        }, {
            key: "findIndex",
            value: function findIndex(optKey, t) {
                var cachedIndex = optKey.index;
                if (-1 !== cachedIndex) if (t > this.keyFrames[cachedIndex].time) for (var i = 0; i < 3; i++) {
                    var currIndex = cachedIndex + i;
                    if (currIndex + 1 < this.keyFrames.length && this.keyFrames[currIndex + 1].time > t) return currIndex;
                } else for (var _i = 0; _i < 3; _i++) {
                    var _currIndex = cachedIndex - _i;
                    if (_currIndex >= 0 && this.keyFrames[_currIndex - 1].time <= t) return _currIndex - 1;
                }
                for (var left = 0, right = this.keyFrames.length, mid = Math.floor((left + right) / 2); right - left > 1; ) this.keyFrames[mid].time >= t ? right = mid : left = mid + 1, 
                mid = Math.floor((left + right) / 2);
                return left;
            }
        } ]), AnimationCurve;
    }();
    AnimationCurve.defaultKF = [ {
        time: 0,
        value: 1,
        inTangent: 0,
        outTangent: 0
    }, {
        time: 1,
        value: 1,
        inTangent: 0,
        outTangent: 0
    } ], CCClass.fastDefine("cc.AnimationCurve", AnimationCurve, {
        preWrapMode: WrapMode.Default,
        postWrapMode: WrapMode.Default,
        keyFrames: []
    }), exports.replaceProperty(line.prototype, "line", [ {
        name: "mag",
        newName: "len"
    }, {
        name: "magnitude",
        newName: "len"
    } ]), exports.removeProperty(intersect, "intersect", [ {
        name: "line_quad"
    } ]);
    var geometry = Object.freeze({
        __proto__: null,
        distance: distance,
        enums: enums,
        intersect: intersect,
        line: line,
        plane: plane,
        ray: ray,
        triangle: triangle,
        sphere: sphere,
        aabb: aabb,
        obb: obb,
        capsule: capsule,
        frustum: frustum,
        Keyframe: Keyframe,
        AnimationCurve: AnimationCurve
    }), Pool$1 = function() {
        function Pool(fn, size) {
            _classCallCheck(this, Pool), this._fn = fn, this._idx = size - 1, this._frees = new Array(size);
            for (var i = 0; i < size; ++i) this._frees[i] = fn();
        }
        return _createClass(Pool, [ {
            key: "alloc",
            value: function alloc() {
                this._idx < 0 && this._expand(Math.round(1.2 * this._frees.length) + 1);
                var ret = this._frees[this._idx];
                return this._frees.splice(this._idx), --this._idx, ret;
            }
        }, {
            key: "free",
            value: function free(obj) {
                ++this._idx, this._frees[this._idx] = obj;
            }
        }, {
            key: "clear",
            value: function clear(fn) {
                for (var i = 0; i <= this._idx; i++) fn && fn(this._frees[i]);
                this._frees.splice(0), this._idx = -1;
            }
        }, {
            key: "_expand",
            value: function _expand(size) {
                var old = this._frees;
                this._frees = new Array(size);
                for (var len = size - old.length, i = 0; i < len; ++i) this._frees[i] = this._fn();
                for (var _i = len, j = 0; _i < size; ++_i, ++j) this._frees[_i] = old[j];
                this._idx += len;
            }
        } ]), Pool;
    }(), RecyclePool = function() {
        function RecyclePool(fn, size) {
            _classCallCheck(this, RecyclePool), this._count = 0, this._fn = fn, this._data = new Array(size);
            for (var i = 0; i < size; ++i) this._data[i] = fn();
        }
        return _createClass(RecyclePool, [ {
            key: "reset",
            value: function reset() {
                this._count = 0;
            }
        }, {
            key: "resize",
            value: function resize(size) {
                if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this._data[i] = this._fn();
            }
        }, {
            key: "add",
            value: function add() {
                return this._count >= this._data.length && this.resize(2 * this._data.length), this._data[this._count++];
            }
        }, {
            key: "removeAt",
            value: function removeAt(idx) {
                if (!(idx >= this._count)) {
                    var last = this._count - 1, tmp = this._data[idx];
                    this._data[idx] = this._data[last], this._data[last] = tmp, this._count -= 1;
                }
            }
        }, {
            key: "length",
            get: function get() {
                return this._count;
            }
        }, {
            key: "data",
            get: function get() {
                return this._data;
            }
        } ]), RecyclePool;
    }(), CachedArray = function() {
        function CachedArray(length, compareFn) {
            _classCallCheck(this, CachedArray), this.length = 0, this.array = new Array(length), 
            this.length = 0, this._compareFn = void 0 !== compareFn ? compareFn : function(a, b) {
                return a - b;
            };
        }
        return _createClass(CachedArray, [ {
            key: "push",
            value: function push(item) {
                this.array[this.length++] = item;
            }
        }, {
            key: "pop",
            value: function pop() {
                return this.array[--this.length];
            }
        }, {
            key: "get",
            value: function get(idx) {
                return this.array[idx];
            }
        }, {
            key: "clear",
            value: function clear() {
                this.length = 0;
            }
        }, {
            key: "sort",
            value: function sort() {
                this.array.length = this.length, this.array.sort(this._compareFn);
            }
        }, {
            key: "concat",
            value: function concat(array) {
                for (var i = 0; i < array.length; ++i) this.array[this.length++] = array[i];
            }
        }, {
            key: "fastRemove",
            value: function fastRemove(idx) {
                if (!(idx >= this.length || idx < 0)) {
                    var last = --this.length;
                    this.array[idx] = this.array[last];
                }
            }
        }, {
            key: "indexOf",
            value: function indexOf(val) {
                return this.array.indexOf(val);
            }
        } ]), CachedArray;
    }(), index = Object.freeze({
        __proto__: null,
        Pool: Pool$1,
        RecyclePool: RecyclePool,
        CachedArray: CachedArray
    }), WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûа-яА-ЯЁё]+|\S)/, SYMBOL_REG = /^[!,.:;'}\]%\?>、‘“》？。，！]/, LAST_WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]+|\S)$/, LAST_ENGLISH_REG = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]+$/, FIRST_ENGLISH_REG = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]/;
    function isUnicodeCJK(ch) {
        return /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/.test(ch) || /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g.test(ch) || /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/.test(ch);
    }
    function isUnicodeSpace(ch) {
        var chCode = ch.charCodeAt(0);
        return chCode >= 9 && chCode <= 13 || 32 === chCode || 133 === chCode || 160 === chCode || 5760 === chCode || chCode >= 8192 && chCode <= 8202 || 8232 === chCode || 8233 === chCode || 8239 === chCode || 8287 === chCode || 12288 === chCode;
    }
    function safeMeasureText(ctx, string) {
        var metric = ctx.measureText(string);
        return metric && metric.width || 0;
    }
    function fragmentText(stringToken, allWidth, maxWidth, measureText) {
        var wrappedWords = [];
        if (0 === stringToken.length || maxWidth < 0) return wrappedWords.push(""), wrappedWords;
        for (var text = stringToken; allWidth > maxWidth && text.length > 1; ) {
            for (var fuzzyLen = text.length * (maxWidth / allWidth) | 0, tmpText = text.substr(fuzzyLen), width = allWidth - measureText(tmpText), sLine = tmpText, pushNum = 0, checkWhile = 0; width > maxWidth && checkWhile++ < 10; ) fuzzyLen *= maxWidth / width, 
            fuzzyLen |= 0, width = allWidth - measureText(tmpText = text.substr(fuzzyLen));
            for (checkWhile = 0; width <= maxWidth && checkWhile++ < 10; ) {
                if (tmpText) {
                    var exec = WORD_REG.exec(tmpText);
                    pushNum = exec ? exec[0].length : 1, sLine = tmpText;
                }
                fuzzyLen += pushNum, width = allWidth - measureText(tmpText = text.substr(fuzzyLen));
            }
            0 === (fuzzyLen -= pushNum) && (fuzzyLen = 1, sLine = sLine.substr(1));
            var sText = text.substr(0, fuzzyLen), result = void 0;
            SYMBOL_REG.test(sLine || tmpText) && (0 === (fuzzyLen -= (result = LAST_WORD_REG.exec(sText)) ? result[0].length : 0) && (fuzzyLen = 1), 
            sLine = text.substr(fuzzyLen), sText = text.substr(0, fuzzyLen)), FIRST_ENGLISH_REG.test(sLine) && (result = LAST_ENGLISH_REG.exec(sText)) && sText !== result[0] && (fuzzyLen -= result[0].length, 
            sLine = text.substr(fuzzyLen), sText = text.substr(0, fuzzyLen)), 0 === wrappedWords.length ? wrappedWords.push(sText) : (sText = sText.trim()).length > 0 && wrappedWords.push(sText), 
            allWidth = measureText(text = sLine || tmpText);
        }
        return 0 === wrappedWords.length ? wrappedWords.push(text) : (text = text.trim()).length > 0 && wrappedWords.push(text), 
        wrappedWords;
    }
    var eventRegx = /^(click)(\s)*=|(param)(\s)*=/, imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/, HtmlTextParser = function() {
        function HtmlTextParser() {
            _classCallCheck(this, HtmlTextParser), this._specialSymbolArray = [], this._stack = [], 
            this._resultObjectArray = [], this._specialSymbolArray.push([ /&lt;/g, "<" ]), this._specialSymbolArray.push([ /&gt;/g, ">" ]), 
            this._specialSymbolArray.push([ /&amp;/g, "&" ]), this._specialSymbolArray.push([ /&quot;/g, '"' ]), 
            this._specialSymbolArray.push([ /&apos;/g, "'" ]);
        }
        return _createClass(HtmlTextParser, [ {
            key: "parse",
            value: function parse(htmlString) {
                this._resultObjectArray.length = 0, this._stack.length = 0;
                for (var startIndex = 0, length = htmlString.length; startIndex < length; ) {
                    var tagBeginIndex = htmlString.indexOf("<", startIndex);
                    if (tagBeginIndex < 0) this._stack.pop(), this._processResult(htmlString.substring(startIndex)), 
                    startIndex = length; else {
                        this._processResult(htmlString.substring(startIndex, tagBeginIndex));
                        var tagEndIndex = htmlString.indexOf(">", startIndex);
                        -1 === tagEndIndex ? tagEndIndex = tagBeginIndex : "/" === htmlString.charAt(tagBeginIndex + 1) ? this._stack.pop() : this._addToStack(htmlString.substring(tagBeginIndex + 1, tagEndIndex)), 
                        startIndex = tagEndIndex + 1;
                    }
                }
                return this._resultObjectArray;
            }
        }, {
            key: "_attributeToObject",
            value: function _attributeToObject(attribute) {
                var obj = {}, header = (attribute = attribute.trim()).match(/^(color|size)(\s)*=/), tagName = "", nextSpace = 0, eventHanlderString = "";
                if (header) {
                    if (tagName = header[0], "" === (attribute = attribute.substring(tagName.length).trim())) return obj;
                    switch (nextSpace = attribute.indexOf(" "), tagName[0]) {
                      case "c":
                        obj.color = nextSpace > -1 ? attribute.substring(0, nextSpace).trim() : attribute;
                        break;

                      case "s":
                        obj.size = parseInt(attribute);
                    }
                    return nextSpace > -1 && (eventHanlderString = attribute.substring(nextSpace + 1).trim(), 
                    obj.event = this._processEventHandler(eventHanlderString)), obj;
                }
                if ((header = attribute.match(/^(br(\s)*\/)/)) && header[0].length > 0 && (tagName = header[0].trim()).startsWith("br") && "/" === tagName[tagName.length - 1]) return obj.isNewLine = !0, 
                this._resultObjectArray.push({
                    text: "",
                    style: {
                        newline: !0
                    }
                }), obj;
                var remainingArgument = "";
                if ((header = attribute.match(/^(img(\s)*src(\s)*=[^>]+\/)/)) && header[0].length > 0 && (tagName = header[0].trim()).startsWith("img") && "/" === tagName[tagName.length - 1]) {
                    var tagValue;
                    header = attribute.match(imageAttrReg);
                    for (var isValidImageTag = !1; header; ) tagName = (attribute = attribute.substring(attribute.indexOf(header[0]))).substr(0, header[0].length), 
                    tagValue = (nextSpace = (remainingArgument = attribute.substring(tagName.length).trim()).indexOf(" ")) > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument, 
                    tagName = (tagName = tagName.replace(/[^a-zA-Z]/g, "").trim()).toLocaleLowerCase(), 
                    attribute = remainingArgument.substring(nextSpace).trim(), "src" === tagName ? (obj.isImage = !0, 
                    tagValue.endsWith("/") && (tagValue = tagValue.substring(0, tagValue.length - 1)), 
                    0 === tagValue.indexOf("'") ? (isValidImageTag = !0, tagValue = tagValue.substring(1, tagValue.length - 1)) : 0 === tagValue.indexOf('"') && (isValidImageTag = !0, 
                    tagValue = tagValue.substring(1, tagValue.length - 1)), obj.src = tagValue) : "height" === tagName ? obj.imageHeight = parseInt(tagValue) : "width" === tagName ? obj.imageWidth = parseInt(tagValue) : "click" === tagName && (obj.event = this._processEventHandler(tagName + "=" + tagValue)), 
                    obj.event && "param" === tagName && (obj.event[tagName] = tagValue.replace(/^\"|\"$/g, "")), 
                    header = attribute.match(imageAttrReg);
                    return isValidImageTag && obj.isImage && this._resultObjectArray.push({
                        text: "",
                        style: obj
                    }), {};
                }
                if (header = attribute.match(/^(outline(\s)*[^>]*)/)) {
                    var defaultOutlineObject = {
                        color: "#ffffff",
                        width: 1
                    };
                    if (attribute = header[0].substring("outline".length).trim()) {
                        var _tagValue, outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
                        for (header = attribute.match(outlineAttrReg); header; ) tagName = (attribute = attribute.substring(attribute.indexOf(header[0]))).substr(0, header[0].length), 
                        _tagValue = (nextSpace = (remainingArgument = attribute.substring(tagName.length).trim()).indexOf(" ")) > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument, 
                        tagName = (tagName = tagName.replace(/[^a-zA-Z]/g, "").trim()).toLocaleLowerCase(), 
                        attribute = remainingArgument.substring(nextSpace).trim(), "click" === tagName ? obj.event = this._processEventHandler(tagName + "=" + _tagValue) : "color" === tagName ? defaultOutlineObject.color = _tagValue : "width" === tagName && (defaultOutlineObject.width = parseInt(_tagValue)), 
                        obj.event && "param" === tagName && (obj.event[tagName] = _tagValue.replace(/^\"|\"$/g, "")), 
                        header = attribute.match(outlineAttrReg);
                    }
                    obj.outline = defaultOutlineObject;
                }
                if ((header = attribute.match(/^(on|u|b|i)(\s)*/)) && header[0].length > 0) {
                    switch (tagName = header[0], attribute = attribute.substring(tagName.length).trim(), 
                    tagName[0]) {
                      case "u":
                        obj.underline = !0;
                        break;

                      case "i":
                        obj.italic = !0;
                        break;

                      case "b":
                        obj.bold = !0;
                    }
                    if ("" === attribute) return obj;
                    obj.event = this._processEventHandler(attribute);
                }
                return obj;
            }
        }, {
            key: "_processEventHandler",
            value: function _processEventHandler(eventString) {
                for (var index = 0, obj = new Map, eventNames = eventString.match(eventRegx), isValidTag = !1; eventNames; ) {
                    var eventName = eventNames[0], eventValue = "";
                    if (isValidTag = !1, '"' === (eventString = eventString.substring(eventName.length).trim()).charAt(0)) (index = eventString.indexOf('"', 1)) > -1 && (eventValue = eventString.substring(1, index).trim(), 
                    isValidTag = !0), index++; else if ("'" === eventString.charAt(0)) (index = eventString.indexOf("'", 1)) > -1 && (eventValue = eventString.substring(1, index).trim(), 
                    isValidTag = !0), index++; else {
                        var match = eventString.match(/(\S)+/);
                        index = (eventValue = match ? match[0] : "").length;
                    }
                    isValidTag && (obj[eventName = eventName.substring(0, eventName.length - 1).trim()] = eventValue), 
                    eventNames = (eventString = eventString.substring(index).trim()).match(eventRegx);
                }
                return obj;
            }
        }, {
            key: "_addToStack",
            value: function _addToStack(attribute) {
                var obj = this._attributeToObject(attribute);
                if (0 === this._stack.length) this._stack.push(obj); else {
                    if (obj.isNewLine || obj.isImage) return;
                    var previousTagObj = this._stack[this._stack.length - 1];
                    for (var key in previousTagObj) obj[key] || (obj[key] = previousTagObj[key]);
                    this._stack.push(obj);
                }
            }
        }, {
            key: "_processResult",
            value: function _processResult(value) {
                0 !== value.length && (value = this._escapeSpecialSymbol(value), this._stack.length > 0 ? this._resultObjectArray.push({
                    text: value,
                    style: this._stack[this._stack.length - 1]
                }) : this._resultObjectArray.push({
                    text: value
                }));
            }
        }, {
            key: "_escapeSpecialSymbol",
            value: function _escapeSpecialSymbol(str) {
                var _iterator = this._specialSymbolArray, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var symbolArr = _ref, key = symbolArr[0], value = symbolArr[1];
                    str = str.replace(key, value);
                }
                return str;
            }
        } ]), HtmlTextParser;
    }();
    function fNOP(ctor) {
        return ctor;
    }
    function getSubDict(obj, key) {
        return obj[key] || (obj[key] = {});
    }
    function checkCtorArgument(decorate) {
        return function(target) {
            return "function" == typeof target ? decorate(target) : function(ctor) {
                return decorate(ctor, target);
            };
        };
    }
    function _checkNormalArgument(validator_DEV, decorate, decoratorName) {
        return function(target) {
            return function(ctor) {
                return decorate(ctor, target);
            };
        };
    }
    var checkCompArgument = _checkNormalArgument.bind(null, !1);
    function _argumentChecker(type) {
        return _checkNormalArgument.bind(null, !1);
    }
    var checkStringArgument = _argumentChecker(), checkNumberArgument = _argumentChecker();
    function getClassCache(ctor, decoratorName) {
        return getSubDict(ctor, "__ccclassCache__");
    }
    function genProperty(ctor, properties, propName, options, desc, cache) {
        var fullOptions;
        options && (fullOptions = (fullOptions = getFullFormOfProperty(options)) || options);
        var prop = mixin(properties[propName] || {}, fullOptions || {});
        if (desc && (desc.get || desc.set)) {
            desc.get && (prop.get = desc.get), desc.set && (prop.set = desc.set);
        } else {
            var defaultValue;
            0;
            if (desc) desc.initializer && (defaultValue = function getDefaultFromInitializer(initializer) {
                var value;
                try {
                    value = initializer();
                } catch (e) {
                    return initializer;
                }
                return "object" !== _typeof(value) || null === value ? value : initializer;
            }(desc.initializer), !0); else {
                var actualDefaultValues = cache.default || (cache.default = function extractActualDefaultValues(ctor) {
                    var dummyObj;
                    try {
                        dummyObj = new ctor;
                    } catch (e) {
                        return {};
                    }
                    return dummyObj;
                }(ctor));
                actualDefaultValues.hasOwnProperty(propName) && (defaultValue = actualDefaultValues[propName], 
                !0);
            }
            0, prop.default = defaultValue;
        }
        properties[propName] = prop;
    }
    var ccclass = checkCtorArgument((function(ctor, name) {
        var base = getSuper(ctor);
        base === Object && (base = null);
        var proto = {
            name: name,
            extends: base,
            ctor: ctor,
            __ES6__: !0
        }, cache = ctor.__ccclassCache__;
        if (cache) {
            var decoratedProto = cache.proto;
            decoratedProto && mixin(proto, decoratedProto), ctor.__ccclassCache__ = void 0;
        }
        return cc.Class(proto);
    }));
    function property(ctorProtoOrOptions, propName, desc) {
        var options = null;
        function normalized(ctorProto, propName, desc) {
            var cache = getClassCache(ctorProto.constructor);
            if (cache) {
                var ccclassProto = getSubDict(cache, "proto"), properties = getSubDict(ccclassProto, "properties");
                genProperty(ctorProto.constructor, properties, propName, options, desc, cache);
            }
        }
        return void 0 === ctorProtoOrOptions ? property({
            type: void 0
        }) : void 0 === propName ? (options = ctorProtoOrOptions, normalized) : void normalized(ctorProtoOrOptions, propName, desc);
    }
    function createEditorDecorator(argCheckFunc, editorPropName, staticValue) {
        return argCheckFunc((function(ctor, decoratedValue) {
            var cache = getClassCache(ctor);
            if (cache) {
                var value = void 0 !== staticValue ? staticValue : decoratedValue, proto = getSubDict(cache, "proto");
                getSubDict(proto, "editor")[editorPropName] = value;
            }
        }), editorPropName);
    }
    function createDummyDecorator(argCheckFunc) {
        return argCheckFunc(fNOP);
    }
    var executeInEditMode = createDummyDecorator(checkCtorArgument), requireComponent = createEditorDecorator(checkCompArgument, "requireComponent"), menu = createDummyDecorator(checkStringArgument), executionOrder = createEditorDecorator(checkNumberArgument, "executionOrder"), disallowMultiple = createDummyDecorator(checkCtorArgument), playOnFocus = createDummyDecorator(checkCtorArgument), inspector = createDummyDecorator(checkStringArgument), icon = createDummyDecorator(checkStringArgument), help = createDummyDecorator(checkStringArgument);
    var integer = type(CCInteger), _float = type(CCFloat), _boolean = type(CCBoolean), string = type(CCString);
    function type(type) {
        return property({
            type: type
        });
    }
    var _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _decorator = Object.freeze({
        __proto__: null,
        ccclass: ccclass,
        property: property,
        executeInEditMode: executeInEditMode,
        requireComponent: requireComponent,
        menu: menu,
        executionOrder: executionOrder,
        disallowMultiple: disallowMultiple,
        playOnFocus: playOnFocus,
        inspector: inspector,
        icon: icon,
        help: help,
        mixins: function mixins() {
            for (var mixins = [], i = 0; i < arguments.length; i++) mixins[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
            return function(ctor) {
                var cache = getClassCache(ctor);
                cache && (getSubDict(cache, "proto").mixins = mixins);
            };
        },
        integer: integer,
        float: _float,
        boolean: _boolean,
        string: string,
        type: type
    }), PrefabInfo = ccclass("cc.PrefabInfo")((_descriptor = _applyDecoratedDescriptor((_class2 = function PrefabInfo() {
        _classCallCheck(this, PrefabInfo), _initializerDefineProperty(this, "root", _descriptor, this), 
        _initializerDefineProperty(this, "asset", _descriptor2, this), _initializerDefineProperty(this, "fileId", _descriptor3, this), 
        _initializerDefineProperty(this, "sync", _descriptor4, this), _initializerDefineProperty(this, "_synced", _descriptor5, this);
    }).prototype, "root", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "asset", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "fileId", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "sync", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_synced", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return {
                default: !1,
                serializable: !1
            };
        }
    }), _class = _class2)) || _class;
    cc._PrefabInfo = PrefabInfo;
    var GFXObjectType, GFXStatus, BufferBlob = function() {
        function BufferBlob() {
            _classCallCheck(this, BufferBlob), this._arrayBufferOrPaddings = [], this._length = 0;
        }
        return _createClass(BufferBlob, [ {
            key: "setNextAlignment",
            value: function setNextAlignment(align) {
                if (0 !== align) {
                    var remainder = this._length % align;
                    if (0 !== remainder) {
                        var padding = align - remainder;
                        this._arrayBufferOrPaddings.push(padding), this._length += padding;
                    }
                }
            }
        }, {
            key: "addBuffer",
            value: function addBuffer(arrayBuffer) {
                var result = this._length;
                return this._arrayBufferOrPaddings.push(arrayBuffer), this._length += arrayBuffer.byteLength, 
                result;
            }
        }, {
            key: "getLength",
            value: function getLength() {
                return this._length;
            }
        }, {
            key: "getCombined",
            value: function getCombined() {
                var result = new Uint8Array(this._length), counter = 0;
                return this._arrayBufferOrPaddings.forEach((function(arrayBufferOrPadding) {
                    "number" == typeof arrayBufferOrPadding ? counter += arrayBufferOrPadding : (result.set(new Uint8Array(arrayBufferOrPadding), counter), 
                    counter += arrayBufferOrPadding.byteLength);
                })), result.buffer;
            }
        } ]), BufferBlob;
    }();
    (GFXObjectType = exports.GFXObjectType || (exports.GFXObjectType = {}))[GFXObjectType.UNKNOWN = 0] = "UNKNOWN", 
    GFXObjectType[GFXObjectType.BUFFER = 1] = "BUFFER", GFXObjectType[GFXObjectType.TEXTURE = 2] = "TEXTURE", 
    GFXObjectType[GFXObjectType.TEXTURE_VIEW = 3] = "TEXTURE_VIEW", GFXObjectType[GFXObjectType.RENDER_PASS = 4] = "RENDER_PASS", 
    GFXObjectType[GFXObjectType.FRAMEBUFFER = 5] = "FRAMEBUFFER", GFXObjectType[GFXObjectType.SAMPLER = 6] = "SAMPLER", 
    GFXObjectType[GFXObjectType.SHADER = 7] = "SHADER", GFXObjectType[GFXObjectType.PIPELINE_LAYOUT = 8] = "PIPELINE_LAYOUT", 
    GFXObjectType[GFXObjectType.PIPELINE_STATE = 9] = "PIPELINE_STATE", GFXObjectType[GFXObjectType.BINDING_LAYOUT = 10] = "BINDING_LAYOUT", 
    GFXObjectType[GFXObjectType.INPUT_ASSEMBLER = 11] = "INPUT_ASSEMBLER", GFXObjectType[GFXObjectType.COMMAND_ALLOCATOR = 12] = "COMMAND_ALLOCATOR", 
    GFXObjectType[GFXObjectType.COMMAND_BUFFER = 13] = "COMMAND_BUFFER", GFXObjectType[GFXObjectType.QUEUE = 14] = "QUEUE", 
    GFXObjectType[GFXObjectType.WINDOW = 15] = "WINDOW", (GFXStatus = exports.GFXStatus || (exports.GFXStatus = {}))[GFXStatus.UNREADY = 0] = "UNREADY", 
    GFXStatus[GFXStatus.FAILED = 1] = "FAILED", GFXStatus[GFXStatus.SUCCESS = 2] = "SUCCESS";
    var GFXAttributeName, GFXType, GFXFormat, GFXBufferUsageBit, GFXMemoryUsageBit, GFXBufferFlagBit, GFXBufferAccessBit, GFXPrimitiveMode, GFXPolygonMode, GFXShadeModel, GFXCullMode, GFXComparisonFunc, GFXStencilOp, GFXBlendOp, GFXBlendFactor, GFXColorMask, GFXFilter, GFXAddress, GFXTextureType, GFXTextureUsageBit, GFXSampleCount, GFXTextureFlagBit, GFXTextureViewType, GFXShaderType, GFXBindingType, GFXCommandBufferType, GFXLoadOp, GFXStoreOp, GFXTextureLayout, GFXPipelineBindPoint, GFXDynamicState, GFXStencilFace, GFXQueueType, GFXClearFlag, GFXObject = function() {
        function GFXObject(gfxType) {
            _classCallCheck(this, GFXObject), this._gfxType = exports.GFXObjectType.UNKNOWN, 
            this._status = exports.GFXStatus.UNREADY, this._gfxType = gfxType;
        }
        return _createClass(GFXObject, [ {
            key: "gfxType",
            get: function get() {
                return this._gfxType;
            }
        }, {
            key: "status",
            get: function get() {
                return this._status;
            }
        } ]), GFXObject;
    }();
    (GFXAttributeName = exports.GFXAttributeName || (exports.GFXAttributeName = {})).ATTR_POSITION = "a_position", 
    GFXAttributeName.ATTR_NORMAL = "a_normal", GFXAttributeName.ATTR_TANGENT = "a_tangent", 
    GFXAttributeName.ATTR_BITANGENT = "a_bitangent", GFXAttributeName.ATTR_WEIGHTS = "a_weights", 
    GFXAttributeName.ATTR_JOINTS = "a_joints", GFXAttributeName.ATTR_COLOR = "a_color", 
    GFXAttributeName.ATTR_COLOR1 = "a_color1", GFXAttributeName.ATTR_COLOR2 = "a_color2", 
    GFXAttributeName.ATTR_TEX_COORD = "a_texCoord", GFXAttributeName.ATTR_TEX_COORD1 = "a_texCoord1", 
    GFXAttributeName.ATTR_TEX_COORD2 = "a_texCoord2", GFXAttributeName.ATTR_TEX_COORD3 = "a_texCoord3", 
    GFXAttributeName.ATTR_TEX_COORD4 = "a_texCoord4", GFXAttributeName.ATTR_TEX_COORD5 = "a_texCoord5", 
    GFXAttributeName.ATTR_TEX_COORD6 = "a_texCoord6", GFXAttributeName.ATTR_TEX_COORD7 = "a_texCoord7", 
    GFXAttributeName.ATTR_TEX_COORD8 = "a_texCoord8", GFXAttributeName.ATTR_BATCH_ID = "a_batch_id", 
    GFXAttributeName.ATTR_BATCH_UV = "a_batch_uv", (GFXType = exports.GFXType || (exports.GFXType = {}))[GFXType.UNKNOWN = 0] = "UNKNOWN", 
    GFXType[GFXType.BOOL = 1] = "BOOL", GFXType[GFXType.BOOL2 = 2] = "BOOL2", GFXType[GFXType.BOOL3 = 3] = "BOOL3", 
    GFXType[GFXType.BOOL4 = 4] = "BOOL4", GFXType[GFXType.INT = 5] = "INT", GFXType[GFXType.INT2 = 6] = "INT2", 
    GFXType[GFXType.INT3 = 7] = "INT3", GFXType[GFXType.INT4 = 8] = "INT4", GFXType[GFXType.UINT = 9] = "UINT", 
    GFXType[GFXType.UINT2 = 10] = "UINT2", GFXType[GFXType.UINT3 = 11] = "UINT3", GFXType[GFXType.UINT4 = 12] = "UINT4", 
    GFXType[GFXType.FLOAT = 13] = "FLOAT", GFXType[GFXType.FLOAT2 = 14] = "FLOAT2", 
    GFXType[GFXType.FLOAT3 = 15] = "FLOAT3", GFXType[GFXType.FLOAT4 = 16] = "FLOAT4", 
    GFXType[GFXType.MAT2 = 17] = "MAT2", GFXType[GFXType.MAT2X3 = 18] = "MAT2X3", GFXType[GFXType.MAT2X4 = 19] = "MAT2X4", 
    GFXType[GFXType.MAT3X2 = 20] = "MAT3X2", GFXType[GFXType.MAT3 = 21] = "MAT3", GFXType[GFXType.MAT3X4 = 22] = "MAT3X4", 
    GFXType[GFXType.MAT4X2 = 23] = "MAT4X2", GFXType[GFXType.MAT4X3 = 24] = "MAT4X3", 
    GFXType[GFXType.MAT4 = 25] = "MAT4", GFXType[GFXType.SAMPLER1D = 26] = "SAMPLER1D", 
    GFXType[GFXType.SAMPLER1D_ARRAY = 27] = "SAMPLER1D_ARRAY", GFXType[GFXType.SAMPLER2D = 28] = "SAMPLER2D", 
    GFXType[GFXType.SAMPLER2D_ARRAY = 29] = "SAMPLER2D_ARRAY", GFXType[GFXType.SAMPLER3D = 30] = "SAMPLER3D", 
    GFXType[GFXType.SAMPLER_CUBE = 31] = "SAMPLER_CUBE", GFXType[GFXType.COUNT = 32] = "COUNT", 
    (GFXFormat = exports.GFXFormat || (exports.GFXFormat = {}))[GFXFormat.UNKNOWN = 0] = "UNKNOWN", 
    GFXFormat[GFXFormat.A8 = 1] = "A8", GFXFormat[GFXFormat.L8 = 2] = "L8", GFXFormat[GFXFormat.LA8 = 3] = "LA8", 
    GFXFormat[GFXFormat.R8 = 4] = "R8", GFXFormat[GFXFormat.R8SN = 5] = "R8SN", GFXFormat[GFXFormat.R8UI = 6] = "R8UI", 
    GFXFormat[GFXFormat.R8I = 7] = "R8I", GFXFormat[GFXFormat.R16F = 8] = "R16F", GFXFormat[GFXFormat.R16UI = 9] = "R16UI", 
    GFXFormat[GFXFormat.R16I = 10] = "R16I", GFXFormat[GFXFormat.R32F = 11] = "R32F", 
    GFXFormat[GFXFormat.R32UI = 12] = "R32UI", GFXFormat[GFXFormat.R32I = 13] = "R32I", 
    GFXFormat[GFXFormat.RG8 = 14] = "RG8", GFXFormat[GFXFormat.RG8SN = 15] = "RG8SN", 
    GFXFormat[GFXFormat.RG8UI = 16] = "RG8UI", GFXFormat[GFXFormat.RG8I = 17] = "RG8I", 
    GFXFormat[GFXFormat.RG16F = 18] = "RG16F", GFXFormat[GFXFormat.RG16UI = 19] = "RG16UI", 
    GFXFormat[GFXFormat.RG16I = 20] = "RG16I", GFXFormat[GFXFormat.RG32F = 21] = "RG32F", 
    GFXFormat[GFXFormat.RG32UI = 22] = "RG32UI", GFXFormat[GFXFormat.RG32I = 23] = "RG32I", 
    GFXFormat[GFXFormat.RGB8 = 24] = "RGB8", GFXFormat[GFXFormat.SRGB8 = 25] = "SRGB8", 
    GFXFormat[GFXFormat.RGB8SN = 26] = "RGB8SN", GFXFormat[GFXFormat.RGB8UI = 27] = "RGB8UI", 
    GFXFormat[GFXFormat.RGB8I = 28] = "RGB8I", GFXFormat[GFXFormat.RGB16F = 29] = "RGB16F", 
    GFXFormat[GFXFormat.RGB16UI = 30] = "RGB16UI", GFXFormat[GFXFormat.RGB16I = 31] = "RGB16I", 
    GFXFormat[GFXFormat.RGB32F = 32] = "RGB32F", GFXFormat[GFXFormat.RGB32UI = 33] = "RGB32UI", 
    GFXFormat[GFXFormat.RGB32I = 34] = "RGB32I", GFXFormat[GFXFormat.RGBA8 = 35] = "RGBA8", 
    GFXFormat[GFXFormat.SRGB8_A8 = 36] = "SRGB8_A8", GFXFormat[GFXFormat.RGBA8SN = 37] = "RGBA8SN", 
    GFXFormat[GFXFormat.RGBA8UI = 38] = "RGBA8UI", GFXFormat[GFXFormat.RGBA8I = 39] = "RGBA8I", 
    GFXFormat[GFXFormat.RGBA16F = 40] = "RGBA16F", GFXFormat[GFXFormat.RGBA16UI = 41] = "RGBA16UI", 
    GFXFormat[GFXFormat.RGBA16I = 42] = "RGBA16I", GFXFormat[GFXFormat.RGBA32F = 43] = "RGBA32F", 
    GFXFormat[GFXFormat.RGBA32UI = 44] = "RGBA32UI", GFXFormat[GFXFormat.RGBA32I = 45] = "RGBA32I", 
    GFXFormat[GFXFormat.R5G6B5 = 46] = "R5G6B5", GFXFormat[GFXFormat.R11G11B10F = 47] = "R11G11B10F", 
    GFXFormat[GFXFormat.RGB5A1 = 48] = "RGB5A1", GFXFormat[GFXFormat.RGBA4 = 49] = "RGBA4", 
    GFXFormat[GFXFormat.RGB10A2 = 50] = "RGB10A2", GFXFormat[GFXFormat.RGB10A2UI = 51] = "RGB10A2UI", 
    GFXFormat[GFXFormat.RGB9E5 = 52] = "RGB9E5", GFXFormat[GFXFormat.D16 = 53] = "D16", 
    GFXFormat[GFXFormat.D16S8 = 54] = "D16S8", GFXFormat[GFXFormat.D24 = 55] = "D24", 
    GFXFormat[GFXFormat.D24S8 = 56] = "D24S8", GFXFormat[GFXFormat.D32F = 57] = "D32F", 
    GFXFormat[GFXFormat.D32F_S8 = 58] = "D32F_S8", GFXFormat[GFXFormat.BC1 = 59] = "BC1", 
    GFXFormat[GFXFormat.BC1_ALPHA = 60] = "BC1_ALPHA", GFXFormat[GFXFormat.BC1_SRGB = 61] = "BC1_SRGB", 
    GFXFormat[GFXFormat.BC1_SRGB_ALPHA = 62] = "BC1_SRGB_ALPHA", GFXFormat[GFXFormat.BC2 = 63] = "BC2", 
    GFXFormat[GFXFormat.BC2_SRGB = 64] = "BC2_SRGB", GFXFormat[GFXFormat.BC3 = 65] = "BC3", 
    GFXFormat[GFXFormat.BC3_SRGB = 66] = "BC3_SRGB", GFXFormat[GFXFormat.BC4 = 67] = "BC4", 
    GFXFormat[GFXFormat.BC4_SNORM = 68] = "BC4_SNORM", GFXFormat[GFXFormat.BC5 = 69] = "BC5", 
    GFXFormat[GFXFormat.BC5_SNORM = 70] = "BC5_SNORM", GFXFormat[GFXFormat.BC6H_UF16 = 71] = "BC6H_UF16", 
    GFXFormat[GFXFormat.BC6H_SF16 = 72] = "BC6H_SF16", GFXFormat[GFXFormat.BC7 = 73] = "BC7", 
    GFXFormat[GFXFormat.BC7_SRGB = 74] = "BC7_SRGB", GFXFormat[GFXFormat.ETC_RGB8 = 75] = "ETC_RGB8", 
    GFXFormat[GFXFormat.ETC2_RGB8 = 76] = "ETC2_RGB8", GFXFormat[GFXFormat.ETC2_SRGB8 = 77] = "ETC2_SRGB8", 
    GFXFormat[GFXFormat.ETC2_RGB8_A1 = 78] = "ETC2_RGB8_A1", GFXFormat[GFXFormat.ETC2_SRGB8_A1 = 79] = "ETC2_SRGB8_A1", 
    GFXFormat[GFXFormat.ETC2_RGBA8 = 80] = "ETC2_RGBA8", GFXFormat[GFXFormat.ETC2_SRGB8_A8 = 81] = "ETC2_SRGB8_A8", 
    GFXFormat[GFXFormat.EAC_R11 = 82] = "EAC_R11", GFXFormat[GFXFormat.EAC_R11SN = 83] = "EAC_R11SN", 
    GFXFormat[GFXFormat.EAC_RG11 = 84] = "EAC_RG11", GFXFormat[GFXFormat.EAC_RG11SN = 85] = "EAC_RG11SN", 
    GFXFormat[GFXFormat.PVRTC_RGB2 = 86] = "PVRTC_RGB2", GFXFormat[GFXFormat.PVRTC_RGBA2 = 87] = "PVRTC_RGBA2", 
    GFXFormat[GFXFormat.PVRTC_RGB4 = 88] = "PVRTC_RGB4", GFXFormat[GFXFormat.PVRTC_RGBA4 = 89] = "PVRTC_RGBA4", 
    GFXFormat[GFXFormat.PVRTC2_2BPP = 90] = "PVRTC2_2BPP", GFXFormat[GFXFormat.PVRTC2_4BPP = 91] = "PVRTC2_4BPP", 
    (GFXBufferUsageBit = exports.GFXBufferUsageBit || (exports.GFXBufferUsageBit = {}))[GFXBufferUsageBit.NONE = 0] = "NONE", 
    GFXBufferUsageBit[GFXBufferUsageBit.TRANSFER_SRC = 1] = "TRANSFER_SRC", GFXBufferUsageBit[GFXBufferUsageBit.TRANSFER_DST = 2] = "TRANSFER_DST", 
    GFXBufferUsageBit[GFXBufferUsageBit.INDEX = 4] = "INDEX", GFXBufferUsageBit[GFXBufferUsageBit.VERTEX = 8] = "VERTEX", 
    GFXBufferUsageBit[GFXBufferUsageBit.UNIFORM = 16] = "UNIFORM", GFXBufferUsageBit[GFXBufferUsageBit.STORAGE = 32] = "STORAGE", 
    GFXBufferUsageBit[GFXBufferUsageBit.INDIRECT = 64] = "INDIRECT", (GFXMemoryUsageBit = exports.GFXMemoryUsageBit || (exports.GFXMemoryUsageBit = {}))[GFXMemoryUsageBit.NONE = 0] = "NONE", 
    GFXMemoryUsageBit[GFXMemoryUsageBit.DEVICE = 1] = "DEVICE", GFXMemoryUsageBit[GFXMemoryUsageBit.HOST = 2] = "HOST", 
    (GFXBufferFlagBit = exports.GFXBufferFlagBit || (exports.GFXBufferFlagBit = {}))[GFXBufferFlagBit.NONE = 0] = "NONE", 
    GFXBufferFlagBit[GFXBufferFlagBit.BAKUP_BUFFER = 4] = "BAKUP_BUFFER", (GFXBufferAccessBit = exports.GFXBufferAccessBit || (exports.GFXBufferAccessBit = {}))[GFXBufferAccessBit.NONE = 0] = "NONE", 
    GFXBufferAccessBit[GFXBufferAccessBit.READ = 1] = "READ", GFXBufferAccessBit[GFXBufferAccessBit.WRITE = 2] = "WRITE", 
    (GFXPrimitiveMode = exports.GFXPrimitiveMode || (exports.GFXPrimitiveMode = {}))[GFXPrimitiveMode.POINT_LIST = 0] = "POINT_LIST", 
    GFXPrimitiveMode[GFXPrimitiveMode.LINE_LIST = 1] = "LINE_LIST", GFXPrimitiveMode[GFXPrimitiveMode.LINE_STRIP = 2] = "LINE_STRIP", 
    GFXPrimitiveMode[GFXPrimitiveMode.LINE_LOOP = 3] = "LINE_LOOP", GFXPrimitiveMode[GFXPrimitiveMode.LINE_LIST_ADJACENCY = 4] = "LINE_LIST_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.LINE_STRIP_ADJACENCY = 5] = "LINE_STRIP_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.ISO_LINE_LIST = 6] = "ISO_LINE_LIST", GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_LIST = 7] = "TRIANGLE_LIST", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_STRIP = 8] = "TRIANGLE_STRIP", GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_FAN = 9] = "TRIANGLE_FAN", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_LIST_ADJACENCY = 10] = "TRIANGLE_LIST_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_STRIP_ADJACENCY = 11] = "TRIANGLE_STRIP_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_PATCH_ADJACENCY = 12] = "TRIANGLE_PATCH_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.QUAD_PATCH_LIST = 13] = "QUAD_PATCH_LIST", (GFXPolygonMode = exports.GFXPolygonMode || (exports.GFXPolygonMode = {}))[GFXPolygonMode.FILL = 0] = "FILL", 
    GFXPolygonMode[GFXPolygonMode.POINT = 1] = "POINT", GFXPolygonMode[GFXPolygonMode.LINE = 2] = "LINE", 
    (GFXShadeModel = exports.GFXShadeModel || (exports.GFXShadeModel = {}))[GFXShadeModel.GOURAND = 0] = "GOURAND", 
    GFXShadeModel[GFXShadeModel.FLAT = 1] = "FLAT", (GFXCullMode = exports.GFXCullMode || (exports.GFXCullMode = {}))[GFXCullMode.NONE = 0] = "NONE", 
    GFXCullMode[GFXCullMode.FRONT = 1] = "FRONT", GFXCullMode[GFXCullMode.BACK = 2] = "BACK", 
    (GFXComparisonFunc = exports.GFXComparisonFunc || (exports.GFXComparisonFunc = {}))[GFXComparisonFunc.NEVER = 0] = "NEVER", 
    GFXComparisonFunc[GFXComparisonFunc.LESS = 1] = "LESS", GFXComparisonFunc[GFXComparisonFunc.EQUAL = 2] = "EQUAL", 
    GFXComparisonFunc[GFXComparisonFunc.LESS_EQUAL = 3] = "LESS_EQUAL", GFXComparisonFunc[GFXComparisonFunc.GREATER = 4] = "GREATER", 
    GFXComparisonFunc[GFXComparisonFunc.NOT_EQUAL = 5] = "NOT_EQUAL", GFXComparisonFunc[GFXComparisonFunc.GREATER_EQUAL = 6] = "GREATER_EQUAL", 
    GFXComparisonFunc[GFXComparisonFunc.ALWAYS = 7] = "ALWAYS", (GFXStencilOp = exports.GFXStencilOp || (exports.GFXStencilOp = {}))[GFXStencilOp.ZERO = 0] = "ZERO", 
    GFXStencilOp[GFXStencilOp.KEEP = 1] = "KEEP", GFXStencilOp[GFXStencilOp.REPLACE = 2] = "REPLACE", 
    GFXStencilOp[GFXStencilOp.INCR = 3] = "INCR", GFXStencilOp[GFXStencilOp.DECR = 4] = "DECR", 
    GFXStencilOp[GFXStencilOp.INVERT = 5] = "INVERT", GFXStencilOp[GFXStencilOp.INCR_WRAP = 6] = "INCR_WRAP", 
    GFXStencilOp[GFXStencilOp.DECR_WRAP = 7] = "DECR_WRAP", (GFXBlendOp = exports.GFXBlendOp || (exports.GFXBlendOp = {}))[GFXBlendOp.ADD = 0] = "ADD", 
    GFXBlendOp[GFXBlendOp.SUB = 1] = "SUB", GFXBlendOp[GFXBlendOp.REV_SUB = 2] = "REV_SUB", 
    GFXBlendOp[GFXBlendOp.MIN = 3] = "MIN", GFXBlendOp[GFXBlendOp.MAX = 4] = "MAX", 
    (GFXBlendFactor = exports.GFXBlendFactor || (exports.GFXBlendFactor = {}))[GFXBlendFactor.ZERO = 0] = "ZERO", 
    GFXBlendFactor[GFXBlendFactor.ONE = 1] = "ONE", GFXBlendFactor[GFXBlendFactor.SRC_ALPHA = 2] = "SRC_ALPHA", 
    GFXBlendFactor[GFXBlendFactor.DST_ALPHA = 3] = "DST_ALPHA", GFXBlendFactor[GFXBlendFactor.ONE_MINUS_SRC_ALPHA = 4] = "ONE_MINUS_SRC_ALPHA", 
    GFXBlendFactor[GFXBlendFactor.ONE_MINUS_DST_ALPHA = 5] = "ONE_MINUS_DST_ALPHA", 
    GFXBlendFactor[GFXBlendFactor.SRC_COLOR = 6] = "SRC_COLOR", GFXBlendFactor[GFXBlendFactor.DST_COLOR = 7] = "DST_COLOR", 
    GFXBlendFactor[GFXBlendFactor.ONE_MINUS_SRC_COLOR = 8] = "ONE_MINUS_SRC_COLOR", 
    GFXBlendFactor[GFXBlendFactor.ONE_MINUS_DST_COLOR = 9] = "ONE_MINUS_DST_COLOR", 
    GFXBlendFactor[GFXBlendFactor.SRC_ALPHA_SATURATE = 10] = "SRC_ALPHA_SATURATE", GFXBlendFactor[GFXBlendFactor.CONSTANT_COLOR = 11] = "CONSTANT_COLOR", 
    GFXBlendFactor[GFXBlendFactor.ONE_MINUS_CONSTANT_COLOR = 12] = "ONE_MINUS_CONSTANT_COLOR", 
    GFXBlendFactor[GFXBlendFactor.CONSTANT_ALPHA = 13] = "CONSTANT_ALPHA", GFXBlendFactor[GFXBlendFactor.ONE_MINUS_CONSTANT_ALPHA = 14] = "ONE_MINUS_CONSTANT_ALPHA", 
    (GFXColorMask = exports.GFXColorMask || (exports.GFXColorMask = {}))[GFXColorMask.NONE = 0] = "NONE", 
    GFXColorMask[GFXColorMask.R = 1] = "R", GFXColorMask[GFXColorMask.G = 2] = "G", 
    GFXColorMask[GFXColorMask.B = 4] = "B", GFXColorMask[GFXColorMask.A = 8] = "A", 
    GFXColorMask[GFXColorMask.ALL = 15] = "ALL", (GFXFilter = exports.GFXFilter || (exports.GFXFilter = {}))[GFXFilter.NONE = 0] = "NONE", 
    GFXFilter[GFXFilter.POINT = 1] = "POINT", GFXFilter[GFXFilter.LINEAR = 2] = "LINEAR", 
    GFXFilter[GFXFilter.ANISOTROPIC = 3] = "ANISOTROPIC", (GFXAddress = exports.GFXAddress || (exports.GFXAddress = {}))[GFXAddress.WRAP = 0] = "WRAP", 
    GFXAddress[GFXAddress.MIRROR = 1] = "MIRROR", GFXAddress[GFXAddress.CLAMP = 2] = "CLAMP", 
    GFXAddress[GFXAddress.BORDER = 3] = "BORDER", (GFXTextureType = exports.GFXTextureType || (exports.GFXTextureType = {}))[GFXTextureType.TEX1D = 0] = "TEX1D", 
    GFXTextureType[GFXTextureType.TEX2D = 1] = "TEX2D", GFXTextureType[GFXTextureType.TEX3D = 2] = "TEX3D", 
    (GFXTextureUsageBit = exports.GFXTextureUsageBit || (exports.GFXTextureUsageBit = {}))[GFXTextureUsageBit.NONE = 0] = "NONE", 
    GFXTextureUsageBit[GFXTextureUsageBit.TRANSFER_SRC = 1] = "TRANSFER_SRC", GFXTextureUsageBit[GFXTextureUsageBit.TRANSFER_DST = 2] = "TRANSFER_DST", 
    GFXTextureUsageBit[GFXTextureUsageBit.SAMPLED = 4] = "SAMPLED", GFXTextureUsageBit[GFXTextureUsageBit.STORAGE = 8] = "STORAGE", 
    GFXTextureUsageBit[GFXTextureUsageBit.COLOR_ATTACHMENT = 16] = "COLOR_ATTACHMENT", 
    GFXTextureUsageBit[GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT = 32] = "DEPTH_STENCIL_ATTACHMENT", 
    GFXTextureUsageBit[GFXTextureUsageBit.TRANSIENT_ATTACHMENT = 64] = "TRANSIENT_ATTACHMENT", 
    GFXTextureUsageBit[GFXTextureUsageBit.INPUT_ATTACHMENT = 128] = "INPUT_ATTACHMENT", 
    (GFXSampleCount = exports.GFXSampleCount || (exports.GFXSampleCount = {}))[GFXSampleCount.X1 = 0] = "X1", 
    GFXSampleCount[GFXSampleCount.X2 = 1] = "X2", GFXSampleCount[GFXSampleCount.X4 = 2] = "X4", 
    GFXSampleCount[GFXSampleCount.X8 = 3] = "X8", GFXSampleCount[GFXSampleCount.X16 = 4] = "X16", 
    GFXSampleCount[GFXSampleCount.X32 = 5] = "X32", GFXSampleCount[GFXSampleCount.X64 = 6] = "X64", 
    (GFXTextureFlagBit = exports.GFXTextureFlagBit || (exports.GFXTextureFlagBit = {}))[GFXTextureFlagBit.NONE = 0] = "NONE", 
    GFXTextureFlagBit[GFXTextureFlagBit.GEN_MIPMAP = 1] = "GEN_MIPMAP", GFXTextureFlagBit[GFXTextureFlagBit.CUBEMAP = 2] = "CUBEMAP", 
    GFXTextureFlagBit[GFXTextureFlagBit.BAKUP_BUFFER = 4] = "BAKUP_BUFFER", (GFXTextureViewType = exports.GFXTextureViewType || (exports.GFXTextureViewType = {}))[GFXTextureViewType.TV1D = 0] = "TV1D", 
    GFXTextureViewType[GFXTextureViewType.TV2D = 1] = "TV2D", GFXTextureViewType[GFXTextureViewType.TV3D = 2] = "TV3D", 
    GFXTextureViewType[GFXTextureViewType.CUBE = 3] = "CUBE", GFXTextureViewType[GFXTextureViewType.TV1D_ARRAY = 4] = "TV1D_ARRAY", 
    GFXTextureViewType[GFXTextureViewType.TV2D_ARRAY = 5] = "TV2D_ARRAY", (GFXShaderType = exports.GFXShaderType || (exports.GFXShaderType = {}))[GFXShaderType.VERTEX = 0] = "VERTEX", 
    GFXShaderType[GFXShaderType.HULL = 1] = "HULL", GFXShaderType[GFXShaderType.DOMAIN = 2] = "DOMAIN", 
    GFXShaderType[GFXShaderType.GEOMETRY = 3] = "GEOMETRY", GFXShaderType[GFXShaderType.FRAGMENT = 4] = "FRAGMENT", 
    GFXShaderType[GFXShaderType.COMPUTE = 5] = "COMPUTE", GFXShaderType[GFXShaderType.COUNT = 6] = "COUNT", 
    (GFXBindingType = exports.GFXBindingType || (exports.GFXBindingType = {}))[GFXBindingType.UNKNOWN = 0] = "UNKNOWN", 
    GFXBindingType[GFXBindingType.UNIFORM_BUFFER = 1] = "UNIFORM_BUFFER", GFXBindingType[GFXBindingType.SAMPLER = 2] = "SAMPLER", 
    GFXBindingType[GFXBindingType.STORAGE_BUFFER = 3] = "STORAGE_BUFFER", (GFXCommandBufferType = exports.GFXCommandBufferType || (exports.GFXCommandBufferType = {}))[GFXCommandBufferType.PRIMARY = 0] = "PRIMARY", 
    GFXCommandBufferType[GFXCommandBufferType.SECONDARY = 1] = "SECONDARY", (GFXLoadOp = exports.GFXLoadOp || (exports.GFXLoadOp = {}))[GFXLoadOp.LOAD = 0] = "LOAD", 
    GFXLoadOp[GFXLoadOp.CLEAR = 1] = "CLEAR", GFXLoadOp[GFXLoadOp.DISCARD = 2] = "DISCARD", 
    (GFXStoreOp = exports.GFXStoreOp || (exports.GFXStoreOp = {}))[GFXStoreOp.STORE = 0] = "STORE", 
    GFXStoreOp[GFXStoreOp.DISCARD = 1] = "DISCARD", (GFXTextureLayout = exports.GFXTextureLayout || (exports.GFXTextureLayout = {}))[GFXTextureLayout.UNDEFINED = 0] = "UNDEFINED", 
    GFXTextureLayout[GFXTextureLayout.GENERAL = 1] = "GENERAL", GFXTextureLayout[GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL = 2] = "COLOR_ATTACHMENT_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3] = "DEPTH_STENCIL_ATTACHMENT_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.DEPTH_STENCIL_READONLY_OPTIMAL = 4] = "DEPTH_STENCIL_READONLY_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.SHADER_READONLY_OPTIMAL = 5] = "SHADER_READONLY_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.TRANSFER_SRC_OPTIMAL = 6] = "TRANSFER_SRC_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.TRANSFER_DST_OPTIMAL = 7] = "TRANSFER_DST_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.PREINITIALIZED = 8] = "PREINITIALIZED", GFXTextureLayout[GFXTextureLayout.PRESENT_SRC = 9] = "PRESENT_SRC", 
    (GFXPipelineBindPoint = exports.GFXPipelineBindPoint || (exports.GFXPipelineBindPoint = {}))[GFXPipelineBindPoint.GRAPHICS = 0] = "GRAPHICS", 
    GFXPipelineBindPoint[GFXPipelineBindPoint.COMPUTE = 1] = "COMPUTE", GFXPipelineBindPoint[GFXPipelineBindPoint.RAY_TRACING = 2] = "RAY_TRACING", 
    (GFXDynamicState = exports.GFXDynamicState || (exports.GFXDynamicState = {}))[GFXDynamicState.VIEWPORT = 0] = "VIEWPORT", 
    GFXDynamicState[GFXDynamicState.SCISSOR = 1] = "SCISSOR", GFXDynamicState[GFXDynamicState.LINE_WIDTH = 2] = "LINE_WIDTH", 
    GFXDynamicState[GFXDynamicState.DEPTH_BIAS = 3] = "DEPTH_BIAS", GFXDynamicState[GFXDynamicState.BLEND_CONSTANTS = 4] = "BLEND_CONSTANTS", 
    GFXDynamicState[GFXDynamicState.DEPTH_BOUNDS = 5] = "DEPTH_BOUNDS", GFXDynamicState[GFXDynamicState.STENCIL_WRITE_MASK = 6] = "STENCIL_WRITE_MASK", 
    GFXDynamicState[GFXDynamicState.STENCIL_COMPARE_MASK = 7] = "STENCIL_COMPARE_MASK", 
    (GFXStencilFace = exports.GFXStencilFace || (exports.GFXStencilFace = {}))[GFXStencilFace.FRONT = 0] = "FRONT", 
    GFXStencilFace[GFXStencilFace.BACK = 1] = "BACK", GFXStencilFace[GFXStencilFace.ALL = 2] = "ALL", 
    (GFXQueueType = exports.GFXQueueType || (exports.GFXQueueType = {}))[GFXQueueType.GRAPHICS = 0] = "GRAPHICS", 
    GFXQueueType[GFXQueueType.COMPUTE = 1] = "COMPUTE", GFXQueueType[GFXQueueType.TRANSFER = 2] = "TRANSFER", 
    (GFXClearFlag = exports.GFXClearFlag || (exports.GFXClearFlag = {}))[GFXClearFlag.NONE = 0] = "NONE", 
    GFXClearFlag[GFXClearFlag.COLOR = 1] = "COLOR", GFXClearFlag[GFXClearFlag.DEPTH = 2] = "DEPTH", 
    GFXClearFlag[GFXClearFlag.STENCIL = 4] = "STENCIL", GFXClearFlag[GFXClearFlag.DEPTH_STENCIL = 6] = "DEPTH_STENCIL", 
    GFXClearFlag[GFXClearFlag.ALL = 7] = "ALL";
    var GFXFormatType, GFXTextureSubres = function GFXTextureSubres() {
        _classCallCheck(this, GFXTextureSubres), this.baseMipLevel = 0, this.levelCount = 1, 
        this.baseArrayLayer = 0, this.layerCount = 1;
    }, GFXTextureCopy = function GFXTextureCopy() {
        _classCallCheck(this, GFXTextureCopy), this.srcSubres = new GFXTextureSubres, this.srcOffset = {
            x: 0,
            y: 0,
            z: 0
        }, this.dstSubres = new GFXTextureSubres, this.dstOffset = {
            x: 0,
            y: 0,
            z: 0
        }, this.extent = {
            width: 0,
            height: 0,
            depth: 0
        };
    }, GFXBufferTextureCopy = function GFXBufferTextureCopy() {
        _classCallCheck(this, GFXBufferTextureCopy), this.buffOffset = 0, this.buffStride = 0, 
        this.buffTexHeight = 0, this.texOffset = {
            x: 0,
            y: 0,
            z: 0
        }, this.texExtent = {
            width: 0,
            height: 0,
            depth: 0
        }, this.texSubres = new GFXTextureSubres;
    };
    (GFXFormatType = exports.GFXFormatType || (exports.GFXFormatType = {}))[GFXFormatType.NONE = 0] = "NONE", 
    GFXFormatType[GFXFormatType.UNORM = 1] = "UNORM", GFXFormatType[GFXFormatType.SNORM = 2] = "SNORM", 
    GFXFormatType[GFXFormatType.UINT = 3] = "UINT", GFXFormatType[GFXFormatType.INT = 4] = "INT", 
    GFXFormatType[GFXFormatType.UFLOAT = 5] = "UFLOAT", GFXFormatType[GFXFormatType.FLOAT = 6] = "FLOAT";
    var GFXFormatInfos = [ {
        name: "UNKNOWN",
        size: 0,
        count: 0,
        type: exports.GFXFormatType.NONE,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "A8",
        size: 1,
        count: 1,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "L8",
        size: 1,
        count: 1,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "LA8",
        size: 1,
        count: 2,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R8",
        size: 1,
        count: 1,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R8SN",
        size: 1,
        count: 1,
        type: exports.GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R8UI",
        size: 1,
        count: 1,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R8I",
        size: 1,
        count: 1,
        type: exports.GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R16F",
        size: 2,
        count: 1,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R16UI",
        size: 2,
        count: 1,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R16I",
        size: 2,
        count: 1,
        type: exports.GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R32F",
        size: 4,
        count: 1,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R32UI",
        size: 4,
        count: 1,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R32I",
        size: 4,
        count: 1,
        type: exports.GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG8",
        size: 2,
        count: 2,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG8SN",
        size: 2,
        count: 2,
        type: exports.GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG8UI",
        size: 2,
        count: 2,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG8I",
        size: 2,
        count: 2,
        type: exports.GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG16F",
        size: 4,
        count: 2,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG16UI",
        size: 4,
        count: 2,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG16I",
        size: 4,
        count: 2,
        type: exports.GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG32F",
        size: 8,
        count: 2,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG32UI",
        size: 8,
        count: 2,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG32I",
        size: 8,
        count: 2,
        type: exports.GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB8",
        size: 3,
        count: 3,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "SRGB8",
        size: 3,
        count: 3,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB8SN",
        size: 3,
        count: 3,
        type: exports.GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB8UI",
        size: 3,
        count: 3,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB8I",
        size: 3,
        count: 3,
        type: exports.GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB16F",
        size: 6,
        count: 3,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB16UI",
        size: 6,
        count: 3,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB16I",
        size: 6,
        count: 3,
        type: exports.GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB32F",
        size: 12,
        count: 3,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB32UI",
        size: 12,
        count: 3,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB32I",
        size: 12,
        count: 3,
        type: exports.GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA8",
        size: 4,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "SRGB8_A8",
        size: 4,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA8SN",
        size: 4,
        count: 4,
        type: exports.GFXFormatType.SNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA8UI",
        size: 4,
        count: 4,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA8I",
        size: 4,
        count: 4,
        type: exports.GFXFormatType.INT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA16F",
        size: 8,
        count: 4,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA16UI",
        size: 8,
        count: 4,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA16I",
        size: 8,
        count: 4,
        type: exports.GFXFormatType.INT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA32F",
        size: 16,
        count: 4,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA32UI",
        size: 16,
        count: 4,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA32I",
        size: 16,
        count: 4,
        type: exports.GFXFormatType.INT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R5G6B5",
        size: 2,
        count: 3,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R11G11B10F",
        size: 4,
        count: 3,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB5A1",
        size: 2,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA4",
        size: 2,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB10A2",
        size: 2,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB10A2UI",
        size: 2,
        count: 4,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB9E5",
        size: 2,
        count: 4,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "D16",
        size: 2,
        count: 1,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "D16S8",
        size: 3,
        count: 2,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !0,
        isCompressed: !1
    }, {
        name: "D24",
        size: 3,
        count: 1,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "D24S8",
        size: 4,
        count: 2,
        type: exports.GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !0,
        isCompressed: !1
    }, {
        name: "D32F",
        size: 4,
        count: 1,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "D32FS8",
        size: 5,
        count: 2,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !0,
        isCompressed: !1
    }, {
        name: "BC1",
        size: 1,
        count: 3,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC1_ALPHA",
        size: 1,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC1_SRGB",
        size: 1,
        count: 3,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC1_SRGB_ALPHA",
        size: 1,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC2",
        size: 1,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC2_SRGB",
        size: 1,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC3",
        size: 1,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC3_SRGB",
        size: 1,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC4",
        size: 1,
        count: 1,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC4_SNORM",
        size: 1,
        count: 1,
        type: exports.GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC5",
        size: 1,
        count: 2,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC5_SNORM",
        size: 1,
        count: 2,
        type: exports.GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC6H_UF16",
        size: 1,
        count: 3,
        type: exports.GFXFormatType.UFLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC6H_SF16",
        size: 1,
        count: 3,
        type: exports.GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC7",
        size: 1,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC7_SRGB",
        size: 1,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC_RGB8",
        size: 1,
        count: 3,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_RGB8",
        size: 1,
        count: 3,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_SRGB8",
        size: 1,
        count: 3,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_RGB8_A1",
        size: 1,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_SRGB8_A1",
        size: 1,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_RGBA8",
        size: 2,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_SRGB8_A8",
        size: 2,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "EAC_R11",
        size: 1,
        count: 1,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "EAC_R11SN",
        size: 1,
        count: 1,
        type: exports.GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "EAC_RG11",
        size: 2,
        count: 2,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "EAC_RG11SN",
        size: 2,
        count: 2,
        type: exports.GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC_RGB2",
        size: 2,
        count: 3,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC_RGBA2",
        size: 2,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC_RGB4",
        size: 2,
        count: 3,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC_RGBA4",
        size: 2,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC2_2BPP",
        size: 2,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC2_4BPP",
        size: 2,
        count: 4,
        type: exports.GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    } ];
    function GFXFormatSize(format, width, height, depth) {
        if (!GFXFormatInfos[format].isCompressed) return width * height * depth * GFXFormatInfos[format].size;
        switch (format) {
          case exports.GFXFormat.BC1:
          case exports.GFXFormat.BC1_ALPHA:
          case exports.GFXFormat.BC1_SRGB:
          case exports.GFXFormat.BC1_SRGB_ALPHA:
            return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

          case exports.GFXFormat.BC2:
          case exports.GFXFormat.BC2_SRGB:
          case exports.GFXFormat.BC3:
          case exports.GFXFormat.BC3_SRGB:
          case exports.GFXFormat.BC4:
          case exports.GFXFormat.BC4_SNORM:
          case exports.GFXFormat.BC6H_SF16:
          case exports.GFXFormat.BC6H_UF16:
          case exports.GFXFormat.BC7:
          case exports.GFXFormat.BC7_SRGB:
            return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

          case exports.GFXFormat.BC5:
          case exports.GFXFormat.BC5_SNORM:
            return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;

          case exports.GFXFormat.ETC_RGB8:
          case exports.GFXFormat.ETC2_RGB8:
          case exports.GFXFormat.ETC2_SRGB8:
          case exports.GFXFormat.ETC2_RGB8_A1:
          case exports.GFXFormat.ETC2_SRGB8_A1:
          case exports.GFXFormat.EAC_R11:
          case exports.GFXFormat.EAC_R11SN:
            return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

          case exports.GFXFormat.EAC_RG11:
          case exports.GFXFormat.EAC_RG11SN:
            return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

          case exports.GFXFormat.PVRTC_RGB2:
          case exports.GFXFormat.PVRTC_RGBA2:
          case exports.GFXFormat.PVRTC2_2BPP:
            return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 4) * depth;

          case exports.GFXFormat.PVRTC_RGB4:
          case exports.GFXFormat.PVRTC_RGBA4:
          case exports.GFXFormat.PVRTC2_4BPP:
            return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 2) * depth;

          default:
            return 0;
        }
    }
    function GFXFormatSurfaceSize(format, width, height, depth, mips) {
        for (var size = 0, i = 0; i < mips; ++i) size += GFXFormatSize(format, width, height, depth), 
        width = Math.max(width >> 1, 1), height = Math.max(height >> 1, 1), depth = Math.max(depth >> 1, 1);
        return size;
    }
    var _type2size = [ 0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4 ];
    function GFXGetTypeSize(type) {
        return _type2size[type] || 0;
    }
    var GFXAPI, GFXFeature, GFXDefines = Object.freeze({
        __proto__: null,
        GFX_MAX_VERTEX_ATTRIBUTES: 16,
        GFX_MAX_TEXTURE_UNITS: 16,
        GFX_MAX_ATTACHMENTS: 4,
        GFX_MAX_BUFFER_BINDINGS: 24,
        get GFXObjectType() {
            return exports.GFXObjectType;
        },
        get GFXStatus() {
            return exports.GFXStatus;
        },
        GFXObject: GFXObject,
        get GFXAttributeName() {
            return exports.GFXAttributeName;
        },
        get GFXType() {
            return exports.GFXType;
        },
        get GFXFormat() {
            return exports.GFXFormat;
        },
        get GFXBufferUsageBit() {
            return exports.GFXBufferUsageBit;
        },
        get GFXMemoryUsageBit() {
            return exports.GFXMemoryUsageBit;
        },
        get GFXBufferFlagBit() {
            return exports.GFXBufferFlagBit;
        },
        get GFXBufferAccessBit() {
            return exports.GFXBufferAccessBit;
        },
        get GFXPrimitiveMode() {
            return exports.GFXPrimitiveMode;
        },
        get GFXPolygonMode() {
            return exports.GFXPolygonMode;
        },
        get GFXShadeModel() {
            return exports.GFXShadeModel;
        },
        get GFXCullMode() {
            return exports.GFXCullMode;
        },
        get GFXComparisonFunc() {
            return exports.GFXComparisonFunc;
        },
        get GFXStencilOp() {
            return exports.GFXStencilOp;
        },
        get GFXBlendOp() {
            return exports.GFXBlendOp;
        },
        get GFXBlendFactor() {
            return exports.GFXBlendFactor;
        },
        get GFXColorMask() {
            return exports.GFXColorMask;
        },
        get GFXFilter() {
            return exports.GFXFilter;
        },
        get GFXAddress() {
            return exports.GFXAddress;
        },
        get GFXTextureType() {
            return exports.GFXTextureType;
        },
        get GFXTextureUsageBit() {
            return exports.GFXTextureUsageBit;
        },
        get GFXSampleCount() {
            return exports.GFXSampleCount;
        },
        get GFXTextureFlagBit() {
            return exports.GFXTextureFlagBit;
        },
        get GFXTextureViewType() {
            return exports.GFXTextureViewType;
        },
        get GFXShaderType() {
            return exports.GFXShaderType;
        },
        get GFXBindingType() {
            return exports.GFXBindingType;
        },
        get GFXCommandBufferType() {
            return exports.GFXCommandBufferType;
        },
        get GFXLoadOp() {
            return exports.GFXLoadOp;
        },
        get GFXStoreOp() {
            return exports.GFXStoreOp;
        },
        get GFXTextureLayout() {
            return exports.GFXTextureLayout;
        },
        get GFXPipelineBindPoint() {
            return exports.GFXPipelineBindPoint;
        },
        get GFXDynamicState() {
            return exports.GFXDynamicState;
        },
        get GFXStencilFace() {
            return exports.GFXStencilFace;
        },
        get GFXQueueType() {
            return exports.GFXQueueType;
        },
        get GFXClearFlag() {
            return exports.GFXClearFlag;
        },
        GFXTextureSubres: GFXTextureSubres,
        GFXTextureCopy: GFXTextureCopy,
        GFXBufferTextureCopy: GFXBufferTextureCopy,
        get GFXFormatType() {
            return exports.GFXFormatType;
        },
        GFXFormatInfos: GFXFormatInfos,
        GFXFormatSize: GFXFormatSize,
        GFXFormatSurfaceSize: GFXFormatSurfaceSize,
        GFXGetTypeSize: GFXGetTypeSize
    });
    ccenum(exports.GFXFormat), (GFXAPI = exports.GFXAPI || (exports.GFXAPI = {}))[GFXAPI.UNKNOWN = 0] = "UNKNOWN", 
    GFXAPI[GFXAPI.WEBGL = 1] = "WEBGL", GFXAPI[GFXAPI.WEBGL2 = 2] = "WEBGL2", (GFXFeature = exports.GFXFeature || (exports.GFXFeature = {}))[GFXFeature.COLOR_FLOAT = 0] = "COLOR_FLOAT", 
    GFXFeature[GFXFeature.COLOR_HALF_FLOAT = 1] = "COLOR_HALF_FLOAT", GFXFeature[GFXFeature.TEXTURE_FLOAT = 2] = "TEXTURE_FLOAT", 
    GFXFeature[GFXFeature.TEXTURE_HALF_FLOAT = 3] = "TEXTURE_HALF_FLOAT", GFXFeature[GFXFeature.TEXTURE_FLOAT_LINEAR = 4] = "TEXTURE_FLOAT_LINEAR", 
    GFXFeature[GFXFeature.TEXTURE_HALF_FLOAT_LINEAR = 5] = "TEXTURE_HALF_FLOAT_LINEAR", 
    GFXFeature[GFXFeature.FORMAT_R11G11B10F = 6] = "FORMAT_R11G11B10F", GFXFeature[GFXFeature.FORMAT_D24S8 = 7] = "FORMAT_D24S8", 
    GFXFeature[GFXFeature.FORMAT_ETC1 = 8] = "FORMAT_ETC1", GFXFeature[GFXFeature.FORMAT_ETC2 = 9] = "FORMAT_ETC2", 
    GFXFeature[GFXFeature.FORMAT_DXT = 10] = "FORMAT_DXT", GFXFeature[GFXFeature.FORMAT_PVRTC = 11] = "FORMAT_PVRTC", 
    GFXFeature[GFXFeature.FORMAT_ASTC = 12] = "FORMAT_ASTC", GFXFeature[GFXFeature.MSAA = 13] = "MSAA", 
    GFXFeature[GFXFeature.COUNT = 14] = "COUNT", GFXFeature[GFXFeature.ELEMENT_INDEX_UINT = 15] = "ELEMENT_INDEX_UINT";
    var GFXDevice = function() {
        function GFXDevice() {
            _classCallCheck(this, GFXDevice), this._canvas = null, this._canvas2D = null, this._gfxAPI = exports.GFXAPI.UNKNOWN, 
            this._deviceName = "", this._renderer = "", this._vendor = "", this._version = "", 
            this._features = new Array(exports.GFXFeature.COUNT), this._queue = null, this._devicePixelRatio = 1, 
            this._width = 0, this._height = 0, this._nativeWidth = 0, this._nativeHeight = 0, 
            this._mainWindow = null, this._cmdAllocator = null, this._maxVertexAttributes = 0, 
            this._maxVertexUniformVectors = 0, this._maxFragmentUniformVectors = 0, this._maxTextureUnits = 0, 
            this._maxVertexTextureUnits = 0, this._maxUniformBufferBindings = 24, this._maxUniformBlockSize = 0, 
            this._maxTextureSize = 0, this._maxCubeMapTextureSize = 0, this._depthBits = 0, 
            this._stencilBits = 0, this._colorFmt = exports.GFXFormat.UNKNOWN, this._depthStencilFmt = exports.GFXFormat.UNKNOWN, 
            this._reverseCW = !1, this._shaderIdGen = 0, this._macros = new Map, this._numDrawCalls = 0, 
            this._numTris = 0, this._memoryStatus = {
                bufferSize: 0,
                textureSize: 0
            };
        }
        return _createClass(GFXDevice, [ {
            key: "hasFeature",
            value: function hasFeature(feature) {
                return this._features[feature];
            }
        }, {
            key: "genShaderId",
            value: function genShaderId() {
                return this._shaderIdGen++;
            }
        }, {
            key: "defineMacro",
            value: function defineMacro(macro, value) {
                var val = void 0 !== value ? value : "";
                this._macros.set(macro, val);
            }
        }, {
            key: "canvas",
            get: function get() {
                return this._canvas;
            }
        }, {
            key: "canvas2D",
            get: function get() {
                return this._canvas2D;
            }
        }, {
            key: "gfxAPI",
            get: function get() {
                return this._gfxAPI;
            }
        }, {
            key: "queue",
            get: function get() {
                return this._queue;
            }
        }, {
            key: "devicePixelRatio",
            get: function get() {
                return this._devicePixelRatio;
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        }, {
            key: "nativeWidth",
            get: function get() {
                return this._nativeWidth;
            }
        }, {
            key: "nativeHeight",
            get: function get() {
                return this._nativeHeight;
            }
        }, {
            key: "mainWindow",
            get: function get() {
                return this._mainWindow;
            }
        }, {
            key: "commandAllocator",
            get: function get() {
                return this._cmdAllocator;
            }
        }, {
            key: "renderer",
            get: function get() {
                return this._renderer;
            }
        }, {
            key: "vendor",
            get: function get() {
                return this._vendor;
            }
        }, {
            key: "maxVertexAttributes",
            get: function get() {
                return this._maxVertexAttributes;
            }
        }, {
            key: "maxVertexUniformVectors",
            get: function get() {
                return this._maxVertexUniformVectors;
            }
        }, {
            key: "maxFragmentUniformVectors",
            get: function get() {
                return this._maxFragmentUniformVectors;
            }
        }, {
            key: "maxTextureUnits",
            get: function get() {
                return this._maxTextureUnits;
            }
        }, {
            key: "maxVertexTextureUnits",
            get: function get() {
                return this._maxVertexTextureUnits;
            }
        }, {
            key: "maxUniformBufferBindings",
            get: function get() {
                return this._maxUniformBufferBindings;
            }
        }, {
            key: "maxUniformBlockSize",
            get: function get() {
                return this._maxUniformBlockSize;
            }
        }, {
            key: "maxTextureSize",
            get: function get() {
                return this._maxTextureSize;
            }
        }, {
            key: "maxCubeMapTextureSize",
            get: function get() {
                return this._maxCubeMapTextureSize;
            }
        }, {
            key: "depthBits",
            get: function get() {
                return this._depthBits;
            }
        }, {
            key: "stencilBits",
            get: function get() {
                return this._stencilBits;
            }
        }, {
            key: "colorFormat",
            get: function get() {
                return this._colorFmt;
            }
        }, {
            key: "depthStencilFormat",
            get: function get() {
                return this._depthStencilFmt;
            }
        }, {
            key: "macros",
            get: function get() {
                return this._macros;
            }
        }, {
            key: "numDrawCalls",
            get: function get() {
                return this._numDrawCalls;
            }
        }, {
            key: "numTris",
            get: function get() {
                return this._numTris;
            }
        }, {
            key: "memoryStatus",
            get: function get() {
                return this._memoryStatus;
            }
        }, {
            key: "reverseCW",
            get: function get() {
                return this._reverseCW;
            },
            set: function set(val) {
                this._reverseCW = val;
            }
        } ]), GFXDevice;
    }(), getUint8ForString = String.prototype.charCodeAt;
    function getUint8ForArray(idx) {
        return this[idx];
    }
    function murmurhash2_32_gc(input, seed) {
        for (var l = input.length, h = seed ^ l, i = 0, getUint8 = "string" == typeof input ? getUint8ForString : getUint8ForArray; l >= 4; ) {
            var k = 255 & getUint8.call(input, i) | (255 & getUint8.call(input, ++i)) << 8 | (255 & getUint8.call(input, ++i)) << 16 | (255 & getUint8.call(input, ++i)) << 24;
            k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16), h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ (k = 1540483477 * (65535 & (k ^= k >>> 24)) + ((1540483477 * (k >>> 16) & 65535) << 16)), 
            l -= 4, ++i;
        }
        switch (l) {
          case 3:
            h ^= (255 & getUint8.call(input, i + 2)) << 16;

          case 2:
            h ^= (255 & getUint8.call(input, i + 1)) << 8;

          case 1:
            h = 1540483477 * (65535 & (h ^= 255 & getUint8.call(input, i))) + ((1540483477 * (h >>> 16) & 65535) << 16);
        }
        return h = 1540483477 * (65535 & (h ^= h >>> 13)) + ((1540483477 * (h >>> 16) & 65535) << 16), 
        (h ^= h >>> 15) >>> 0;
    }
    var fastRemoveAt$1 = array.fastRemoveAt;
    function empty() {}
    var CallbackInfo = function() {
        function CallbackInfo() {
            _classCallCheck(this, CallbackInfo), this.callback = empty, this.target = void 0, 
            this.once = !1;
        }
        return _createClass(CallbackInfo, [ {
            key: "set",
            value: function set(callback, target, once) {
                this.callback = callback, this.target = target, this.once = !!once;
            }
        } ]), CallbackInfo;
    }(), callbackInfoPool = new Pool$1((function() {
        return new CallbackInfo;
    }), 32), CallbackList = function() {
        function CallbackList() {
            _classCallCheck(this, CallbackList), this.callbackInfos = [], this.isInvoking = !1, 
            this.containCanceled = !1;
        }
        return _createClass(CallbackList, [ {
            key: "removeByCallback",
            value: function removeByCallback(cb) {
                for (var i = 0; i < this.callbackInfos.length; ++i) {
                    var info = this.callbackInfos[i];
                    info && info.callback === cb && (callbackInfoPool.free(info), fastRemoveAt$1(this.callbackInfos, i), 
                    --i);
                }
            }
        }, {
            key: "removeByTarget",
            value: function removeByTarget(target) {
                for (var i = 0; i < this.callbackInfos.length; ++i) {
                    var info = this.callbackInfos[i];
                    info && info.target === target && (callbackInfoPool.free(info), fastRemoveAt$1(this.callbackInfos, i), 
                    --i);
                }
            }
        }, {
            key: "cancel",
            value: function cancel(index) {
                var info = this.callbackInfos[index];
                info && (callbackInfoPool.free(info), this.callbackInfos[index] = null), this.containCanceled = !0;
            }
        }, {
            key: "cancelAll",
            value: function cancelAll() {
                for (var i = 0; i < this.callbackInfos.length; i++) {
                    var info = this.callbackInfos[i];
                    info && (callbackInfoPool.free(info), this.callbackInfos[i] = null);
                }
                this.containCanceled = !0;
            }
        }, {
            key: "purgeCanceled",
            value: function purgeCanceled() {
                for (var i = this.callbackInfos.length - 1; i >= 0; --i) {
                    this.callbackInfos[i] || fastRemoveAt$1(this.callbackInfos, i);
                }
                this.containCanceled = !1;
            }
        }, {
            key: "clear",
            value: function clear() {
                this.cancelAll(), this.callbackInfos.length = 0, this.isInvoking = !1, this.containCanceled = !1;
            }
        } ]), CallbackList;
    }(), callbackListPool = new Pool$1((function() {
        return new CallbackList;
    }), 16), CallbacksInvoker = function() {
        function CallbacksInvoker() {
            _classCallCheck(this, CallbacksInvoker), this._callbackTable = createMap(!0);
        }
        return _createClass(CallbacksInvoker, [ {
            key: "on",
            value: function on(key, callback, target, once) {
                var list = this._callbackTable[key];
                list || (list = this._callbackTable[key] = callbackListPool.alloc());
                var info = callbackInfoPool.alloc();
                info.set(callback, target, once), list.callbackInfos.push(info);
            }
        }, {
            key: "hasEventListener",
            value: function hasEventListener(key, callback) {
                var target = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, list = this._callbackTable[key];
                if (!list) return !1;
                var infos = list.callbackInfos;
                if (!callback) {
                    if (list.isInvoking) {
                        var _iterator = infos, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            if (_ref) return !0;
                        }
                        return !1;
                    }
                    return infos.length > 0;
                }
                var _iterator2 = infos, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var _info = _ref2;
                    if (_info && _info.callback === callback && _info.target === target) return !0;
                }
                return !1;
            }
        }, {
            key: "removeAll",
            value: function removeAll(keyOrTarget) {
                if ("string" == typeof keyOrTarget) {
                    var list = this._callbackTable[keyOrTarget];
                    list && (list.isInvoking ? list.cancelAll() : (list.clear(), callbackListPool.free(list), 
                    delete this._callbackTable[keyOrTarget]));
                } else if (keyOrTarget) for (var key in this._callbackTable) {
                    var _list = this._callbackTable[key];
                    if (_list.isInvoking) for (var infos = _list.callbackInfos, i = 0; i < infos.length; ++i) {
                        var info = infos[i];
                        info && info.target === keyOrTarget && _list.cancel(i);
                    } else _list.removeByTarget(keyOrTarget);
                }
            }
        }, {
            key: "off",
            value: function off(key, callback, target) {
                var list = this._callbackTable[key];
                if (list) {
                    var infos = list.callbackInfos;
                    if (callback) for (var i = 0; i < infos.length; ++i) {
                        var info = infos[i];
                        if (info && info.callback === callback && info.target === target) {
                            list.isInvoking ? list.cancel(i) : (fastRemoveAt$1(infos, i), callbackInfoPool.free(info));
                            break;
                        }
                    } else this.removeAll(key);
                }
            }
        }, {
            key: "emit",
            value: function emit(key) {
                var list = this._callbackTable[key];
                if (list) {
                    var rootInvoker = !list.isInvoking;
                    list.isInvoking = !0;
                    for (var infos = list.callbackInfos, _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                    for (var i = 0, len = infos.length; i < len; ++i) {
                        var info = infos[i];
                        if (info) {
                            var callback = info.callback, target = info.target;
                            info.once && this.off(key, callback, target), target ? callback.call.apply(callback, [ target ].concat(args)) : callback.apply(void 0, args);
                        }
                    }
                    rootInvoker && (list.isInvoking = !1, list.containCanceled && list.purgeCanceled());
                }
            }
        } ]), CallbacksInvoker;
    }();
    var fastRemove$1 = array.fastRemove, EventTarget = function(_CallbacksInvoker) {
        function EventTarget() {
            return _classCallCheck(this, EventTarget), _possibleConstructorReturn(this, _getPrototypeOf(EventTarget).apply(this, arguments));
        }
        return _inherits(EventTarget, _CallbacksInvoker), _createClass(EventTarget, [ {
            key: "on",
            value: function on(type, callback, target) {
                if (callback) {
                    if (!this.hasEventListener(type, callback, target)) {
                        _get(_getPrototypeOf(EventTarget.prototype), "on", this).call(this, type, callback, target);
                        var targetImpl = target;
                        target && (targetImpl.__eventTargets ? targetImpl.__eventTargets.push(this) : targetImpl.node && targetImpl.node.__eventTargets && targetImpl.node.__eventTargets.push(this));
                    }
                    return callback;
                }
                cc.errorID(6800);
            }
        }, {
            key: "off",
            value: function off(type, callback, target) {
                if (callback) {
                    _get(_getPrototypeOf(EventTarget.prototype), "off", this).call(this, type, callback, target);
                    var targetImpl = target;
                    target && (targetImpl.__eventTargets ? fastRemove$1(targetImpl.__eventTargets, this) : targetImpl.node && targetImpl.node.__eventTargets && fastRemove$1(targetImpl.node.__eventTargets, this));
                } else this.removeAll(type);
            }
        }, {
            key: "targetOff",
            value: function targetOff(keyOrTarget) {
                this.removeAll(keyOrTarget);
            }
        }, {
            key: "once",
            value: function once(type, callback, target) {
                if (callback) {
                    if (!this.hasEventListener(type, callback, target)) {
                        _get(_getPrototypeOf(EventTarget.prototype), "on", this).call(this, type, callback, target, !0);
                        var targetImpl = target;
                        target && (targetImpl.__eventTargets ? targetImpl.__eventTargets.push(this) : targetImpl.node && targetImpl.node.__eventTargets && targetImpl.node.__eventTargets.push(this));
                    }
                    return callback;
                }
                cc.errorID(6800);
            }
        } ]), EventTarget;
    }(CallbacksInvoker);
    function applyMixins(derivedCtor, baseCtors) {
        baseCtors.forEach((function(baseCtor) {
            Object.getOwnPropertyNames(baseCtor.prototype).forEach((function(name) {
                "constructor" !== name && Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
            }));
        }));
    }
    cc.EventTarget = EventTarget;
    var objectsToDestroy = [];
    var _class$1, CCObject = function() {
        function CCObject() {
            var name = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            _classCallCheck(this, CCObject), this._name = name, this._objFlags = 0;
        }
        return _createClass(CCObject, null, [ {
            key: "_deferredDestroy",
            value: function _deferredDestroy() {
                for (var deleteCount = objectsToDestroy.length, i = 0; i < deleteCount; ++i) {
                    var obj = objectsToDestroy[i];
                    1 & obj._objFlags || obj._destroyImmediate();
                }
                deleteCount === objectsToDestroy.length ? objectsToDestroy.length = 0 : objectsToDestroy.splice(0, deleteCount);
            }
        } ]), _createClass(CCObject, [ {
            key: "destroy",
            value: function destroy() {
                return 1 & this._objFlags ? (warnID(5e3), !1) : !(4 & this._objFlags) && (this._objFlags |= 4, 
                objectsToDestroy.push(this), !0);
            }
        }, {
            key: "_destruct",
            value: function _destruct() {
                var ctor = this.constructor, destruct = ctor.__destruct__;
                destruct || (destruct = function compileDestruct(obj, ctor) {
                    var key, shouldSkipId = obj instanceof cc._BaseNode || obj instanceof cc.Component, idToSkip = shouldSkipId ? "_id" : null, propsToReset = {};
                    for (key in obj) if (obj.hasOwnProperty(key)) {
                        if (key === idToSkip) continue;
                        switch (_typeof(obj[key])) {
                          case "string":
                            propsToReset[key] = "";
                            break;

                          case "object":
                          case "function":
                            propsToReset[key] = null;
                        }
                    }
                    if (CCClass._isCCClass(ctor)) for (var attrs = cc.Class.Attr.getClassAttrs(ctor), propList = ctor.__props__, i = 0; i < propList.length; i++) {
                        var attrKey = (key = propList[i]) + cc.Class.Attr.DELIMETER + "default";
                        if (attrKey in attrs) {
                            if (shouldSkipId && "_id" === key) continue;
                            switch (_typeof(attrs[attrKey])) {
                              case "string":
                                propsToReset[key] = "";
                                break;

                              case "object":
                              case "function":
                                propsToReset[key] = null;
                                break;

                              case "undefined":
                                propsToReset[key] = void 0;
                            }
                        }
                    }
                    return function(o) {
                        for (var _key in propsToReset) o[_key] = propsToReset[_key];
                    };
                }(this, ctor), value(ctor, "__destruct__", destruct, !0)), destruct(this);
            }
        }, {
            key: "_destroyImmediate",
            value: function _destroyImmediate() {
                1 & this._objFlags ? errorID(5e3) : (this._onPreDestroy && this._onPreDestroy(), 
                this._destruct(), this._objFlags |= 1);
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            },
            set: function set(value) {
                this._name = value;
            }
        }, {
            key: "isValid",
            get: function get() {
                return !(1 & this._objFlags);
            }
        } ]), CCObject;
    }(), prototype = CCObject.prototype;
    function isValid(value, strictMode) {
        return "object" === _typeof(value) ? !(!value || value._objFlags & (strictMode ? 5 : 1)) : void 0 !== value;
    }
    prototype._deserialize = null, prototype._onPreDestroy = null, CCClass.fastDefine("cc.Object", CCObject, {
        _name: "",
        _objFlags: 0
    }), value(CCObject, "Flags", {
        Destroyed: 1,
        DontSave: 8,
        EditorOnly: 16,
        Dirty: 32,
        DontDestroy: 64,
        PersistentMask: -4192741,
        Destroying: 128,
        Deactivating: 256,
        LockedInEditor: 512,
        HideInHierarchy: 1024,
        IsPreloadStarted: 8192,
        IsOnLoadStarted: 32768,
        IsOnLoadCalled: 16384,
        IsOnEnableCalled: 2048,
        IsStartCalled: 65536,
        IsEditorOnEnableCalled: 4096,
        IsPositionLocked: 1 << 21,
        IsRotationLocked: 1 << 17,
        IsScaleLocked: 1 << 18,
        IsAnchorLocked: 1 << 19,
        IsSizeLocked: 1 << 20
    }), cc.isValid = isValid, cc.Object = CCObject;
    var _dec$2, _dec2, _class$2, _class2$1, _descriptor$1, _class3, _temp$1, RawAsset = ccclass("cc.RawAsset")(_class$1 = function(_CCObject) {
        function RawAsset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, RawAsset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RawAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), 
            Object.defineProperty(_assertThisInitialized(_this), "_uuid", {
                value: "",
                writable: !0
            }), _this;
        }
        return _inherits(RawAsset, _CCObject), _createClass(RawAsset, null, [ {
            key: "isRawAssetType",
            value: function isRawAssetType(ctor) {
                return isChildClassOf(ctor, cc.RawAsset) && !isChildClassOf(ctor, cc.Asset);
            }
        } ]), RawAsset;
    }(CCObject)) || _class$1;
    cc.RawAsset = RawAsset;
    var Asset = (_dec$2 = ccclass("cc.Asset"), _dec2 = property({
        visible: !1
    }), _dec$2((_temp$1 = _class3 = function(_RawAsset) {
        function Asset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Asset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Asset)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).loaded = !0, 
            _initializerDefineProperty(_this, "_native", _descriptor$1, _assertThisInitialized(_this)), 
            _this._file = null, _this._callbackTable = createMap(!0), _this;
        }
        return _inherits(Asset, _RawAsset), _createClass(Asset, null, [ {
            key: "deserialize",
            value: function deserialize(data) {
                return cc.deserialize(data);
            }
        } ]), _createClass(Asset, [ {
            key: "on",
            value: function on(type, callback, target) {}
        }, {
            key: "off",
            value: function off(type, callback, target) {}
        }, {
            key: "targetOff",
            value: function targetOff(keyOrTarget) {}
        }, {
            key: "once",
            value: function once(type, callback, target) {}
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {}
        }, {
            key: "hasEventListener",
            value: function hasEventListener(key, callback, target) {
                return !1;
            }
        }, {
            key: "removeAll",
            value: function removeAll(keyOrTarget) {}
        }, {
            key: "emit",
            value: function emit(key) {}
        }, {
            key: "toString",
            value: function toString() {
                return this.nativeUrl;
            }
        }, {
            key: "_setRawAsset",
            value: function _setRawAsset(filename) {
                var inLibrary = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this._native = !1 !== inLibrary ? filename || "" : "/" + filename;
            }
        }, {
            key: "nativeUrl",
            get: function get() {
                if (this._native) {
                    var name = this._native;
                    if (47 === name.charCodeAt(0)) return name.slice(1);
                    if (cc.AssetLibrary) {
                        var base = cc.AssetLibrary.getLibUrlNoExt(this._uuid, !0);
                        return 46 === name.charCodeAt(0) ? base + name : base + "/" + name;
                    }
                    cc.errorID(6400);
                }
                return "";
            }
        }, {
            key: "_nativeAsset",
            get: function get() {
                return this._file;
            },
            set: function set(obj) {
                this._file = obj;
            }
        } ]), Asset;
    }(RawAsset), _class3.preventDeferredLoadDependents = !1, _class3.preventPreloadNativeObject = !1, 
    _descriptor$1 = _applyDecoratedDescriptor((_class2$1 = _temp$1).prototype, "_native", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _applyDecoratedDescriptor(_class2$1.prototype, "nativeUrl", [ _dec2 ], Object.getOwnPropertyDescriptor(_class2$1.prototype, "nativeUrl"), _class2$1.prototype), 
    _applyDecoratedDescriptor(_class2$1.prototype, "_nativeAsset", [ property ], Object.getOwnPropertyDescriptor(_class2$1.prototype, "_nativeAsset"), _class2$1.prototype), 
    _class$2 = _class2$1)) || _class$2);
    applyMixins(Asset, [ CallbacksInvoker, EventTarget ]), Asset.prototype.createNode = null, 
    cc.Asset = Asset;
    var buffer, _class$3, _class2$2, _descriptor$2, _descriptor2$1, _descriptor3$1, sys = {}, _global$1 = "undefined" == typeof window ? global : window;
    if (sys.LANGUAGE_ENGLISH = "en", sys.LANGUAGE_CHINESE = "zh", sys.LANGUAGE_FRENCH = "fr", 
    sys.LANGUAGE_ITALIAN = "it", sys.LANGUAGE_GERMAN = "de", sys.LANGUAGE_SPANISH = "es", 
    sys.LANGUAGE_DUTCH = "du", sys.LANGUAGE_RUSSIAN = "ru", sys.LANGUAGE_KOREAN = "ko", 
    sys.LANGUAGE_JAPANESE = "ja", sys.LANGUAGE_HUNGARIAN = "hu", sys.LANGUAGE_PORTUGUESE = "pt", 
    sys.LANGUAGE_ARABIC = "ar", sys.LANGUAGE_NORWEGIAN = "no", sys.LANGUAGE_POLISH = "pl", 
    sys.LANGUAGE_TURKISH = "tr", sys.LANGUAGE_UKRAINIAN = "uk", sys.LANGUAGE_ROMANIAN = "ro", 
    sys.LANGUAGE_BULGARIAN = "bg", sys.LANGUAGE_UNKNOWN = "unknown", sys.OS_IOS = "iOS", 
    sys.OS_ANDROID = "Android", sys.OS_WINDOWS = "Windows", sys.OS_MARMALADE = "Marmalade", 
    sys.OS_LINUX = "Linux", sys.OS_BADA = "Bada", sys.OS_BLACKBERRY = "Blackberry", 
    sys.OS_OSX = "OS X", sys.OS_WP8 = "WP8", sys.OS_WINRT = "WINRT", sys.OS_UNKNOWN = "Unknown", 
    sys.UNKNOWN = -1, sys.WIN32 = 0, sys.LINUX = 1, sys.MACOS = 2, sys.ANDROID = 3, 
    sys.IPHONE = 4, sys.IPAD = 5, sys.BLACKBERRY = 6, sys.NACL = 7, sys.EMSCRIPTEN = 8, 
    sys.TIZEN = 9, sys.WINRT = 10, sys.WP8 = 11, sys.MOBILE_BROWSER = 100, sys.DESKTOP_BROWSER = 101, 
    sys.EDITOR_PAGE = 102, sys.EDITOR_CORE = 103, sys.WECHAT_GAME = 104, sys.QQ_PLAY = 105, 
    sys.BROWSER_TYPE_WECHAT = "wechat", sys.BROWSER_TYPE_WECHAT_GAME = "wechatgame", 
    sys.BROWSER_TYPE_ALIPAY_GAME = "alipaygame", sys.BROWSER_TYPE_XIAOMI_GAME = "xiaomiquickgame", 
    sys.BROWSER_TYPE_BAIDU_GAME = "baidugame", sys.BROWSER_TYPE_COCOSPLAY = "cocosplay", 
    sys.BROWSER_TYPE_ANDROID = "androidbrowser", sys.BROWSER_TYPE_IE = "ie", sys.BROWSER_TYPE_QQ = "qqbrowser", 
    sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser", sys.BROWSER_TYPE_UC = "ucbrowser", sys.BROWSER_TYPE_UCBS = "ucbs", 
    sys.BROWSER_TYPE_360 = "360browser", sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp", 
    sys.BROWSER_TYPE_BAIDU = "baidubrowser", sys.BROWSER_TYPE_MAXTHON = "maxthon", sys.BROWSER_TYPE_OPERA = "opera", 
    sys.BROWSER_TYPE_OUPENG = "oupeng", sys.BROWSER_TYPE_MIUI = "miuibrowser", sys.BROWSER_TYPE_FIREFOX = "firefox", 
    sys.BROWSER_TYPE_SAFARI = "safari", sys.BROWSER_TYPE_CHROME = "chrome", sys.BROWSER_TYPE_LIEBAO = "liebao", 
    sys.BROWSER_TYPE_QZONE = "qzone", sys.BROWSER_TYPE_SOUGOU = "sogou", sys.BROWSER_TYPE_UNKNOWN = "unknown", 
    sys.isNative = !0, sys.isBrowser = "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && "object" === ("undefined" == typeof document ? "undefined" : _typeof(document)) && !1, 
    sys.isLittleEndian = (buffer = new ArrayBuffer(2), new DataView(buffer).setInt16(0, 256, !0), 
    256 === new Int16Array(buffer)[0]), _global$1.__globalAdapter && _global$1.__globalAdapter.adaptSys) _global$1.__globalAdapter.adaptSys(sys); else {
        var platform = sys.platform = __getPlatform();
        sys.isMobile = platform === sys.ANDROID || platform === sys.IPAD || platform === sys.IPHONE || platform === sys.WP8 || platform === sys.TIZEN || platform === sys.BLACKBERRY, 
        sys.os = __getOS(), sys.language = __getCurrentLanguage(), sys.osVersion = __getOSVersion(), 
        sys.osMainVersion = parseInt(sys.osVersion), sys.browserType = null, sys.browserVersion = null;
        var capabilities, w = window.innerWidth, h = window.innerHeight, ratio = window.devicePixelRatio || 1;
        sys.windowPixelResolution = {
            width: ratio * w,
            height: ratio * h
        }, sys.localStorage = window.localStorage, capabilities = sys.capabilities = {
            canvas: !1,
            opengl: !0,
            webp: !0
        }, sys.isMobile ? (capabilities.accelerometer = !0, capabilities.touches = !0) : (capabilities.keyboard = !0, 
        capabilities.mouse = !0, capabilities.touches = !1), sys.__audioSupport = {
            ONLY_ONE: !1,
            WEB_AUDIO: !1,
            DELAY_CREATE_CTX: !1,
            format: [ ".mp3" ]
        };
    }
    function getIndexStrideCtor(stride) {
        switch (stride) {
          case 1:
            return Uint8Array;

          case 2:
            return Uint16Array;

          case 4:
            return Uint32Array;
        }
        return Uint8Array;
    }
    sys.NetworkType = {
        NONE: 0,
        LAN: 1,
        WWAN: 2
    }, sys.getNetworkType = function() {
        return sys.NetworkType.LAN;
    }, sys.getBatteryLevel = function() {
        return 1;
    }, sys.garbageCollect = function() {}, sys.dumpRoot = function() {}, sys.restartVM = function() {}, 
    sys.cleanScript = function(jsfile) {}, sys.isObjectValid = function(obj) {
        return !!obj;
    }, sys.dump = function() {
        var str = "";
        str += "isMobile : " + this.isMobile + "\r\n", str += "language : " + this.language + "\r\n", 
        str += "browserType : " + this.browserType + "\r\n", str += "browserVersion : " + this.browserVersion + "\r\n", 
        str += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n", str += "os : " + this.os + "\r\n", 
        str += "osVersion : " + this.osVersion + "\r\n", str += "platform : " + this.platform + "\r\n", 
        str += "Using " + (cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n", 
        cc.log(str);
    }, sys.openURL = function(url) {
        jsb.openURL(url);
    }, sys.now = function() {
        return Date.now ? Date.now() : +new Date;
    }, cc.sys = sys;
    var RenderingMesh = function() {
        function RenderingMesh(_subMeshes) {
            _classCallCheck(this, RenderingMesh), this._subMeshes = _subMeshes;
        }
        return _createClass(RenderingMesh, [ {
            key: "getSubmesh",
            value: function getSubmesh(index) {
                return this._subMeshes[index];
            }
        }, {
            key: "destroySubMeshes",
            value: function destroySubMeshes() {
                for (var i = 0; i < this._subMeshes.length; ++i) {
                    for (var subMesh = this._subMeshes[i], j = 0; j < subMesh.vertexBuffers.length; ++j) subMesh.vertexBuffers[j].destroy();
                    subMesh.indexBuffer && subMesh.indexBuffer.destroy();
                }
                this._subMeshes.splice(0);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.destroySubMeshes(), this._subMeshes.length = 0;
            }
        }, {
            key: "subMeshes",
            get: function get() {
                return this._subMeshes;
            }
        }, {
            key: "subMeshCount",
            get: function get() {
                return this._subMeshes.length;
            }
        } ]), RenderingMesh;
    }(), Mesh = ccclass("cc.Mesh")((_descriptor$2 = _applyDecoratedDescriptor((_class2$2 = function(_Asset) {
        function Mesh() {
            var _this;
            return _classCallCheck(this, Mesh), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Mesh).call(this)), "_struct", _descriptor$2, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_dataLength", _descriptor2$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_hash", _descriptor3$1, _assertThisInitialized(_this)), 
            _this._data = null, _this._initialized = !1, _this._hasFlatBuffers = !1, _this._renderingMesh = null, 
            _this.loaded = !1, _this;
        }
        return _inherits(Mesh, _Asset), _createClass(Mesh, [ {
            key: "_nativeAsset",
            get: function get() {
                return this._data.buffer;
            },
            set: function set(value) {
                this._data && this._data.byteLength === value.byteLength ? (this._data.set(new Uint8Array(value)), 
                cc.loader._cache[this.nativeUrl] && (cc.loader._cache[this.nativeUrl].content = this._data.buffer)) : this._data = new Uint8Array(value), 
                this.loaded = !0, this.emit("load");
            }
        }, {
            key: "subMeshCount",
            get: function get() {
                var renderingMesh = this.renderingMesh;
                return renderingMesh ? renderingMesh.subMeshCount : 0;
            }
        }, {
            key: "minPosition",
            get: function get() {
                return this.struct.minPosition;
            }
        }, {
            key: "maxPosition",
            get: function get() {
                return this.struct.maxPosition;
            }
        }, {
            key: "struct",
            get: function get() {
                return this._struct;
            }
        }, {
            key: "data",
            get: function get() {
                return this._data;
            }
        }, {
            key: "hash",
            get: function get() {
                return !this._hash && this._data && (this._hash = murmurhash2_32_gc(this._data, 666)), 
                this._hash;
            }
        }, {
            key: "hasFlatBuffers",
            get: function get() {
                return this._hasFlatBuffers;
            }
        } ]), _createClass(Mesh, [ {
            key: "initialize",
            value: function initialize() {
                var _this2 = this;
                if (!this._initialized) {
                    this._initialized = !0, this._data || (this._data = new Uint8Array(this._dataLength), 
                    function postLoadMesh(mesh, callback) {
                        mesh.loaded ? callback && callback() : mesh.nativeUrl ? cc.loader.load({
                            url: mesh.nativeUrl
                        }, (function(err, arrayBuffer) {
                            arrayBuffer && (mesh.loaded || (mesh._nativeAsset = arrayBuffer)), callback && callback(err);
                        })) : callback && callback();
                    }(this));
                    var buffer = this._data.buffer, gfxDevice = cc.director.root.device, vertexBuffers = this._createVertexBuffers(gfxDevice, buffer), submeshes = [], _loop2 = function _loop2() {
                        if (_isArray) {
                            if (_i >= _iterator.length) return "break";
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) return "break";
                            _ref = _i.value;
                        }
                        var prim = _ref;
                        if (0 === prim.vertexBundelIndices.length) return "continue";
                        var indexBuffer = null, ib = null;
                        if (prim.indexView) {
                            var idxView = prim.indexView, dstStride = idxView.stride, dstSize = idxView.length;
                            if (4 === dstStride && !gfxDevice.hasFeature(exports.GFXFeature.ELEMENT_INDEX_UINT)) {
                                var vertexCount = _this2._struct.vertexBundles[prim.vertexBundelIndices[0]].view.count;
                                if (vertexCount >= 65536) return warnID(10001, vertexCount, 65536), "continue";
                                dstStride >>= 1, dstSize >>= 1;
                            }
                            indexBuffer = gfxDevice.createBuffer({
                                usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                                size: dstSize,
                                stride: dstStride
                            }), ib = new (getIndexStrideCtor(idxView.stride))(buffer, idxView.offset, idxView.count), 
                            idxView.stride !== dstStride && (ib = getIndexStrideCtor(dstStride).from(ib)), _this2.loaded ? indexBuffer.update(ib) : _this2.once("load", (function() {
                                indexBuffer.update(ib);
                            }));
                        }
                        var vbReference = prim.vertexBundelIndices.map((function(i) {
                            return vertexBuffers[i];
                        })), gfxAttributes = [];
                        if (prim.vertexBundelIndices.length > 0) {
                            var idx = prim.vertexBundelIndices[0];
                            gfxAttributes = _this2._struct.vertexBundles[idx].attributes;
                        }
                        var subMesh = {
                            primitiveMode: prim.primitiveMode,
                            vertexBuffers: vbReference,
                            flatBuffers: [],
                            indexBuffer: indexBuffer,
                            attributes: gfxAttributes
                        };
                        if (prim.geometricInfo) {
                            var info = prim.geometricInfo, positions = new Float32Array(buffer, info.view.offset, info.view.length / 4);
                            subMesh.geometricInfo = {
                                indices: ib,
                                positions: positions
                            };
                        }
                        submeshes.push(subMesh);
                    };
                    var _iterator = this._struct.primitives, _isArray = Array.isArray(_iterator), _i = 0;
                    _loop: for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        switch (_loop2()) {
                          case "break":
                            break _loop;

                          case "continue":
                            continue;
                        }
                    }
                    this._renderingMesh = new RenderingMesh(submeshes);
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this.destroyRenderingMesh(), cc.director.root.dataPoolManager.releaseMesh(this), 
                _get(_getPrototypeOf(Mesh.prototype), "destroy", this).call(this);
            }
        }, {
            key: "destroyRenderingMesh",
            value: function destroyRenderingMesh() {
                this._renderingMesh && (this._renderingMesh.destroy(), this._renderingMesh = null, 
                this._data = null, this._initialized = !1);
            }
        }, {
            key: "assign",
            value: function assign(struct, data) {
                this.reset({
                    struct: struct,
                    data: data
                });
            }
        }, {
            key: "reset",
            value: function reset(info) {
                this.destroyRenderingMesh(), this._struct = info.struct, this._data = info.data, 
                this._hash = 0, this.loaded = !0, this.emit("load");
            }
        }, {
            key: "getSubMesh",
            value: function getSubMesh(index) {
                return this.renderingMesh.getSubmesh(index);
            }
        }, {
            key: "merge",
            value: function merge(mesh, worldMatrix, validate) {
                if (void 0 !== validate && validate && (!this.loaded || !mesh.loaded || !this.validateMergingMesh(mesh))) return !1;
                var vec3_temp = new Vec3, rotate = worldMatrix && new Quat, boundingBox = worldMatrix && new aabb;
                if (rotate && worldMatrix.getRotation(rotate), !this._initialized && mesh._data) {
                    var struct = JSON.parse(JSON.stringify(mesh._struct)), data = mesh._data.slice();
                    if (worldMatrix) {
                        struct.maxPosition && struct.minPosition && (Vec3.add(boundingBox.center, struct.maxPosition, struct.minPosition), 
                        Vec3.multiplyScalar(boundingBox.center, boundingBox.center, .5), Vec3.subtract(boundingBox.halfExtents, struct.maxPosition, struct.minPosition), 
                        Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, .5), aabb.transform(boundingBox, boundingBox, worldMatrix), 
                        Vec3.add(struct.maxPosition, boundingBox.center, boundingBox.halfExtents), Vec3.subtract(struct.minPosition, boundingBox.center, boundingBox.halfExtents));
                        for (var i = 0; i < struct.vertexBundles.length; i++) for (var vtxBdl = struct.vertexBundles[i], j = 0; j < vtxBdl.attributes.length; j++) if (vtxBdl.attributes[j].name === exports.GFXAttributeName.ATTR_POSITION || vtxBdl.attributes[j].name === exports.GFXAttributeName.ATTR_NORMAL) {
                            var format = vtxBdl.attributes[j].format, inputView = new DataView(data.buffer, vtxBdl.view.offset + getOffset(vtxBdl.attributes, j)), reader = getReader(inputView, format), writer = getWriter(inputView, format);
                            if (!reader || !writer) continue;
                            for (var vertexCount = vtxBdl.view.count, vertexStride = vtxBdl.view.stride, attrComponentByteLength = getComponentByteLength(format), vtxIdx = 0; vtxIdx < vertexCount; vtxIdx++) {
                                var xOffset = vtxIdx * vertexStride, yOffset = xOffset + attrComponentByteLength, zOffset = yOffset + attrComponentByteLength;
                                switch (vec3_temp.set(reader(xOffset), reader(yOffset), reader(zOffset)), vtxBdl.attributes[j].name) {
                                  case exports.GFXAttributeName.ATTR_POSITION:
                                    vec3_temp.transformMat4(worldMatrix);
                                    break;

                                  case exports.GFXAttributeName.ATTR_NORMAL:
                                    Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                                }
                                writer(xOffset, vec3_temp.x), writer(yOffset, vec3_temp.y), writer(zOffset, vec3_temp.z);
                            }
                        }
                    }
                    return this.reset({
                        struct: struct,
                        data: data
                    }), this.initialize(), !0;
                }
                for (var vb, vbView, srcVBView, dstVBView, dstAttrView, bufferBlob = new BufferBlob, vertCount = 0, vertStride = 0, srcOffset = 0, dstOffset = 0, srcAttrOffset = 0, srcVBOffset = 0, dstVBOffset = 0, attrSize = 0, hasAttr = !1, vertexBundles = new Array(this._struct.vertexBundles.length), _i2 = 0; _i2 < this._struct.vertexBundles.length; ++_i2) {
                    var bundle = this._struct.vertexBundles[_i2], dstBundle = mesh._struct.vertexBundles[_i2];
                    srcOffset = bundle.view.offset, dstOffset = dstBundle.view.offset, vertStride = bundle.view.stride, 
                    vertCount = bundle.view.count + dstBundle.view.count, vb = new ArrayBuffer(vertCount * vertStride), 
                    vbView = new Uint8Array(vb), srcOffset += (srcVBView = this._data.subarray(srcOffset, srcOffset + bundle.view.length)).length, 
                    dstOffset += (dstVBView = mesh._data.subarray(dstOffset, dstOffset + dstBundle.view.length)).length, 
                    vbView.set(srcVBView), srcAttrOffset = 0;
                    var _iterator2 = bundle.attributes, _isArray2 = Array.isArray(_iterator2), _i3 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i3 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i3++];
                        } else {
                            if ((_i3 = _iterator2.next()).done) break;
                            _ref2 = _i3.value;
                        }
                        var attr = _ref2;
                        dstVBOffset = 0, hasAttr = !1;
                        var _iterator3 = dstBundle.attributes, _isArray3 = Array.isArray(_iterator3), _i4 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i4 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i4++];
                            } else {
                                if ((_i4 = _iterator3.next()).done) break;
                                _ref3 = _i4.value;
                            }
                            var dstAttr = _ref3;
                            if (attr.name === dstAttr.name && attr.format === dstAttr.format) {
                                hasAttr = !0;
                                break;
                            }
                            dstVBOffset += GFXFormatInfos[dstAttr.format].size;
                        }
                        if (hasAttr) {
                            attrSize = GFXFormatInfos[attr.format].size, srcVBOffset = bundle.view.length + srcAttrOffset;
                            for (var v = 0; v < dstBundle.view.count; ++v) {
                                if (dstAttrView = dstVBView.subarray(dstVBOffset, dstVBOffset + attrSize), vbView.set(dstAttrView, srcVBOffset), 
                                (attr.name === exports.GFXAttributeName.ATTR_POSITION || attr.name === exports.GFXAttributeName.ATTR_NORMAL) && worldMatrix) {
                                    var f32_temp = new Float32Array(vbView.buffer, srcVBOffset, 3);
                                    switch (vec3_temp.set(f32_temp[0], f32_temp[1], f32_temp[2]), attr.name) {
                                      case exports.GFXAttributeName.ATTR_POSITION:
                                        vec3_temp.transformMat4(worldMatrix);
                                        break;

                                      case exports.GFXAttributeName.ATTR_NORMAL:
                                        Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                                    }
                                    f32_temp[0] = vec3_temp.x, f32_temp[1] = vec3_temp.y, f32_temp[2] = vec3_temp.z;
                                }
                                srcVBOffset += bundle.view.stride, dstVBOffset += dstBundle.view.stride;
                            }
                        }
                        srcAttrOffset += GFXFormatInfos[attr.format].size;
                    }
                    vertexBundles[_i2] = {
                        attributes: bundle.attributes,
                        view: {
                            offset: bufferBlob.getLength(),
                            length: vb.byteLength,
                            count: vertCount,
                            stride: vertStride
                        }
                    }, bufferBlob.addBuffer(vb);
                }
                for (var ibView, srcIBView, dstIBView, idxCount = 0, idxStride = 2, vertBatchCount = 0, primitives = new Array(this._struct.primitives.length), _i5 = 0; _i5 < this._struct.primitives.length; ++_i5) {
                    var prim = this._struct.primitives[_i5], dstPrim = mesh._struct.primitives[_i5];
                    primitives[_i5] = {
                        primitiveMode: prim.primitiveMode,
                        vertexBundelIndices: prim.vertexBundelIndices
                    };
                    var _iterator4 = prim.vertexBundelIndices, _isArray4 = Array.isArray(_iterator4), _i6 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i6 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i6++];
                        } else {
                            if ((_i6 = _iterator4.next()).done) break;
                            _ref4 = _i6.value;
                        }
                        var bundleIdx = _ref4;
                        vertBatchCount = Math.max(vertBatchCount, this._struct.vertexBundles[bundleIdx].view.count);
                    }
                    if (prim.indexView && dstPrim.indexView) {
                        idxCount = prim.indexView.count, idxCount += dstPrim.indexView.count, srcOffset = prim.indexView.offset, 
                        dstOffset = dstPrim.indexView.offset, idxStride = idxCount < 256 ? 1 : idxCount < 65536 ? 2 : 4;
                        var ib = new ArrayBuffer(idxCount * idxStride);
                        if (ibView = 2 === idxStride ? new Uint16Array(ib) : 1 === idxStride ? new Uint8Array(ib) : new Uint32Array(ib), 
                        srcIBView = 2 === prim.indexView.stride ? new Uint16Array(this._data.buffer, srcOffset, prim.indexView.count) : 1 === prim.indexView.stride ? new Uint8Array(this._data.buffer, srcOffset, prim.indexView.count) : new Uint32Array(this._data.buffer, srcOffset, prim.indexView.count), 
                        idxStride === prim.indexView.stride) ibView.set(srcIBView); else for (var n = 0; n < prim.indexView.count; ++n) ibView[n] = srcIBView[n];
                        srcOffset += prim.indexView.length, dstIBView = 2 === dstPrim.indexView.stride ? new Uint16Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count) : 1 === dstPrim.indexView.stride ? new Uint8Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count) : new Uint32Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                        for (var _n = 0; _n < dstPrim.indexView.count; ++_n) ibView[prim.indexView.count + _n] = vertBatchCount + dstIBView[_n];
                        dstOffset += dstPrim.indexView.length, primitives[_i5].indexView = {
                            offset: bufferBlob.getLength(),
                            length: ib.byteLength,
                            count: idxCount,
                            stride: idxStride
                        }, bufferBlob.setNextAlignment(idxStride), bufferBlob.addBuffer(ib);
                    }
                    if (prim.geometricInfo && dstPrim.geometricInfo) {
                        var geomBuffSize = prim.geometricInfo.view.length + dstPrim.geometricInfo.view.length, geomBuff = new ArrayBuffer(geomBuffSize), geomBuffView = new Uint8Array(geomBuff), srcView = new Uint8Array(this._data.buffer, prim.geometricInfo.view.offset, prim.geometricInfo.view.length), dstView = new Uint8Array(mesh._data.buffer, dstPrim.geometricInfo.view.offset, dstPrim.geometricInfo.view.length);
                        geomBuffView.set(srcView), geomBuffView.set(dstView, srcView.length), bufferBlob.setNextAlignment(4), 
                        primitives[_i5].geometricInfo = {
                            doubleSided: prim.geometricInfo.doubleSided,
                            view: {
                                offset: bufferBlob.getLength(),
                                length: geomBuffView.length,
                                count: prim.geometricInfo.view.count + dstPrim.geometricInfo.view.count,
                                stride: prim.geometricInfo.view.stride
                            }
                        }, bufferBlob.addBuffer(geomBuff);
                    }
                }
                var meshStruct = {
                    vertexBundles: vertexBundles,
                    primitives: primitives,
                    minPosition: this._struct.minPosition,
                    maxPosition: this._struct.maxPosition
                };
                return meshStruct.minPosition && mesh._struct.minPosition && meshStruct.maxPosition && mesh._struct.maxPosition && (worldMatrix ? (Vec3.add(boundingBox.center, mesh._struct.maxPosition, mesh._struct.minPosition), 
                Vec3.multiplyScalar(boundingBox.center, boundingBox.center, .5), Vec3.subtract(boundingBox.halfExtents, mesh._struct.maxPosition, mesh._struct.minPosition), 
                Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, .5), aabb.transform(boundingBox, boundingBox, worldMatrix), 
                Vec3.add(vec3_temp, boundingBox.center, boundingBox.halfExtents), Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, vec3_temp), 
                Vec3.subtract(vec3_temp, boundingBox.center, boundingBox.halfExtents), Vec3.min(meshStruct.minPosition, meshStruct.minPosition, vec3_temp)) : (Vec3.min(meshStruct.minPosition, meshStruct.minPosition, mesh._struct.minPosition), 
                Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, mesh._struct.maxPosition))), 
                this.reset({
                    struct: meshStruct,
                    data: new Uint8Array(bufferBlob.getCombined())
                }), this.initialize(), !0;
            }
        }, {
            key: "validateMergingMesh",
            value: function validateMergingMesh(mesh) {
                if (!this._data && mesh._data) return !0;
                if (this._struct.vertexBundles.length !== mesh._struct.vertexBundles.length) return !1;
                for (var i = 0; i < this._struct.vertexBundles.length; ++i) {
                    var bundle = this._struct.vertexBundles[i], dstBundle = mesh._struct.vertexBundles[i];
                    if (bundle.attributes.length !== dstBundle.attributes.length) return !1;
                    for (var j = 0; j < bundle.attributes.length; ++j) if (bundle.attributes[j].format !== dstBundle.attributes[j].format) return !1;
                }
                if (this._struct.primitives.length !== mesh._struct.primitives.length) return !1;
                for (var _i7 = 0; _i7 < this._struct.primitives.length; ++_i7) {
                    var prim = this._struct.primitives[_i7], dstPrim = mesh._struct.primitives[_i7];
                    if (prim.vertexBundelIndices.length !== dstPrim.vertexBundelIndices.length) return !1;
                    for (var _j = 0; _j < prim.vertexBundelIndices.length; ++_j) if (prim.vertexBundelIndices[_j] !== dstPrim.vertexBundelIndices[_j]) return !1;
                    if (prim.primitiveMode !== dstPrim.primitiveMode) return !1;
                    if (prim.indexView) {
                        if (void 0 === dstPrim.indexView) return !1;
                    } else if (dstPrim.indexView) return !1;
                }
                return !0;
            }
        }, {
            key: "readAttribute",
            value: function readAttribute(primitiveIndex, attributeName) {
                var _this3 = this, result = null;
                return this._accessAttribute(primitiveIndex, attributeName, (function(vertexBundle, iAttribute) {
                    var format = vertexBundle.attributes[iAttribute].format, inputView = new DataView(_this3._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute)), formatInfo = GFXFormatInfos[format], storageConstructor = getStorageConstructor(format), reader = getReader(inputView, format);
                    if (storageConstructor && reader) {
                        for (var vertexCount = vertexBundle.view.count, componentCount = formatInfo.count, storage = new storageConstructor(vertexCount * componentCount), inputStride = vertexBundle.view.stride, iVertex = 0; iVertex < vertexCount; ++iVertex) for (var iComponent = 0; iComponent < componentCount; ++iComponent) storage[componentCount * iVertex + iComponent] = reader(inputStride * iVertex + storage.BYTES_PER_ELEMENT * iComponent);
                        result = storage;
                    }
                })), result;
            }
        }, {
            key: "copyAttribute",
            value: function copyAttribute(primitiveIndex, attributeName, buffer, stride, offset) {
                var _this4 = this, written = !1;
                return this._accessAttribute(primitiveIndex, attributeName, (function(vertexBundle, iAttribute) {
                    var format = vertexBundle.attributes[iAttribute].format, inputView = new DataView(_this4._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute)), outputView = new DataView(buffer, offset), formatInfo = GFXFormatInfos[format], reader = getReader(inputView, format), writer = getWriter(outputView, format);
                    if (reader && writer) {
                        for (var vertexCount = vertexBundle.view.count, componentCount = formatInfo.count, inputStride = vertexBundle.view.stride, inputComponentByteLength = getComponentByteLength(format), outputStride = stride, outputComponentByteLength = inputComponentByteLength, iVertex = 0; iVertex < vertexCount; ++iVertex) for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                            writer(outputStride * iVertex + outputComponentByteLength * iComponent, reader(inputStride * iVertex + inputComponentByteLength * iComponent));
                        }
                        written = !0;
                    }
                })), written;
            }
        }, {
            key: "readIndices",
            value: function readIndices(primitiveIndex) {
                if (!this._data || primitiveIndex >= this._struct.primitives.length) return null;
                var primitive = this._struct.primitives[primitiveIndex];
                if (!primitive.indexView) return null;
                for (var indexCount = primitive.indexView.count, indexFormat = indexCount < 256 ? exports.GFXFormat.R8UI : indexCount < 65536 ? exports.GFXFormat.R16UI : exports.GFXFormat.R32UI, storage = new (getStorageConstructor(indexFormat))(indexCount), reader = getReader(new DataView(this._data.buffer), indexFormat), i = 0; i < indexCount; ++i) storage[i] = reader(primitive.indexView.offset + storage.BYTES_PER_ELEMENT * i);
                return storage;
            }
        }, {
            key: "copyIndices",
            value: function copyIndices(primitiveIndex, outputArray) {
                if (!this._data || primitiveIndex >= this._struct.primitives.length) return !1;
                var primitive = this._struct.primitives[primitiveIndex];
                if (!primitive.indexView) return !1;
                for (var indexCount = primitive.indexView.count, indexFormat = 1 === primitive.indexView.stride ? exports.GFXFormat.R8UI : 2 === primitive.indexView.stride ? exports.GFXFormat.R16UI : exports.GFXFormat.R32UI, reader = getReader(new DataView(this._data.buffer), indexFormat), i = 0; i < indexCount; ++i) outputArray[i] = reader(primitive.indexView.offset + GFXFormatInfos[indexFormat].size * i);
                return !0;
            }
        }, {
            key: "createFlatBuffers",
            value: function createFlatBuffers() {
                if (this._hasFlatBuffers) return !1;
                cc.director.root.device;
                for (var ibView, idxCount = 0, i = 0; i < this._struct.primitives.length; ++i) {
                    var prim = this._struct.primitives[i], subMesh = this.renderingMesh.subMeshes[i];
                    prim.indexView && (idxCount = prim.indexView.count);
                    var _iterator5 = prim.vertexBundelIndices, _isArray5 = Array.isArray(_iterator5), _i8 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i8 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i8++];
                        } else {
                            if ((_i8 = _iterator5.next()).done) break;
                            _ref5 = _i8.value;
                        }
                        var bundleIdx = _ref5, _vertexBundle2 = this._struct.vertexBundles[bundleIdx], vbCount = prim.indexView ? prim.indexView.count : _vertexBundle2.view.count, vbStride = _vertexBundle2.view.stride, vbSize = vbStride * vbCount, view = new Uint8Array(this._data.buffer, _vertexBundle2.view.offset, _vertexBundle2.view.length);
                        if (prim.indexView) {
                            var vbView = new Uint8Array(vbSize);
                            ibView = 2 === (idxCount < 65536 ? 2 : 4) ? new Uint16Array(this._data.buffer, prim.indexView.offset, prim.indexView.count) : new Uint32Array(this._data.buffer, prim.indexView.offset, prim.indexView.count);
                            for (var n = 0; n < idxCount; ++n) for (var offset = n * vbStride, srcOffset = ibView[n] * vbStride, m = 0; m < vbStride; ++m) vbView[offset + m] = view[srcOffset + m];
                            subMesh.flatBuffers.push({
                                stride: vbStride,
                                count: vbCount,
                                buffer: vbView
                            });
                        } else subMesh.flatBuffers.push({
                            stride: vbStride,
                            count: vbCount,
                            buffer: view
                        });
                    }
                }
                return this._hasFlatBuffers = !0, !0;
            }
        }, {
            key: "destroyFlatBuffers",
            value: function destroyFlatBuffers() {
                if (this._hasFlatBuffers) {
                    if (this._renderingMesh) for (var subMeshes = this._renderingMesh.subMeshes, i = 0; i < subMeshes.length; ++i) subMeshes[i].flatBuffers.splice(0);
                    this._hasFlatBuffers = !1;
                }
            }
        }, {
            key: "_accessAttribute",
            value: function _accessAttribute(primitiveIndex, attributeName, accessor) {
                if (this._data && !(primitiveIndex >= this._struct.primitives.length)) {
                    var _iterator6 = this._struct.primitives[primitiveIndex].vertexBundelIndices, _isArray6 = Array.isArray(_iterator6), _i9 = 0;
                    for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                        var _ref6;
                        if (_isArray6) {
                            if (_i9 >= _iterator6.length) break;
                            _ref6 = _iterator6[_i9++];
                        } else {
                            if ((_i9 = _iterator6.next()).done) break;
                            _ref6 = _i9.value;
                        }
                        var vertexBundleIndex = _ref6, _vertexBundle3 = this._struct.vertexBundles[vertexBundleIndex], _iAttribute = _vertexBundle3.attributes.findIndex((function(a) {
                            return a.name === attributeName;
                        }));
                        if (!(_iAttribute < 0)) {
                            accessor(_vertexBundle3, _iAttribute);
                            break;
                        }
                    }
                }
            }
        }, {
            key: "_createVertexBuffers",
            value: function _createVertexBuffers(gfxDevice, data) {
                var _this5 = this;
                return this._struct.vertexBundles.map((function(vertexBundle) {
                    var vertexBuffer = gfxDevice.createBuffer({
                        usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                        size: vertexBundle.view.length,
                        stride: vertexBundle.view.stride
                    }), view = new Uint8Array(data, vertexBundle.view.offset, vertexBundle.view.length);
                    return _this5.loaded ? vertexBuffer.update(view) : _this5.once("load", (function() {
                        vertexBuffer.update(view);
                    })), vertexBuffer;
                }));
            }
        }, {
            key: "renderingMesh",
            get: function get() {
                return this.initialize(), this._renderingMesh;
            }
        } ]), Mesh;
    }(Asset)).prototype, "_struct", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return {
                vertexBundles: [],
                primitives: []
            };
        }
    }), _descriptor2$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_dataLength", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor3$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_hash", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$3 = _class2$2)) || _class$3;
    function getOffset(attributes, attributeIndex) {
        for (var result = 0, i = 0; i < attributeIndex; ++i) {
            var attribute = attributes[i];
            result += GFXFormatInfos[attribute.format].size;
        }
        return result;
    }
    function getStorageConstructor(format) {
        var info = GFXFormatInfos[format], stride = info.size / info.count;
        switch (info.type) {
          case exports.GFXFormatType.UNORM:
          case exports.GFXFormatType.UINT:
            switch (stride) {
              case 1:
                return Uint8Array;

              case 2:
                return Uint16Array;

              case 4:
                return Uint32Array;
            }
            break;

          case exports.GFXFormatType.SNORM:
          case exports.GFXFormatType.INT:
            switch (stride) {
              case 1:
                return Int8Array;

              case 2:
                return Int16Array;

              case 4:
                return Int32Array;
            }
            break;

          case exports.GFXFormatType.FLOAT:
            return Float32Array;
        }
        return null;
    }
    cc.Mesh = Mesh;
    var isLittleEndian = sys.isLittleEndian;
    function getComponentByteLength(format) {
        var info = GFXFormatInfos[format];
        return info.size / info.count;
    }
    function getReader(dataView, format) {
        var info = GFXFormatInfos[format], stride = info.size / info.count;
        switch (info.type) {
          case exports.GFXFormatType.UNORM:
            switch (stride) {
              case 1:
                return function(offset) {
                    return dataView.getUint8(offset);
                };

              case 2:
                return function(offset) {
                    return dataView.getUint16(offset, isLittleEndian);
                };

              case 4:
                return function(offset) {
                    return dataView.getUint32(offset, isLittleEndian);
                };
            }
            break;

          case exports.GFXFormatType.SNORM:
          case exports.GFXFormatType.INT:
            switch (stride) {
              case 1:
                return function(offset) {
                    return dataView.getInt8(offset);
                };

              case 2:
                return function(offset) {
                    return dataView.getInt16(offset, isLittleEndian);
                };

              case 4:
                return function(offset) {
                    return dataView.getInt32(offset, isLittleEndian);
                };
            }
            break;

          case exports.GFXFormatType.UINT:
            switch (stride) {
              case 1:
                return function(offset) {
                    return dataView.getUint8(offset);
                };

              case 2:
                return function(offset) {
                    return dataView.getUint16(offset, isLittleEndian);
                };

              case 4:
                return function(offset) {
                    return dataView.getUint32(offset, isLittleEndian);
                };
            }
            break;

          case exports.GFXFormatType.FLOAT:
            return function(offset) {
                return dataView.getFloat32(offset, isLittleEndian);
            };
        }
        return null;
    }
    function getWriter(dataView, format) {
        var info = GFXFormatInfos[format], stride = info.size / info.count;
        switch (info.type) {
          case exports.GFXFormatType.UNORM:
            switch (stride) {
              case 1:
                return function(offset, value) {
                    return dataView.setUint8(offset, value);
                };

              case 2:
                return function(offset, value) {
                    return dataView.setUint16(offset, value, isLittleEndian);
                };

              case 4:
                return function(offset, value) {
                    return dataView.setUint32(offset, value, isLittleEndian);
                };
            }
            break;

          case exports.GFXFormatType.SNORM:
          case exports.GFXFormatType.INT:
            switch (stride) {
              case 1:
                return function(offset, value) {
                    return dataView.setInt8(offset, value);
                };

              case 2:
                return function(offset, value) {
                    return dataView.setInt16(offset, value, isLittleEndian);
                };

              case 4:
                return function(offset, value) {
                    return dataView.setInt32(offset, value, isLittleEndian);
                };
            }
            break;

          case exports.GFXFormatType.UINT:
            switch (stride) {
              case 1:
                return function(offset, value) {
                    return dataView.setUint8(offset, value);
                };

              case 2:
                return function(offset, value) {
                    return dataView.setUint16(offset, value, isLittleEndian);
                };

              case 4:
                return function(offset, value) {
                    return dataView.setUint32(offset, value, isLittleEndian);
                };
            }
            break;

          case exports.GFXFormatType.FLOAT:
            return function(offset, value) {
                return dataView.setFloat32(offset, value, isLittleEndian);
            };
        }
        return null;
    }
    var layerList = {
        NONE: 0,
        IGNORE_RAYCAST: 1 << 20,
        GIZMOS: 1 << 21,
        EDITOR: 1 << 22,
        UI_3D: 1 << 23,
        SCENE_GIZMO: 1 << 24,
        UI_2D: 1 << 25,
        PROFILER: 1 << 28,
        DEFAULT: 1 << 30,
        ALL: 4294967295
    }, Layers = function() {
        function Layers() {
            _classCallCheck(this, Layers);
        }
        return _createClass(Layers, null, [ {
            key: "makeMaskInclude",
            value: function makeMaskInclude(includes) {
                var mask = 0, _iterator = includes, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    mask |= _ref;
                }
                return mask;
            }
        }, {
            key: "makeMaskExclude",
            value: function makeMaskExclude(excludes) {
                return ~Layers.makeMaskInclude(excludes);
            }
        }, {
            key: "addLayer",
            value: function addLayer(name, bitNum) {
                void 0 !== bitNum ? bitNum > 19 || bitNum < 0 ? console.warn("maximum layers reached.") : (Layers.Enum[name] = 1 << bitNum, 
                Layers.Enum[bitNum] = name, Layers.BitMask[name] = 1 << bitNum, Layers.BitMask[bitNum] = name) : console.warn("bitNum can't be undefined");
            }
        }, {
            key: "deleteLayer",
            value: function deleteLayer(bitNum) {
                bitNum > 19 || bitNum < 0 ? console.warn("do not change buildin layers.") : (delete Layers.Enum[Layers.Enum[bitNum]], 
                delete Layers.Enum[bitNum], delete Layers.BitMask[Layers.BitMask[bitNum]], delete Layers.BitMask[bitNum]);
            }
        } ]), Layers;
    }();
    Layers.Enum = Enum(layerList), Layers.BitMask = BitMask(Object.assign({}, layerList)), 
    cc.Layers = Layers;
    var RenderPassStage, RenderPriority;
    (RenderPassStage = exports.RenderPassStage || (exports.RenderPassStage = {}))[RenderPassStage.DEFAULT = 100] = "DEFAULT", 
    function(RenderPriority) {
        RenderPriority[RenderPriority.MIN = 0] = "MIN", RenderPriority[RenderPriority.MAX = 255] = "MAX", 
        RenderPriority[RenderPriority.DEFAULT = 128] = "DEFAULT";
    }(RenderPriority || (RenderPriority = {}));
    var UniformBinding;
    !function(UniformBinding) {
        UniformBinding[UniformBinding.UBO_GLOBAL = 23] = "UBO_GLOBAL", UniformBinding[UniformBinding.UBO_SHADOW = 22] = "UBO_SHADOW", 
        UniformBinding[UniformBinding.UBO_LOCAL = 21] = "UBO_LOCAL", UniformBinding[UniformBinding.UBO_FORWARD_LIGHTS = 20] = "UBO_FORWARD_LIGHTS", 
        UniformBinding[UniformBinding.UBO_SKINNING_ANIMATION = 19] = "UBO_SKINNING_ANIMATION", 
        UniformBinding[UniformBinding.UBO_SKINNING_TEXTURE = 18] = "UBO_SKINNING_TEXTURE", 
        UniformBinding[UniformBinding.SAMPLER_JOINTS = 25] = "SAMPLER_JOINTS", UniformBinding[UniformBinding.SAMPLER_ENVIRONMENT = 26] = "SAMPLER_ENVIRONMENT", 
        UniformBinding[UniformBinding.CUSTUM_UBO_BINDING_END_POINT = 18] = "CUSTUM_UBO_BINDING_END_POINT", 
        UniformBinding[UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT = 30] = "CUSTOM_SAMPLER_BINDING_START_POINT";
    }(UniformBinding || (UniformBinding = {}));
    var isBuiltinBinding = function isBuiltinBinding(binding) {
        return binding >= UniformBinding.CUSTUM_UBO_BINDING_END_POINT && binding < UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT;
    }, UBOGlobal = function UBOGlobal() {
        _classCallCheck(this, UBOGlobal), this.view = new Float32Array(UBOGlobal.COUNT);
    };
    UBOGlobal.SIZE = 4 * (UBOGlobal.COUNT = (UBOGlobal.AMBIENT_GROUND_OFFSET = (UBOGlobal.AMBIENT_SKY_OFFSET = (UBOGlobal.MAIN_LIT_COLOR_OFFSET = (UBOGlobal.MAIN_LIT_DIR_OFFSET = (UBOGlobal.EXPOSURE_OFFSET = (UBOGlobal.CAMERA_POS_OFFSET = (UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET = (UBOGlobal.MAT_VIEW_PROJ_OFFSET = (UBOGlobal.MAT_PROJ_INV_OFFSET = (UBOGlobal.MAT_PROJ_OFFSET = (UBOGlobal.MAT_VIEW_INV_OFFSET = (UBOGlobal.MAT_VIEW_OFFSET = (UBOGlobal.NATIVE_SIZE_OFFSET = (UBOGlobal.SCREEN_SCALE_OFFSET = (UBOGlobal.SCREEN_SIZE_OFFSET = (UBOGlobal.TIME_OFFSET = 0) + 4) + 4) + 4) + 4) + 16) + 16) + 16) + 16) + 16) + 16) + 4) + 4) + 4) + 4) + 4) + 4), 
    UBOGlobal.BLOCK = {
        binding: UniformBinding.UBO_GLOBAL,
        name: "CCGlobal",
        members: [ {
            name: "cc_time",
            type: exports.GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_screenSize",
            type: exports.GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_screenScale",
            type: exports.GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_nativeSize",
            type: exports.GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_matView",
            type: exports.GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matViewInv",
            type: exports.GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matProj",
            type: exports.GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matProjInv",
            type: exports.GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matViewProj",
            type: exports.GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matViewProjInv",
            type: exports.GFXType.MAT4,
            count: 1
        }, {
            name: "cc_cameraPos",
            type: exports.GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_exposure",
            type: exports.GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_mainLitDir",
            type: exports.GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_mainLitColor",
            type: exports.GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_ambientSky",
            type: exports.GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_ambientGround",
            type: exports.GFXType.FLOAT4,
            count: 1
        } ]
    };
    var UBOShadow = function UBOShadow() {
        _classCallCheck(this, UBOShadow), this.view = new Float32Array(UBOShadow.COUNT);
    };
    UBOShadow.SIZE = 4 * (UBOShadow.COUNT = (UBOShadow.SHADOW_COLOR_OFFSET = (UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET = 0) + 16) + 4), 
    UBOShadow.BLOCK = {
        binding: UniformBinding.UBO_SHADOW,
        name: "CCShadow",
        members: [ {
            name: "cc_matLightPlaneProj",
            type: exports.GFXType.MAT4,
            count: 1
        }, {
            name: "cc_shadowColor",
            type: exports.GFXType.FLOAT4,
            count: 1
        } ]
    };
    var UNIFORM_ENVIRONMENT = {
        binding: UniformBinding.SAMPLER_ENVIRONMENT,
        name: "cc_environment",
        type: exports.GFXType.SAMPLER_CUBE,
        count: 1
    }, localBindingsDesc = new Map, UBOLocal = function UBOLocal() {
        _classCallCheck(this, UBOLocal), this.view = new Float32Array(UBOLocal.COUNT);
    };
    UBOLocal.SIZE = 4 * (UBOLocal.COUNT = (UBOLocal.MAT_WORLD_IT_OFFSET = (UBOLocal.MAT_WORLD_OFFSET = 0) + 16) + 16), 
    UBOLocal.BLOCK = {
        binding: UniformBinding.UBO_LOCAL,
        name: "CCLocal",
        members: [ {
            name: "cc_matWorld",
            type: exports.GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matWorldIT",
            type: exports.GFXType.MAT4,
            count: 1
        } ]
    }, localBindingsDesc.set(UBOLocal.BLOCK.name, {
        type: exports.GFXBindingType.UNIFORM_BUFFER,
        blockInfo: UBOLocal.BLOCK
    });
    var UBOLocalBatched = function UBOLocalBatched() {
        _classCallCheck(this, UBOLocalBatched), this.view = new Float32Array(UBOLocalBatched.COUNT);
    };
    UBOLocalBatched.BATCHING_COUNT = 10, UBOLocalBatched.MAT_WORLDS_OFFSET = 0, UBOLocalBatched.SIZE = 4 * (UBOLocalBatched.COUNT = 16 * UBOLocalBatched.BATCHING_COUNT), 
    UBOLocalBatched.BLOCK = {
        binding: UniformBinding.UBO_LOCAL,
        name: "CCLocalBatched",
        members: [ {
            name: "cc_matWorlds",
            type: exports.GFXType.MAT4,
            count: UBOLocalBatched.BATCHING_COUNT
        } ]
    }, localBindingsDesc.set(UBOLocalBatched.BLOCK.name, {
        type: exports.GFXBindingType.UNIFORM_BUFFER,
        blockInfo: UBOLocalBatched.BLOCK
    });
    var UBOForwardLight = function UBOForwardLight() {
        _classCallCheck(this, UBOForwardLight), this.view = new Float32Array(UBOForwardLight.COUNT);
    };
    UBOForwardLight.MAX_SPHERE_LIGHTS = 2, UBOForwardLight.MAX_SPOT_LIGHTS = 2, UBOForwardLight.SIZE = 4 * (UBOForwardLight.COUNT = (UBOForwardLight.SPOT_LIGHT_COLOR_OFFSET = (UBOForwardLight.SPOT_LIGHT_DIR_OFFSET = (UBOForwardLight.SPOT_LIGHT_SIZE_RANGE_ANGLE_OFFSET = (UBOForwardLight.SPOT_LIGHT_POS_OFFSET = (UBOForwardLight.SPHERE_LIGHT_COLOR_OFFSET = (UBOForwardLight.SPHERE_LIGHT_SIZE_RANGE_OFFSET = (UBOForwardLight.SPHERE_LIGHT_POS_OFFSET = 0) + 4 * UBOForwardLight.MAX_SPHERE_LIGHTS) + 4 * UBOForwardLight.MAX_SPHERE_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS), 
    UBOForwardLight.BLOCK = {
        binding: UniformBinding.UBO_FORWARD_LIGHTS,
        name: "CCForwardLight",
        members: [ {
            name: "cc_sphereLitPos",
            type: exports.GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPHERE_LIGHTS
        }, {
            name: "cc_sphereLitSizeRange",
            type: exports.GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPHERE_LIGHTS
        }, {
            name: "cc_sphereLitColor",
            type: exports.GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPHERE_LIGHTS
        }, {
            name: "cc_spotLitPos",
            type: exports.GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPOT_LIGHTS
        }, {
            name: "cc_spotLitSizeRangeAngle",
            type: exports.GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPOT_LIGHTS
        }, {
            name: "cc_spotLitDir",
            type: exports.GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPOT_LIGHTS
        }, {
            name: "cc_spotLitColor",
            type: exports.GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPOT_LIGHTS
        } ]
    }, localBindingsDesc.set(UBOForwardLight.BLOCK.name, {
        type: exports.GFXBindingType.UNIFORM_BUFFER,
        blockInfo: UBOForwardLight.BLOCK
    });
    var UBOSkinningTexture = function UBOSkinningTexture() {
        _classCallCheck(this, UBOSkinningTexture);
    };
    UBOSkinningTexture.SIZE = 4 * (UBOSkinningTexture.COUNT = (UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0) + 4), 
    UBOSkinningTexture.BLOCK = {
        binding: UniformBinding.UBO_SKINNING_TEXTURE,
        name: "CCSkinningTexture",
        members: [ {
            name: "cc_jointsTextureInfo",
            type: exports.GFXType.FLOAT4,
            count: 1
        } ]
    }, localBindingsDesc.set(UBOSkinningTexture.BLOCK.name, {
        type: exports.GFXBindingType.UNIFORM_BUFFER,
        blockInfo: UBOSkinningTexture.BLOCK
    });
    var UBOSkinningAnimation = function UBOSkinningAnimation() {
        _classCallCheck(this, UBOSkinningAnimation);
    };
    UBOSkinningAnimation.SIZE = 4 * (UBOSkinningAnimation.COUNT = (UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET = 0) + 4), 
    UBOSkinningAnimation.BLOCK = {
        binding: UniformBinding.UBO_SKINNING_ANIMATION,
        name: "CCSkinningAnimation",
        members: [ {
            name: "cc_jointsAnimInfo",
            type: exports.GFXType.FLOAT4,
            count: 1
        } ]
    }, localBindingsDesc.set(UBOSkinningAnimation.BLOCK.name, {
        type: exports.GFXBindingType.UNIFORM_BUFFER,
        blockInfo: UBOSkinningAnimation.BLOCK
    });
    var UniformJointsTexture = {
        binding: UniformBinding.SAMPLER_JOINTS,
        name: "cc_jointsTexture",
        type: exports.GFXType.SAMPLER2D,
        count: 1
    };
    localBindingsDesc.set(UniformJointsTexture.name, {
        type: exports.GFXBindingType.SAMPLER,
        samplerInfo: UniformJointsTexture
    });
    var CameraDefaultMask = Layers.makeMaskExclude([ Layers.BitMask.UI_2D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER ]), CameraEditorMask = Layers.makeMaskExclude([ Layers.BitMask.UI_2D, Layers.BitMask.PROFILER ]), Customization = (Layers.Enum.ALL, 
    function() {
        function Customization(info) {
            _classCallCheck(this, Customization), this._models = {}, this._onAttach = info.onAttach, 
            this._onDetach = info.onDetach;
        }
        return _createClass(Customization, [ {
            key: "attach",
            value: function attach(model) {
                var models = this._models, id = model.id;
                models[id] ? models[id]++ : (this._onAttach && this._onAttach(model), models[id] = 1);
            }
        }, {
            key: "detach",
            value: function detach(model) {
                var models = this._models, id = model.id;
                !models[id] || --models[id] > 0 || this._onDetach && this._onDetach(model);
            }
        } ]), Customization;
    }()), customizationManager = new (function() {
        function CustomizationManager() {
            _classCallCheck(this, CustomizationManager), this._customs = {};
        }
        return _createClass(CustomizationManager, [ {
            key: "register",
            value: function register(name, info) {
                this._customs[name] = new Customization(info);
            }
        }, {
            key: "attach",
            value: function attach(name, model) {
                var cus = this._customs[name];
                cus ? cus.attach(model) : console.warn("no customization named '".concat(name, "'"));
            }
        }, {
            key: "detach",
            value: function detach(name, model) {
                var cus = this._customs[name];
                cus ? cus.detach(model) : console.warn("no customization named '".concat(name, "'"));
            }
        } ]), CustomizationManager;
    }());
    cc.customizationManager = customizationManager;
    var SubModel = function() {
        function SubModel() {
            _classCallCheck(this, SubModel), this._subMeshObject = null, this._material = null, 
            this._cmdBuffers = new Array, this._psos = null, this._inputAssembler = null, this._priority = RenderPriority.DEFAULT;
        }
        return _createClass(SubModel, [ {
            key: "initialize",
            value: function initialize(subMesh, mat, psos) {
                this._psos = psos, this.subMeshData = subMesh, this.material = mat;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._inputAssembler && this._inputAssembler.destroy();
                for (var i = 0; i < this.passes.length; i++) this.passes[i].destroyPipelineState(this._psos[i]);
                var _iterator = this._cmdBuffers, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.destroy();
                }
                this._cmdBuffers.splice(0), this._material = null;
            }
        }, {
            key: "updateCommandBuffer",
            value: function updateCommandBuffer() {
                if (this._material) {
                    for (var i = 0; i < this._material.passes.length; i++) this._subMeshObject && this._material.passes[i].primitive !== this._subMeshObject.primitiveMode && console.warn("mesh primitive type doesn't match with pass settings"), 
                    this.recordCommandBuffer(i);
                    for (var _i2 = this._cmdBuffers.length - 1; _i2 >= this._material.passes.length; _i2--) {
                        var cmdBuff = this._cmdBuffers.pop();
                        cmdBuff && cmdBuff.destroy();
                    }
                }
            }
        }, {
            key: "recordCommandBuffer",
            value: function recordCommandBuffer(index) {
                var device = cc.director.root.device, pso = this._psos[index];
                if (null == this._cmdBuffers[index]) {
                    var cmdBufferInfo = {
                        allocator: device.commandAllocator,
                        type: exports.GFXCommandBufferType.SECONDARY
                    };
                    this._cmdBuffers[index] = device.createCommandBuffer(cmdBufferInfo);
                } else this._cmdBuffers[index].status === exports.GFXStatus.UNREADY && this._cmdBuffers[index].initialize({
                    allocator: device.commandAllocator,
                    type: exports.GFXCommandBufferType.SECONDARY
                });
                var inputAssembler = this._inputAssembler, cmdBuff = this._cmdBuffers[index];
                cmdBuff.begin(), cmdBuff.bindPipelineState(pso), cmdBuff.bindBindingLayout(pso.pipelineLayout.layouts[0]), 
                cmdBuff.bindInputAssembler(inputAssembler), cmdBuff.draw(inputAssembler), cmdBuff.end();
            }
        }, {
            key: "priority",
            set: function set(val) {
                this._priority = val;
            },
            get: function get() {
                return this._priority;
            }
        }, {
            key: "subMeshData",
            set: function set(sm) {
                this._inputAssembler && this._inputAssembler.destroy(), this._subMeshObject = sm;
                var iaInfo = {};
                iaInfo.attributes = this._subMeshObject.attributes, iaInfo.vertexBuffers = this._subMeshObject.vertexBuffers, 
                this._subMeshObject.indexBuffer && (iaInfo.indexBuffer = this._subMeshObject.indexBuffer), 
                this._subMeshObject.indirectBuffer && (iaInfo.indirectBuffer = this._subMeshObject.indirectBuffer), 
                this._inputAssembler ? this._inputAssembler.initialize(iaInfo) : this._inputAssembler = cc.director.root.device.createInputAssembler(iaInfo);
            },
            get: function get() {
                return this._subMeshObject;
            }
        }, {
            key: "psos",
            get: function get() {
                return this._psos;
            },
            set: function set(val) {
                this._psos = val;
            }
        }, {
            key: "material",
            set: function set(material) {
                this._material = material, null != material && this.updateCommandBuffer();
            },
            get: function get() {
                return this._material;
            }
        }, {
            key: "inputAssembler",
            get: function get() {
                return this._inputAssembler;
            }
        }, {
            key: "passes",
            get: function get() {
                return this._material.passes;
            }
        }, {
            key: "commandBuffers",
            get: function get() {
                return this._cmdBuffers;
            }
        } ]), SubModel;
    }(), m4_1 = new Mat4, _subMeshPool = new Pool$1((function() {
        return new SubModel;
    }), 32);
    function getUniformBlockSize(block) {
        var size = 0, _iterator = block.members, _isArray = Array.isArray(_iterator), _i = 0;
        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
            var _ref;
            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                if ((_i = _iterator.next()).done) break;
                _ref = _i.value;
            }
            var mem = _ref;
            size += GFXGetTypeSize(mem.type) * mem.count;
        }
        return size;
    }
    var NodeSpace, TransformBit, PixelFormat, WrapMode$1, Filter, DepthStencilFormat, _dec$4, _dec2$1, _class$4, _class2$3, _class3$1, _temp$3, MODEL_ID = 0, Model = function() {
        function Model() {
            _classCallCheck(this, Model), this._type = "default", this._scene = null, this._node = null, 
            this._transform = null, this._id = MODEL_ID++, this._enabled = !0, this._visFlags = Layers.Enum.NONE, 
            this._cameraID = -1, this._userKey = -1, this._worldBounds = null, this._modelBounds = null, 
            this._subModels = [], this._implantPSOs = [], this._matPSORecord = new Map, this._matRefCount = new Map, 
            this._uboLocal = new UBOLocal, this._localUBO = null, this._localBindings = new Map, 
            this._inited = !1, this._uboUpdated = !1, this._castShadow = !1, this._isDynamicBatching = !1, 
            this._transformUpdated = !0, this._device = cc.director.root.device;
        }
        return _createClass(Model, [ {
            key: "scene",
            set: function set(scene) {
                this._scene = scene;
            },
            get: function get() {
                return this._scene;
            }
        }, {
            key: "id",
            get: function get() {
                return this._id;
            }
        }, {
            key: "subModels",
            get: function get() {
                return this._subModels;
            }
        }, {
            key: "subModelNum",
            get: function get() {
                return this._subModels.length;
            }
        }, {
            key: "inited",
            get: function get() {
                return this._inited;
            }
        }, {
            key: "enabled",
            set: function set(val) {
                this._enabled = val;
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "node",
            get: function get() {
                return this._node;
            },
            set: function set(node) {
                this._node = node;
            }
        }, {
            key: "transform",
            get: function get() {
                return this._transform;
            },
            set: function set(transform) {
                this._transform = transform;
            }
        }, {
            key: "worldBounds",
            get: function get() {
                return this._worldBounds;
            }
        }, {
            key: "modelBounds",
            get: function get() {
                return this._modelBounds;
            }
        }, {
            key: "visFlags",
            get: function get() {
                return this._visFlags;
            },
            set: function set(id) {
                this._visFlags = id;
            }
        }, {
            key: "userKey",
            set: function set(key) {
                this._userKey = key;
            }
        }, {
            key: "uboLocal",
            get: function get() {
                return this._uboLocal;
            }
        }, {
            key: "localUBO",
            get: function get() {
                return this._localUBO;
            }
        }, {
            key: "localBindings",
            get: function get() {
                return this._localBindings;
            }
        }, {
            key: "castShadow",
            get: function get() {
                return this._castShadow;
            },
            set: function set(val) {
                this._castShadow = val;
            }
        }, {
            key: "isDynamicBatching",
            get: function get() {
                return this._isDynamicBatching;
            },
            set: function set(val) {
                this._isDynamicBatching = val;
            }
        }, {
            key: "UBOUpdated",
            get: function get() {
                return this._uboUpdated;
            }
        } ]), _createClass(Model, [ {
            key: "initialize",
            value: function initialize(node) {
                this._transform = this._node = node;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var _iterator2 = this._subModels, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var subModel = _ref2;
                    subModel.destroy(), _subMeshPool.free(subModel);
                }
                for (var lbIter = this._localBindings.values(), lbResult = lbIter.next(); !lbResult.done; ) {
                    var localBinding = lbResult.value;
                    localBinding.buffer && (localBinding.buffer.destroy(), localBinding.buffer = void 0), 
                    lbResult = lbIter.next();
                }
                this._localBindings.has(UBOForwardLight.BLOCK.name) && this._localBindings.delete(UBOForwardLight.BLOCK.name), 
                this._worldBounds = null, this._modelBounds = null, this._subModels.splice(0), this._matPSORecord.clear(), 
                this._matRefCount.clear(), this._inited = !1, this._transformUpdated = !0, this._isDynamicBatching = !1;
            }
        }, {
            key: "attachToScene",
            value: function attachToScene(scene) {
                this._scene = scene;
            }
        }, {
            key: "detachFromScene",
            value: function detachFromScene() {
                this._scene = null;
            }
        }, {
            key: "getSubModel",
            value: function getSubModel(idx) {
                return this._subModels[idx];
            }
        }, {
            key: "updateTransform",
            value: function updateTransform() {
                var node = this._transform;
                (node.hasChangedFlags || node._dirtyFlags) && (node.updateWorldTransform(), this._transformUpdated = !0, 
                this._modelBounds && this._worldBounds && this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, this._worldBounds));
            }
        }, {
            key: "_resetUBOUpdateFlag",
            value: function _resetUBOUpdateFlag() {
                this._uboUpdated = !1;
            }
        }, {
            key: "updateUBOs",
            value: function updateUBOs() {
                if (this._uboUpdated) return !1;
                if (this._uboUpdated = !0, this._transformUpdated && !this._isDynamicBatching) {
                    var worldMatrix = this._transform._mat;
                    Mat4.toArray(this._uboLocal.view, worldMatrix, UBOLocal.MAT_WORLD_OFFSET), Mat4.inverseTranspose(m4_1, worldMatrix), 
                    Mat4.toArray(this._uboLocal.view, m4_1, UBOLocal.MAT_WORLD_IT_OFFSET);
                    var commonLocal = this._localBindings.get(UBOLocal.BLOCK.name);
                    commonLocal && commonLocal.buffer && commonLocal.buffer.update(this._uboLocal.view), 
                    this._transformUpdated = !1;
                }
                return this._matPSORecord.forEach(this._updatePass, this), !0;
            }
        }, {
            key: "createBoundingShape",
            value: function createBoundingShape(minPos, maxPos) {
                minPos && maxPos && (this._modelBounds = aabb.fromPoints(aabb.create(), minPos, maxPos), 
                this._worldBounds = aabb.clone(this._modelBounds), this._transform.updateWorldTransform(), 
                this._modelBounds.transform(this._transform._mat, this._transform._pos, this._transform._rot, this._transform._scale, this._worldBounds));
            }
        }, {
            key: "initSubModel",
            value: function initSubModel(idx, subMeshData, mat) {
                if (this.initLocalBindings(mat), null == this._subModels[idx]) this._subModels[idx] = _subMeshPool.alloc(); else {
                    var oldMat = this._subModels[idx].material;
                    this._subModels[idx].destroy(), this.releasePSO(oldMat);
                }
                this.allocatePSO(mat), this._subModels[idx].initialize(subMeshData, mat, this._matPSORecord.get(mat)), 
                this._inited = !0;
            }
        }, {
            key: "setSubModelMesh",
            value: function setSubModelMesh(idx, subMeshData) {
                null == this._subModels[idx] && (this._subModels[idx] = _subMeshPool.alloc()), this._subModels[idx].subMeshData = subMeshData;
            }
        }, {
            key: "setSubModelMaterial",
            value: function setSubModelMaterial(idx, mat) {
                null != this._subModels[idx] && (this.initLocalBindings(mat), this._subModels[idx].material === mat ? mat && (this.destroyPipelineStates(mat, this._matPSORecord.get(mat)), 
                this._matPSORecord.set(mat, this.createPipelineStates(mat))) : (this._subModels[idx].material && this.releasePSO(this._subModels[idx].material), 
                mat && this.allocatePSO(mat)), this._subModels[idx].psos = mat && this._matPSORecord.get(mat) || null, 
                this._subModels[idx].material = mat);
            }
        }, {
            key: "onGlobalPipelineStateChanged",
            value: function onGlobalPipelineStateChanged() {
                var _iterator3 = this._subModels, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    for (var m = _ref3, mat = m.material, psos = this._matPSORecord.get(mat), i = 0; i < mat.passes.length; i++) {
                        var pass = mat.passes[i];
                        pass.beginChangeStatesSilently(), pass.tryCompile(), pass.endChangeStatesSilently(), 
                        pass.destroyPipelineState(psos[i]), psos[i] = this.createPipelineState(pass), psos[i].pipelineLayout.layouts[0].update();
                    }
                    m.updateCommandBuffer();
                }
            }
        }, {
            key: "insertImplantPSO",
            value: function insertImplantPSO(pso) {
                this._implantPSOs.push(pso);
            }
        }, {
            key: "removeImplantPSO",
            value: function removeImplantPSO(pso) {
                var idx = this._implantPSOs.indexOf(pso);
                idx >= 0 && this._implantPSOs.splice(idx, 1);
            }
        }, {
            key: "createPipelineStates",
            value: function createPipelineStates(mat) {
                for (var ret = new Array(mat.passes.length), i = 0; i < ret.length; i++) {
                    var pass = mat.passes[i], _iterator4 = pass.customizations, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref4 = _i4.value;
                        }
                        var cus = _ref4;
                        customizationManager.attach(cus, this);
                    }
                    ret[i] = this.createPipelineState(pass);
                }
                return ret;
            }
        }, {
            key: "destroyPipelineStates",
            value: function destroyPipelineStates(mat, pso) {
                for (var i = 0; i < mat.passes.length; i++) {
                    var pass = mat.passes[i];
                    pass.destroyPipelineState(pso[i]);
                    var _iterator5 = pass.customizations, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i5 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i5++];
                        } else {
                            if ((_i5 = _iterator5.next()).done) break;
                            _ref5 = _i5.value;
                        }
                        var cus = _ref5;
                        customizationManager.detach(cus, this);
                    }
                }
            }
        }, {
            key: "createPipelineState",
            value: function createPipelineState(pass) {
                var pso = pass.createPipelineState();
                return pso.pipelineLayout.layouts[0].bindBuffer(UBOLocal.BLOCK.binding, this._localBindings.get(UBOLocal.BLOCK.name).buffer), 
                this._localBindings.has(UBOForwardLight.BLOCK.name) && pso.pipelineLayout.layouts[0].bindBuffer(UBOForwardLight.BLOCK.binding, this._localBindings.get(UBOForwardLight.BLOCK.name).buffer), 
                pso;
            }
        }, {
            key: "onSetLocalBindings",
            value: function onSetLocalBindings(mat) {
                this._localBindings.has(UBOLocal.BLOCK.name) || this._localBindings.set(UBOLocal.BLOCK.name, {
                    type: exports.GFXBindingType.UNIFORM_BUFFER,
                    blockInfo: UBOLocal.BLOCK
                });
                var hasForwardLight = !1, _iterator6 = mat.passes, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref6 = _i6.value;
                    }
                    if (_ref6.bindings.find((function(b) {
                        return b.name === UBOForwardLight.BLOCK.name;
                    }))) {
                        hasForwardLight = !0;
                        break;
                    }
                }
                hasForwardLight && "ForwardPipeline" === cc.director.root.pipeline.name && (this._localBindings.has(UBOForwardLight.BLOCK.name) || this._localBindings.set(UBOForwardLight.BLOCK.name, {
                    type: exports.GFXBindingType.UNIFORM_BUFFER,
                    blockInfo: UBOForwardLight.BLOCK
                }));
            }
        }, {
            key: "initLocalBindings",
            value: function initLocalBindings(mat) {
                if (mat) {
                    this.onSetLocalBindings(mat);
                    for (var lbIter = this._localBindings.values(), lbResult = lbIter.next(); !lbResult.done; ) {
                        var localBinding = lbResult.value;
                        localBinding.buffer || (localBinding.buffer = this._device.createBuffer({
                            usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                            size: getUniformBlockSize(localBinding.blockInfo)
                        })), lbResult = lbIter.next();
                    }
                }
            }
        }, {
            key: "_updatePass",
            value: function _updatePass(psos, mat) {
                for (var i = 0; i < mat.passes.length; i++) mat.passes[i].update();
                for (var _i7 = 0; _i7 < psos.length; _i7++) psos[_i7].pipelineLayout.layouts[0].update();
            }
        }, {
            key: "allocatePSO",
            value: function allocatePSO(mat) {
                null == this._matRefCount.get(mat) ? (this._matRefCount.set(mat, 1), this._matPSORecord.set(mat, this.createPipelineStates(mat))) : this._matRefCount.set(mat, this._matRefCount.get(mat) + 1);
            }
        }, {
            key: "releasePSO",
            value: function releasePSO(mat) {
                this._matRefCount.set(mat, this._matRefCount.get(mat) - 1), 0 === this._matRefCount.get(mat) && (this.destroyPipelineStates(mat, this._matPSORecord.get(mat)), 
                this._matPSORecord.delete(mat), this._matRefCount.delete(mat));
            }
        } ]), Model;
    }();
    !function(NodeSpace) {
        NodeSpace[NodeSpace.LOCAL = 0] = "LOCAL", NodeSpace[NodeSpace.WORLD = 1] = "WORLD";
    }(NodeSpace || (NodeSpace = {})), function(TransformBit) {
        TransformBit[TransformBit.NONE = 0] = "NONE", TransformBit[TransformBit.POSITION = 1] = "POSITION", 
        TransformBit[TransformBit.ROTATION = 2] = "ROTATION", TransformBit[TransformBit.SCALE = 4] = "SCALE", 
        TransformBit[TransformBit.RS = TransformBit.ROTATION | TransformBit.SCALE] = "RS", 
        TransformBit[TransformBit.TRS = TransformBit.POSITION | TransformBit.ROTATION | TransformBit.SCALE] = "TRS", 
        TransformBit[TransformBit.TRS_MASK = ~TransformBit.TRS] = "TRS_MASK";
    }(TransformBit || (TransformBit = {})), function(PixelFormat) {
        PixelFormat[PixelFormat.RGB565 = exports.GFXFormat.R5G6B5] = "RGB565", PixelFormat[PixelFormat.RGB5A1 = exports.GFXFormat.RGB5A1] = "RGB5A1", 
        PixelFormat[PixelFormat.RGBA4444 = exports.GFXFormat.RGBA4] = "RGBA4444", PixelFormat[PixelFormat.RGB888 = exports.GFXFormat.RGB8] = "RGB888", 
        PixelFormat[PixelFormat.RGBA8888 = exports.GFXFormat.RGBA8] = "RGBA8888", PixelFormat[PixelFormat.RGBA32F = exports.GFXFormat.RGBA32F] = "RGBA32F", 
        PixelFormat[PixelFormat.A8 = exports.GFXFormat.A8] = "A8", PixelFormat[PixelFormat.I8 = exports.GFXFormat.L8] = "I8", 
        PixelFormat[PixelFormat.AI8 = exports.GFXFormat.LA8] = "AI8", PixelFormat[PixelFormat.RGB_PVRTC_2BPPV1 = exports.GFXFormat.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1", 
        PixelFormat[PixelFormat.RGBA_PVRTC_2BPPV1 = exports.GFXFormat.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1", 
        PixelFormat[PixelFormat.RGB_PVRTC_4BPPV1 = exports.GFXFormat.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1", 
        PixelFormat[PixelFormat.RGBA_PVRTC_4BPPV1 = exports.GFXFormat.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1", 
        PixelFormat[PixelFormat.RGB_ETC1 = exports.GFXFormat.ETC_RGB8] = "RGB_ETC1", PixelFormat[PixelFormat.RGB_ETC2 = exports.GFXFormat.ETC2_RGB8] = "RGB_ETC2", 
        PixelFormat[PixelFormat.RGBA_ETC2 = exports.GFXFormat.ETC2_RGBA8] = "RGBA_ETC2";
    }(PixelFormat || (PixelFormat = {})), function(WrapMode) {
        WrapMode[WrapMode.REPEAT = exports.GFXAddress.WRAP] = "REPEAT", WrapMode[WrapMode.CLAMP_TO_EDGE = exports.GFXAddress.CLAMP] = "CLAMP_TO_EDGE", 
        WrapMode[WrapMode.MIRRORED_REPEAT = exports.GFXAddress.MIRROR] = "MIRRORED_REPEAT", 
        WrapMode[WrapMode.CLAMP_TO_BORDER = exports.GFXAddress.BORDER] = "CLAMP_TO_BORDER";
    }(WrapMode$1 || (WrapMode$1 = {})), function(Filter) {
        Filter[Filter.NONE = exports.GFXFilter.NONE] = "NONE", Filter[Filter.LINEAR = exports.GFXFilter.LINEAR] = "LINEAR", 
        Filter[Filter.NEAREST = exports.GFXFilter.POINT] = "NEAREST";
    }(Filter || (Filter = {})), function(DepthStencilFormat) {
        DepthStencilFormat[DepthStencilFormat.NONE = exports.GFXFormat.UNKNOWN] = "NONE", 
        DepthStencilFormat[DepthStencilFormat.DEPTH_16 = exports.GFXFormat.D16] = "DEPTH_16", 
        DepthStencilFormat[DepthStencilFormat.DEPTH_24 = exports.GFXFormat.D24] = "DEPTH_24", 
        DepthStencilFormat[DepthStencilFormat.DEPTH_32 = exports.GFXFormat.D32F] = "DEPTH_32", 
        DepthStencilFormat[DepthStencilFormat.DEPTH_16_STENCIL_8 = exports.GFXFormat.D16S8] = "DEPTH_16_STENCIL_8", 
        DepthStencilFormat[DepthStencilFormat.DEPTH_24_STENCIL_8 = exports.GFXFormat.D24S8] = "DEPTH_24_STENCIL_8", 
        DepthStencilFormat[DepthStencilFormat.DEPTH_32_STENCIL_8 = exports.GFXFormat.D32F_S8] = "DEPTH_32_STENCIL_8";
    }(DepthStencilFormat || (DepthStencilFormat = {}));
    var SamplerInfoIndex, ImageAsset = (_dec$4 = ccclass("cc.ImageAsset"), _dec2$1 = property({
        override: !0
    }), _dec$4((_temp$3 = _class3$1 = function(_Asset) {
        function ImageAsset(nativeAsset) {
            var _this;
            return _classCallCheck(this, ImageAsset), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ImageAsset).call(this)))._exportedExts = void 0, 
            _this._format = PixelFormat.RGBA8888, _this._width = 0, _this._height = 0, _this._url = "", 
            _this.loaded = !1, _this._nativeData = {
                _data: null,
                width: 0,
                height: 0,
                format: 0,
                _compressed: !1
            }, void 0 !== nativeAsset && _this.reset(nativeAsset), _this;
        }
        return _inherits(ImageAsset, _Asset), _createClass(ImageAsset, [ {
            key: "_nativeAsset",
            get: function get() {
                return this._nativeData;
            },
            set: function set(value) {
                this.reset(value);
            }
        }, {
            key: "data",
            get: function get() {
                var data = this._nativeData._data;
                return ArrayBuffer.isView(data) ? data : this._nativeData;
            }
        }, {
            key: "width",
            get: function get() {
                return this._nativeData.width || this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._nativeData.height || this._height;
            }
        }, {
            key: "format",
            get: function get() {
                return this._format;
            }
        }, {
            key: "isCompressed",
            get: function get() {
                return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_PVRTC_4BPPV1;
            }
        }, {
            key: "url",
            get: function get() {
                return this._url;
            }
        }, {
            key: "_texture",
            set: function set(tex) {
                this._tex = tex;
            },
            get: function get() {
                if (!this._tex) {
                    var tex = new cc.Texture2D;
                    tex.name = this._url, tex.image = this, this._tex = tex;
                }
                return this._tex;
            }
        } ]), _createClass(ImageAsset, [ {
            key: "reset",
            value: function reset(data) {
                var _this2 = this;
                data instanceof HTMLElement ? (this._nativeData = data, data.complete || data instanceof HTMLCanvasElement ? this._onDataComplete() : (this.loaded = !1, 
                data.addEventListener("load", (function() {
                    _this2._onDataComplete();
                })), data.addEventListener("error", (function(err) {
                    cc.warnID(3119, err.message);
                })))) : (this._nativeData = data, this._format = data.format, this._onDataComplete());
            }
        }, {
            key: "_serialize",
            value: function _serialize() {
                var targetExtensions = this._exportedExts;
                if (!targetExtensions && this._native && (targetExtensions = [ this._native ]), 
                !targetExtensions) return "";
                var extensionIndices = [], _iterator = targetExtensions, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var targetExtension = _ref, extensionFormat = targetExtension.split("@"), i = ImageAsset.extnames.indexOf(extensionFormat[0]), exportedExtensionID = i < 0 ? targetExtension : "".concat(i);
                    extensionFormat[1] && (exportedExtensionID += "@" + extensionFormat[1]), extensionIndices.push(exportedExtensionID);
                }
                return {
                    fmt: extensionIndices.join("_"),
                    w: this.width,
                    h: this.height
                };
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(data, handle) {
                var fmtStr = "";
                "string" == typeof data ? fmtStr = data : (this._width = data.w, this._height = data.h, 
                fmtStr = data.fmt);
                var device = function _getGlobalDevice() {
                    return cc.director.root ? cc.director.root.device : null;
                }(), extensionIDs = fmtStr.split("_"), preferedExtensionIndex = Number.MAX_VALUE, format = this._format, ext = "", SupportTextureFormats = cc.macro.SUPPORT_TEXTURE_FORMATS, _iterator2 = extensionIDs, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var extFormat = _ref2.split("@"), i = parseInt(extFormat[0], void 0), tmpExt = ImageAsset.extnames[i] || extFormat.join(), index = SupportTextureFormats.indexOf(tmpExt);
                    if (-1 !== index && index < preferedExtensionIndex) {
                        var fmt = extFormat[1] ? parseInt(extFormat[1]) : this._format;
                        if (!(".pvr" !== tmpExt || device && device.hasFeature(exports.GFXFeature.FORMAT_PVRTC))) continue;
                        if (!(fmt !== PixelFormat.RGB_ETC1 || device && device.hasFeature(exports.GFXFeature.FORMAT_ETC1))) continue;
                        if (!(fmt !== PixelFormat.RGB_ETC2 && fmt !== PixelFormat.RGBA_ETC2 || device && device.hasFeature(exports.GFXFeature.FORMAT_ETC2))) continue;
                        if (".webp" === tmpExt && !cc.sys.capabilities.webp) continue;
                        preferedExtensionIndex = index, ext = tmpExt, format = fmt;
                    }
                }
                ext && (this._setRawAsset(ext), this._format = format);
                var loadingItem = handle.customEnv, uuid = loadingItem && loadingItem.uuid;
                uuid && (this._uuid = uuid, this._url = this.nativeUrl);
            }
        }, {
            key: "_onDataComplete",
            value: function _onDataComplete() {
                this.loaded = !0, this.emit("load");
            }
        } ]), ImageAsset;
    }(Asset), _class3$1.extnames = [ ".png", ".jpg", ".jpeg", ".bmp", ".webp", ".pvr", ".pkm" ], 
    _applyDecoratedDescriptor((_class2$3 = _temp$3).prototype, "_nativeAsset", [ _dec2$1 ], Object.getOwnPropertyDescriptor(_class2$3.prototype, "_nativeAsset"), _class2$3.prototype), 
    _class$4 = _class2$3)) || _class$4);
    cc.ImageAsset = ImageAsset, function(SamplerInfoIndex) {
        SamplerInfoIndex[SamplerInfoIndex.minFilter = 0] = "minFilter", SamplerInfoIndex[SamplerInfoIndex.magFilter = 1] = "magFilter", 
        SamplerInfoIndex[SamplerInfoIndex.mipFilter = 2] = "mipFilter", SamplerInfoIndex[SamplerInfoIndex.addressU = 3] = "addressU", 
        SamplerInfoIndex[SamplerInfoIndex.addressV = 4] = "addressV", SamplerInfoIndex[SamplerInfoIndex.addressW = 5] = "addressW", 
        SamplerInfoIndex[SamplerInfoIndex.maxAnisotropy = 6] = "maxAnisotropy", SamplerInfoIndex[SamplerInfoIndex.cmpFunc = 7] = "cmpFunc", 
        SamplerInfoIndex[SamplerInfoIndex.minLOD = 8] = "minLOD", SamplerInfoIndex[SamplerInfoIndex.maxLOD = 9] = "maxLOD", 
        SamplerInfoIndex[SamplerInfoIndex.mipLODBias = 10] = "mipLODBias", SamplerInfoIndex[SamplerInfoIndex.total = 11] = "total";
    }(SamplerInfoIndex || (SamplerInfoIndex = {}));
    var defaultInfo = [ exports.GFXFilter.LINEAR, exports.GFXFilter.LINEAR, exports.GFXFilter.NONE, exports.GFXAddress.WRAP, exports.GFXAddress.WRAP, exports.GFXAddress.WRAP, 8, exports.GFXComparisonFunc.NEVER, 0, 0, 0 ], defaultHash = genSamplerHash(defaultInfo), borderColor = {
        r: 0,
        g: 0,
        b: 0,
        a: 0
    }, gfxInfo = {};
    function genSamplerHash(info) {
        for (var value = 0, hash = 0, i = 0; i < defaultInfo.length; i++) switch (value = info[i] || defaultInfo[i], 
        i) {
          case SamplerInfoIndex.minFilter:
            hash |= value;
            break;

          case SamplerInfoIndex.magFilter:
            hash |= value << 2;
            break;

          case SamplerInfoIndex.mipFilter:
            hash |= value << 4;
            break;

          case SamplerInfoIndex.addressU:
            hash |= value << 6;
            break;

          case SamplerInfoIndex.addressV:
            hash |= value << 8;
            break;

          case SamplerInfoIndex.addressW:
            hash |= value << 10;
            break;

          case SamplerInfoIndex.maxAnisotropy:
            hash |= value << 12;
            break;

          case SamplerInfoIndex.cmpFunc:
            hash |= value << 16;
            break;

          case SamplerInfoIndex.minLOD:
            hash |= value << 20;
            break;

          case SamplerInfoIndex.maxLOD:
            hash |= value << 24;
            break;

          case SamplerInfoIndex.mipLODBias:
            hash |= value << 28;
        }
        return hash;
    }
    var _class$5, _class2$4, _descriptor$3, _descriptor2$2, _descriptor3$2, _descriptor4$1, _descriptor5$1, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _class3$2, _temp$4, samplerLib = new (function() {
        function SamplerLib() {
            _classCallCheck(this, SamplerLib), this._cache = {};
        }
        return _createClass(SamplerLib, [ {
            key: "getSampler",
            value: function getSampler(device, hash) {
                0 === hash && (hash = defaultHash);
                var cache = this._cache[hash];
                return cache || (gfxInfo.minFilter = 3 & hash, gfxInfo.magFilter = hash >> 2 & 3, 
                gfxInfo.mipFilter = hash >> 4 & 3, gfxInfo.addressU = hash >> 6 & 3, gfxInfo.addressV = hash >> 8 & 3, 
                gfxInfo.addressW = hash >> 10 & 3, gfxInfo.maxAnisotropy = hash >> 12 & 15, gfxInfo.cmpFunc = hash >> 16 & 15, 
                gfxInfo.minLOD = hash >> 20 & 15, gfxInfo.maxLOD = hash >> 24 & 15, gfxInfo.mipLODBias = hash >> 28 & 15, 
                gfxInfo.borderColor = borderColor, this._cache[hash] = device.createSampler(gfxInfo));
            }
        } ]), SamplerLib;
    }());
    cc.samplerLib = samplerLib;
    var _dec$6, _dec2$2, _class$6, _class2$5, _descriptor$4, _class3$3, _temp$5, idGenerator = new IDGenerator("Tex"), TextureBase = ccclass("cc.TextureBase")((_temp$4 = _class3$2 = function(_Asset) {
        function TextureBase() {
            var _this, flipY = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return _classCallCheck(this, TextureBase), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(TextureBase).call(this)), "_format", _descriptor$3, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_premultiplyAlpha", _descriptor2$2, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_flipY", _descriptor3$2, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_minFilter", _descriptor4$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_magFilter", _descriptor5$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_mipFilter", _descriptor6, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_wrapS", _descriptor7, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_wrapT", _descriptor8, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_wrapR", _descriptor9, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_anisotropy", _descriptor10, _assertThisInitialized(_this)), 
            _this._width = 0, _this._height = 0, _this._samplerInfo = [], _this._samplerHash = 0, 
            _this._flipY = flipY, _this._id = idGenerator.getNewId(), _this.loaded = !1, _this;
        }
        return _inherits(TextureBase, _Asset), _createClass(TextureBase, [ {
            key: "isCompressed",
            get: function get() {
                return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_PVRTC_4BPPV1;
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        } ]), _createClass(TextureBase, [ {
            key: "getId",
            value: function getId() {
                return this._id;
            }
        }, {
            key: "getPixelFormat",
            value: function getPixelFormat() {
                return this._format;
            }
        }, {
            key: "hasPremultipliedAlpha",
            value: function hasPremultipliedAlpha() {
                return this._premultiplyAlpha || !1;
            }
        }, {
            key: "getAnisotropy",
            value: function getAnisotropy() {
                return this._anisotropy;
            }
        }, {
            key: "setWrapMode",
            value: function setWrapMode(wrapS, wrapT, wrapR) {
                this._wrapS = wrapS, this._samplerInfo[SamplerInfoIndex.addressU] = wrapS, this._wrapT = wrapT, 
                this._samplerInfo[SamplerInfoIndex.addressV] = wrapT, void 0 !== wrapR && (this._wrapR = wrapR, 
                this._samplerInfo[SamplerInfoIndex.addressW] = wrapR), this._samplerHash = genSamplerHash(this._samplerInfo);
            }
        }, {
            key: "setFilters",
            value: function setFilters(minFilter, magFilter) {
                this._minFilter = minFilter, this._samplerInfo[SamplerInfoIndex.minFilter] = minFilter, 
                this._magFilter = magFilter, this._samplerInfo[SamplerInfoIndex.magFilter] = magFilter, 
                this._samplerHash = genSamplerHash(this._samplerInfo);
            }
        }, {
            key: "setMipFilter",
            value: function setMipFilter(mipFilter) {
                this._mipFilter = mipFilter, this._samplerInfo[SamplerInfoIndex.mipFilter] = mipFilter, 
                this._samplerInfo[SamplerInfoIndex.maxLOD] = mipFilter === Filter.NONE ? 0 : 15, 
                this._samplerHash = genSamplerHash(this._samplerInfo);
            }
        }, {
            key: "setFlipY",
            value: function setFlipY(flipY) {
                this._flipY = flipY;
            }
        }, {
            key: "setPremultiplyAlpha",
            value: function setPremultiplyAlpha(premultiply) {
                this._premultiplyAlpha = premultiply;
            }
        }, {
            key: "setAnisotropy",
            value: function setAnisotropy(anisotropy) {
                this._anisotropy = anisotropy, this._samplerInfo[SamplerInfoIndex.maxAnisotropy] = anisotropy, 
                this._samplerHash = genSamplerHash(this._samplerInfo);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return _get(_getPrototypeOf(TextureBase.prototype), "destroy", this).call(this);
            }
        }, {
            key: "getGFXTextureView",
            value: function getGFXTextureView() {
                return null;
            }
        }, {
            key: "getSamplerHash",
            value: function getSamplerHash() {
                return this._samplerHash;
            }
        }, {
            key: "_serialize",
            value: function _serialize(exporting) {
                return this._minFilter + "," + this._magFilter + "," + this._wrapS + "," + this._wrapT + "," + (this._premultiplyAlpha ? 1 : 0) + "," + this._mipFilter + "," + this._anisotropy + "," + (this._flipY ? 1 : 0);
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(serializedData, handle) {
                var fields = serializedData.split(",");
                fields.unshift(""), fields.length >= 6 && (this.setFilters(parseInt(fields[1]), parseInt(fields[2])), 
                this.setWrapMode(parseInt(fields[3]), parseInt(fields[4])), this._premultiplyAlpha = 49 === fields[5].charCodeAt(0)), 
                fields.length >= 8 && (this.setMipFilter(parseInt(fields[6])), this.setAnisotropy(parseInt(fields[7]))), 
                fields.length >= 9 && (this._flipY = 49 === fields[8].charCodeAt(0));
            }
        }, {
            key: "_getGFXDevice",
            value: function _getGFXDevice() {
                return cc.director.root && cc.director.root.device;
            }
        }, {
            key: "_getGFXFormat",
            value: function _getGFXFormat() {
                return this._format;
            }
        }, {
            key: "_setGFXFormat",
            value: function _setGFXFormat(format) {
                this._format = void 0 === format ? PixelFormat.RGBA8888 : format;
            }
        } ]), TextureBase;
    }(Asset), _class3$2.PixelFormat = PixelFormat, _class3$2.WrapMode = WrapMode$1, 
    _class3$2.Filter = Filter, _descriptor$3 = _applyDecoratedDescriptor((_class2$4 = _temp$4).prototype, "_format", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return PixelFormat.RGBA8888;
        }
    }), _descriptor2$2 = _applyDecoratedDescriptor(_class2$4.prototype, "_premultiplyAlpha", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$2 = _applyDecoratedDescriptor(_class2$4.prototype, "_flipY", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor4$1 = _applyDecoratedDescriptor(_class2$4.prototype, "_minFilter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Filter.LINEAR;
        }
    }), _descriptor5$1 = _applyDecoratedDescriptor(_class2$4.prototype, "_magFilter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Filter.LINEAR;
        }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2$4.prototype, "_mipFilter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Filter.NONE;
        }
    }), _descriptor7 = _applyDecoratedDescriptor(_class2$4.prototype, "_wrapS", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return WrapMode$1.REPEAT;
        }
    }), _descriptor8 = _applyDecoratedDescriptor(_class2$4.prototype, "_wrapT", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return WrapMode$1.REPEAT;
        }
    }), _descriptor9 = _applyDecoratedDescriptor(_class2$4.prototype, "_wrapR", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return WrapMode$1.REPEAT;
        }
    }), _descriptor10 = _applyDecoratedDescriptor(_class2$4.prototype, "_anisotropy", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 8;
        }
    }), _class$5 = _class2$4)) || _class$5;
    cc.TextureBase = TextureBase, ccenum(DepthStencilFormat);
    var _class$7, RenderTexture = (_dec$6 = ccclass("cc.RenderTexture"), _dec2$2 = property({
        type: DepthStencilFormat
    }), _dec$6((_temp$5 = _class3$3 = function(_TextureBase) {
        function RenderTexture() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, RenderTexture);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderTexture)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._window = null, 
            _initializerDefineProperty(_this, "_depthStencilFormat", _descriptor$4, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(RenderTexture, _TextureBase), _createClass(RenderTexture, [ {
            key: "getGFXWindow",
            value: function getGFXWindow() {
                return this._window;
            }
        }, {
            key: "getGFXTextureView",
            value: function getGFXTextureView() {
                return this._window ? this._window.colorTexView : null;
            }
        }, {
            key: "getGFXStencilTexture",
            value: function getGFXStencilTexture() {
                return this._window ? this._window.depthStencilTexView : null;
            }
        }, {
            key: "reset",
            value: function reset(info) {
                info && (this._width = info.width, this._height = info.height, info.colorFormat && (this._format = info.colorFormat), 
                info.depthStencilFormat && (this._depthStencilFormat = info.depthStencilFormat), 
                this._tryResetWindow(), this.emit("resize", this));
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this._window && (cc.director.root.destroyWindow(this._window), this._window = null), 
                _get(_getPrototypeOf(RenderTexture.prototype), "destroy", this).call(this);
            }
        }, {
            key: "onLoaded",
            value: function onLoaded() {
                this._tryResetWindow(), this.loaded = !0, this.emit("load");
            }
        }, {
            key: "_serialize",
            value: function _serialize(exporting) {
                return {
                    base: _get(_getPrototypeOf(RenderTexture.prototype), "_serialize", this).call(this),
                    name: this._name,
                    width: this._width,
                    height: this._height,
                    colorFormat: this._format,
                    depthStencilFormat: this._depthStencilFormat
                };
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(serializeData, handle) {
                _get(_getPrototypeOf(RenderTexture.prototype), "_deserialize", this).call(this, serializeData.base, handle);
                var data = serializeData;
                this.name = data.name || "", this._width = data.width, this._height = data.height, 
                this._format = data.colorFormat, this._depthStencilFormat = data.depthStencilFormat;
            }
        }, {
            key: "_tryResetWindow",
            value: function _tryResetWindow() {
                var device = this._getGFXDevice();
                device && (this._window && this._window.destroy(), this._createWindow(device));
            }
        }, {
            key: "_createWindow",
            value: function _createWindow(device) {
                var config = {
                    title: this.name,
                    isOffscreen: !0,
                    width: this._width,
                    height: this._height,
                    colorFmt: this._format,
                    depthStencilFmt: this._depthStencilFormat
                };
                if (this._window) return this._window.initialize(config), this._window;
                this._window = cc.director.root.createWindow(config);
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            },
            set: function set(value) {
                this._width = value, this.reset();
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            },
            set: function set(value) {
                this._height = value, this.reset();
            }
        }, {
            key: "depthStencilFormat",
            get: function get() {
                return this._depthStencilFormat;
            },
            set: function set(value) {
                this._depthStencilFormat = value, this.reset();
            }
        } ]), RenderTexture;
    }(TextureBase), _class3$3.DepthStencilFormat = DepthStencilFormat, _descriptor$4 = _applyDecoratedDescriptor((_class2$5 = _temp$5).prototype, "_depthStencilFormat", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return DepthStencilFormat.NONE;
        }
    }), _applyDecoratedDescriptor(_class2$5.prototype, "width", [ property ], Object.getOwnPropertyDescriptor(_class2$5.prototype, "width"), _class2$5.prototype), 
    _applyDecoratedDescriptor(_class2$5.prototype, "height", [ property ], Object.getOwnPropertyDescriptor(_class2$5.prototype, "height"), _class2$5.prototype), 
    _applyDecoratedDescriptor(_class2$5.prototype, "depthStencilFormat", [ _dec2$2 ], Object.getOwnPropertyDescriptor(_class2$5.prototype, "depthStencilFormat"), _class2$5.prototype), 
    _class$6 = _class2$5)) || _class$6);
    cc.RenderTexture = RenderTexture;
    var _regions = [ {
        buffOffset: 0,
        buffStride: 0,
        buffTexHeight: 0,
        texOffset: {
            x: 0,
            y: 0,
            z: 0
        },
        texExtent: {
            width: 1,
            height: 1,
            depth: 1
        },
        texSubres: {
            baseMipLevel: 1,
            levelCount: 1,
            baseArrayLayer: 0,
            layerCount: 1
        }
    } ];
    function isPOT(n) {
        return n && 0 == (n & n - 1);
    }
    var _dec$8, _dec2$3, _class$8, _class2$6, _descriptor$5, SimpleTexture = ccclass("cc.SimpleTexture")(_class$7 = function(_TextureBase) {
        function SimpleTexture() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SimpleTexture);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SimpleTexture)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gfxTexture = null, 
            _this._gfxTextureView = null, _this._mipmapLevel = 1, _this;
        }
        return _inherits(SimpleTexture, _TextureBase), _createClass(SimpleTexture, [ {
            key: "getGFXTexture",
            value: function getGFXTexture() {
                return this._gfxTexture;
            }
        }, {
            key: "getGFXTextureView",
            value: function getGFXTextureView() {
                return this._gfxTextureView;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this._tryDestroyTexture(), _get(_getPrototypeOf(SimpleTexture.prototype), "destroy", this).call(this);
            }
        }, {
            key: "updateImage",
            value: function updateImage() {
                this.updateMipmaps(0);
            }
        }, {
            key: "updateMipmaps",
            value: function updateMipmaps() {}
        }, {
            key: "uploadData",
            value: function uploadData(source) {
                var level = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, arrayIndex = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                if (this._gfxTexture && !(this._gfxTexture.mipLevel <= level)) {
                    var gfxDevice = this._getGFXDevice();
                    if (gfxDevice) {
                        var region = _regions[0];
                        region.texExtent.width = this._gfxTexture.width >> level, region.texExtent.height = this._gfxTexture.height >> level, 
                        region.texSubres.baseMipLevel = level, region.texSubres.baseArrayLayer = arrayIndex, 
                        ArrayBuffer.isView(source) ? gfxDevice.copyBuffersToTexture([ source ], this._gfxTexture, _regions) : gfxDevice.copyTexImagesToTexture([ source ], this._gfxTexture, _regions);
                    }
                }
            }
        }, {
            key: "_assignImage",
            value: function _assignImage(image, level, arrayIndex) {
                var _this2 = this, upload = function upload() {
                    var data = image.data;
                    data && (_this2.uploadData(data, level, arrayIndex), _this2._checkTextureLoaded());
                };
                if (image.loaded) upload(); else {
                    if (image.once("load", (function() {
                        upload();
                    })), !this.isCompressed) {
                        var defaultImg = cc.builtinResMgr.get("black-texture").image;
                        this.uploadData(defaultImg.data, level, arrayIndex);
                    }
                    cc.textureUtil.postLoadImage(image);
                }
            }
        }, {
            key: "_checkTextureLoaded",
            value: function _checkTextureLoaded() {
                this._textureReady();
            }
        }, {
            key: "_textureReady",
            value: function _textureReady() {
                this.loaded = !0, this.emit("load");
            }
        }, {
            key: "_setMipmapLevel",
            value: function _setMipmapLevel(value) {
                this._mipmapLevel = value < 1 ? 1 : value;
            }
        }, {
            key: "_getGfxTextureCreateInfo",
            value: function _getGfxTextureCreateInfo(presumed) {
                return null;
            }
        }, {
            key: "_getGfxTextureViewCreateInfo",
            value: function _getGfxTextureViewCreateInfo(texture) {
                return null;
            }
        }, {
            key: "_tryReset",
            value: function _tryReset() {
                this._tryDestroyTexture();
                var device = this._getGFXDevice();
                device && this._createTexture(device);
            }
        }, {
            key: "_createTexture",
            value: function _createTexture(device) {
                var flags = exports.GFXTextureFlagBit.NONE;
                this._mipFilter !== Filter.NONE && function canGenerateMipmap(device, w, h) {
                    return !(device.gfxAPI === exports.GFXAPI.WEBGL) || isPOT(w) && isPOT(h);
                }(device, this._width, this._height) && (this._mipmapLevel = function getMipLevel(width, height) {
                    for (var size = Math.max(width, height), level = 0; size; ) size >>= 1, level++;
                    return level;
                }(this._width, this._height), flags = exports.GFXTextureFlagBit.GEN_MIPMAP);
                var textureCreateInfo = this._getGfxTextureCreateInfo({
                    usage: exports.GFXTextureUsageBit.SAMPLED | exports.GFXTextureUsageBit.TRANSFER_DST,
                    format: this._getGFXFormat(),
                    mipLevel: this._mipmapLevel,
                    flags: flags
                });
                if (textureCreateInfo) {
                    var texture = device.createTexture(textureCreateInfo), textureViewCreateInfo = this._getGfxTextureViewCreateInfo({
                        texture: texture,
                        format: this._getGFXFormat()
                    });
                    if (textureViewCreateInfo) {
                        var view = device.createTextureView(textureViewCreateInfo);
                        view ? (this._gfxTexture = texture, this._gfxTextureView = view) : texture.destroy();
                    } else texture.destroy();
                }
            }
        }, {
            key: "_tryDestroyTexture",
            value: function _tryDestroyTexture() {
                this._gfxTexture && (this._gfxTexture.destroy(), this._gfxTexture = null), this._gfxTextureView && (this._gfxTextureView.destroy(), 
                this._gfxTextureView = null);
            }
        }, {
            key: "mipmapLevel",
            get: function get() {
                return this._mipmapLevel;
            }
        } ]), SimpleTexture;
    }(TextureBase)) || _class$7;
    cc.SimpleTexture = SimpleTexture;
    var _class$9, Texture2D = (_dec$8 = ccclass("cc.Texture2D"), _dec2$3 = property([ ImageAsset ]), 
    _dec$8((_descriptor$5 = _applyDecoratedDescriptor((_class2$6 = function(_SimpleTexture) {
        function Texture2D() {
            var _this;
            return _classCallCheck(this, Texture2D), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Texture2D).call(this, !0)), "_mipmaps", _descriptor$5, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(Texture2D, _SimpleTexture), _createClass(Texture2D, [ {
            key: "mipmaps",
            get: function get() {
                return this._mipmaps;
            },
            set: function set(value) {
                var _this2 = this;
                if (this._mipmaps = value, this._setMipmapLevel(this._mipmaps.length), this._mipmaps.length > 0) {
                    var imageAsset = this._mipmaps[0];
                    this.reset({
                        width: imageAsset.width,
                        height: imageAsset.height,
                        format: imageAsset.format,
                        mipmapLevel: this._mipmaps.length
                    }), this._mipmaps.forEach((function(mipmap, level) {
                        _this2._assignImage(mipmap, level);
                    }));
                } else this.reset({
                    width: 0,
                    height: 0,
                    mipmapLevel: this._mipmaps.length
                });
            }
        }, {
            key: "image",
            get: function get() {
                return 0 === this._mipmaps.length ? null : this._mipmaps[0];
            },
            set: function set(value) {
                this.mipmaps = value ? [ value ] : [];
            }
        } ]), _createClass(Texture2D, [ {
            key: "onLoaded",
            value: function onLoaded() {
                this.initialize();
            }
        }, {
            key: "reset",
            value: function reset(info) {
                this._width = info.width, this._height = info.height, this._setGFXFormat(info.format), 
                this._setMipmapLevel(info.mipmapLevel || 1), this._tryReset();
            }
        }, {
            key: "create",
            value: function create(width, height) {
                var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : PixelFormat.RGBA8888, mipmapLevel = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                this.reset({
                    width: width,
                    height: height,
                    format: format,
                    mipmapLevel: mipmapLevel
                });
            }
        }, {
            key: "toString",
            value: function toString() {
                return 0 !== this._mipmaps.length ? this._mipmaps[0].url : "";
            }
        }, {
            key: "updateMipmaps",
            value: function updateMipmaps() {
                var firstLevel = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, count = arguments.length > 1 ? arguments[1] : void 0;
                if (!(firstLevel >= this._mipmaps.length)) for (var nUpdate = Math.min(void 0 === count ? this._mipmaps.length : count, this._mipmaps.length - firstLevel), i = 0; i < nUpdate; ++i) {
                    var level = firstLevel + i;
                    this._assignImage(this._mipmaps[level], level);
                }
            }
        }, {
            key: "getHtmlElementObj",
            value: function getHtmlElementObj() {
                return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this._mipmaps = [], _get(_getPrototypeOf(Texture2D.prototype), "destroy", this).call(this);
            }
        }, {
            key: "description",
            value: function description() {
                var url = this._mipmaps[0] ? this._mipmaps[0].url : "";
                return "<cc.Texture2D | Name = ".concat(url, " | Dimension = ").concat(this.width, " x ").concat(this.height, ">");
            }
        }, {
            key: "releaseTexture",
            value: function releaseTexture() {
                this.destroy();
            }
        }, {
            key: "_serialize",
            value: function _serialize(exporting) {
                return {
                    base: _get(_getPrototypeOf(Texture2D.prototype), "_serialize", this).call(this, exporting),
                    mipmaps: this._mipmaps.map((function(mipmap) {
                        return mipmap && mipmap._uuid ? exporting ? Editor.Utils.UuidUtils.compressUuid(mipmap._uuid, !0) : mipmap._uuid : null;
                    }))
                };
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(serializedData, handle) {
                var data = serializedData;
                _get(_getPrototypeOf(Texture2D.prototype), "_deserialize", this).call(this, data.base, handle), 
                this._mipmaps = new Array(data.mipmaps.length);
                for (var i = 0; i < data.mipmaps.length; ++i) if (this._mipmaps[i] = new ImageAsset, 
                data.mipmaps[i]) {
                    var mipmapUUID = data.mipmaps[i];
                    handle.result.push(this._mipmaps, "".concat(i), mipmapUUID), this._mipmaps[i]._texture = this;
                }
            }
        }, {
            key: "initialize",
            value: function initialize() {
                this.mipmaps = this._mipmaps;
            }
        }, {
            key: "_getGfxTextureCreateInfo",
            value: function _getGfxTextureCreateInfo(presumed) {
                return Object.assign({
                    type: exports.GFXTextureType.TEX2D,
                    width: this._width,
                    height: this._height
                }, presumed);
            }
        }, {
            key: "_getGfxTextureViewCreateInfo",
            value: function _getGfxTextureViewCreateInfo(presumed) {
                return Object.assign({
                    type: exports.GFXTextureViewType.TV2D
                }, presumed);
            }
        }, {
            key: "_checkTextureLoaded",
            value: function _checkTextureLoaded() {
                for (var ready = !0, i = 0; i < this._mipmaps.length; ++i) {
                    if (!this._mipmaps[i].loaded) {
                        ready = !1;
                        break;
                    }
                }
                ready && _get(_getPrototypeOf(Texture2D.prototype), "_textureReady", this).call(this);
            }
        } ]), Texture2D;
    }(SimpleTexture)).prototype, "_mipmaps", [ _dec2$3 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$8 = _class2$6)) || _class$8);
    cc.Texture2D = Texture2D;
    var _class$a, _class2$7, _descriptor$6, _class3$4, _temp$9, FaceIndex, temp_uvs = [ {
        u: 0,
        v: 0
    }, {
        u: 0,
        v: 0
    }, {
        u: 0,
        v: 0
    }, {
        u: 0,
        v: 0
    } ], SpriteFrame = ccclass("cc.SpriteFrame")(_class$9 = function(_Asset) {
        function SpriteFrame() {
            var _this;
            return _classCallCheck(this, SpriteFrame), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SpriteFrame).call(this))).vertices = null, 
            _this.uv = [], _this.uvHash = 0, _this._image = null, _this.uvSliced = [], _this._rect = new Rect, 
            _this._offset = new Vec2, _this._originalSize = new Size, _this._rotated = !1, _this._capInsets = [ 0, 0, 0, 0 ], 
            _this._atlasUuid = "", _this._flipUv = !1, _this;
        }
        return _inherits(SpriteFrame, _Asset), _createClass(SpriteFrame, [ {
            key: "insetTop",
            get: function get() {
                return this._capInsets[1];
            },
            set: function set(value) {
                this._capInsets[1] !== value && (this._capInsets[1] = value, this._texture && this._calculateSlicedUV());
            }
        }, {
            key: "insetBottom",
            get: function get() {
                return this._capInsets[3];
            },
            set: function set(value) {
                this._capInsets[3] !== value && (this._capInsets[3] = value, this._texture && this._calculateSlicedUV());
            }
        }, {
            key: "insetLeft",
            get: function get() {
                return this._capInsets[0];
            },
            set: function set(value) {
                this._capInsets[0] !== value && (this._capInsets[0] = value, this._texture && this._calculateSlicedUV());
            }
        }, {
            key: "insetRight",
            get: function get() {
                return this._capInsets[2];
            },
            set: function set(value) {
                this._capInsets[2] !== value && (this._capInsets[2] = value, this._texture && this._calculateSlicedUV());
            }
        }, {
            key: "rect",
            get: function get() {
                return this._rect;
            },
            set: function set(value) {
                this._rect.equals(value) || (this._rect.set(value), this._texture && this._calculateUV());
            }
        }, {
            key: "originalSize",
            get: function get() {
                return this._originalSize;
            },
            set: function set(value) {
                this._originalSize.equals(value) || (this._originalSize.set(value), this._texture && this._calculateUV());
            }
        }, {
            key: "offset",
            get: function get() {
                return this._offset;
            },
            set: function set(value) {
                this._offset.set(value);
            }
        }, {
            key: "rotated",
            get: function get() {
                return this._rotated;
            },
            set: function set(rotated) {
                this._rotated !== rotated && (this._rotated = rotated, this._texture && this._calculateUV());
            }
        }, {
            key: "texture",
            get: function get() {
                return this._texture || (this._texture = !this._image || window.Editor && Editor.isBuilder ? new Texture2D : this._image._texture, 
                this._texture.on("load", this._textureLoaded, this)), this._texture;
            },
            set: function set(value) {
                value ? (this.reset({
                    texture: value
                }, !0), this._texture instanceof RenderTexture && this.onLoaded()) : console.warn("Error Texture in ".concat(this.name));
            }
        }, {
            key: "atlasUuid",
            get: function get() {
                return this._atlasUuid;
            },
            set: function set(value) {
                this._atlasUuid = value;
            }
        }, {
            key: "width",
            get: function get() {
                return this._texture.width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._texture.height;
            }
        }, {
            key: "_imageSource",
            set: function set(value) {
                this._image = value, window.Editor && Editor.isBuilder || (this._texture = value._texture, 
                this._texture.on("load", this._textureLoaded, this), this._calculateUV());
            }
        } ]), _createClass(SpriteFrame, [ {
            key: "textureLoaded",
            value: function textureLoaded() {
                return this.loaded;
            }
        }, {
            key: "isRotated",
            value: function isRotated() {
                return this._rotated;
            }
        }, {
            key: "setRotated",
            value: function setRotated(rotated) {
                this.rotated = rotated;
            }
        }, {
            key: "getRect",
            value: function getRect(out) {
                return out ? (out.set(this._rect), out) : this._rect.clone();
            }
        }, {
            key: "setRect",
            value: function setRect(rect) {
                this.rect = rect;
            }
        }, {
            key: "getOriginalSize",
            value: function getOriginalSize(out) {
                return out ? (out.set(this._originalSize), out) : this._originalSize.clone();
            }
        }, {
            key: "setOriginalSize",
            value: function setOriginalSize(size) {
                this.originalSize = size;
            }
        }, {
            key: "getOffset",
            value: function getOffset(out) {
                return out ? (out.set(this._offset), out) : this._offset.clone();
            }
        }, {
            key: "setOffset",
            value: function setOffset(offset) {
                this.offset = offset;
            }
        }, {
            key: "getGFXTextureView",
            value: function getGFXTextureView() {
                return this._texture.getGFXTextureView();
            }
        }, {
            key: "reset",
            value: function reset(info) {
                var clearData = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], calUV = !1;
                clearData && (this._originalSize.set(0, 0), this._rect.set(0, 0, 0, 0), this._offset.set(0, 0), 
                this._capInsets = [ 0, 0, 0, 0 ], this._rotated = !1, calUV = !0), info && (info.texture && (this._rect.x = this._rect.y = 0, 
                this._rect.width = info.texture.width, this._rect.height = info.texture.height, 
                this._texture && this._texture.off("load"), this._texture = info.texture, this.checkRect(this._texture), 
                this._texture.on("load", this._textureLoaded, this)), info.originalSize && this._originalSize.set(info.originalSize), 
                info.rect && this._rect.set(info.rect), info.offset && this._offset.set(info.offset), 
                void 0 !== info.borderTop && (this._capInsets[1] = info.borderTop), void 0 !== info.borderBottom && (this._capInsets[3] = info.borderBottom), 
                void 0 !== info.borderLeft && (this._capInsets[0] = info.borderLeft), void 0 !== info.borderRight && (this._capInsets[2] = info.borderRight), 
                void 0 !== info.isRotate && (this._rotated = !!info.isRotate), void 0 !== info.isFlipUv && (this._flipUv = !!info.isFlipUv), 
                this._texture instanceof RenderTexture && (this._flipUv = !0), calUV = !0), calUV && this._calculateUV();
            }
        }, {
            key: "checkRect",
            value: function checkRect(texture) {
                var rect = this._rect, maxX = rect.x, maxY = rect.y;
                return this._rotated ? (maxX += rect.height, maxY += rect.width) : (maxX += rect.width, 
                maxY += rect.height), maxX > texture.width ? (cc.errorID(3300, this.name + "/" + texture.name, maxX, texture.width), 
                !1) : !(maxY > texture.height) || (cc.errorID(3301, this.name + "/" + texture.name, maxY, texture.height), 
                !1);
            }
        }, {
            key: "onLoaded",
            value: function onLoaded() {
                this.loaded = !0, this.emit("load");
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this._texture && this._texture.off("load"), _get(_getPrototypeOf(SpriteFrame.prototype), "destroy", this).call(this);
            }
        }, {
            key: "_calculateSlicedUV",
            value: function _calculateSlicedUV() {
                var rect = this._rect, tex = this.texture, atlasWidth = tex.width, atlasHeight = tex.height, leftWidth = this._capInsets[0], rightWidth = this._capInsets[2], centerWidth = rect.width - leftWidth - rightWidth, topHeight = this._capInsets[1], bottomHeight = this._capInsets[3], centerHeight = rect.height - topHeight - bottomHeight, uvSliced = this.uvSliced;
                if (uvSliced.length = 0, this._rotated) {
                    temp_uvs[0].u = (rect.x + rect.height) / atlasWidth, temp_uvs[1].u = (rect.x + topHeight + centerHeight) / atlasWidth, 
                    temp_uvs[2].u = (rect.x + topHeight) / atlasWidth, temp_uvs[3].u = rect.x / atlasWidth, 
                    temp_uvs[3].v = rect.y / atlasHeight, temp_uvs[2].v = (rect.y + rightWidth) / atlasHeight, 
                    temp_uvs[1].v = (rect.y + rightWidth + centerWidth) / atlasHeight, temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;
                    for (var row = 0; row < 4; ++row) for (var rowD = temp_uvs[row], col = 0; col < 4; ++col) {
                        var colD = temp_uvs[col];
                        uvSliced.push({
                            u: rowD.u,
                            v: colD.v
                        });
                    }
                } else {
                    temp_uvs[0].u = rect.x / atlasWidth, temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth, 
                    temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth, temp_uvs[3].u = (rect.x + rect.width) / atlasWidth, 
                    temp_uvs[3].v = rect.y / atlasHeight, temp_uvs[2].v = (rect.y + topHeight) / atlasHeight, 
                    temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight, temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;
                    for (var _row = 0; _row < 4; ++_row) for (var _rowD = temp_uvs[_row], _col = 0; _col < 4; ++_col) {
                        var _colD = temp_uvs[_col];
                        uvSliced.push({
                            u: _colD.u,
                            v: _rowD.v
                        });
                    }
                }
            }
        }, {
            key: "_calculateUV",
            value: function _calculateUV() {
                var rect = this._rect, uv = this.uv, tex = this.texture, texw = tex.width, texh = tex.height;
                if (this._rotated) {
                    var l = 0 === texw ? 0 : rect.x / texw, r = 0 === texw ? 0 : (rect.x + rect.height) / texw, t = 0 === texh ? 0 : rect.y / texh, b = 0 === texh ? 0 : (rect.y + rect.width) / texh;
                    this._flipUv ? (uv[0] = l, uv[1] = t, uv[2] = l, uv[3] = b, uv[4] = r, uv[5] = t, 
                    uv[6] = r, uv[7] = b) : (uv[0] = r, uv[1] = b, uv[2] = r, uv[3] = t, uv[4] = l, 
                    uv[5] = b, uv[6] = l, uv[7] = t);
                } else {
                    var _l = 0 === texw ? 0 : rect.x / texw, _r = 0 === texw ? 0 : (rect.x + rect.width) / texw, _b = 0 === texh ? 0 : (rect.y + rect.height) / texh, _t = 0 === texh ? 0 : rect.y / texh;
                    this._flipUv ? (uv[0] = _l, uv[1] = _t, uv[2] = _r, uv[3] = _t, uv[4] = _l, uv[5] = _b, 
                    uv[6] = _r, uv[7] = _b) : (uv[0] = _l, uv[1] = _b, uv[2] = _r, uv[3] = _b, uv[4] = _l, 
                    uv[5] = _t, uv[6] = _r, uv[7] = _t);
                }
                for (var uvHashStr = "", i = 0; i < uv.length; i++) uvHashStr += uv[i];
                this.uvHash = murmurhash2_32_gc(uvHashStr, 666);
                var vertices = this.vertices;
                if (vertices) {
                    vertices.nu.length = 0, vertices.nv.length = 0;
                    for (var _i = 0; _i < vertices.u.length; _i++) vertices.nu[_i] = vertices.u[_i] / texw, 
                    vertices.nv[_i] = vertices.v[_i] / texh;
                }
                this._calculateSlicedUV();
            }
        }, {
            key: "_serialize",
            value: function _serialize(exporting) {
                var vertices, rect = this._rect, offset = this._offset, originalSize = this._originalSize, uuid = this._uuid;
                return uuid && exporting && (uuid = Editor.Utils.UuidUtils.compressUuid(uuid, !0)), 
                this.vertices && (vertices = {
                    triangles: this.vertices.triangles,
                    x: this.vertices.x,
                    y: this.vertices.y,
                    u: this.vertices.u,
                    v: this.vertices.v
                }), {
                    image: this._image ? exporting ? Editor.Utils.UuidUtils.compressUuid(this._image._uuid, !0) : this._image._uuid : void 0,
                    name: this._name,
                    atlas: exporting ? void 0 : this._atlasUuid,
                    rect: rect,
                    offset: offset,
                    originalSize: originalSize,
                    rotated: this._rotated,
                    capInsets: this._capInsets,
                    vertices: vertices
                };
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(serializeData, handle) {
                var data = serializeData, rect = data.rect;
                rect && (this._rect = new Rect(rect.x, rect.y, rect.width, rect.height));
                var offset = data.offset;
                data.offset && (this._offset = new Vec2(offset.x, offset.y));
                var originalSize = data.originalSize;
                data.originalSize && (this._originalSize = new Size(originalSize.width, originalSize.height)), 
                this._rotated = !!data.rotated, this._name = data.name;
                var capInsets = data.capInsets;
                capInsets && (this._capInsets[0] = capInsets[0], this._capInsets[1] = capInsets[1], 
                this._capInsets[2] = capInsets[2], this._capInsets[3] = capInsets[3]), handle.result.push(this, "_imageSource", data.image), 
                this.vertices = data.vertices, this.vertices && (this.vertices.nu = [], this.vertices.nv = []);
            }
        }, {
            key: "_textureLoaded",
            value: function _textureLoaded() {
                var tex = this._texture, config = {}, isReset = !1;
                0 !== this._rect.width && 0 !== this._rect.height && this.checkRect(tex) || (config.rect = new Rect(0, 0, tex.width, tex.height), 
                isReset = !0), (0 === this._originalSize.width || 0 === this._originalSize.height || isReset) && (config.originalSize = new Size(tex.width, tex.height), 
                isReset = !0), isReset && (this.reset(config), this.onLoaded());
            }
        } ]), SpriteFrame;
    }(Asset)) || _class$9;
    cc.SpriteFrame = SpriteFrame, function(FaceIndex) {
        FaceIndex[FaceIndex.right = 0] = "right", FaceIndex[FaceIndex.left = 1] = "left", 
        FaceIndex[FaceIndex.top = 2] = "top", FaceIndex[FaceIndex.bottom = 3] = "bottom", 
        FaceIndex[FaceIndex.front = 4] = "front", FaceIndex[FaceIndex.back = 5] = "back";
    }(FaceIndex || (FaceIndex = {}));
    var SystemEventType, TextureCube = ccclass("cc.TextureCube")((_temp$9 = _class3$4 = function(_SimpleTexture) {
        function TextureCube() {
            var _this;
            return _classCallCheck(this, TextureCube), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(TextureCube).call(this)), "_mipmaps", _descriptor$6, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(TextureCube, _SimpleTexture), _createClass(TextureCube, [ {
            key: "mipmaps",
            get: function get() {
                return this._mipmaps;
            },
            set: function set(value) {
                var _this2 = this;
                if (this._mipmaps = value, this._setMipmapLevel(this._mipmaps.length), this._mipmaps.length > 0) {
                    var imageAsset = this._mipmaps[0].front;
                    this.reset({
                        width: imageAsset.width,
                        height: imageAsset.height,
                        format: imageAsset.format,
                        mipmapLevel: this._mipmaps.length
                    }), this._mipmaps.forEach((function(mipmap, level) {
                        _forEachFace(mipmap, (function(face, faceIndex) {
                            _this2._assignImage(face, level, faceIndex);
                        }));
                    }));
                } else this.reset({
                    width: 0,
                    height: 0,
                    mipmapLevel: this._mipmaps.length
                });
            }
        }, {
            key: "image",
            get: function get() {
                return 0 === this._mipmaps.length ? null : this._mipmaps[0];
            },
            set: function set(value) {
                this.mipmaps = value ? [ value ] : [];
            }
        } ], [ {
            key: "fromTexture2DArray",
            value: function fromTexture2DArray(textures, out) {
                for (var mipmaps = [], nMipmaps = textures.length / 6, i = 0; i < nMipmaps; i++) {
                    var x = 6 * i;
                    mipmaps.push({
                        front: textures[x + FaceIndex.front].image,
                        back: textures[x + FaceIndex.back].image,
                        left: textures[x + FaceIndex.left].image,
                        right: textures[x + FaceIndex.right].image,
                        top: textures[x + FaceIndex.top].image,
                        bottom: textures[x + FaceIndex.bottom].image
                    });
                }
                return (out = out || new TextureCube).mipmaps = mipmaps, out;
            }
        } ]), _createClass(TextureCube, [ {
            key: "onLoaded",
            value: function onLoaded() {
                this.mipmaps = this._mipmaps, this.loaded = !0, this.emit("load");
            }
        }, {
            key: "reset",
            value: function reset(info) {
                this._width = info.width, this._height = info.height, this._setGFXFormat(info.format), 
                this._setMipmapLevel(info.mipmapLevel || 1), this._tryReset();
            }
        }, {
            key: "updateMipmaps",
            value: function updateMipmaps() {
                var _this3 = this, firstLevel = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, count = arguments.length > 1 ? arguments[1] : void 0;
                if (!(firstLevel >= this._mipmaps.length)) for (var nUpdate = Math.min(void 0 === count ? this._mipmaps.length : count, this._mipmaps.length - firstLevel), _loop = function _loop(i) {
                    var level = firstLevel + i;
                    _forEachFace(_this3._mipmaps[level], (function(face, faceIndex) {
                        _this3._assignImage(face, level, faceIndex);
                    }));
                }, i = 0; i < nUpdate; ++i) _loop(i);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this._mipmaps = [], _get(_getPrototypeOf(TextureCube.prototype), "destroy", this).call(this);
            }
        }, {
            key: "releaseTexture",
            value: function releaseTexture() {
                this.mipmaps = [];
            }
        }, {
            key: "_serialize",
            value: function _serialize(exporting) {
                return {
                    base: _get(_getPrototypeOf(TextureCube.prototype), "_serialize", this).call(this),
                    mipmaps: this._mipmaps.map((function(mipmap) {
                        return exporting ? {
                            front: Editor.Utils.UuidUtils.compressUuid(mipmap.front._uuid, !0),
                            back: Editor.Utils.UuidUtils.compressUuid(mipmap.back._uuid, !0),
                            left: Editor.Utils.UuidUtils.compressUuid(mipmap.left._uuid, !0),
                            right: Editor.Utils.UuidUtils.compressUuid(mipmap.right._uuid, !0),
                            top: Editor.Utils.UuidUtils.compressUuid(mipmap.top._uuid, !0),
                            bottom: Editor.Utils.UuidUtils.compressUuid(mipmap.bottom._uuid, !0)
                        } : {
                            front: mipmap.front._uuid,
                            back: mipmap.back._uuid,
                            left: mipmap.left._uuid,
                            right: mipmap.right._uuid,
                            top: mipmap.top._uuid,
                            bottom: mipmap.bottom._uuid
                        };
                    }))
                };
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(serializedData, handle) {
                var data = serializedData;
                _get(_getPrototypeOf(TextureCube.prototype), "_deserialize", this).call(this, data.base, handle), 
                this._mipmaps = new Array(data.mipmaps.length);
                for (var i = 0; i < data.mipmaps.length; ++i) {
                    this._mipmaps[i] = {
                        front: new ImageAsset,
                        back: new ImageAsset,
                        left: new ImageAsset,
                        right: new ImageAsset,
                        top: new ImageAsset,
                        bottom: new ImageAsset
                    };
                    var mipmap = data.mipmaps[i];
                    handle.result.push(this._mipmaps[i], "front", mipmap.front), handle.result.push(this._mipmaps[i], "back", mipmap.back), 
                    handle.result.push(this._mipmaps[i], "left", mipmap.left), handle.result.push(this._mipmaps[i], "right", mipmap.right), 
                    handle.result.push(this._mipmaps[i], "top", mipmap.top), handle.result.push(this._mipmaps[i], "bottom", mipmap.bottom);
                }
            }
        }, {
            key: "_getGfxTextureCreateInfo",
            value: function _getGfxTextureCreateInfo(presumed) {
                var result = Object.assign({
                    type: exports.GFXTextureType.TEX2D,
                    width: this._width,
                    height: this._height,
                    arrayLayer: 6
                }, presumed);
                return result.flags = (result.flags || 0) | exports.GFXTextureFlagBit.CUBEMAP, result;
            }
        }, {
            key: "_getGfxTextureViewCreateInfo",
            value: function _getGfxTextureViewCreateInfo(presumed) {
                return Object.assign({
                    type: exports.GFXTextureViewType.CUBE,
                    layerCount: 6
                }, presumed);
            }
        } ]), TextureCube;
    }(SimpleTexture), _class3$4.FaceIndex = FaceIndex, _descriptor$6 = _applyDecoratedDescriptor((_class2$7 = _temp$9).prototype, "_mipmaps", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$a = _class2$7)) || _class$a;
    function _forEachFace(mipmap, callback) {
        callback(mipmap.front, FaceIndex.front), callback(mipmap.back, FaceIndex.back), 
        callback(mipmap.left, FaceIndex.left), callback(mipmap.right, FaceIndex.right), 
        callback(mipmap.top, FaceIndex.top), callback(mipmap.bottom, FaceIndex.bottom);
    }
    cc.TextureCube = TextureCube, (SystemEventType = exports.SystemEventType || (exports.SystemEventType = {})).TOUCH_START = "touch-start", 
    SystemEventType.TOUCH_MOVE = "touch-move", SystemEventType.TOUCH_END = "touch-end", 
    SystemEventType.TOUCH_CANCEL = "touch-cancel", SystemEventType.MOUSE_DOWN = "mouse-down", 
    SystemEventType.MOUSE_MOVE = "mouse-move", SystemEventType.MOUSE_UP = "mouse-up", 
    SystemEventType.MOUSE_WHEEL = "mouse-wheel", SystemEventType.MOUSE_ENTER = "mouse-enter", 
    SystemEventType.MOUSE_LEAVE = "mouse-leave", SystemEventType.KEY_DOWN = "keydown", 
    SystemEventType.KEY_UP = "keyup", SystemEventType.DEVICEMOTION = "devicemotion", 
    SystemEventType.TRANSFORM_CHANGED = "transform-changed", SystemEventType.SCENE_CHANGED_FOR_PERSISTS = "scene-changed-for-persists", 
    SystemEventType.SIZE_CHANGED = "size-changed", SystemEventType.ANCHOR_CHANGED = "anchor-changed", 
    SystemEventType.CHILD_ADDED = "child-added", SystemEventType.CHILD_REMOVED = "child-removed", 
    SystemEventType.PARENT_CHANGED = "parent-changed", SystemEventType.NODE_DESTROYED = "node-destroyed", 
    ccenum(exports.SystemEventType), cc.SystemEventType = exports.SystemEventType;
    var Event = function() {
        function Event(type, bubbles) {
            _classCallCheck(this, Event), this.target = null, this.currentTarget = null, this.eventPhase = 0, 
            this.propagationStopped = !1, this.propagationImmediateStopped = !1, this.type = type, 
            this.bubbles = !!bubbles;
        }
        return _createClass(Event, [ {
            key: "unuse",
            value: function unuse() {
                this.type = Event.NO_TYPE, this.target = null, this.currentTarget = null, this.eventPhase = Event.NONE, 
                this.propagationStopped = !1, this.propagationImmediateStopped = !1;
            }
        }, {
            key: "reuse",
            value: function reuse(type, bubbles) {
                this.type = type, this.bubbles = bubbles || !1;
            }
        }, {
            key: "isStopped",
            value: function isStopped() {
                return this.propagationStopped || this.propagationImmediateStopped;
            }
        }, {
            key: "getCurrentTarget",
            value: function getCurrentTarget() {
                return this.currentTarget;
            }
        }, {
            key: "getType",
            value: function getType() {
                return this.type;
            }
        } ]), Event;
    }();
    Event.NO_TYPE = "no_type", Event.TOUCH = "touch", Event.MOUSE = "mouse", Event.KEYBOARD = "keyboard", 
    Event.ACCELERATION = "acceleration", Event.NONE = 0, Event.CAPTURING_PHASE = 1, 
    Event.AT_TARGET = 2, Event.BUBBLING_PHASE = 3, cc.Event = Event;
    var EventMouse = function(_Event) {
        function EventMouse(eventType, bubbles) {
            var _this;
            return _classCallCheck(this, EventMouse), (_this = _possibleConstructorReturn(this, _getPrototypeOf(EventMouse).call(this, Event.MOUSE, bubbles))).movementX = 0, 
            _this.movementY = 0, _this._button = 0, _this._x = 0, _this._y = 0, _this._prevX = 0, 
            _this._prevY = 0, _this._scrollX = 0, _this._scrollY = 0, _this._eventType = eventType, 
            _this;
        }
        return _inherits(EventMouse, _Event), _createClass(EventMouse, [ {
            key: "setScrollData",
            value: function setScrollData(scrollX, scrollY) {
                this._scrollX = scrollX, this._scrollY = scrollY;
            }
        }, {
            key: "getScrollX",
            value: function getScrollX() {
                return this._scrollX;
            }
        }, {
            key: "getScrollY",
            value: function getScrollY() {
                return this._scrollY;
            }
        }, {
            key: "setLocation",
            value: function setLocation(x, y) {
                this._x = x, this._y = y;
            }
        }, {
            key: "getLocation",
            value: function getLocation(out) {
                return out || (out = new Vec2), Vec2.set(out, this._x, this._y), out;
            }
        }, {
            key: "getLocationInView",
            value: function getLocationInView(out) {
                return out || (out = new Vec2), Vec2.set(out, this._x, cc.view._designResolutionSize.height - this._y), 
                out;
            }
        }, {
            key: "getUILocation",
            value: function getUILocation(out) {
                return out || (out = new Vec2), Vec2.set(out, this._x, this._y), cc.view._convertPointWithScale(out), 
                out;
            }
        }, {
            key: "_setPrevCursor",
            value: function _setPrevCursor(x, y) {
                this._prevX = x, this._prevY = y;
            }
        }, {
            key: "getPreviousLocation",
            value: function getPreviousLocation(out) {
                return out || (out = new Vec2), Vec2.set(out, this._prevX, this._prevY), out;
            }
        }, {
            key: "getUIPreviousLocation",
            value: function getUIPreviousLocation(out) {
                return out || (out = new Vec2), Vec2.set(out, this._prevX, this._prevY), cc.view._convertPointWithScale(out), 
                out;
            }
        }, {
            key: "getDelta",
            value: function getDelta(out) {
                return out || (out = new Vec2), Vec2.set(out, this._x - this._prevX, this._y - this._prevY), 
                out;
            }
        }, {
            key: "getDeltaX",
            value: function getDeltaX() {
                return this._x - this._prevX;
            }
        }, {
            key: "getDeltaY",
            value: function getDeltaY() {
                return this._y - this._prevY;
            }
        }, {
            key: "getUIDelta",
            value: function getUIDelta(out) {
                return out || (out = new Vec2), Vec2.set(out, (this._x - this._prevX) / cc.view.getScaleX(), (this._y - this._prevY) / cc.view.getScaleY()), 
                out;
            }
        }, {
            key: "getUIDeltaX",
            value: function getUIDeltaX() {
                return (this._x - this._prevX) / cc.view.getScaleX();
            }
        }, {
            key: "getUIDeltaY",
            value: function getUIDeltaY() {
                return (this._y - this._prevY) / cc.view.getScaleY();
            }
        }, {
            key: "setButton",
            value: function setButton(button) {
                this._button = button;
            }
        }, {
            key: "getButton",
            value: function getButton() {
                return this._button;
            }
        }, {
            key: "getLocationX",
            value: function getLocationX() {
                return this._x;
            }
        }, {
            key: "getLocationY",
            value: function getLocationY() {
                return this._y;
            }
        }, {
            key: "getUILocationX",
            value: function getUILocationX() {
                var viewport = cc.view.getViewportRect();
                return (this._x - viewport.x) / cc.view.getScaleX();
            }
        }, {
            key: "getUILocationY",
            value: function getUILocationY() {
                var viewport = cc.view.getViewportRect();
                return (this._y - viewport.y) / cc.view.getScaleY();
            }
        } ]), EventMouse;
    }(Event);
    EventMouse.NONE = 0, EventMouse.DOWN = 1, EventMouse.UP = 2, EventMouse.MOVE = 3, 
    EventMouse.SCROLL = 4, EventMouse.BUTTON_LEFT = 0, EventMouse.BUTTON_RIGHT = 2, 
    EventMouse.BUTTON_MIDDLE = 1, EventMouse.BUTTON_4 = 3, EventMouse.BUTTON_5 = 4, 
    EventMouse.BUTTON_6 = 5, EventMouse.BUTTON_7 = 6, EventMouse.BUTTON_8 = 7;
    var EventTouch = function(_Event2) {
        function EventTouch(touches, bubbles) {
            var _this2;
            return _classCallCheck(this, EventTouch), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(EventTouch).call(this, Event.TOUCH, bubbles))).touch = null, 
            _this2._eventCode = 0, _this2.simulate = !1, _this2._eventCode = 0, _this2._touches = touches || [], 
            _this2;
        }
        return _inherits(EventTouch, _Event2), _createClass(EventTouch, [ {
            key: "getEventCode",
            value: function getEventCode() {
                return this._eventCode;
            }
        }, {
            key: "getTouches",
            value: function getTouches() {
                return this._touches;
            }
        }, {
            key: "_setEventCode",
            value: function _setEventCode(eventCode) {
                this._eventCode = eventCode;
            }
        }, {
            key: "_setTouches",
            value: function _setTouches(touches) {
                this._touches = touches;
            }
        }, {
            key: "setLocation",
            value: function setLocation(x, y) {
                this.touch && this.touch.setTouchInfo(this.touch.getID(), x, y);
            }
        }, {
            key: "getLocation",
            value: function getLocation(out) {
                return this.touch ? this.touch.getLocation(out) : new Vec2;
            }
        }, {
            key: "getUILocation",
            value: function getUILocation(out) {
                return this.touch ? this.touch.getUILocation(out) : new Vec2;
            }
        }, {
            key: "getLocationInView",
            value: function getLocationInView(out) {
                return this.touch ? this.touch.getLocationInView(out) : new Vec2;
            }
        }, {
            key: "getUILocationInView",
            value: function getUILocationInView(out) {
                return this.touch ? this.touch.getLocationInView(out) : new Vec2;
            }
        }, {
            key: "getPreviousLocation",
            value: function getPreviousLocation(out) {
                return this.touch ? this.touch.getPreviousLocation(out) : new Vec2;
            }
        }, {
            key: "getStartLocation",
            value: function getStartLocation(out) {
                return this.touch ? this.touch.getStartLocation(out) : new Vec2;
            }
        }, {
            key: "getUIStartLocation",
            value: function getUIStartLocation(out) {
                return this.touch ? this.touch.getUIStartLocation(out) : new Vec2;
            }
        }, {
            key: "getID",
            value: function getID() {
                return this.touch ? this.touch.getID() : null;
            }
        }, {
            key: "getDelta",
            value: function getDelta(out) {
                return this.touch ? this.touch.getDelta(out) : new Vec2;
            }
        }, {
            key: "getUIDelta",
            value: function getUIDelta(out) {
                return this.touch ? this.touch.getUIDelta(out) : new Vec2;
            }
        }, {
            key: "getDeltaX",
            value: function getDeltaX(out) {
                return this.touch ? this.touch.getDelta(out).x : 0;
            }
        }, {
            key: "getDeltaY",
            value: function getDeltaY(out) {
                return this.touch ? this.touch.getDelta(out).y : 0;
            }
        }, {
            key: "getLocationX",
            value: function getLocationX() {
                return this.touch ? this.touch.getLocationX() : 0;
            }
        }, {
            key: "getLocationY",
            value: function getLocationY() {
                return this.touch ? this.touch.getLocationY() : 0;
            }
        } ]), EventTouch;
    }(Event);
    EventTouch.MAX_TOUCHES = 5, EventTouch.BEGAN = 0, EventTouch.MOVED = 1, EventTouch.ENDED = 2, 
    EventTouch.CANCELLED = 3;
    var EventAcceleration = function(_Event3) {
        function EventAcceleration(acc, bubbles) {
            var _this3;
            return _classCallCheck(this, EventAcceleration), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(EventAcceleration).call(this, Event.ACCELERATION, bubbles))).acc = acc, 
            _this3;
        }
        return _inherits(EventAcceleration, _Event3), EventAcceleration;
    }(Event), EventKeyboard = function(_Event4) {
        function EventKeyboard(keyCode, isPressed, bubbles) {
            var _this4;
            return _classCallCheck(this, EventKeyboard), _this4 = _possibleConstructorReturn(this, _getPrototypeOf(EventKeyboard).call(this, Event.KEYBOARD, bubbles)), 
            "number" == typeof keyCode ? _this4.keyCode = keyCode : (_this4.keyCode = keyCode.keyCode, 
            _this4.rawEvent = keyCode), _this4.isPressed = isPressed, _this4;
        }
        return _inherits(EventKeyboard, _Event4), EventKeyboard;
    }(Event);
    Event.EventMouse = EventMouse, Event.EventTouch = EventTouch, Event.EventAcceleration = EventAcceleration, 
    Event.EventKeyboard = EventKeyboard;
    var EventListener = function() {
        function EventListener(type, listenerID, callback) {
            _classCallCheck(this, EventListener), this.owner = null, this.mask = null, this._previousIn = !1, 
            this._target = null, this._registered = !1, this._fixedPriority = 0, this._node = null, 
            this._paused = !0, this._isEnabled = !0, this._onEvent = callback, this._type = type || 0, 
            this._listenerID = listenerID || "";
        }
        return _createClass(EventListener, [ {
            key: "onEvent",
            get: function get() {
                return this._onEvent;
            }
        } ], [ {
            key: "create",
            value: function create(argObj) {
                cc.assertID(argObj && argObj.event, 1900);
                var listenerType = argObj.event;
                delete argObj.event;
                var listener = null;
                if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? listener = new TouchOneByOne : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? listener = new TouchAllAtOnce : listenerType === cc.EventListener.MOUSE ? listener = new Mouse : listenerType === cc.EventListener.KEYBOARD ? listener = new Keyboard : listenerType === cc.EventListener.ACCELERATION && (listener = new Acceleration(argObj.callback), 
                delete argObj.callback), listener) for (var _i = 0, _Object$keys = Object.keys(argObj); _i < _Object$keys.length; _i++) {
                    var key = _Object$keys[_i];
                    listener[key] = argObj[key];
                }
                return listener;
            }
        } ]), _createClass(EventListener, [ {
            key: "_setPaused",
            value: function _setPaused(paused) {
                this._paused = paused;
            }
        }, {
            key: "_isPaused",
            value: function _isPaused() {
                return this._paused;
            }
        }, {
            key: "_setRegistered",
            value: function _setRegistered(registered) {
                this._registered = registered;
            }
        }, {
            key: "_isRegistered",
            value: function _isRegistered() {
                return this._registered;
            }
        }, {
            key: "_getType",
            value: function _getType() {
                return this._type;
            }
        }, {
            key: "_getListenerID",
            value: function _getListenerID() {
                return this._listenerID;
            }
        }, {
            key: "_setFixedPriority",
            value: function _setFixedPriority(fixedPriority) {
                this._fixedPriority = fixedPriority;
            }
        }, {
            key: "_getFixedPriority",
            value: function _getFixedPriority() {
                return this._fixedPriority;
            }
        }, {
            key: "_setSceneGraphPriority",
            value: function _setSceneGraphPriority(node) {
                this._target = node, this._node = node;
            }
        }, {
            key: "_getSceneGraphPriority",
            value: function _getSceneGraphPriority() {
                return this._node;
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return null !== this._onEvent;
            }
        }, {
            key: "clone",
            value: function clone() {
                return null;
            }
        }, {
            key: "setEnabled",
            value: function setEnabled(enabled) {
                this._isEnabled = enabled;
            }
        }, {
            key: "isEnabled",
            value: function isEnabled() {
                return this._isEnabled;
            }
        } ]), EventListener;
    }();
    EventListener.UNKNOWN = 0, EventListener.TOUCH_ONE_BY_ONE = 1, EventListener.TOUCH_ALL_AT_ONCE = 2, 
    EventListener.KEYBOARD = 3, EventListener.MOUSE = 4, EventListener.ACCELERATION = 6, 
    EventListener.CUSTOM = 8, EventListener.ListenerID = {
        MOUSE: "__cc_mouse",
        TOUCH_ONE_BY_ONE: "__cc_touch_one_by_one",
        TOUCH_ALL_AT_ONCE: "__cc_touch_all_at_once",
        KEYBOARD: "__cc_keyboard",
        ACCELERATION: "__cc_acceleration"
    };
    var ListenerID = EventListener.ListenerID, Mouse = function(_EventListener) {
        function Mouse() {
            var _this;
            return _classCallCheck(this, Mouse), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Mouse).call(this, EventListener.MOUSE, ListenerID.MOUSE, null))).onMouseDown = null, 
            _this.onMouseUp = null, _this.onMouseMove = null, _this.onMouseScroll = null, _this._onEvent = function(event) {
                return _this._callback(event);
            }, _this;
        }
        return _inherits(Mouse, _EventListener), _createClass(Mouse, [ {
            key: "_callback",
            value: function _callback(event) {
                var eventType = cc.Event.EventMouse;
                switch (event._eventType) {
                  case eventType.DOWN:
                    this.onMouseDown && this.onMouseDown(event);
                    break;

                  case eventType.UP:
                    this.onMouseUp && this.onMouseUp(event);
                    break;

                  case eventType.MOVE:
                    this.onMouseMove && this.onMouseMove(event);
                    break;

                  case eventType.SCROLL:
                    this.onMouseScroll && this.onMouseScroll(event);
                }
            }
        }, {
            key: "clone",
            value: function clone() {
                var eventListener = new Mouse;
                return eventListener.onMouseDown = this.onMouseDown, eventListener.onMouseUp = this.onMouseUp, 
                eventListener.onMouseMove = this.onMouseMove, eventListener.onMouseScroll = this.onMouseScroll, 
                eventListener;
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return !0;
            }
        } ]), Mouse;
    }(EventListener), TouchOneByOne = function(_EventListener2) {
        function TouchOneByOne() {
            var _this2;
            return _classCallCheck(this, TouchOneByOne), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(TouchOneByOne).call(this, EventListener.TOUCH_ONE_BY_ONE, ListenerID.TOUCH_ONE_BY_ONE, null))).swallowTouches = !1, 
            _this2.onTouchBegan = null, _this2.onTouchMoved = null, _this2.onTouchEnded = null, 
            _this2.onTouchCancelled = null, _this2._claimedTouches = [], _this2;
        }
        return _inherits(TouchOneByOne, _EventListener2), _createClass(TouchOneByOne, [ {
            key: "setSwallowTouches",
            value: function setSwallowTouches(needSwallow) {
                this.swallowTouches = needSwallow;
            }
        }, {
            key: "isSwallowTouches",
            value: function isSwallowTouches() {
                return this.swallowTouches;
            }
        }, {
            key: "clone",
            value: function clone() {
                var eventListener = new TouchOneByOne;
                return eventListener.onTouchBegan = this.onTouchBegan, eventListener.onTouchMoved = this.onTouchMoved, 
                eventListener.onTouchEnded = this.onTouchEnded, eventListener.onTouchCancelled = this.onTouchCancelled, 
                eventListener.swallowTouches = this.swallowTouches, eventListener;
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return !!this.onTouchBegan || (cc.logID(1801), !1);
            }
        } ]), TouchOneByOne;
    }(EventListener), TouchAllAtOnce = function(_EventListener3) {
        function TouchAllAtOnce() {
            var _this3;
            return _classCallCheck(this, TouchAllAtOnce), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(TouchAllAtOnce).call(this, EventListener.TOUCH_ALL_AT_ONCE, ListenerID.TOUCH_ALL_AT_ONCE, null))).onTouchesBegan = null, 
            _this3.onTouchesMoved = null, _this3.onTouchesEnded = null, _this3.onTouchesCancelled = null, 
            _this3;
        }
        return _inherits(TouchAllAtOnce, _EventListener3), _createClass(TouchAllAtOnce, [ {
            key: "clone",
            value: function clone() {
                var eventListener = new TouchAllAtOnce;
                return eventListener.onTouchesBegan = this.onTouchesBegan, eventListener.onTouchesMoved = this.onTouchesMoved, 
                eventListener.onTouchesEnded = this.onTouchesEnded, eventListener.onTouchesCancelled = this.onTouchesCancelled, 
                eventListener;
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return null !== this.onTouchesBegan || null !== this.onTouchesMoved || null !== this.onTouchesEnded || null !== this.onTouchesCancelled || (cc.logID(1802), 
                !1);
            }
        } ]), TouchAllAtOnce;
    }(EventListener), Acceleration = function(_EventListener4) {
        function Acceleration(callback) {
            var _this4;
            return _classCallCheck(this, Acceleration), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(Acceleration).call(this, EventListener.ACCELERATION, ListenerID.ACCELERATION, null)))._onAccelerationEvent = null, 
            _this4._onEvent = function(event) {
                return _this4._callback(event);
            }, _this4._onAccelerationEvent = callback, _this4;
        }
        return _inherits(Acceleration, _EventListener4), _createClass(Acceleration, [ {
            key: "_callback",
            value: function _callback(event) {
                this._onAccelerationEvent && this._onAccelerationEvent(event.acc, event);
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return cc.assertID(this._onAccelerationEvent, 1803), !0;
            }
        }, {
            key: "clone",
            value: function clone() {
                return new Acceleration(this._onAccelerationEvent);
            }
        } ]), Acceleration;
    }(EventListener), Keyboard = function(_EventListener5) {
        function Keyboard() {
            var _this5;
            return _classCallCheck(this, Keyboard), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(Keyboard).call(this, EventListener.KEYBOARD, ListenerID.KEYBOARD, null))).onKeyPressed = null, 
            _this5.onKeyReleased = null, _this5._onEvent = function(event) {
                return _this5._callback(event);
            }, _this5;
        }
        return _inherits(Keyboard, _EventListener5), _createClass(Keyboard, [ {
            key: "_callback",
            value: function _callback(event) {
                event.isPressed ? this.onKeyPressed && this.onKeyPressed(event.keyCode, event) : this.onKeyReleased && this.onKeyReleased(event.keyCode, event);
            }
        }, {
            key: "clone",
            value: function clone() {
                var eventListener = new Keyboard;
                return eventListener.onKeyPressed = this.onKeyPressed, eventListener.onKeyReleased = this.onKeyReleased, 
                eventListener;
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return null !== this.onKeyPressed || null !== this.onKeyReleased || (cc.logID(1800), 
                !1);
            }
        } ]), Keyboard;
    }(EventListener);
    cc.EventListener = EventListener;
    var ListenerID$1 = EventListener.ListenerID;
    var _EventListenerVector = function() {
        function _EventListenerVector() {
            _classCallCheck(this, _EventListenerVector), this.gt0Index = 0, this._fixedListeners = [], 
            this._sceneGraphListeners = [];
        }
        return _createClass(_EventListenerVector, [ {
            key: "size",
            value: function size() {
                return this._fixedListeners.length + this._sceneGraphListeners.length;
            }
        }, {
            key: "empty",
            value: function empty() {
                return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length;
            }
        }, {
            key: "push",
            value: function push(listener) {
                0 === listener._getFixedPriority() ? this._sceneGraphListeners.push(listener) : this._fixedListeners.push(listener);
            }
        }, {
            key: "clearSceneGraphListeners",
            value: function clearSceneGraphListeners() {
                this._sceneGraphListeners.length = 0;
            }
        }, {
            key: "clearFixedListeners",
            value: function clearFixedListeners() {
                this._fixedListeners.length = 0;
            }
        }, {
            key: "clear",
            value: function clear() {
                this._sceneGraphListeners.length = 0, this._fixedListeners.length = 0;
            }
        }, {
            key: "getFixedPriorityListeners",
            value: function getFixedPriorityListeners() {
                return this._fixedListeners;
            }
        }, {
            key: "getSceneGraphPriorityListeners",
            value: function getSceneGraphPriorityListeners() {
                return this._sceneGraphListeners;
            }
        } ]), _EventListenerVector;
    }();
    var _class$b, _class2$8, _class3$5, eventManager = new (function() {
        function EventManager() {
            _classCallCheck(this, EventManager), this._listenersMap = {}, this._priorityDirtyFlagMap = {}, 
            this._nodeListenersMap = {}, this._toAddedListeners = [], this._toRemovedListeners = [], 
            this._dirtyListeners = [], this._inDispatch = 0, this._isEnabled = !1, this._internalCustomListenerIDs = [], 
            this._currentTouch = null;
        }
        return _createClass(EventManager, [ {
            key: "pauseTarget",
            value: function pauseTarget(node) {
                var recursive = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (node instanceof cc._BaseNode) {
                    var listeners = this._nodeListenersMap[node.uuid];
                    if (listeners) for (var i = 0; i < listeners.length; ++i) {
                        var listener = listeners[i];
                        listener._setPaused(!0);
                    }
                    if (!0 === recursive) {
                        var locChildren = node.children;
                        if (locChildren) for (var _i = 0; _i < locChildren.length; ++_i) {
                            var locChild = locChildren[_i];
                            this.pauseTarget(locChild, !0);
                        }
                    }
                } else cc.warnID(3506);
            }
        }, {
            key: "resumeTarget",
            value: function resumeTarget(node) {
                var recursive = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (node instanceof cc._BaseNode) {
                    var listeners = this._nodeListenersMap[node.uuid];
                    if (listeners) for (var i = 0; i < listeners.length; ++i) {
                        var listener = listeners[i];
                        listener._setPaused(!1);
                    }
                    if (this._setDirtyForNode(node), !0 === recursive && node.children.length > 0) {
                        var locChildren = node.children;
                        if (locChildren) for (var _i2 = 0; _i2 < locChildren.length; ++_i2) {
                            var locChild = locChildren[_i2];
                            this.resumeTarget(locChild, !0);
                        }
                    }
                } else cc.warnID(3506);
            }
        }, {
            key: "frameUpdateListeners",
            value: function frameUpdateListeners() {
                var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
                for (var selKey in locListenersMap) locListenersMap[selKey].empty() && (delete locPriorityDirtyFlagMap[selKey], 
                delete locListenersMap[selKey]);
                var locToAddedListeners = this._toAddedListeners;
                if (0 !== locToAddedListeners.length) {
                    for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
                    locToAddedListeners.length = 0;
                }
                0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
            }
        }, {
            key: "hasEventListener",
            value: function hasEventListener(listenerID) {
                return !!this._getListeners(listenerID);
            }
        }, {
            key: "addListener",
            value: function addListener(listener, nodeOrPriority) {
                if (cc.assertID(listener && nodeOrPriority, 3503), cc.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof cc._BaseNode) {
                    if (listener instanceof cc.EventListener) {
                        if (listener._isRegistered()) return void cc.logID(3505);
                    } else cc.assertID(!cc.js.isNumber(nodeOrPriority), 3504), listener = cc.EventListener.create(listener);
                    if (listener.checkAvailable()) {
                        if (cc.js.isNumber(nodeOrPriority)) {
                            if (0 === nodeOrPriority) return void cc.logID(3500);
                            listener._setSceneGraphPriority(null), listener._setFixedPriority(nodeOrPriority), 
                            listener._setRegistered(!0), listener._setPaused(!1), this._addListener(listener);
                        } else {
                            if (!function checkUINode(node) {
                                for (;node; ) {
                                    if (node.getComponent("cc.CanvasComponent")) return !0;
                                    node = node.parent;
                                }
                                return !1;
                            }(nodeOrPriority)) return void cc.logID(3512);
                            listener._setSceneGraphPriority(nodeOrPriority), listener._setFixedPriority(0), 
                            listener._setRegistered(!0), this._addListener(listener);
                        }
                        return listener;
                    }
                } else cc.warnID(3506);
            }
        }, {
            key: "addCustomListener",
            value: function addCustomListener(eventName, callback) {
                var listener = EventListener.create({
                    event: cc.EventListener.CUSTOM,
                    eventName: eventName,
                    callback: callback
                });
                return this.addListener(listener, 1), listener;
            }
        }, {
            key: "removeListener",
            value: function removeListener(listener) {
                if (null != listener) {
                    var isFound = !1, locListener = this._listenersMap;
                    for (var selKey in locListener) {
                        var listeners = locListener[selKey], fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                        if ((isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener)) ? this._setDirty(listener._getListenerID(), 2) : (isFound = this._removeListenerInVector(fixedPriorityListeners, listener)) && this._setDirty(listener._getListenerID(), 1), 
                        listeners.empty() && (delete this._priorityDirtyFlagMap[listener._getListenerID()], 
                        delete locListener[selKey]), isFound) break;
                    }
                    if (!isFound) for (var locToAddedListeners = this._toAddedListeners, i = locToAddedListeners.length - 1; i >= 0; i--) {
                        var selListener = locToAddedListeners[i];
                        if (selListener === listener) {
                            cc.js.array.removeAt(locToAddedListeners, i), selListener._setRegistered(!1);
                            break;
                        }
                    }
                }
            }
        }, {
            key: "removeListeners",
            value: function removeListeners(listenerType) {
                var recursive = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (cc.js.isNumber(listenerType) || listenerType instanceof cc._BaseNode) if (void 0 !== listenerType._id) {
                    var listeners = this._nodeListenersMap[listenerType._id];
                    if (listeners) {
                        for (var listenersCopy = cc.js.array.copy(listeners), i = 0; i < listenersCopy.length; ++i) {
                            var listenerCopy = listenersCopy[i];
                            this.removeListener(listenerCopy);
                        }
                        delete this._nodeListenersMap[listenerType._id];
                    }
                    for (var locToAddedListeners = this._toAddedListeners, _i3 = 0; _i3 < locToAddedListeners.length; ) {
                        var listener = locToAddedListeners[_i3];
                        listener._getSceneGraphPriority() === listenerType ? (listener._setSceneGraphPriority(null), 
                        listener._setRegistered(!1), locToAddedListeners.splice(_i3, 1)) : ++_i3;
                    }
                    if (!0 === recursive) for (var locChildren = listenerType.getChildren(), _i4 = 0; _i4 < locChildren.length; ++_i4) {
                        var locChild = locChildren[_i4];
                        this.removeListeners(locChild, !0);
                    }
                } else listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(ListenerID$1.TOUCH_ONE_BY_ONE) : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(ListenerID$1.TOUCH_ALL_AT_ONCE) : listenerType === cc.EventListener.MOUSE ? this._removeListenersForListenerID(ListenerID$1.MOUSE) : listenerType === cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(ListenerID$1.ACCELERATION) : listenerType === cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(ListenerID$1.KEYBOARD) : cc.logID(3501); else cc.warnID(3506);
            }
        }, {
            key: "removeCustomListeners",
            value: function removeCustomListeners(customEventName) {
                this._removeListenersForListenerID(customEventName);
            }
        }, {
            key: "removeAllListeners",
            value: function removeAllListeners() {
                var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
                for (var selKey in locListeners) -1 === locInternalCustomEventIDs.indexOf(selKey) && this._removeListenersForListenerID(selKey);
            }
        }, {
            key: "setPriority",
            value: function setPriority(listener, fixedPriority) {
                if (null != listener) {
                    var locListeners = this._listenersMap;
                    for (var selKey in locListeners) {
                        var fixedPriorityListeners = locListeners[selKey].getFixedPriorityListeners();
                        if (fixedPriorityListeners) if (-1 !== fixedPriorityListeners.indexOf(listener)) return null != listener._getSceneGraphPriority() && cc.logID(3502), 
                        void (listener._getFixedPriority() !== fixedPriority && (listener._setFixedPriority(fixedPriority), 
                        this._setDirty(listener._getListenerID(), 1)));
                    }
                }
            }
        }, {
            key: "setEnabled",
            value: function setEnabled(enabled) {
                this._isEnabled = enabled;
            }
        }, {
            key: "isEnabled",
            value: function isEnabled() {
                return this._isEnabled;
            }
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {
                if (this._isEnabled) if (this._updateDirtyFlagForSceneGraph(), this._inDispatch++, 
                event && event.getType) {
                    if (event.getType().startsWith(cc.Event.TOUCH)) return this._dispatchTouchEvent(event), 
                    void this._inDispatch--;
                    var listenerID = function __getListenerID(event) {
                        var eventType = Event, type = event.type;
                        return type === eventType.ACCELERATION ? ListenerID$1.ACCELERATION : type === eventType.KEYBOARD ? ListenerID$1.KEYBOARD : type.startsWith(eventType.MOUSE) ? ListenerID$1.MOUSE : (type.startsWith(eventType.TOUCH) && cc.logID(2e3), 
                        "");
                    }(event);
                    this._sortEventListeners(listenerID);
                    var selListeners = this._listenersMap[listenerID];
                    null != selListeners && (this._dispatchEventToListeners(selListeners, this._onListenerCallback, event), 
                    this._onUpdateListeners(selListeners)), this._inDispatch--;
                } else cc.errorID(3511);
            }
        }, {
            key: "_onListenerCallback",
            value: function _onListenerCallback(listener, event) {
                event.currentTarget = listener._target;
                var onEvent = listener.onEvent;
                return onEvent && onEvent(event), event.isStopped();
            }
        }, {
            key: "dispatchCustomEvent",
            value: function dispatchCustomEvent(eventName, optionalUserData) {
                var ev = new cc.Event.EventCustom(eventName);
                ev.setUserData(optionalUserData), this.dispatchEvent(ev);
            }
        }, {
            key: "_setDirtyForNode",
            value: function _setDirtyForNode(node) {
                var selListeners = this._nodeListenersMap[node._id];
                if (void 0 !== selListeners) for (var j = 0, len = selListeners.length; j < len; j++) {
                    var listenerID = selListeners[j]._getListenerID();
                    null == this._dirtyListeners[listenerID] && (this._dirtyListeners[listenerID] = !0);
                }
                if (node.children.length > 0) for (var _children = node.children, i = 0, _len = _children ? _children.length : 0; i < _len; i++) this._setDirtyForNode(_children[i]);
            }
        }, {
            key: "_addListener",
            value: function _addListener(listener) {
                0 === this._inDispatch ? this._forceAddEventListener(listener) : this._toAddedListeners.push(listener);
            }
        }, {
            key: "_forceAddEventListener",
            value: function _forceAddEventListener(listener) {
                var listenerID = listener._getListenerID(), listeners = this._listenersMap[listenerID];
                if (listeners || (listeners = new _EventListenerVector, this._listenersMap[listenerID] = listeners), 
                listeners.push(listener), 0 === listener._getFixedPriority()) {
                    this._setDirty(listenerID, 2);
                    var node = listener._getSceneGraphPriority();
                    null === node && cc.logID(3507), this._associateNodeAndEventListener(node, listener), 
                    node.activeInHierarchy && this.resumeTarget(node);
                } else this._setDirty(listenerID, 1);
            }
        }, {
            key: "_getListeners",
            value: function _getListeners(listenerID) {
                return this._listenersMap[listenerID];
            }
        }, {
            key: "_updateDirtyFlagForSceneGraph",
            value: function _updateDirtyFlagForSceneGraph() {
                var locDirtyListeners = this._dirtyListeners;
                for (var selKey in locDirtyListeners) this._setDirty(selKey, 2);
                this._dirtyListeners.length = 0;
            }
        }, {
            key: "_removeAllListenersInVector",
            value: function _removeAllListenersInVector(listenerVector) {
                if (listenerVector) for (var selListener, i = listenerVector.length - 1; i >= 0; i--) (selListener = listenerVector[i])._setRegistered(!1), 
                null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                selListener._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.js.array.removeAt(listenerVector, i);
            }
        }, {
            key: "_removeListenersForListenerID",
            value: function _removeListenersForListenerID(listenerID) {
                var listeners = this._listenersMap[listenerID];
                if (listeners) {
                    var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    this._removeAllListenersInVector(sceneGraphPriorityListeners), this._removeAllListenersInVector(fixedPriorityListeners), 
                    delete this._priorityDirtyFlagMap[listenerID], this._inDispatch || (listeners.clear(), 
                    delete this._listenersMap[listenerID]);
                }
                for (var locToAddedListeners = this._toAddedListeners, i = locToAddedListeners.length - 1; i >= 0; i--) {
                    var listener = locToAddedListeners[i];
                    listener && listener._getListenerID() === listenerID && cc.js.array.removeAt(locToAddedListeners, i);
                }
            }
        }, {
            key: "_sortEventListeners",
            value: function _sortEventListeners(listenerID) {
                var dirtyFlag = 0, locFlagMap = this._priorityDirtyFlagMap;
                (locFlagMap[listenerID] && (dirtyFlag = locFlagMap[listenerID]), 0 !== dirtyFlag) && (locFlagMap[listenerID] = 0, 
                1 & dirtyFlag && this._sortListenersOfFixedPriority(listenerID), 2 & dirtyFlag && cc.director.getScene() && this._sortListenersOfSceneGraphPriority(listenerID));
            }
        }, {
            key: "_sortListenersOfSceneGraphPriority",
            value: function _sortListenersOfSceneGraphPriority(listenerID) {
                var listeners = this._getListeners(listenerID);
                if (listeners) {
                    var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
                    sceneGraphListener && 0 !== sceneGraphListener.length && listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
                }
            }
        }, {
            key: "_sortEventListenersOfSceneGraphPriorityDes",
            value: function _sortEventListenersOfSceneGraphPriorityDes(l1, l2) {
                var node1 = l1._getSceneGraphPriority(), node2 = l2._getSceneGraphPriority();
                if (!(l2 && node2 && node2._activeInHierarchy && node2._uiProps.uiTransformComp)) return -1;
                if (!(l1 && node1 && node1._activeInHierarchy && node1._uiProps.uiTransformComp)) return 1;
                var p1 = node1, p2 = node2, trans1 = node1._uiProps.uiTransformComp, trans2 = node2._uiProps.uiTransformComp, ex = !1;
                if (trans1.visibility !== trans2.visibility) return trans2.visibility - trans1.visibility;
                for (;p1.parent._id !== p2.parent._id; ) p1 = null === p1.parent.parent ? (ex = !0) && node2 : p1.parent, 
                p2 = null === p2.parent.parent ? (ex = !0) && node1 : p2.parent;
                if (p1._id === p2._id) {
                    if (p1._id === node2._id) return -1;
                    if (p1._id === node1._id) return 1;
                }
                var priority1 = p1.getSiblingIndex(), priority2 = p2.getSiblingIndex();
                return ex ? priority1 - priority2 : priority2 - priority1;
            }
        }, {
            key: "_sortListenersOfFixedPriority",
            value: function _sortListenersOfFixedPriority(listenerID) {
                var listeners = this._listenersMap[listenerID];
                if (listeners) {
                    var fixedListeners = listeners.getFixedPriorityListeners();
                    if (fixedListeners && 0 !== fixedListeners.length) {
                        fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
                        for (var index = 0, len = fixedListeners.length; index < len && !(fixedListeners[index]._getFixedPriority() >= 0); ) ++index;
                        listeners.gt0Index = index;
                    }
                }
            }
        }, {
            key: "_sortListenersOfFixedPriorityAsc",
            value: function _sortListenersOfFixedPriorityAsc(l1, l2) {
                return l1._getFixedPriority() - l2._getFixedPriority();
            }
        }, {
            key: "_onUpdateListeners",
            value: function _onUpdateListeners(listeners) {
                var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners(), toRemovedListeners = this._toRemovedListeners;
                if (sceneGraphPriorityListeners) for (var i = sceneGraphPriorityListeners.length - 1; i >= 0; i--) {
                    var selListener = sceneGraphPriorityListeners[i];
                    if (!selListener._isRegistered()) {
                        cc.js.array.removeAt(sceneGraphPriorityListeners, i);
                        var idx = toRemovedListeners.indexOf(selListener);
                        -1 !== idx && toRemovedListeners.splice(idx, 1);
                    }
                }
                if (fixedPriorityListeners) for (var _i5 = fixedPriorityListeners.length - 1; _i5 >= 0; _i5--) {
                    var _selListener = fixedPriorityListeners[_i5];
                    if (!_selListener._isRegistered()) {
                        cc.js.array.removeAt(fixedPriorityListeners, _i5);
                        var _idx = toRemovedListeners.indexOf(_selListener);
                        -1 !== _idx && toRemovedListeners.splice(_idx, 1);
                    }
                }
                sceneGraphPriorityListeners && 0 === sceneGraphPriorityListeners.length && listeners.clearSceneGraphListeners(), 
                fixedPriorityListeners && 0 === fixedPriorityListeners.length && listeners.clearFixedListeners();
            }
        }, {
            key: "_updateTouchListeners",
            value: function _updateTouchListeners(event) {
                var locInDispatch = this._inDispatch;
                if (cc.assertID(locInDispatch > 0, 3508), !(locInDispatch > 1)) {
                    var listeners;
                    (listeners = this._listenersMap[ListenerID$1.TOUCH_ONE_BY_ONE]) && this._onUpdateListeners(listeners), 
                    (listeners = this._listenersMap[ListenerID$1.TOUCH_ALL_AT_ONCE]) && this._onUpdateListeners(listeners), 
                    cc.assertID(1 === locInDispatch, 3509);
                    var locToAddedListeners = this._toAddedListeners;
                    if (0 !== locToAddedListeners.length) {
                        for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
                        this._toAddedListeners.length = 0;
                    }
                    0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
                }
            }
        }, {
            key: "_cleanToRemovedListeners",
            value: function _cleanToRemovedListeners() {
                for (var toRemovedListeners = this._toRemovedListeners, i = 0; i < toRemovedListeners.length; ++i) {
                    var selListener = toRemovedListeners[i], listeners = this._listenersMap[selListener._getListenerID()];
                    if (listeners) {
                        var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                        if (sceneGraphPriorityListeners) {
                            var idx = sceneGraphPriorityListeners.indexOf(selListener);
                            -1 !== idx && sceneGraphPriorityListeners.splice(idx, 1);
                        }
                        if (fixedPriorityListeners) {
                            var _idx2 = fixedPriorityListeners.indexOf(selListener);
                            -1 !== _idx2 && fixedPriorityListeners.splice(_idx2, 1);
                        }
                    }
                }
                toRemovedListeners.length = 0;
            }
        }, {
            key: "_onTouchEventCallback",
            value: function _onTouchEventCallback(listener, argsObj) {
                if (!listener._isRegistered()) return !1;
                var event = argsObj.event, selTouch = event.touch;
                event.currentTarget = listener._getSceneGraphPriority();
                var isClaimed = !1, removedIdx = -1, getCode = event.getEventCode();
                if (getCode === EventTouch.BEGAN) {
                    if (!cc.macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch) return !1;
                    listener.onTouchBegan && (isClaimed = listener.onTouchBegan(selTouch, event)) && listener._isRegistered() && (listener._claimedTouches.push(selTouch), 
                    eventManager._currentTouch = selTouch);
                } else if (listener._claimedTouches.length > 0 && -1 !== (removedIdx = listener._claimedTouches.indexOf(selTouch))) {
                    if (isClaimed = !0, !cc.macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch && eventManager._currentTouch !== selTouch) return !1;
                    getCode === EventTouch.MOVED && listener.onTouchMoved ? listener.onTouchMoved(selTouch, event) : getCode === EventTouch.ENDED ? (listener.onTouchEnded && listener.onTouchEnded(selTouch, event), 
                    listener._isRegistered() && listener._claimedTouches.splice(removedIdx, 1), eventManager._currentTouch = null) : getCode === EventTouch.CANCELLED && (listener.onTouchCancelled && listener.onTouchCancelled(selTouch, event), 
                    listener._isRegistered() && listener._claimedTouches.splice(removedIdx, 1), eventManager._currentTouch = null);
                }
                return event.isStopped() ? (eventManager._updateTouchListeners(event), !0) : !!(isClaimed && listener._isRegistered() && listener.swallowTouches) && (argsObj.needsMutableSet && argsObj.touches.splice(selTouch, 1), 
                !0);
            }
        }, {
            key: "_dispatchTouchEvent",
            value: function _dispatchTouchEvent(event) {
                this._sortEventListeners(ListenerID$1.TOUCH_ONE_BY_ONE), this._sortEventListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);
                var oneByOneListeners = this._getListeners(ListenerID$1.TOUCH_ONE_BY_ONE), allAtOnceListeners = this._getListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);
                if (null !== oneByOneListeners || null !== allAtOnceListeners) {
                    var originalTouches = event.getTouches(), mutableTouches = cc.js.array.copy(originalTouches), oneByOneArgsObj = {
                        event: event,
                        needsMutableSet: oneByOneListeners && allAtOnceListeners,
                        touches: mutableTouches,
                        selTouch: null
                    };
                    if (oneByOneListeners) for (var i = 0; i < originalTouches.length; ++i) {
                        var originalTouch = originalTouches[i];
                        event.touch = originalTouch, event.propagationStopped = event.propagationImmediateStopped = !1, 
                        this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
                    }
                    allAtOnceListeners && mutableTouches.length > 0 && (this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
                        event: event,
                        touches: mutableTouches
                    }), event.isStopped()) || this._updateTouchListeners(event);
                }
            }
        }, {
            key: "_onTouchesEventCallback",
            value: function _onTouchesEventCallback(listener, callbackParams) {
                if (!listener._isRegistered()) return !1;
                var event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
                return event.currentTarget = listener._getSceneGraphPriority(), getCode === EventTouch.BEGAN && listener.onTouchesBegan ? listener.onTouchesBegan(touches, event) : getCode === EventTouch.MOVED && listener.onTouchesMoved ? listener.onTouchesMoved(touches, event) : getCode === EventTouch.ENDED && listener.onTouchesEnded ? listener.onTouchesEnded(touches, event) : getCode === EventTouch.CANCELLED && listener.onTouchesCancelled && listener.onTouchesCancelled(touches, event), 
                !!event.isStopped() && (eventManager._updateTouchListeners(event), !0);
            }
        }, {
            key: "_associateNodeAndEventListener",
            value: function _associateNodeAndEventListener(node, listener) {
                var listeners = this._nodeListenersMap[node.uuid];
                listeners || (listeners = [], this._nodeListenersMap[node.uuid] = listeners), listeners.push(listener);
            }
        }, {
            key: "_dissociateNodeAndEventListener",
            value: function _dissociateNodeAndEventListener(node, listener) {
                var listeners = this._nodeListenersMap[node.uuid];
                listeners && (cc.js.array.remove(listeners, listener), 0 === listeners.length && delete this._nodeListenersMap[node.uuid]);
            }
        }, {
            key: "_dispatchEventToListeners",
            value: function _dispatchEventToListeners(listeners, onEvent, eventOrArgs) {
                var shouldStopPropagation = !1, fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners(), i = 0;
                if (fixedPriorityListeners && 0 !== fixedPriorityListeners.length) for (;i < listeners.gt0Index; ++i) {
                    var selListener = fixedPriorityListeners[i];
                    if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                        shouldStopPropagation = !0;
                        break;
                    }
                }
                if (sceneGraphPriorityListeners && !shouldStopPropagation) for (var _i6 = 0; _i6 < sceneGraphPriorityListeners.length; ++_i6) {
                    var _selListener2 = sceneGraphPriorityListeners[_i6];
                    if (_selListener2.isEnabled() && !_selListener2._isPaused() && _selListener2._isRegistered() && onEvent(_selListener2, eventOrArgs)) {
                        shouldStopPropagation = !0;
                        break;
                    }
                }
                if (fixedPriorityListeners && !shouldStopPropagation) for (;i < fixedPriorityListeners.length; ++i) {
                    var _selListener3 = fixedPriorityListeners[i];
                    if (_selListener3.isEnabled() && !_selListener3._isPaused() && _selListener3._isRegistered() && onEvent(_selListener3, eventOrArgs)) {
                        shouldStopPropagation = !0;
                        break;
                    }
                }
            }
        }, {
            key: "_setDirty",
            value: function _setDirty(listenerID, flag) {
                var locDirtyFlagMap = this._priorityDirtyFlagMap;
                null == locDirtyFlagMap[listenerID] ? locDirtyFlagMap[listenerID] = flag : locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
            }
        }, {
            key: "_sortNumberAsc",
            value: function _sortNumberAsc(a, b) {
                return a - b;
            }
        }, {
            key: "_removeListenerInCallback",
            value: function _removeListenerInCallback(listeners, callback) {
                if (null == listeners) return !1;
                for (var i = listeners.length - 1; i >= 0; i--) {
                    var selListener = listeners[i];
                    if (selListener._onCustomEvent === callback || selListener.onEvent === callback) return selListener._setRegistered(!1), 
                    null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                    selListener._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener), 
                    !0;
                }
                return !1;
            }
        }, {
            key: "_removeListenerInVector",
            value: function _removeListenerInVector(listeners, listener) {
                if (null == listeners) return !1;
                for (var i = listeners.length - 1; i >= 0; i--) {
                    var selListener = listeners[i];
                    if (selListener === listener) return selListener._setRegistered(!1), null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                    selListener._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener), 
                    !0;
                }
                return !1;
            }
        } ]), EventManager;
    }());
    cc.eventManager = eventManager;
    var Script = ccclass("cc.Script")(_class$b = function(_Asset) {
        function Script() {
            return _classCallCheck(this, Script), _possibleConstructorReturn(this, _getPrototypeOf(Script).apply(this, arguments));
        }
        return _inherits(Script, _Asset), Script;
    }(Asset)) || _class$b;
    cc._Script = Script;
    var JavaScript = ccclass("cc.JavaScript")(_class2$8 = function(_Script) {
        function JavaScript() {
            return _classCallCheck(this, JavaScript), _possibleConstructorReturn(this, _getPrototypeOf(JavaScript).apply(this, arguments));
        }
        return _inherits(JavaScript, _Script), JavaScript;
    }(Script)) || _class2$8;
    cc._JavaScript = JavaScript;
    var _dec$c, _dec2$5, _dec3$1, _dec4, _dec5, _dec6, _dec7, _class$c, _class2$9, _descriptor$7, _descriptor2$3, _class3$6, _temp$a, TypeScript = ccclass("cc.TypeScript")(_class3$5 = function(_Script2) {
        function TypeScript() {
            return _classCallCheck(this, TypeScript), _possibleConstructorReturn(this, _getPrototypeOf(TypeScript).apply(this, arguments));
        }
        return _inherits(TypeScript, _Script2), TypeScript;
    }(Script)) || _class3$5;
    cc._TypeScript = TypeScript;
    var idGenerator$1 = new IDGenerator("Comp"), IsOnLoadCalled$1 = (CCObject.Flags.IsOnEnableCalled, 
    CCObject.Flags.IsOnLoadCalled), Component = (_dec$c = ccclass("cc.Component"), _dec2$5 = property({
        visible: !1
    }), _dec3$1 = property({
        visible: !1
    }), _dec4 = property({
        displayName: "Script",
        type: Script,
        tooltip: void 0
    }), _dec5 = property({
        visible: !1
    }), _dec6 = property({
        visible: !1
    }), _dec7 = property({
        visible: !1
    }), _dec$c((_temp$a = _class3$6 = function(_CCObject) {
        function Component() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Component);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Component)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "node", _descriptor$7, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_enabled", _descriptor2$3, _assertThisInitialized(_this)), 
            _this._sceneGetter = null, _this._id = idGenerator$1.getNewId(), _this._eventTargets = [], 
            _this;
        }
        return _inherits(Component, _CCObject), _createClass(Component, [ {
            key: "_getRenderScene",
            value: function _getRenderScene() {
                return this._sceneGetter ? this._sceneGetter() : this.node.scene._renderScene;
            }
        }, {
            key: "addComponent",
            value: function addComponent(typeOrClassName) {
                return this.node.addComponent(typeOrClassName);
            }
        }, {
            key: "getComponent",
            value: function getComponent(typeOrClassName) {
                return this.node.getComponent(typeOrClassName);
            }
        }, {
            key: "getComponents",
            value: function getComponents(typeOrClassName) {
                return this.node.getComponents(typeOrClassName);
            }
        }, {
            key: "getComponentInChildren",
            value: function getComponentInChildren(typeOrClassName) {
                return this.node.getComponentInChildren(typeOrClassName);
            }
        }, {
            key: "getComponentsInChildren",
            value: function getComponentsInChildren(typeOrClassName) {
                return this.node.getComponentsInChildren(typeOrClassName);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(Component.prototype), "destroy", this).call(this) && this._enabled && this.node.activeInHierarchy && cc.director._compScheduler.disableComp(this);
            }
        }, {
            key: "_onPreDestroy",
            value: function _onPreDestroy() {
                this.unscheduleAllCallbacks();
                for (var eventTargets = this._eventTargets, i = 0, l = eventTargets.length; i < l; ++i) {
                    var target = eventTargets[i];
                    target && target.targetOff(this);
                }
                eventTargets.length = 0, cc.director._nodeActivator.destroyComp(this), this.node._removeComponent(this);
            }
        }, {
            key: "_instantiate",
            value: function _instantiate(cloned) {
                return cloned || (cloned = cc.instantiate._clone(this, this)), cloned.node = null, 
                cloned;
            }
        }, {
            key: "schedule",
            value: function schedule(callback) {
                var interval = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, repeat = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : cc.macro.REPEAT_FOREVER, delay = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                cc.assertID(callback, 1619), cc.assertID(interval >= 0, 1620), interval = interval || 0, 
                repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat, delay = delay || 0;
                var scheduler = cc.director.getScheduler(), paused = scheduler.isTargetPaused(this);
                scheduler.schedule(callback, this, interval, repeat, delay, paused);
            }
        }, {
            key: "scheduleOnce",
            value: function scheduleOnce(callback) {
                var delay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.schedule(callback, 0, 0, delay);
            }
        }, {
            key: "unschedule",
            value: function unschedule(callback_fn) {
                callback_fn && cc.director.getScheduler().unschedule(callback_fn, this);
            }
        }, {
            key: "unscheduleAllCallbacks",
            value: function unscheduleAllCallbacks() {
                cc.director.getScheduler().unscheduleAllForTarget(this);
            }
        }, {
            key: "name",
            get: function get() {
                if (this._name) return this._name;
                var className = getClassName(this), trimLeft = className.lastIndexOf(".");
                return trimLeft >= 0 && (className = className.slice(trimLeft + 1)), this.node.name + "<" + className + ">";
            },
            set: function set(value) {
                this._name = value;
            }
        }, {
            key: "uuid",
            get: function get() {
                return this._id;
            }
        }, {
            key: "__scriptAsset",
            get: function get() {
                return null;
            }
        }, {
            key: "enabled",
            get: function get() {
                return this._enabled;
            },
            set: function set(value) {
                if (this._enabled !== value && (this._enabled = value, this.node.activeInHierarchy)) {
                    var compScheduler = cc.director._compScheduler;
                    value ? compScheduler.enableComp(this) : compScheduler.disableComp(this);
                }
            }
        }, {
            key: "enabledInHierarchy",
            get: function get() {
                return this._enabled && this.node && this.node.activeInHierarchy;
            }
        }, {
            key: "_isOnLoadCalled",
            get: function get() {
                return this._objFlags & IsOnLoadCalled$1;
            }
        } ]), Component;
    }(CCObject), _class3$6.system = null, _applyDecoratedDescriptor((_class2$9 = _temp$a).prototype, "name", [ _dec2$5 ], Object.getOwnPropertyDescriptor(_class2$9.prototype, "name"), _class2$9.prototype), 
    _applyDecoratedDescriptor(_class2$9.prototype, "uuid", [ _dec3$1 ], Object.getOwnPropertyDescriptor(_class2$9.prototype, "uuid"), _class2$9.prototype), 
    _applyDecoratedDescriptor(_class2$9.prototype, "__scriptAsset", [ _dec4 ], Object.getOwnPropertyDescriptor(_class2$9.prototype, "__scriptAsset"), _class2$9.prototype), 
    _applyDecoratedDescriptor(_class2$9.prototype, "enabled", [ _dec5 ], Object.getOwnPropertyDescriptor(_class2$9.prototype, "enabled"), _class2$9.prototype), 
    _applyDecoratedDescriptor(_class2$9.prototype, "enabledInHierarchy", [ _dec6 ], Object.getOwnPropertyDescriptor(_class2$9.prototype, "enabledInHierarchy"), _class2$9.prototype), 
    _descriptor$7 = _applyDecoratedDescriptor(_class2$9.prototype, "node", [ _dec7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$3 = _applyDecoratedDescriptor(_class2$9.prototype, "_enabled", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _class$c = _class2$9)) || _class$c), proto = Component.prototype;
    proto.update = null, proto.lateUpdate = null, proto.__preload = null, proto.onLoad = null, 
    proto.start = null, proto.onEnable = null, proto.onDisable = null, proto.onDestroy = null, 
    proto.onFocusInEditor = null, proto.onLostFocusInEditor = null, proto.resetInEditor = null, 
    proto._getLocalBounds = null, proto.onRestore = null, Component._requireComponent = null, 
    Component._executionOrder = 0, value(Component, "_registerEditorProps", (function(cls, props) {
        var reqComp = props.requireComponent;
        reqComp && (cls._requireComponent = reqComp);
        var order = props.executionOrder;
        order && "number" == typeof order && (cls._executionOrder = order);
    })), cc.Component = Component;
    CCObject.Flags.Destroying;
    var _cachedArray = new Array(16), _currentHovered = null, pos = new Vec2, _touchEvents = [ exports.SystemEventType.TOUCH_START.toString(), exports.SystemEventType.TOUCH_MOVE.toString(), exports.SystemEventType.TOUCH_END.toString(), exports.SystemEventType.TOUCH_CANCEL.toString() ], _mouseEvents = [ exports.SystemEventType.MOUSE_DOWN.toString(), exports.SystemEventType.MOUSE_ENTER.toString(), exports.SystemEventType.MOUSE_MOVE.toString(), exports.SystemEventType.MOUSE_LEAVE.toString(), exports.SystemEventType.MOUSE_UP.toString(), exports.SystemEventType.MOUSE_WHEEL.toString() ];
    function _touchStartHandler(touch, event) {
        var node = this.owner;
        return !(!node || !node._uiProps.uiTransformComp) && (touch.getUILocation(pos), 
        !!node._uiProps.uiTransformComp.isHit(pos, this) && (event.type = exports.SystemEventType.TOUCH_START.toString(), 
        event.touch = touch, event.bubbles = !0, node.dispatchEvent(event), !0));
    }
    function _touchMoveHandler(touch, event) {
        var node = this.owner;
        if (!node || !node._uiProps.uiTransformComp) return !1;
        event.type = exports.SystemEventType.TOUCH_MOVE.toString(), event.touch = touch, 
        event.bubbles = !0, node.dispatchEvent(event);
    }
    function _touchEndHandler(touch, event) {
        var node = this.owner;
        node && node._uiProps.uiTransformComp && (touch.getUILocation(pos), node._uiProps.uiTransformComp.isHit(pos, this) ? event.type = exports.SystemEventType.TOUCH_END.toString() : event.type = exports.SystemEventType.TOUCH_CANCEL.toString(), 
        event.touch = touch, event.bubbles = !0, node.dispatchEvent(event));
    }
    function _touchCancelHandler(touch, event) {
        var node = this.owner;
        node && node._uiProps.uiTransformComp && (event.type = exports.SystemEventType.TOUCH_CANCEL.toString(), 
        event.touch = touch, event.bubbles = !0, node.dispatchEvent(event));
    }
    function _mouseDownHandler(event) {
        var node = this.owner;
        node && node._uiProps.uiTransformComp && (pos = event.getUILocation(), node._uiProps.uiTransformComp.isHit(pos, this) && (event.type = exports.SystemEventType.MOUSE_DOWN.toString(), 
        event.bubbles = !0, node.dispatchEvent(event)));
    }
    function _mouseMoveHandler(event) {
        var node = this.owner;
        if (node && node._uiProps.uiTransformComp) {
            if (pos = event.getUILocation(), node._uiProps.uiTransformComp.isHit(pos, this)) this._previousIn || (_currentHovered && _currentHovered.eventProcessor.mouseListener && (event.type = exports.SystemEventType.MOUSE_LEAVE, 
            _currentHovered.dispatchEvent(event), _currentHovered.eventProcessor.mouseListener && (_currentHovered.eventProcessor.mouseListener._previousIn = !1)), 
            _currentHovered = node, event.type = exports.SystemEventType.MOUSE_ENTER.toString(), 
            node.dispatchEvent(event), this._previousIn = !0), event.type = exports.SystemEventType.MOUSE_MOVE.toString(), 
            event.bubbles = !0, node.dispatchEvent(event); else {
                if (!this._previousIn) return;
                event.type = exports.SystemEventType.MOUSE_LEAVE.toString(), node.dispatchEvent(event), 
                this._previousIn = !1, _currentHovered = null;
            }
            event.propagationStopped = !0;
        }
    }
    function _mouseUpHandler(event) {
        var node = this.owner;
        node && node._uiProps.uiTransformComp && (pos = event.getUILocation(), node._uiProps.uiTransformComp.isHit(pos, this) && (event.type = exports.SystemEventType.MOUSE_UP.toString(), 
        event.bubbles = !0, node.dispatchEvent(event), event.propagationStopped = !0));
    }
    function _mouseWheelHandler(event) {
        var node = this.owner;
        node && node._uiProps.uiTransformComp && (pos = event.getUILocation(), node._uiProps.uiTransformComp.isHit(pos, this) && (event.type = exports.SystemEventType.MOUSE_WHEEL.toString(), 
        event.bubbles = !0, node.dispatchEvent(event), event.propagationStopped = !0));
    }
    function _searchMaskInParent(node) {
        var Mask = cc.MaskComponent;
        if (Mask) for (var index = 0, curr = node; curr && cc.Node.isNode(curr); curr = curr.parent, 
        ++index) if (curr.getComponent(Mask)) return {
            index: index,
            node: curr
        };
        return null;
    }
    function _checkListeners(node, events) {
        if (!node._persistNode) {
            var i = 0;
            if (node.eventProcessor.bubblingTargets) for (;i < events.length; ++i) if (node.eventProcessor.bubblingTargets.hasEventListener(events[i])) return !0;
            if (node.eventProcessor.capturingTargets) for (;i < events.length; ++i) if (node.eventProcessor.capturingTargets.hasEventListener(events[i])) return !0;
            return !1;
        }
        return !0;
    }
    var _class$d, _class2$a, _descriptor$8, _descriptor2$4, _descriptor3$3, _descriptor4$2, _descriptor5$2, _class3$7, _temp$b, NodeEventProcessor = function() {
        function NodeEventProcessor(node) {
            _classCallCheck(this, NodeEventProcessor), this.bubblingTargets = null, this.capturingTargets = null, 
            this.touchListener = null, this.mouseListener = null, this._node = node;
        }
        return _createClass(NodeEventProcessor, [ {
            key: "node",
            get: function get() {
                return this._node;
            }
        } ]), _createClass(NodeEventProcessor, [ {
            key: "reattach",
            value: function reattach() {
                if (this.touchListener) {
                    var mask = this.touchListener.mask = _searchMaskInParent(this._node);
                    this.mouseListener && (this.mouseListener.mask = mask);
                } else this.mouseListener && (this.mouseListener.mask = _searchMaskInParent(this._node));
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _currentHovered === this._node && (_currentHovered = null), (this.touchListener || this.mouseListener) && (eventManager.removeListeners(this._node), 
                this.touchListener && (this.touchListener.owner = null, this.touchListener.mask = null, 
                this.touchListener = null), this.mouseListener && (this.mouseListener.owner = null, 
                this.mouseListener.mask = null, this.mouseListener = null));
            }
        }, {
            key: "on",
            value: function on(type, callback, target, useCapture) {
                return this._checknSetupSysEvent(type) ? this._onDispatch(type, callback, target, useCapture) : (this.bubblingTargets || (this.bubblingTargets = new EventTarget), 
                this.bubblingTargets.on(type, callback, target));
            }
        }, {
            key: "once",
            value: function once(type, callback, target, useCapture) {
                (this._checknSetupSysEvent(type) && useCapture ? this.capturingTargets = this.capturingTargets || new EventTarget : this.bubblingTargets = this.bubblingTargets || new EventTarget).once(type, callback, target);
            }
        }, {
            key: "off",
            value: function off(type, callback, target, useCapture) {
                var touchEvent = -1 !== _touchEvents.indexOf(type), mouseEvent = !touchEvent && -1 !== _mouseEvents.indexOf(type);
                touchEvent || mouseEvent ? (this._offDispatch(type, callback, target, useCapture), 
                touchEvent ? this.touchListener && !_checkListeners(this._node, _touchEvents) && (eventManager.removeListener(this.touchListener), 
                this.touchListener = null) : mouseEvent && this.mouseListener && !_checkListeners(this._node, _mouseEvents) && (eventManager.removeListener(this.mouseListener), 
                this.mouseListener = null)) : this.bubblingTargets && this.bubblingTargets.off(type, callback, target);
            }
        }, {
            key: "emit",
            value: function emit(type) {
                if (this.bubblingTargets) {
                    for (var _this$bubblingTargets, _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                    (_this$bubblingTargets = this.bubblingTargets).emit.apply(_this$bubblingTargets, [ type ].concat(args));
                }
            }
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {
                !function _doDispatchEvent(owner, event) {
                    var target, i = 0;
                    for (event.target = owner, _cachedArray.length = 0, owner.eventProcessor.getCapturingTargets(event.type, _cachedArray), 
                    event.eventPhase = 1, i = _cachedArray.length - 1; i >= 0; --i) if ((target = _cachedArray[i]).eventProcessor.capturingTargets && (event.currentTarget = target, 
                    target.eventProcessor.capturingTargets.emit(event.type, event, _cachedArray), event.propagationStopped)) return void (_cachedArray.length = 0);
                    if (_cachedArray.length = 0, event.eventPhase = 2, event.currentTarget = owner, 
                    owner.eventProcessor.capturingTargets && owner.eventProcessor.capturingTargets.emit(event.type, event), 
                    !event.propagationImmediateStopped && owner.eventProcessor.bubblingTargets && owner.eventProcessor.bubblingTargets.emit(event.type, event), 
                    !event.propagationStopped && event.bubbles) for (owner.eventProcessor.getBubblingTargets(event.type, _cachedArray), 
                    event.eventPhase = 3, i = 0; i < _cachedArray.length; ++i) if ((target = _cachedArray[i]).eventProcessor.bubblingTargets && (event.currentTarget = target, 
                    target.eventProcessor.bubblingTargets.emit(event.type, event), event.propagationStopped)) return void (_cachedArray.length = 0);
                    _cachedArray.length = 0;
                }(this._node, event), _cachedArray.length = 0;
            }
        }, {
            key: "hasEventListener",
            value: function hasEventListener(type) {
                var has = !1;
                return this.bubblingTargets && (has = this.bubblingTargets.hasEventListener(type)), 
                !has && this.capturingTargets && (has = this.capturingTargets.hasEventListener(type)), 
                has;
            }
        }, {
            key: "targetOff",
            value: function targetOff(target) {
                this.capturingTargets && this.capturingTargets.targetOff(target), this.bubblingTargets && this.bubblingTargets.targetOff(target), 
                this.touchListener && !_checkListeners(this.node, _touchEvents) && (eventManager.removeListener(this.touchListener), 
                this.touchListener = null), this.mouseListener && !_checkListeners(this.node, _mouseEvents) && (eventManager.removeListener(this.mouseListener), 
                this.mouseListener = null);
            }
        }, {
            key: "getCapturingTargets",
            value: function getCapturingTargets(type, targets) {
                for (var parent = this._node.parent; parent; ) parent.eventProcessor.capturingTargets && parent.eventProcessor.capturingTargets.hasEventListener(type) && targets.push(parent), 
                parent = parent.parent;
            }
        }, {
            key: "getBubblingTargets",
            value: function getBubblingTargets(type, targets) {
                for (var parent = this._node.parent; parent; ) parent.eventProcessor.bubblingTargets && parent.eventProcessor.bubblingTargets.hasEventListener(type) && targets.push(parent), 
                parent = parent.parent;
            }
        }, {
            key: "_checknSetupSysEvent",
            value: function _checknSetupSysEvent(type) {
                var _this = this, newAdded = !1, forDispatch = !1;
                return -1 !== _touchEvents.indexOf(type) ? (this.touchListener || (this.touchListener = cc.EventListener.create({
                    event: cc.EventListener.TOUCH_ONE_BY_ONE,
                    swallowTouches: !0,
                    owner: this._node,
                    mask: _searchMaskInParent(this._node),
                    onTouchBegan: _touchStartHandler,
                    onTouchMoved: _touchMoveHandler,
                    onTouchEnded: _touchEndHandler,
                    onTouchCancelled: _touchCancelHandler
                }), eventManager.addListener(this.touchListener, this._node), newAdded = !0), forDispatch = !0) : -1 !== _mouseEvents.indexOf(type) && (this.mouseListener || (this.mouseListener = cc.EventListener.create({
                    event: cc.EventListener.MOUSE,
                    _previousIn: !1,
                    owner: this._node,
                    mask: _searchMaskInParent(this._node),
                    onMouseDown: _mouseDownHandler,
                    onMouseMove: _mouseMoveHandler,
                    onMouseUp: _mouseUpHandler,
                    onMouseScroll: _mouseWheelHandler
                }), eventManager.addListener(this.mouseListener, this._node), newAdded = !0), forDispatch = !0), 
                newAdded && !this._node.activeInHierarchy && cc.director.getScheduler().schedule((function() {
                    _this._node.activeInHierarchy || eventManager.pauseTarget(_this._node);
                }), this._node, 0, 0, 0, !1), forDispatch;
            }
        }, {
            key: "_onDispatch",
            value: function _onDispatch(type, callback, target, useCapture) {
                if ("boolean" == typeof target ? (useCapture = target, target = void 0) : useCapture = !!useCapture, 
                callback) {
                    var listeners = null;
                    return (listeners = useCapture ? this.capturingTargets = this.capturingTargets || new EventTarget : this.bubblingTargets = this.bubblingTargets || new EventTarget).hasEventListener(type, callback, target) || listeners.on(type, callback, target), 
                    callback;
                }
                cc.errorID(6800);
            }
        }, {
            key: "_offDispatch",
            value: function _offDispatch(type, callback, target, useCapture) {
                if ("boolean" == typeof target ? (useCapture = target, target = void 0) : useCapture = !!useCapture, 
                callback) {
                    var listeners = useCapture ? this.capturingTargets : this.bubblingTargets;
                    listeners && listeners.off(type, callback, target);
                } else this.capturingTargets && this.capturingTargets.removeAll(type), this.bubblingTargets && this.bubblingTargets.removeAll(type);
            }
        } ]), NodeEventProcessor;
    }();
    cc.NodeEventProcessor = NodeEventProcessor;
    var Destroying$2 = CCObject.Flags.Destroying, DontDestroy$1 = CCObject.Flags.DontDestroy, Deactivating$1 = CCObject.Flags.Deactivating, ChangingState = CCObject.Flags.Activating | Deactivating$1, idGenerator$2 = new IDGenerator("Node");
    function getConstructor(typeOrClassName) {
        return typeOrClassName ? "string" == typeof typeOrClassName ? getClassByName(typeOrClassName) : typeOrClassName : (errorID(3804), 
        null);
    }
    var _dec$e, _dec2$6, _dec3$2, _dec4$1, _dec5$1, _dec6$1, _class$e, _class2$b, _descriptor$9, _descriptor2$5, _descriptor3$4, _class3$8, _temp$c, BaseNode = ccclass("cc._BaseNode")((_temp$b = _class3$7 = function(_CCObject) {
        function BaseNode(name) {
            var _this;
            return _classCallCheck(this, BaseNode), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BaseNode).call(this, name)), "_parent", _descriptor$8, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_children", _descriptor2$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_active", _descriptor3$3, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_components", _descriptor4$2, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_prefab", _descriptor5$2, _assertThisInitialized(_this)), 
            _this._scene = null, _this._activeInHierarchy = !1, _this._id = idGenerator$2.getNewId(), 
            _this._eventProcessor = new NodeEventProcessor(_assertThisInitialized(_this)), _this._eventMask = 0, 
            _this.__eventTargets = [], _this._siblingIndex = 0, _this._registerIfAttached = void 0, 
            _this._name = void 0 !== name ? name : "New Node", _this;
        }
        return _inherits(BaseNode, _CCObject), _createClass(BaseNode, [ {
            key: "components",
            get: function get() {
                return this._components;
            }
        }, {
            key: "_persistNode",
            get: function get() {
                return (this._objFlags & DontDestroy$1) > 0;
            },
            set: function set(value) {
                value ? this._objFlags |= DontDestroy$1 : this._objFlags &= ~DontDestroy$1;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            },
            set: function set(value) {
                this._name = value;
            }
        }, {
            key: "uuid",
            get: function get() {
                return this._id;
            }
        }, {
            key: "children",
            get: function get() {
                return this._children;
            }
        }, {
            key: "active",
            get: function get() {
                return this._active;
            },
            set: function set(isActive) {
                if (this._active !== isActive) {
                    this._active = isActive;
                    var parent = this._parent;
                    if (parent) parent._activeInHierarchy && cc.director._nodeActivator.activateNode(this, isActive);
                }
            }
        }, {
            key: "activeInHierarchy",
            get: function get() {
                return this._activeInHierarchy;
            }
        }, {
            key: "parent",
            get: function get() {
                return this._parent;
            },
            set: function set(value) {
                this.setParent(value);
            }
        }, {
            key: "scene",
            get: function get() {
                return this._scene;
            }
        }, {
            key: "eventProcessor",
            get: function get() {
                return this._eventProcessor;
            }
        } ], [ {
            key: "_setScene",
            value: function _setScene(node) {
                node instanceof cc.Scene ? node._scene = node : null == node._parent ? cc.error("Node %s(%s) has not attached to a scene.", node.name, node.uuid) : node._scene = node._parent._scene;
            }
        }, {
            key: "_findComponent",
            value: function _findComponent(node, constructor) {
                var cls = constructor, comps = node._components;
                if (cls._sealed) for (var i = 0; i < comps.length; ++i) {
                    var comp = comps[i];
                    if (comp.constructor === constructor) return comp;
                } else for (var _i = 0; _i < comps.length; ++_i) {
                    var _comp = comps[_i];
                    if (_comp instanceof constructor) return _comp;
                }
                return null;
            }
        }, {
            key: "_findComponents",
            value: function _findComponents(node, constructor, components) {
                var cls = constructor, comps = node._components;
                if (cls._sealed) for (var i = 0; i < comps.length; ++i) {
                    var comp = comps[i];
                    comp.constructor === constructor && components.push(comp);
                } else for (var _i2 = 0; _i2 < comps.length; ++_i2) {
                    var _comp2 = comps[_i2];
                    _comp2 instanceof constructor && components.push(_comp2);
                }
            }
        }, {
            key: "_findChildComponent",
            value: function _findChildComponent(children, constructor) {
                for (var i = 0; i < children.length; ++i) {
                    var node = children[i], comp = BaseNode._findComponent(node, constructor);
                    if (comp) return comp;
                    if (node._children.length > 0 && (comp = BaseNode._findChildComponent(node._children, constructor))) return comp;
                }
                return null;
            }
        }, {
            key: "_findChildComponents",
            value: function _findChildComponents(children, constructor, components) {
                for (var i = 0; i < children.length; ++i) {
                    var node = children[i];
                    BaseNode._findComponents(node, constructor, components), node._children.length > 0 && BaseNode._findChildComponents(node._children, constructor, components);
                }
            }
        } ]), _createClass(BaseNode, [ {
            key: "attr",
            value: function attr(attrs) {
                mixin(this, attrs);
            }
        }, {
            key: "getParent",
            value: function getParent() {
                return this._parent;
            }
        }, {
            key: "setParent",
            value: function setParent(value) {
                var keepWorldTransform = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (this._parent !== value) {
                    var oldParent = this._parent;
                    if (oldParent && oldParent._objFlags & ChangingState && errorID(3821), this._parent = value, 
                    this._siblingIndex = 0, this._onSetParent(oldParent, keepWorldTransform), this.emit && this.emit(exports.SystemEventType.PARENT_CHANGED, oldParent), 
                    value && (value._objFlags & Deactivating$1 && errorID(3821), value._children.push(this), 
                    this._siblingIndex = value._children.length - 1, value.emit && value.emit(exports.SystemEventType.CHILD_ADDED, this)), 
                    oldParent && !(oldParent._objFlags & Destroying$2)) {
                        var removeAt = oldParent._children.indexOf(this);
                        0, oldParent._children.splice(removeAt, 1), oldParent._updateSiblingIndex(), oldParent.emit && oldParent.emit(exports.SystemEventType.CHILD_REMOVED, this);
                    }
                    this._onHierarchyChanged(oldParent);
                }
            }
        }, {
            key: "getChildByUuid",
            value: function getChildByUuid(uuid) {
                if (!uuid) return cc.log("Invalid uuid"), null;
                for (var locChildren = this._children, i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._id === uuid) return locChildren[i];
                return null;
            }
        }, {
            key: "getChildByName",
            value: function getChildByName(name) {
                if (!name) return cc.log("Invalid name"), null;
                for (var locChildren = this._children, i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._name === name) return locChildren[i];
                return null;
            }
        }, {
            key: "getChildByPath",
            value: function getChildByPath(path) {
                for (var segments = path.split("/"), lastNode = this, _loop = function _loop(i) {
                    var segment = segments[i];
                    if (0 === segment.length) return "continue";
                    var next = lastNode.children.find((function(childNode) {
                        return childNode.name === segment;
                    }));
                    if (!next) return {
                        v: null
                    };
                    lastNode = next;
                }, i = 0; i < segments.length; ++i) {
                    var _ret = _loop(i);
                    switch (_ret) {
                      case "continue":
                        continue;

                      default:
                        if ("object" === _typeof(_ret)) return _ret.v;
                    }
                }
                return lastNode;
            }
        }, {
            key: "addChild",
            value: function addChild(child) {
                cc.assertID(child, 1606), cc.assertID(null === child._parent, 1605), child.setParent(this);
            }
        }, {
            key: "insertChild",
            value: function insertChild(child, siblingIndex) {
                child.parent = this, child.setSiblingIndex(siblingIndex);
            }
        }, {
            key: "getSiblingIndex",
            value: function getSiblingIndex() {
                return this._siblingIndex;
            }
        }, {
            key: "setSiblingIndex",
            value: function setSiblingIndex(index) {
                if (this._parent) if (this._parent._objFlags & Deactivating$1) errorID(3821); else {
                    var siblings = this._parent._children;
                    index = -1 !== index ? index : siblings.length - 1;
                    var oldIndex = siblings.indexOf(this);
                    index !== oldIndex && (siblings.splice(oldIndex, 1), index < siblings.length ? siblings.splice(index, 0, this) : siblings.push(this), 
                    this._parent._updateSiblingIndex(), this._onSiblingIndexChanged && this._onSiblingIndexChanged(index));
                }
            }
        }, {
            key: "walk",
            value: function walk(prefunc, postfunc) {
                var index = 1, children = null, curr = null, i = 0, stack = BaseNode._stacks[BaseNode._stackId];
                stack || (stack = [], BaseNode._stacks.push(stack)), BaseNode._stackId++, stack.length = 0, 
                stack[0] = this;
                for (var parent = null, afterChildren = !1; index; ) if (curr = stack[--index]) if (!afterChildren && prefunc ? prefunc(curr) : afterChildren && postfunc && postfunc(curr), 
                stack[index] = null, afterChildren) {
                    if (afterChildren = !1, children) if (children[++i]) stack[index] = children[i], 
                    index++; else if (parent && (stack[index] = parent, index++, afterChildren = !0, 
                    parent._parent ? (i = (children = parent._parent._children).indexOf(parent), parent = parent._parent) : (parent = null, 
                    children = null), i < 0)) break;
                } else curr._children.length > 0 ? (parent = curr, children = curr._children, i = 0, 
                stack[index] = children[i], index++) : (stack[index] = curr, index++, afterChildren = !0);
                stack.length = 0, BaseNode._stackId--;
            }
        }, {
            key: "removeFromParent",
            value: function removeFromParent() {
                this._parent && this._parent.removeChild(this);
            }
        }, {
            key: "removeChild",
            value: function removeChild(child) {
                this._children.indexOf(child) > -1 && (child.parent = null);
            }
        }, {
            key: "removeAllChildren",
            value: function removeAllChildren() {
                for (var children = this._children, i = children.length - 1; i >= 0; i--) {
                    var node = children[i];
                    node && (node.parent = null);
                }
                this._children.length = 0;
            }
        }, {
            key: "isChildOf",
            value: function isChildOf(parent) {
                var child = this;
                do {
                    if (child === parent) return !0;
                    child = child._parent;
                } while (child);
                return !1;
            }
        }, {
            key: "getComponent",
            value: function getComponent(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName);
                return constructor ? BaseNode._findComponent(this, constructor) : null;
            }
        }, {
            key: "getComponents",
            value: function getComponents(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName), components = [];
                return constructor && BaseNode._findComponents(this, constructor, components), components;
            }
        }, {
            key: "getComponentInChildren",
            value: function getComponentInChildren(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName);
                return constructor ? BaseNode._findChildComponent(this._children, constructor) : null;
            }
        }, {
            key: "getComponentsInChildren",
            value: function getComponentsInChildren(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName), components = [];
                return constructor && (BaseNode._findComponents(this, constructor, components), 
                BaseNode._findChildComponents(this._children, constructor, components)), components;
            }
        }, {
            key: "addComponent",
            value: function addComponent(typeOrClassName) {
                var constructor;
                if ("string" == typeof typeOrClassName) {
                    if (!(constructor = getClassByName(typeOrClassName))) return errorID(3807, typeOrClassName), 
                    cc._RF.peek() && errorID(3808, typeOrClassName), null;
                } else {
                    if (!typeOrClassName) return errorID(3804), null;
                    constructor = typeOrClassName;
                }
                if ("function" != typeof constructor) return errorID(3809), null;
                if (!isChildClassOf(constructor, cc.Component)) return errorID(3810), null;
                var ReqComp = constructor._requireComponent;
                if (ReqComp && !this.getComponent(ReqComp) && !this.addComponent(ReqComp)) return null;
                var component = new constructor;
                return component.node = this, this._components.push(component), this._activeInHierarchy && cc.director._nodeActivator.activateComp(component), 
                component;
            }
        }, {
            key: "removeComponent",
            value: function removeComponent(component) {
                if (component) {
                    var componentInstance = null;
                    (componentInstance = component instanceof Component ? component : this.getComponent(component)) && componentInstance.destroy();
                } else errorID(3813);
            }
        }, {
            key: "on",
            value: function on(type, callback, target, useCapture) {
                switch (type) {
                  case exports.SystemEventType.TRANSFORM_CHANGED:
                    this._eventMask |= 1;
                }
                this._eventProcessor.on(type, callback, target, useCapture);
            }
        }, {
            key: "off",
            value: function off(type, callback, target, useCapture) {
                if (this._eventProcessor.off(type, callback, target, useCapture), !this._eventProcessor.hasEventListener(type)) switch (type) {
                  case exports.SystemEventType.TRANSFORM_CHANGED:
                    this._eventMask &= -2;
                }
            }
        }, {
            key: "once",
            value: function once(type, callback, target, useCapture) {
                this._eventProcessor.once(type, callback, target, useCapture);
            }
        }, {
            key: "emit",
            value: function emit(type) {
                for (var _this$_eventProcessor, _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                (_this$_eventProcessor = this._eventProcessor).emit.apply(_this$_eventProcessor, [ type ].concat(args));
            }
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {
                this._eventProcessor.dispatchEvent(event);
            }
        }, {
            key: "hasEventListener",
            value: function hasEventListener(type) {
                return this._eventProcessor.hasEventListener(type);
            }
        }, {
            key: "targetOff",
            value: function targetOff(target) {
                this._eventProcessor.targetOff(target), 1 & this._eventMask && !this._eventProcessor.hasEventListener(exports.SystemEventType.TRANSFORM_CHANGED) && (this._eventMask &= -2);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return !!_get(_getPrototypeOf(BaseNode.prototype), "destroy", this).call(this) && (this._activeInHierarchy && this._disableChildComps(), 
                !0);
            }
        }, {
            key: "destroyAllChildren",
            value: function destroyAllChildren() {
                for (var children = this._children, i = 0; i < children.length; ++i) children[i].destroy();
            }
        }, {
            key: "_removeComponent",
            value: function _removeComponent(component) {
                if (component) {
                    if (!(this._objFlags & Destroying$2)) {
                        var i = this._components.indexOf(component);
                        -1 !== i ? this._components.splice(i, 1) : component.node !== this && errorID(3815);
                    }
                } else errorID(3814);
            }
        }, {
            key: "_updateSiblingIndex",
            value: function _updateSiblingIndex() {
                for (var i = 0; i < this._children.length; ++i) this._children[i]._siblingIndex = i;
            }
        }, {
            key: "_onSetParent",
            value: function _onSetParent(oldParent) {
                this._parent && (null != oldParent && oldParent._scene === this._parent._scene || null == this._parent._scene || this.walk((function(node) {
                    BaseNode._setScene(node);
                })));
            }
        }, {
            key: "_onPostActivated",
            value: function _onPostActivated(active) {}
        }, {
            key: "_onBatchRestored",
            value: function _onBatchRestored() {}
        }, {
            key: "_onBatchCreated",
            value: function _onBatchCreated() {
                this._parent && (this._siblingIndex = this._parent.children.indexOf(this));
            }
        }, {
            key: "_onPreDestroy",
            value: function _onPreDestroy() {
                this._onPreDestroyBase();
            }
        }, {
            key: "_onHierarchyChanged",
            value: function _onHierarchyChanged(oldParent) {
                return this._onHierarchyChangedBase(oldParent);
            }
        }, {
            key: "_instantiate",
            value: function _instantiate(cloned) {
                cloned || (cloned = cc.instantiate._clone(this, this));
                var thisPrefabInfo = this._prefab;
                thisPrefabInfo && this === thisPrefabInfo.root && thisPrefabInfo.sync;
                return cloned._parent = null, cloned._onBatchRestored(), cloned;
            }
        }, {
            key: "_onHierarchyChangedBase",
            value: function _onHierarchyChangedBase(oldParent) {
                var newParent = this._parent;
                !this._persistNode || newParent instanceof cc.Scene || cc.game.removePersistRootNode(this);
                var shouldActiveNow = this._active && !(!newParent || !newParent._activeInHierarchy);
                this._activeInHierarchy !== shouldActiveNow && cc.director._nodeActivator.activateNode(this, shouldActiveNow);
            }
        }, {
            key: "_onPreDestroyBase",
            value: function _onPreDestroyBase() {
                this._objFlags |= Destroying$2;
                var parent = this._parent, destroyByParent = !!parent && 0 != (parent._objFlags & Destroying$2);
                for (var children = this._children, i = 0; i < children.length; ++i) children[i]._destroyImmediate();
                for (var comps = this._components, _i5 = 0; _i5 < comps.length; ++_i5) comps[_i5]._destroyImmediate();
                for (var eventTargets = this.__eventTargets, _i6 = 0; _i6 < eventTargets.length; ++_i6) {
                    var et = eventTargets[_i6];
                    et && et.targetOff(this);
                }
                if (eventTargets.length = 0, this._persistNode && cc.game.removePersistRootNode(this), 
                !destroyByParent && parent) {
                    this.emit(exports.SystemEventType.PARENT_CHANGED, this);
                    var childIndex = parent._children.indexOf(this);
                    parent._children.splice(childIndex, 1), this._siblingIndex = 0, parent.emit && parent.emit(exports.SystemEventType.CHILD_REMOVED, this);
                }
                return this.emit(exports.SystemEventType.NODE_DESTROYED, this), destroyByParent;
            }
        }, {
            key: "_disableChildComps",
            value: function _disableChildComps() {
                for (var comps = this._components, i = 0; i < comps.length; ++i) {
                    var component = comps[i];
                    component._enabled && cc.director._compScheduler.disableComp(component);
                }
                for (var children = this._children, _i7 = 0; _i7 < children.length; ++_i7) {
                    var node = children[_i7];
                    node._active && node._disableChildComps();
                }
            }
        } ]), BaseNode;
    }(CCObject), _class3$7.idGenerator = idGenerator$2, _class3$7._stacks = [ [] ], 
    _class3$7._stackId = 0, _applyDecoratedDescriptor((_class2$a = _temp$b).prototype, "_persistNode", [ property ], Object.getOwnPropertyDescriptor(_class2$a.prototype, "_persistNode"), _class2$a.prototype), 
    _applyDecoratedDescriptor(_class2$a.prototype, "name", [ property ], Object.getOwnPropertyDescriptor(_class2$a.prototype, "name"), _class2$a.prototype), 
    _applyDecoratedDescriptor(_class2$a.prototype, "uuid", [ property ], Object.getOwnPropertyDescriptor(_class2$a.prototype, "uuid"), _class2$a.prototype), 
    _applyDecoratedDescriptor(_class2$a.prototype, "children", [ property ], Object.getOwnPropertyDescriptor(_class2$a.prototype, "children"), _class2$a.prototype), 
    _applyDecoratedDescriptor(_class2$a.prototype, "active", [ property ], Object.getOwnPropertyDescriptor(_class2$a.prototype, "active"), _class2$a.prototype), 
    _applyDecoratedDescriptor(_class2$a.prototype, "activeInHierarchy", [ property ], Object.getOwnPropertyDescriptor(_class2$a.prototype, "activeInHierarchy"), _class2$a.prototype), 
    _applyDecoratedDescriptor(_class2$a.prototype, "parent", [ property ], Object.getOwnPropertyDescriptor(_class2$a.prototype, "parent"), _class2$a.prototype), 
    _descriptor$8 = _applyDecoratedDescriptor(_class2$a.prototype, "_parent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$4 = _applyDecoratedDescriptor(_class2$a.prototype, "_children", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor3$3 = _applyDecoratedDescriptor(_class2$a.prototype, "_active", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor4$2 = _applyDecoratedDescriptor(_class2$a.prototype, "_components", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor5$2 = _applyDecoratedDescriptor(_class2$a.prototype, "_prefab", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$d = _class2$a)) || _class$d;
    cc._BaseNode = BaseNode;
    var _vec2a = new Vec2, _vec2b = new Vec2, _mat4_temp = new Mat4, _matrix = new Mat4, _worldMatrix = new Mat4, _rect = new Rect, UITransformComponent = (_dec$e = ccclass("cc.UITransformComponent"), 
    _dec2$6 = executionOrder(110), _dec3$2 = menu("UI/UITransform"), _dec4$1 = property({
        displayOrder: 0,
        tooltip: "内容尺寸"
    }), _dec5$1 = property({
        displayOrder: 1,
        tooltip: "锚点位置"
    }), _dec6$1 = property({
        tooltip: "渲染排序优先级"
    }), _dec$e(_class$e = _dec2$6(_class$e = _dec3$2(_class$e = executeInEditMode((_temp$c = _class3$8 = function(_Component) {
        function UITransformComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, UITransformComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UITransformComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_priority", _descriptor$9, _assertThisInitialized(_this)), 
            _this._canvas = null, _initializerDefineProperty(_this, "_contentSize", _descriptor2$5, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_anchorPoint", _descriptor3$4, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(UITransformComponent, _Component), _createClass(UITransformComponent, [ {
            key: "__preload",
            value: function __preload() {
                this.node._uiProps.uiTransformComp = this;
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._updateVisibility(), this.node.on(exports.SystemEventType.PARENT_CHANGED, this._parentChanged, this), 
                this._sortSiblings();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.node.off(exports.SystemEventType.PARENT_CHANGED, this._parentChanged, this), 
                this._canvas = null;
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this.node._uiProps.uiTransformComp = null;
            }
        }, {
            key: "setContentSize",
            value: function setContentSize(size, height) {
                var locContentSize = this._contentSize;
                if (void 0 === height) {
                    if ((size = size).width === locContentSize.width && size.height === locContentSize.height) return;
                    0, locContentSize.width = size.width, locContentSize.height = size.height;
                } else {
                    if (size === locContentSize.width && height === locContentSize.height) return;
                    0, locContentSize.width = size, locContentSize.height = height;
                }
                this.node.emit(exports.SystemEventType.SIZE_CHANGED);
            }
        }, {
            key: "setAnchorPoint",
            value: function setAnchorPoint(point, y) {
                var locAnchorPoint = this._anchorPoint;
                if (void 0 === y) {
                    if ((point = point).x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
                    locAnchorPoint.x = point.x, locAnchorPoint.y = point.y;
                } else {
                    if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
                    locAnchorPoint.x = point, locAnchorPoint.y = y;
                }
                this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
            }
        }, {
            key: "isHit",
            value: function isHit(point, listener) {
                var w = this._contentSize.width, h = this._contentSize.height, cameraPt = _vec2a, testPt = _vec2b, canvas = this._canvas;
                if (canvas) {
                    canvas.node.getWorldRT(_mat4_temp);
                    var m12 = _mat4_temp.m12, m13 = _mat4_temp.m13, center = cc.visibleRect.center;
                    if (_mat4_temp.m12 = center.x - (_mat4_temp.m00 * m12 + _mat4_temp.m04 * m13), _mat4_temp.m13 = center.y - (_mat4_temp.m01 * m12 + _mat4_temp.m05 * m13), 
                    Mat4.invert(_mat4_temp, _mat4_temp), Vec2.transformMat4(cameraPt, point, _mat4_temp), 
                    this.node.getWorldMatrix(_worldMatrix), Mat4.invert(_mat4_temp, _worldMatrix), Vec2.transformMat4(testPt, cameraPt, _mat4_temp), 
                    testPt.x += this._anchorPoint.x * w, testPt.y += this._anchorPoint.y * h, testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
                        if (listener && listener.mask) {
                            for (var mask = listener.mask, parent = this.node, i = 0; parent && i < mask.index; ++i, 
                            parent = parent.parent) ;
                            if (parent === mask.node) {
                                var comp = parent.getComponent(cc.MaskComponent);
                                return !comp || !comp.enabledInHierarchy || comp.isHit(cameraPt);
                            }
                            return listener.mask = null, !0;
                        }
                        return !0;
                    }
                    return !1;
                }
            }
        }, {
            key: "convertToNodeSpaceAR",
            value: function convertToNodeSpaceAR(worldPoint, out) {
                return this.node.getWorldMatrix(_worldMatrix), Mat4.invert(_mat4_temp, _worldMatrix), 
                out || (out = new Vec3), Vec3.transformMat4(out, worldPoint, _mat4_temp);
            }
        }, {
            key: "convertToWorldSpaceAR",
            value: function convertToWorldSpaceAR(nodePoint, out) {
                return this.node.getWorldMatrix(_worldMatrix), out || (out = new Vec3), Vec3.transformMat4(out, nodePoint, _worldMatrix);
            }
        }, {
            key: "getBoundingBox",
            value: function getBoundingBox() {
                Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                var width = this._contentSize.width, height = this._contentSize.height, rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                return rect.transformMat4(_matrix), rect;
            }
        }, {
            key: "getBoundingBoxToWorld",
            value: function getBoundingBoxToWorld() {
                return this.node.parent ? (this.node.parent.getWorldMatrix(_worldMatrix), this.getBoundingBoxTo(_worldMatrix)) : this.getBoundingBox();
            }
        }, {
            key: "getBoundingBoxTo",
            value: function getBoundingBoxTo(parentMat) {
                Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                var width = this._contentSize.width, height = this._contentSize.height, rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                if (Mat4.multiply(_worldMatrix, parentMat, _matrix), rect.transformMat4(_worldMatrix), 
                !this.node.children) return rect;
                var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var child = _ref;
                    if (child && child.active) {
                        var uiTransform = child.getComponent(UITransformComponent);
                        if (uiTransform) {
                            var childRect = uiTransform.getBoundingBoxTo(parentMat);
                            childRect && Rect.union(rect, rect, childRect);
                        }
                    }
                }
                return rect;
            }
        }, {
            key: "getComputeAABB",
            value: function getComputeAABB(out) {
                var width = this._contentSize.width, height = this._contentSize.height;
                _rect.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height), 
                _rect.transformMat4(this.node.worldMatrix);
                var px = _rect.x + .5 * _rect.width, py = _rect.y + .5 * _rect.height, pz = this.node.worldPosition.z, w = _rect.width / 2, h = _rect.height / 2;
                if (null == out) return new aabb(px, py, pz, w, h, .001);
                aabb.set(out, px, py, pz, w, h, .001);
            }
        }, {
            key: "_updateVisibility",
            value: function _updateVisibility() {
                for (var parent = this.node; parent; ) {
                    if (parent) {
                        var canvasComp = parent.getComponent("cc.CanvasComponent");
                        if (canvasComp) {
                            this._canvas = canvasComp;
                            break;
                        }
                    }
                    parent = parent.parent;
                }
            }
        }, {
            key: "_parentChanged",
            value: function _parentChanged(node) {
                this._canvas && this._canvas.node === this.node || this._sortSiblings();
            }
        }, {
            key: "_sortSiblings",
            value: function _sortSiblings() {
                var siblings = this.node.parent && this.node.parent.children;
                siblings && (siblings.sort((function(a, b) {
                    var aComp = a._uiProps.uiTransformComp, bComp = b._uiProps.uiTransformComp, diff = (aComp ? aComp.priority : 0) - (bComp ? bComp.priority : 0);
                    return 0 === diff ? a.getSiblingIndex() - b.getSiblingIndex() : diff;
                })), this.node.parent._updateSiblingIndex());
            }
        }, {
            key: "contentSize",
            get: function get() {
                return this._contentSize;
            },
            set: function set(value) {
                this._contentSize.equals(value) || (this._contentSize.set(value), this.node.emit(exports.SystemEventType.SIZE_CHANGED));
            }
        }, {
            key: "width",
            get: function get() {
                return this._contentSize.width;
            },
            set: function set(value) {
                this._contentSize.width !== value && (this._contentSize.width = value, this.node.emit(exports.SystemEventType.SIZE_CHANGED));
            }
        }, {
            key: "height",
            get: function get() {
                return this._contentSize.height;
            },
            set: function set(value) {
                this.contentSize.height !== value && (this._contentSize.height = value, this.node.emit(exports.SystemEventType.SIZE_CHANGED));
            }
        }, {
            key: "anchorPoint",
            get: function get() {
                return this._anchorPoint;
            },
            set: function set(value) {
                this._anchorPoint.equals(value) || (this._anchorPoint.set(value), this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
            }
        }, {
            key: "anchorX",
            get: function get() {
                return this._anchorPoint.x;
            },
            set: function set(value) {
                this._anchorPoint.x !== value && (this._anchorPoint.x = value, this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
            }
        }, {
            key: "anchorY",
            get: function get() {
                return this._anchorPoint.y;
            },
            set: function set(value) {
                this._anchorPoint.y !== value && (this._anchorPoint.y = value, this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            },
            set: function set(value) {
                this._priority !== value && (this._canvas && this._canvas.node === this.node ? cc.warn(9200) : (this._priority = value, 
                this._sortSiblings()));
            }
        }, {
            key: "visibility",
            get: function get() {
                return this._canvas ? this._canvas.visibility : -1;
            }
        } ]), UITransformComponent;
    }(Component), _class3$8.EventType = exports.SystemEventType, _applyDecoratedDescriptor((_class2$b = _temp$c).prototype, "contentSize", [ _dec4$1 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "contentSize"), _class2$b.prototype), 
    _applyDecoratedDescriptor(_class2$b.prototype, "anchorPoint", [ _dec5$1 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "anchorPoint"), _class2$b.prototype), 
    _applyDecoratedDescriptor(_class2$b.prototype, "priority", [ _dec6$1 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "priority"), _class2$b.prototype), 
    _descriptor$9 = _applyDecoratedDescriptor(_class2$b.prototype, "_priority", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor2$5 = _applyDecoratedDescriptor(_class2$b.prototype, "_contentSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Size(100, 100);
        }
    }), _descriptor3$4 = _applyDecoratedDescriptor(_class2$b.prototype, "_anchorPoint", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(.5, .5);
        }
    }), _class$e = _class2$b)) || _class$e) || _class$e) || _class$e) || _class$e);
    cc.UITransformComponent = UITransformComponent;
    var _dec$f, _dec2$7, _class$f, _class2$c, _descriptor$a, _descriptor2$6, _descriptor3$5, _descriptor4$3, _descriptor5$3, _class3$9, _temp$d, _class$g, _class2$d, _descriptor$b, _class4, _class5, _descriptor2$7, NodeUIProperties = function() {
        function NodeUIProperties(node) {
            _classCallCheck(this, NodeUIProperties), this.uiComp = null, this.opacity = 1, this._uiTransformComp = null, 
            this._node = node;
        }
        return _createClass(NodeUIProperties, [ {
            key: "uiTransformComp",
            get: function get() {
                return this._uiTransformComp || (this._uiTransformComp = this._node.getComponent(UITransformComponent)), 
                this._uiTransformComp;
            },
            set: function set(value) {
                this._uiTransformComp = value;
            }
        } ]), NodeUIProperties;
    }(), v3_a = new Vec3, q_a = new Quat, q_b = new Quat, array_a = new Array(10), qt_1$1 = new Quat, m3_1$2 = new Mat3, m3_scaling = new Mat3, m4_1$1 = new Mat4, bookOfChange = new Map, Node$1 = (_dec$f = ccclass("cc.Node"), 
    _dec2$7 = property({
        type: Vec3
    }), _dec$f((_temp$d = _class3$9 = function(_BaseNode) {
        function Node() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Node);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Node)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._uiProps = new NodeUIProperties(_assertThisInitialized(_this)), 
            _this._static = !1, _this._pos = new Vec3, _this._rot = new Quat, _this._scale = new Vec3(1, 1, 1), 
            _this._mat = new Mat4, _initializerDefineProperty(_this, "_lpos", _descriptor$a, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_lrot", _descriptor2$6, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_lscale", _descriptor3$5, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_layer", _descriptor4$3, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_euler", _descriptor5$3, _assertThisInitialized(_this)), 
            _this._dirtyFlags = TransformBit.NONE, _this._eulerDirty = !1, _this;
        }
        return _inherits(Node, _BaseNode), _createClass(Node, [ {
            key: "setParent",
            value: function setParent(value) {
                var keepWorldTransform = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                keepWorldTransform && this.updateWorldTransform(), _get(_getPrototypeOf(Node.prototype), "setParent", this).call(this, value, keepWorldTransform);
            }
        }, {
            key: "_onSetParent",
            value: function _onSetParent(oldParent, keepWorldTransform) {
                if (_get(_getPrototypeOf(Node.prototype), "_onSetParent", this).call(this, oldParent, keepWorldTransform), 
                keepWorldTransform) {
                    var parent = this._parent;
                    parent ? (parent.updateWorldTransform(), Mat4.multiply(m4_1$1, Mat4.invert(m4_1$1, parent._mat), this._mat), 
                    Mat4.toRTS(m4_1$1, this._lrot, this._lpos, this._lscale)) : (Vec3.copy(this._lpos, this._pos), 
                    Quat.copy(this._lrot, this._rot), Vec3.copy(this._lscale, this._scale)), this._eulerDirty = !0;
                }
                this.invalidateChildren(TransformBit.TRS);
            }
        }, {
            key: "_onBatchCreated",
            value: function _onBatchCreated() {
                _get(_getPrototypeOf(Node.prototype), "_onBatchCreated", this).call(this), bookOfChange.set(this._id, TransformBit.TRS), 
                this._dirtyFlags = TransformBit.TRS;
                for (var len = this._children.length, i = 0; i < len; ++i) this._children[i]._onBatchCreated();
            }
        }, {
            key: "_onBatchRestored",
            value: function _onBatchRestored() {
                this._onBatchCreated();
            }
        }, {
            key: "_onBeforeSerialize",
            value: function _onBeforeSerialize() {
                this.eulerAngles;
            }
        }, {
            key: "translate",
            value: function translate(trans, ns) {
                var space = ns || NodeSpace.LOCAL;
                if (space === NodeSpace.LOCAL) Vec3.transformQuat(v3_a, trans, this._lrot), this._lpos.x += v3_a.x, 
                this._lpos.y += v3_a.y, this._lpos.z += v3_a.z; else if (space === NodeSpace.WORLD) if (this._parent) {
                    Quat.invert(q_a, this._parent.worldRotation), Vec3.transformQuat(v3_a, trans, q_a);
                    var _scale = this.worldScale;
                    this._lpos.x += v3_a.x / _scale.x, this._lpos.y += v3_a.y / _scale.y, this._lpos.z += v3_a.z / _scale.z;
                } else this._lpos.x += trans.x, this._lpos.y += trans.y, this._lpos.z += trans.z;
                this.invalidateChildren(TransformBit.POSITION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
            }
        }, {
            key: "rotate",
            value: function rotate(rot, ns) {
                var space = ns || NodeSpace.LOCAL;
                if (Quat.normalize(q_a, rot), space === NodeSpace.LOCAL) Quat.multiply(this._lrot, this._lrot, q_a); else if (space === NodeSpace.WORLD) {
                    var worldRot = this.worldRotation;
                    Quat.multiply(q_b, q_a, worldRot), Quat.invert(q_a, worldRot), Quat.multiply(q_b, q_a, q_b), 
                    Quat.multiply(this._lrot, this._lrot, q_b);
                }
                this._eulerDirty = !0, this.invalidateChildren(TransformBit.ROTATION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
            }
        }, {
            key: "lookAt",
            value: function lookAt(pos, up) {
                this.getWorldPosition(v3_a), Vec3.subtract(v3_a, v3_a, pos), Vec3.normalize(v3_a, v3_a), 
                Quat.fromViewUp(q_a, v3_a, up), this.setWorldRotation(q_a);
            }
        }, {
            key: "invalidateChildren",
            value: function invalidateChildren(dirtyBit) {
                if ((this._dirtyFlags & this.hasChangedFlags & dirtyBit) !== dirtyBit) {
                    this._dirtyFlags |= dirtyBit, bookOfChange.set(this._id, this.hasChangedFlags | dirtyBit), 
                    dirtyBit |= TransformBit.POSITION;
                    for (var len = this._children.length, i = 0; i < len; ++i) this._children[i].invalidateChildren(dirtyBit);
                }
            }
        }, {
            key: "updateWorldTransform",
            value: function updateWorldTransform() {
                if (this._dirtyFlags) {
                    for (var child, cur = this, i = 0; cur && cur._dirtyFlags; ) array_a[i++] = cur, 
                    cur = cur._parent;
                    for (var dirtyBits = 0; i; ) dirtyBits |= (child = array_a[--i])._dirtyFlags, cur ? (dirtyBits & TransformBit.POSITION && (Vec3.transformMat4(child._pos, child._lpos, cur._mat), 
                    child._mat.m12 = child._pos.x, child._mat.m13 = child._pos.y, child._mat.m14 = child._pos.z), 
                    dirtyBits & TransformBit.RS && (Mat4.fromRTS(child._mat, child._lrot, child._lpos, child._lscale), 
                    Mat4.multiply(child._mat, cur._mat, child._mat), dirtyBits & TransformBit.ROTATION && Quat.multiply(child._rot, cur._rot, child._lrot), 
                    Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, child._rot)), Mat3.multiplyMat4(m3_1$2, m3_1$2, child._mat), 
                    child._scale.x = m3_1$2.m00, child._scale.y = m3_1$2.m04, child._scale.z = m3_1$2.m08)) : (dirtyBits & TransformBit.POSITION && (Vec3.copy(child._pos, child._lpos), 
                    child._mat.m12 = child._pos.x, child._mat.m13 = child._pos.y, child._mat.m14 = child._pos.z), 
                    dirtyBits & TransformBit.RS && (dirtyBits & TransformBit.ROTATION ? Quat.copy(child._rot, child._lrot) : Vec3.copy(child._scale, child._lscale), 
                    Mat4.fromRTS(child._mat, child._rot, child._pos, child._scale))), child._dirtyFlags = TransformBit.NONE, 
                    cur = child;
                }
            }
        }, {
            key: "setPosition",
            value: function setPosition(val, y, z) {
                void 0 === y || void 0 === z ? Vec3.copy(this._lpos, val) : Vec3.set(this._lpos, val, y, z), 
                this.invalidateChildren(TransformBit.POSITION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
            }
        }, {
            key: "getPosition",
            value: function getPosition(out) {
                return out ? Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z) : Vec3.copy(new Vec3, this._lpos);
            }
        }, {
            key: "setRotation",
            value: function setRotation(val, y, z, w) {
                void 0 === y || void 0 === z || void 0 === w ? Quat.copy(this._lrot, val) : Quat.set(this._lrot, val, y, z, w), 
                this._eulerDirty = !0, this.invalidateChildren(TransformBit.ROTATION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
            }
        }, {
            key: "setRotationFromEuler",
            value: function setRotationFromEuler(x, y, z) {
                Vec3.set(this._euler, x, y, z), Quat.fromEuler(this._lrot, x, y, z), this._eulerDirty = !1, 
                this.invalidateChildren(TransformBit.ROTATION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
            }
        }, {
            key: "getRotation",
            value: function getRotation(out) {
                return out ? Quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w) : Quat.copy(new Quat, this._lrot);
            }
        }, {
            key: "setScale",
            value: function setScale(val, y, z) {
                void 0 === y || void 0 === z ? Vec3.copy(this._lscale, val) : Vec3.set(this._lscale, val, y, z), 
                this.invalidateChildren(TransformBit.SCALE), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
            }
        }, {
            key: "getScale",
            value: function getScale(out) {
                return out ? Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z) : Vec3.copy(new Vec3, this._lscale);
            }
        }, {
            key: "inverseTransformPoint",
            value: function inverseTransformPoint(out, p) {
                Vec3.copy(out, p);
                for (var cur = this, i = 0; cur._parent; ) array_a[i++] = cur, cur = cur._parent;
                for (;i >= 0; ) Vec3.transformInverseRTS(out, out, cur._lrot, cur._lpos, cur._lscale), 
                cur = array_a[--i];
                return out;
            }
        }, {
            key: "setWorldPosition",
            value: function setWorldPosition(val, y, z) {
                void 0 === y || void 0 === z ? Vec3.copy(this._pos, val) : Vec3.set(this._pos, val, y, z);
                var parent = this._parent, local = this._lpos;
                parent ? (parent.updateWorldTransform(), Vec3.transformMat4(local, this._pos, Mat4.invert(m4_1$1, parent._mat))) : Vec3.copy(local, this._pos), 
                this.invalidateChildren(TransformBit.POSITION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
            }
        }, {
            key: "getWorldPosition",
            value: function getWorldPosition(out) {
                return this.updateWorldTransform(), out ? Vec3.copy(out, this._pos) : Vec3.copy(new Vec3, this._pos);
            }
        }, {
            key: "setWorldRotation",
            value: function setWorldRotation(val, y, z, w) {
                void 0 === y || void 0 === z || void 0 === w ? Quat.copy(this._rot, val) : Quat.set(this._rot, val, y, z, w), 
                this._parent ? (this._parent.updateWorldTransform(), Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot)) : Quat.copy(this._lrot, this._rot), 
                this._eulerDirty = !0, this.invalidateChildren(TransformBit.ROTATION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
            }
        }, {
            key: "setWorldRotationFromEuler",
            value: function setWorldRotationFromEuler(x, y, z) {
                Quat.fromEuler(this._rot, x, y, z), this._parent ? (this._parent.updateWorldTransform(), 
                Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot)) : Quat.copy(this._lrot, this._rot), 
                this._eulerDirty = !0, this.invalidateChildren(TransformBit.ROTATION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
            }
        }, {
            key: "getWorldRotation",
            value: function getWorldRotation(out) {
                return this.updateWorldTransform(), out ? Quat.copy(out, this._rot) : Quat.copy(new Quat, this._rot);
            }
        }, {
            key: "setWorldScale",
            value: function setWorldScale(val, y, z) {
                void 0 === y || void 0 === z ? Vec3.copy(this._scale, val) : Vec3.set(this._scale, val, y, z);
                var parent = this._parent;
                parent ? (parent.updateWorldTransform(), Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, parent._rot)), 
                Mat3.multiplyMat4(m3_1$2, m3_1$2, parent._mat), m3_scaling.m00 = this._scale.x, 
                m3_scaling.m04 = this._scale.y, m3_scaling.m08 = this._scale.z, Mat3.multiply(m3_1$2, m3_scaling, Mat3.invert(m3_1$2, m3_1$2)), 
                this._lscale.x = m3_1$2.m00, this._lscale.y = m3_1$2.m04, this._lscale.z = m3_1$2.m08) : Vec3.copy(this._lscale, this._scale), 
                this.invalidateChildren(TransformBit.SCALE), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
            }
        }, {
            key: "getWorldScale",
            value: function getWorldScale(out) {
                return this.updateWorldTransform(), out ? Vec3.copy(out, this._scale) : Vec3.copy(new Vec3, this._scale);
            }
        }, {
            key: "getWorldMatrix",
            value: function getWorldMatrix(out) {
                return this.updateWorldTransform(), out || (out = new Mat4), Mat4.copy(out, this._mat);
            }
        }, {
            key: "getWorldRS",
            value: function getWorldRS(out) {
                return this.updateWorldTransform(), out || (out = new Mat4), Mat4.copy(out, this._mat), 
                out.m12 = 0, out.m13 = 0, out.m14 = 0, out;
            }
        }, {
            key: "getWorldRT",
            value: function getWorldRT(out) {
                return this.updateWorldTransform(), out || (out = new Mat4), Mat4.fromRT(out, this._rot, this._pos);
            }
        }, {
            key: "getAnchorPoint",
            value: function getAnchorPoint(out) {
                return out || (out = new Vec2), out.set(this._uiProps.uiTransformComp.anchorPoint), 
                out;
            }
        }, {
            key: "setAnchorPoint",
            value: function setAnchorPoint(point, y) {
                this._uiProps.uiTransformComp.setAnchorPoint(point, y);
            }
        }, {
            key: "getContentSize",
            value: function getContentSize(out) {
                return out || (out = new Size), out.set(this._uiProps.uiTransformComp.contentSize), 
                out;
            }
        }, {
            key: "setContentSize",
            value: function setContentSize(size, height) {
                this._uiProps.uiTransformComp.setContentSize(size, height);
            }
        }, {
            key: "pauseSystemEvents",
            value: function pauseSystemEvents(recursive) {
                eventManager.pauseTarget(this, recursive);
            }
        }, {
            key: "resumeSystemEvents",
            value: function resumeSystemEvents(recursive) {
                eventManager.resumeTarget(this, recursive);
            }
        }, {
            key: "_onPostActivated",
            value: function _onPostActivated(active) {
                active ? (eventManager.resumeTarget(this), this.eventProcessor.reattach()) : eventManager.pauseTarget(this);
            }
        }, {
            key: "_onPreDestroy",
            value: function _onPreDestroy() {
                this._eventProcessor.destroy(), _get(_getPrototypeOf(Node.prototype), "_onPreDestroy", this).call(this);
            }
        }, {
            key: "position",
            get: function get() {
                return this._lpos;
            },
            set: function set(val) {
                this.setPosition(val);
            }
        }, {
            key: "worldPosition",
            get: function get() {
                return this.updateWorldTransform(), this._pos;
            },
            set: function set(val) {
                this.setWorldPosition(val);
            }
        }, {
            key: "rotation",
            get: function get() {
                return this._lrot;
            },
            set: function set(val) {
                this.setRotation(val);
            }
        }, {
            key: "eulerAngles",
            set: function set(val) {
                this.setRotationFromEuler(val.x, val.y, val.z);
            },
            get: function get() {
                return this._eulerDirty && (Quat.toEuler(this._euler, this._lrot), this._eulerDirty = !1), 
                this._euler;
            }
        }, {
            key: "worldRotation",
            get: function get() {
                return this.updateWorldTransform(), this._rot;
            },
            set: function set(val) {
                this.setWorldRotation(val);
            }
        }, {
            key: "scale",
            get: function get() {
                return this._lscale;
            },
            set: function set(val) {
                this.setScale(val);
            }
        }, {
            key: "worldScale",
            get: function get() {
                return this.updateWorldTransform(), this._scale;
            },
            set: function set(val) {
                this.setWorldScale(val);
            }
        }, {
            key: "matrix",
            set: function set(val) {
                Mat4.toRTS(val, this._lrot, this._lpos, this._lscale), this.invalidateChildren(TransformBit.TRS), 
                this._eulerDirty = !0, 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.TRS);
            }
        }, {
            key: "worldMatrix",
            get: function get() {
                return this.updateWorldTransform(), this._mat;
            }
        }, {
            key: "forward",
            get: function get() {
                return Vec3.transformQuat(new Vec3, Vec3.FORWARD, this.worldRotation);
            },
            set: function set(dir) {
                var len = dir.length();
                Vec3.multiplyScalar(v3_a, dir, -1 / len), Quat.fromViewUp(q_a, v3_a), this.setWorldRotation(q_a);
            }
        }, {
            key: "layer",
            set: function set(l) {
                this._layer = l;
            },
            get: function get() {
                return this._layer;
            }
        }, {
            key: "hasChangedFlags",
            get: function get() {
                return bookOfChange.get(this._id) || 0;
            },
            set: function set(val) {
                bookOfChange.set(this._id, val);
            }
        }, {
            key: "width",
            get: function get() {
                return this._uiProps.uiTransformComp.width;
            },
            set: function set(value) {
                this._uiProps.uiTransformComp.width = value;
            }
        }, {
            key: "height",
            get: function get() {
                return this._uiProps.uiTransformComp.height;
            },
            set: function set(value) {
                this._uiProps.uiTransformComp.height = value;
            }
        }, {
            key: "anchorX",
            get: function get() {
                return this._uiProps.uiTransformComp.anchorX;
            },
            set: function set(value) {
                this._uiProps.uiTransformComp.anchorX = value;
            }
        }, {
            key: "anchorY",
            get: function get() {
                return this._uiProps.uiTransformComp.anchorY;
            },
            set: function set(value) {
                this._uiProps.uiTransformComp.anchorY = value;
            }
        } ], [ {
            key: "isNode",
            value: function isNode(obj) {
                return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
            }
        } ]), Node;
    }(BaseNode), _class3$9.bookOfChange = bookOfChange, _class3$9.EventType = exports.SystemEventType, 
    _class3$9.NodeSpace = NodeSpace, _class3$9.TransformDirtyBit = TransformBit, _class3$9.TransformBit = TransformBit, 
    _descriptor$a = _applyDecoratedDescriptor((_class2$c = _temp$d).prototype, "_lpos", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3;
        }
    }), _descriptor2$6 = _applyDecoratedDescriptor(_class2$c.prototype, "_lrot", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Quat;
        }
    }), _descriptor3$5 = _applyDecoratedDescriptor(_class2$c.prototype, "_lscale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(1, 1, 1);
        }
    }), _descriptor4$3 = _applyDecoratedDescriptor(_class2$c.prototype, "_layer", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Layers.Enum.DEFAULT;
        }
    }), _descriptor5$3 = _applyDecoratedDescriptor(_class2$c.prototype, "_euler", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3;
        }
    }), _applyDecoratedDescriptor(_class2$c.prototype, "eulerAngles", [ _dec2$7 ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "eulerAngles"), _class2$c.prototype), 
    _applyDecoratedDescriptor(_class2$c.prototype, "layer", [ property ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "layer"), _class2$c.prototype), 
    _class$f = _class2$c)) || _class$f);
    function isPropertyPath(path) {
        return "string" == typeof path || "number" == typeof path;
    }
    function isCustomPath(path, constructor) {
        return path instanceof constructor;
    }
    cc.Node = Node$1;
    var HierarchyPath = ccclass("cc.animation.HierarchyPath")((_descriptor$b = _applyDecoratedDescriptor((_class2$d = function() {
        function HierarchyPath(path) {
            _classCallCheck(this, HierarchyPath), _initializerDefineProperty(this, "path", _descriptor$b, this), 
            this.path = path || "";
        }
        return _createClass(HierarchyPath, [ {
            key: "get",
            value: function get(target) {
                if (!(target instanceof Node$1)) throw new Error("Target of hierachy path shall be Node.");
                var result = target.getChildByPath(this.path);
                if (!result) throw new Error('Node "'.concat(target.name, '" has no path "').concat(this.path, '"'));
                return result;
            }
        } ]), HierarchyPath;
    }()).prototype, "path", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _class$g = _class2$d)) || _class$g, ComponentPath = ccclass("cc.animation.ComponentPath")((_descriptor2$7 = _applyDecoratedDescriptor((_class5 = function() {
        function ComponentPath(component) {
            _classCallCheck(this, ComponentPath), _initializerDefineProperty(this, "component", _descriptor2$7, this), 
            this.component = component || "";
        }
        return _createClass(ComponentPath, [ {
            key: "get",
            value: function get(target) {
                if (!(target instanceof Node$1)) throw new Error("Target of component path shall be Node.");
                var result = target.getComponent(this.component);
                if (!result) throw new Error('Node "'.concat(target.name, '" has no component "').concat(this.component, '"'));
                return result;
            }
        } ]), ComponentPath;
    }()).prototype, "component", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _class4 = _class5)) || _class4, SkelAnimDataHub = function() {
        function SkelAnimDataHub() {
            _classCallCheck(this, SkelAnimDataHub);
        }
        return _createClass(SkelAnimDataHub, null, [ {
            key: "getOrExtract",
            value: function getOrExtract(clip) {
                var data = SkelAnimDataHub.pool.get(clip);
                return data && data.info.sample === clip.sample || (data && cc.director.root.dataPoolManager.releaseAnimationClip(clip), 
                data = function convertToSkeletalCurves(clip) {
                    var data = {};
                    clip.curves.forEach((function(curve) {
                        if (!curve.valueAdapter && isCustomPath(curve.modifiers[0], HierarchyPath) && isPropertyPath(curve.modifiers[1])) {
                            var path = curve.modifiers[0].path, cs = data[path];
                            cs || (cs = data[path] = {}), cs[curve.modifiers[1]] = {
                                values: curve.data.values,
                                keys: curve.data.keys
                            };
                        }
                    }));
                    for (var frames = Math.ceil(clip.sample * clip.duration) + 1, _loop = function _loop() {
                        var path = _Object$keys[_i], props = data[path];
                        if (!props) return "continue";
                        Object.defineProperty(props, "worldMatrix", {
                            get: function get() {
                                if (!props._worldMatrix) {
                                    var position = props.position, rotation = props.rotation, scale = props.scale;
                                    convertToUniformSample(clip, position, frames), convertToUniformSample(clip, rotation, frames), 
                                    convertToUniformSample(clip, scale, frames), function convertToWorldSpace(convertedProps, path, props) {
                                        var oPos = props.position.values, oRot = props.rotation.values, oScale = props.scale.values, matrix = oPos.map((function() {
                                            return new Mat4;
                                        })), idx = path.lastIndexOf("/"), pMatrix = null;
                                        if (idx > 0) {
                                            var name = path.substring(0, idx), data = convertedProps[name];
                                            if (!data) return void console.warn("no data for parent bone?");
                                            pMatrix = data.worldMatrix.values;
                                        }
                                        for (var i = 0; i < oPos.length; i++) {
                                            var oT = oPos[i], oR = oRot[i], oS = oScale[i], m = matrix[i];
                                            Mat4.fromRTS(m, oR, oT, oS), pMatrix && Mat4.multiply(m, pMatrix[i], m);
                                        }
                                        Object.keys(props).forEach((function(k) {
                                            return delete props[k];
                                        })), props._worldMatrix = {
                                            keys: 0,
                                            interpolate: !1,
                                            values: matrix
                                        };
                                    }(data, path, props);
                                }
                                return props._worldMatrix;
                            }
                        });
                    }, _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) _loop();
                    return {
                        info: {
                            frames: frames,
                            sample: clip.sample
                        },
                        data: data
                    };
                }(clip), SkelAnimDataHub.pool.set(clip, data)), data;
            }
        }, {
            key: "destroy",
            value: function destroy(clip) {
                SkelAnimDataHub.pool.delete(clip);
            }
        } ]), SkelAnimDataHub;
    }();
    function convertToUniformSample(clip, curve, frames) {
        var keys = clip.keys[curve.keys], values = [];
        if (keys && 1 !== keys.length) for (var _i2 = 0, idx = 0; _i2 < frames; _i2++) {
            for (var time = _i2 / clip.sample; keys[idx] <= time; ) idx++;
            idx > keys.length - 1 ? time = keys[idx = keys.length - 1] : 0 === idx && (idx = 1);
            var from = curve.values[idx - 1].clone();
            from.lerp(curve.values[idx], clamp01((time - keys[idx - 1]) / (keys[idx] - keys[idx - 1]))), 
            values[_i2] = from;
        } else for (var i = 0; i < frames; i++) values[i] = curve.values[0].clone();
        curve.values = values;
    }
    function nearestPOT(num) {
        return --num, num |= num >> 16, num |= num >> 8, num |= num >> 4, num |= num >> 2, 
        num |= num >> 1, ++num;
    }
    SkelAnimDataHub.pool = new Map;
    var _jointsFormat2, JointsMediumType, TextureBufferPool = function() {
        function TextureBufferPool(device) {
            _classCallCheck(this, TextureBufferPool), this._format = exports.GFXFormat.UNKNOWN, 
            this._formatSize = 0, this._chunks = [], this._chunkCount = 0, this._handles = [], 
            this._region0 = new GFXBufferTextureCopy, this._region1 = new GFXBufferTextureCopy, 
            this._region2 = new GFXBufferTextureCopy, this._roundUpFn = null, this._bufferViewCtor = Uint8Array, 
            this._channels = 4, this._inOrderFree = !1, this._device = device;
        }
        return _createClass(TextureBufferPool, [ {
            key: "initialize",
            value: function initialize(info) {
                var formatInfo = GFXFormatInfos[info.format];
                return this._format = info.format, this._formatSize = formatInfo.size, this._channels = formatInfo.count, 
                this._bufferViewCtor = formatInfo.type === exports.GFXFormatType.FLOAT ? Float32Array : Uint8Array, 
                this._chunks = new Array(info.maxChunks), this._roundUpFn = info.roundUpFn || null, 
                this._inOrderFree = info.inOrderFree || !1, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                for (var i = 0; i < this._chunkCount; ++i) {
                    var chunk = this._chunks[i];
                    chunk.texView.destroy(), chunk.texture.destroy();
                }
                this._chunks.splice(0), this._handles.splice(0);
            }
        }, {
            key: "alloc",
            value: function alloc(size) {
                var _this = this;
                if (0 === size) return null;
                for (var _loop = function _loop(i) {
                    var chunk = _this._chunks[i], isFound = !1, start = chunk.start;
                    if (start + size <= chunk.end) isFound = !0; else if (_this._inOrderFree) start > chunk.end ? start + size <= chunk.size ? isFound = !0 : size <= chunk.end && (chunk.start = start = 0, 
                    isFound = !0) : start === chunk.end && (chunk.start = start = 0, chunk.end = chunk.size, 
                    size <= chunk.end && (isFound = !0)); else {
                        start = 0;
                        for (var handles = _this._handles.filter((function(h) {
                            return h.chunkIdx === i;
                        })).sort((function(a, b) {
                            return a.start - b.start;
                        })), j = 0; j < handles.length; j++) {
                            var handle = handles[j];
                            if (start + size <= handle.start) {
                                isFound = !0;
                                break;
                            }
                            start = handle.end;
                        }
                        !isFound && start + size <= chunk.size && (isFound = !0);
                    }
                    if (isFound) {
                        chunk.start += size;
                        var _handle = {
                            chunkIdx: i,
                            start: start,
                            end: start + size,
                            texture: chunk.texture,
                            texView: chunk.texView
                        };
                        return _this._handles.push(_handle), {
                            v: _handle
                        };
                    }
                }, i = 0; i < this._chunkCount; ++i) {
                    var _ret = _loop(i);
                    if ("object" === _typeof(_ret)) return _ret.v;
                }
                if (this._chunkCount >= this._chunks.length) return console.error("TextureBufferPool: Reach max chunk count."), 
                null;
                var targetSize = Math.sqrt(size / this._formatSize), texWidth = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize)), texSize = texWidth * texWidth * this._formatSize;
                console.info("TextureBufferPool: Allocate chunk " + this._chunkCount + ", size: " + texSize + ", format: " + this._format);
                var texture = this._device.createTexture({
                    type: exports.GFXTextureType.TEX2D,
                    usage: exports.GFXTextureUsageBit.SAMPLED,
                    format: this._format,
                    width: texWidth,
                    height: texWidth,
                    mipLevel: 1
                }), texView = this._device.createTextureView({
                    texture: texture,
                    type: exports.GFXTextureViewType.TV2D,
                    format: this._format
                }), texHandle = {
                    chunkIdx: this._chunkCount,
                    start: 0,
                    end: size,
                    texture: texture,
                    texView: texView
                };
                return this._handles.push(texHandle), this._chunks[this._chunkCount++] = {
                    texture: texture,
                    texView: texView,
                    size: texSize,
                    start: size,
                    end: texSize
                }, texHandle;
            }
        }, {
            key: "free",
            value: function free(handle) {
                for (var i = 0; i < this._handles.length; ++i) if (this._handles[i] === handle) return this._chunks[handle.chunkIdx].end = handle.end, 
                void this._handles.splice(i, 1);
            }
        }, {
            key: "update",
            value: function update(handle, buffer) {
                var buffers = [], regions = [], start = handle.start / this._formatSize, remainSize = buffer.byteLength / this._formatSize, offsetX = start % handle.texture.width, offsetY = Math.floor(start / handle.texture.width), copySize = Math.min(handle.texture.width - offsetX, remainSize), begin = 0;
                offsetX > 0 && (this._region0.texOffset.x = offsetX, this._region0.texOffset.y = offsetY, 
                this._region0.texExtent.width = copySize, this._region0.texExtent.height = 1, buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels)), 
                regions.push(this._region0), offsetX = 0, offsetY += 1, remainSize -= copySize, 
                begin += copySize), remainSize > 0 && (this._region1.texOffset.x = offsetX, this._region1.texOffset.y = offsetY, 
                remainSize > handle.texture.width ? (this._region1.texExtent.width = handle.texture.width, 
                this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width), 
                copySize = this._region1.texExtent.width * this._region1.texExtent.height) : (copySize = remainSize, 
                this._region1.texExtent.width = copySize, this._region1.texExtent.height = 1), buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels)), 
                regions.push(this._region1), offsetX = 0, offsetY += this._region1.texExtent.height, 
                remainSize -= copySize, begin += copySize), remainSize > 0 && (this._region2.texOffset.x = offsetX, 
                this._region2.texOffset.y = offsetY, this._region2.texExtent.width = remainSize, 
                this._region2.texExtent.height = 1, buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, remainSize * this._channels)), 
                regions.push(this._region2)), this._device.copyBuffersToTexture(buffers, handle.texture, regions);
            }
        } ]), TextureBufferPool;
    }(), uploadJointData = function uploadJointDataLBS(out, base, mat, firstBone) {
        out[base + 0] = makeStable(mat.m00), out[base + 1] = makeStable(mat.m01), out[base + 2] = makeStable(mat.m02), 
        out[base + 3] = makeStable(mat.m12), out[base + 4] = makeStable(mat.m04), out[base + 5] = makeStable(mat.m05), 
        out[base + 6] = makeStable(mat.m06), out[base + 7] = makeStable(mat.m13), out[base + 8] = makeStable(mat.m08), 
        out[base + 9] = makeStable(mat.m09), out[base + 10] = makeStable(mat.m10), out[base + 11] = makeStable(mat.m14);
    };
    function selectJointsMediumType(device) {
        return device.hasFeature(exports.GFXFeature.TEXTURE_FLOAT) ? JointsMediumType.RGBA32F : JointsMediumType.RGBA8;
    }
    !function(JointsMediumType) {
        JointsMediumType[JointsMediumType.NONE = 0] = "NONE", JointsMediumType[JointsMediumType.RGBA8 = 1] = "RGBA8", 
        JointsMediumType[JointsMediumType.RGBA32F = 2] = "RGBA32F";
    }(JointsMediumType || (JointsMediumType = {}));
    var m4_1$2 = new Mat4;
    new Quat, new Quat, new Vec3, new Quat, new Vec3;
    function makeStable(n) {
        return n || 0;
    }
    function roundUpTextureSize(targetLength, formatSize) {
        var formatScale = 4 / Math.sqrt(formatSize);
        return 12 * Math.ceil(Math.max(480 * formatScale, targetLength) / 12);
    }
    var _typeMap2, _jointsFormat = (_defineProperty(_jointsFormat2 = {}, JointsMediumType.RGBA8, exports.GFXFormat.RGBA8), 
    _defineProperty(_jointsFormat2, JointsMediumType.RGBA32F, exports.GFXFormat.RGBA32F), 
    _jointsFormat2), jointsTextureSamplerHash = genSamplerHash([ exports.GFXFilter.POINT, exports.GFXFilter.POINT, exports.GFXFilter.NONE, exports.GFXAddress.CLAMP, exports.GFXAddress.CLAMP, exports.GFXAddress.CLAMP ]), JointsTexturePool = function() {
        function JointsTexturePool(device) {
            var maxChunks = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 8;
            _classCallCheck(this, JointsTexturePool), this._textureBuffers = new Map, this._maxIdentityJoints = 64, 
            this._formatSize = 0, this._device = device, this._pool = new TextureBufferPool(device);
            var format = _jointsFormat[selectJointsMediumType(this._device)];
            this._formatSize = GFXFormatInfos[format].size;
            var scale = 16 / this._formatSize;
            this._pool.initialize({
                format: format,
                maxChunks: maxChunks * scale,
                roundUpFn: roundUpTextureSize
            }), this._identityBuffer = this._allocIdentityBuffer();
        }
        return _createClass(JointsTexturePool, [ {
            key: "clear",
            value: function clear() {
                this._pool.destroy(), this._textureBuffers.clear(), this._identityBuffer = null;
            }
        }, {
            key: "getDefaultJointsTexture",
            value: function getDefaultJointsTexture(skeleton) {
                var len = skeleton && skeleton.joints.length || 1;
                return len > this._maxIdentityJoints && (this._identityBuffer && (this._identityBuffer.readyToBeDeleted = !0, 
                this.releaseHandle(this._identityBuffer, !1)), this._maxIdentityJoints = nearestPOT(len), 
                this._identityBuffer = this._allocIdentityBuffer()), this._identityBuffer ? (this._identityBuffer.refCount++, 
                this._identityBuffer) : null;
            }
        }, {
            key: "getJointsTextureWithAnimation",
            value: function getJointsTextureWithAnimation(skeleton, clip) {
                var hash = skeleton.hash ^ clip.hash, texture = this._textureBuffers.get(hash) || null;
                if (texture) return texture.refCount++, texture;
                var clipData = SkelAnimDataHub.getOrExtract(clip), frames = clipData.info.frames, bufSize = 12 * skeleton.joints.length * frames, handle = this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);
                if (!handle) return null;
                texture = {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 1,
                    skeletonHash: skeleton.hash,
                    clipHash: clip.hash,
                    readyToBeDeleted: !1,
                    handle: handle
                };
                for (var textureBuffer = new Float32Array(bufSize), i = 0; i < skeleton.joints.length; i++) {
                    var nodeData = clipData.data[skeleton.joints[i]];
                    if (nodeData) for (var bindpose = skeleton.bindposes[i], matrix = nodeData.worldMatrix.values, frame = 0; frame < frames; frame++) {
                        var m = matrix[frame];
                        Mat4.multiply(m4_1$2, m, bindpose), uploadJointData(textureBuffer, 12 * (frames * i + frame), m4_1$2);
                    }
                }
                return this._pool.update(handle, textureBuffer.buffer), this._textureBuffers.set(hash, texture), 
                texture;
            }
        }, {
            key: "releaseHandle",
            value: function releaseHandle(handle) {
                var decr = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                decr && handle.refCount > 0 && handle.refCount--, !handle.refCount && handle.readyToBeDeleted && (this._pool.free(handle.handle), 
                this._textureBuffers.delete(handle.skeletonHash ^ handle.clipHash));
            }
        }, {
            key: "releaseSkeleton",
            value: function releaseSkeleton(skeleton) {
                for (var it = this._textureBuffers.values(), res = it.next(); !res.done; ) res.value.skeletonHash === skeleton.hash && (res.value.readyToBeDeleted = !0, 
                this.releaseHandle(res.value, !1), this._textureBuffers.delete(res.value.skeletonHash ^ res.value.clipHash)), 
                res = it.next();
            }
        }, {
            key: "releaseAnimationClip",
            value: function releaseAnimationClip(clip) {
                for (var it = this._textureBuffers.values(), res = it.next(); !res.done; ) res.value.clipHash === clip.hash && (res.value.readyToBeDeleted = !0, 
                this.releaseHandle(res.value, !1), this._textureBuffers.delete(res.value.skeletonHash ^ res.value.clipHash)), 
                res = it.next();
            }
        }, {
            key: "_allocIdentityBuffer",
            value: function _allocIdentityBuffer() {
                var len = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._maxIdentityJoints, handle = this._pool.alloc(12 * len * Float32Array.BYTES_PER_ELEMENT);
                if (!handle) return null;
                for (var textureBuffer = new Float32Array(12 * len), i = 0; i < len; i++) uploadJointData(textureBuffer, 12 * i, Mat4.IDENTITY);
                return this._pool.update(handle, textureBuffer.buffer), {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 0,
                    skeletonHash: len,
                    clipHash: 0,
                    readyToBeDeleted: !1,
                    handle: handle
                };
            }
        } ]), JointsTexturePool;
    }(), JointsAnimationInfo = function() {
        function JointsAnimationInfo(device) {
            _classCallCheck(this, JointsAnimationInfo), this._pool = new Map, this._device = device;
        }
        return _createClass(JointsAnimationInfo, [ {
            key: "create",
            value: function create(nodeID) {
                var res = this._pool.get(nodeID);
                if (res) return res;
                var buffer = this._device.createBuffer({
                    usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: UBOSkinningAnimation.SIZE,
                    stride: UBOSkinningAnimation.SIZE
                }), data = new Float32Array([ 1, 0, 0, 0 ]);
                buffer.update(data);
                var info = {
                    buffer: buffer,
                    data: data,
                    dirty: !1
                };
                return this._pool.set(nodeID, info), info;
            }
        }, {
            key: "destroy",
            value: function destroy(nodeID) {
                var info = this._pool.get(nodeID);
                info && (info.buffer.destroy(), this._pool.delete(nodeID));
            }
        }, {
            key: "get",
            value: function get() {
                var nodeID = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "-1";
                return this._pool.get(nodeID) || this.create("-1");
            }
        }, {
            key: "switchClip",
            value: function switchClip(info, clip) {
                return info.data[0] = clip ? SkelAnimDataHub.getOrExtract(clip).info.frames : 1, 
                info.data[1] = 0, info.buffer.update(info.data), info.dirty = !1, info;
            }
        }, {
            key: "clear",
            value: function clear() {
                var _iterator = this._pool.values(), _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.buffer.destroy();
                }
                this._pool.clear();
            }
        } ]), JointsAnimationInfo;
    }(), v3_3 = new Vec3, v3_4 = new Vec3, ab_1 = new aabb, AnimatedBoundsInfo = function() {
        function AnimatedBoundsInfo() {
            _classCallCheck(this, AnimatedBoundsInfo), this._perJointBoundsPool = new Map, this._fullClipBoundsPool = new Map;
        }
        return _createClass(AnimatedBoundsInfo, [ {
            key: "get",
            value: function get(mesh, skeleton, clip) {
                var list = this._getFullClipBounds(mesh, skeleton, clip) || [];
                if (list.length) return list;
                var perJointBounds = this._getPerJointBounds(mesh, skeleton);
                perJointBounds || (perJointBounds = this.getBoneSpacePerJointBounds(mesh, skeleton), 
                this._setPerJointBounds(mesh, skeleton, perJointBounds));
                for (var clipData = SkelAnimDataHub.getOrExtract(clip), frames = clipData.info.frames, fid = 0; fid < frames; fid++) list.push(new aabb(1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0));
                for (var joints = skeleton.joints, i = 0; i < joints.length; i++) {
                    var nodeData = clipData.data[joints[i]], bound = perJointBounds[i];
                    if (bound && nodeData) for (var matrix = nodeData.worldMatrix.values, _fid = 0; _fid < frames; _fid++) {
                        var m = matrix[_fid], info = list[_fid];
                        aabb.transform(ab_1, bound, m), ab_1.getBoundary(v3_3, v3_4), Vec3.min(info.center, info.center, v3_3), 
                        Vec3.max(info.halfExtents, info.halfExtents, v3_4);
                    }
                }
                for (var _fid2 = 0; _fid2 < frames; _fid2++) {
                    var _list$_fid = list[_fid2], center = _list$_fid.center, halfExtents = _list$_fid.halfExtents;
                    aabb.fromPoints(list[_fid2], center, halfExtents);
                }
                return this._setFullClipBounds(mesh, skeleton, clip, list), list;
            }
        }, {
            key: "getBoneSpacePerJointBounds",
            value: function getBoneSpacePerJointBounds(mesh, skeleton) {
                for (var bounds = [], valid = [], bindposes = skeleton.bindposes, i = 0; i < bindposes.length; i++) bounds.push(new aabb(1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0)), 
                valid.push(!1);
                for (var p = 0; p < mesh.struct.primitives.length; p++) {
                    var joints = mesh.readAttribute(p, exports.GFXAttributeName.ATTR_JOINTS), weights = mesh.readAttribute(p, exports.GFXAttributeName.ATTR_WEIGHTS), positions = mesh.readAttribute(p, exports.GFXAttributeName.ATTR_POSITION);
                    if (joints && weights && positions) for (var vertCount = Math.min(joints.length / 4, weights.length / 4, positions.length / 3), _i2 = 0; _i2 < vertCount; _i2++) {
                        Vec3.set(v3_3, positions[3 * _i2 + 0], positions[3 * _i2 + 1], positions[3 * _i2 + 2]);
                        for (var j = 0; j < 4; ++j) {
                            var idx = 4 * _i2 + j, joint = joints[idx];
                            if (!(0 === weights[idx] || joint >= bindposes.length)) {
                                Vec3.transformMat4(v3_4, v3_3, bindposes[joint]), valid[joint] = !0;
                                var b = bounds[joint];
                                Vec3.min(b.center, b.center, v3_4), Vec3.max(b.halfExtents, b.halfExtents, v3_4);
                            }
                        }
                    }
                }
                for (var _i3 = 0; _i3 < bindposes.length; _i3++) {
                    var _b = bounds[_i3];
                    valid[_i3] ? aabb.fromPoints(_b, _b.center, _b.halfExtents) : bounds[_i3] = null;
                }
                return bounds;
            }
        }, {
            key: "clear",
            value: function clear() {
                this._perJointBoundsPool.clear(), this._fullClipBoundsPool.clear();
            }
        }, {
            key: "releaseMesh",
            value: function releaseMesh(mesh) {
                this._perJointBoundsPool.delete(mesh.hash), this._fullClipBoundsPool.delete(mesh.hash);
            }
        }, {
            key: "releaseSkeleton",
            value: function releaseSkeleton(skeleton) {
                for (var it1 = this._perJointBoundsPool.values(), res1 = it1.next(); !res1.done; ) res1.value.delete(skeleton.hash), 
                res1 = it1.next();
                for (var it2 = this._fullClipBoundsPool.values(), res2 = it2.next(); !res2.done; ) res2.value.delete(skeleton.hash), 
                res2 = it2.next();
            }
        }, {
            key: "releaseAnimationClip",
            value: function releaseAnimationClip(clip) {
                for (var it = this._fullClipBoundsPool.values(), res = it.next(); !res.done; ) {
                    for (var it2 = res.value.values(), res2 = it2.next(); !res2.done; ) res2.value.delete(clip.hash), 
                    res2 = it2.next();
                    res = it.next();
                }
            }
        }, {
            key: "_getPerJointBounds",
            value: function _getPerJointBounds(mesh, skeleton) {
                var m = this._perJointBoundsPool.get(mesh.hash);
                return m && m.get(skeleton.hash);
            }
        }, {
            key: "_getFullClipBounds",
            value: function _getFullClipBounds(mesh, skeleton, clip) {
                var m = this._fullClipBoundsPool.get(mesh.hash), s = m && m.get(skeleton.hash);
                return s && s.get(clip.hash);
            }
        }, {
            key: "_setPerJointBounds",
            value: function _setPerJointBounds(mesh, skeleton, bounds) {
                var m = this._perJointBoundsPool.get(mesh.hash);
                m || (m = new Map, this._perJointBoundsPool.set(mesh.hash, m)), m.set(skeleton.hash, bounds);
            }
        }, {
            key: "_setFullClipBounds",
            value: function _setFullClipBounds(mesh, skeleton, clip, bounds) {
                var m = this._fullClipBoundsPool.get(mesh.hash);
                m || (m = new Map, this._fullClipBoundsPool.set(mesh.hash, m));
                var s = m.get(skeleton.hash);
                s || (s = new Map, m.set(skeleton.hash, s)), s.set(clip.hash, bounds);
            }
        } ]), AnimatedBoundsInfo;
    }(), effects = [ {
        name: "builtin-billboard",
        _uuid: "711ebe11-f673-4cd9-9a83-63c60ba54c5b",
        techniques: [ {
            name: "add",
            passes: [ {
                rasterizerState: {
                    cullMode: 0
                },
                blendState: {
                    targets: [ {
                        blend: !0,
                        blendSrc: 2,
                        blendDst: 1,
                        blendSrcAlpha: 2,
                        blendDstAlpha: 1
                    } ]
                },
                program: "builtin-billboard|vert:vs_main|tinted-fs:add",
                depthStencilState: {
                    depthTest: !0,
                    depthWrite: !1
                },
                properties: {
                    mainTexture: {
                        value: "grey",
                        type: 28
                    },
                    mainTiling_Offset: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    tintColor: {
                        value: [ .5, .5, .5, .5 ],
                        type: 16
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-billboard|vert:vs_main|tinted-fs:add",
            hash: 916813039,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nuniform builtin {\n  vec4 cc_size_rotation;\n};\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
            },
            builtins: {
                globals: {
                    blocks: [ {
                        name: "CCGlobal",
                        defines: []
                    } ],
                    samplers: []
                },
                locals: {
                    blocks: [ {
                        name: "CCLocal",
                        defines: []
                    } ],
                    samplers: []
                }
            },
            defines: [ {
                name: "CC_USE_HDR",
                type: "boolean"
            } ],
            blocks: [ {
                name: "Constants",
                defines: [],
                binding: 0,
                members: [ {
                    name: "mainTiling_Offset",
                    type: 16,
                    count: 1
                }, {
                    name: "frameTile_velLenScale",
                    type: 16,
                    count: 1
                }, {
                    name: "scale",
                    type: 16,
                    count: 1
                } ]
            }, {
                name: "builtin",
                defines: [],
                binding: 1,
                members: [ {
                    name: "cc_size_rotation",
                    type: 16,
                    count: 1
                } ]
            }, {
                name: "FragConstants",
                defines: [],
                binding: 2,
                members: [ {
                    name: "tintColor",
                    type: 16,
                    count: 1
                } ]
            } ],
            samplers: [ {
                name: "mainTexture",
                type: 28,
                count: 1,
                defines: [],
                binding: 30
            } ]
        } ]
    }, {
        name: "builtin-particle-trail",
        _uuid: "17debcc3-0a6b-4b8a-b00b-dc58b885581e",
        techniques: [ {
            name: "add",
            passes: [ {
                rasterizerState: {
                    cullMode: 0
                },
                blendState: {
                    targets: [ {
                        blend: !0,
                        blendSrc: 2,
                        blendDst: 1,
                        blendSrcAlpha: 2,
                        blendDstAlpha: 1
                    } ]
                },
                program: "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
                depthStencilState: {
                    depthTest: !0,
                    depthWrite: !1
                },
                properties: {
                    mainTexture: {
                        value: "grey",
                        type: 28
                    },
                    mainTiling_Offset: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    frameTile_velLenScale: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    tintColor: {
                        value: [ .5, .5, .5, .5 ],
                        type: 16
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
            hash: 516627142,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                frag: "\n  precision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n  in vec2 uv;\n  in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    in vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  varying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                frag: "\n  precision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n  varying vec2 uv;\n  varying vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    varying vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  uniform vec4 tintColor;\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nvoid main() { gl_FragColor = add(); }"
            },
            builtins: {
                globals: {
                    blocks: [ {
                        name: "CCGlobal",
                        defines: []
                    } ],
                    samplers: []
                },
                locals: {
                    blocks: [ {
                        name: "CCLocal",
                        defines: []
                    } ],
                    samplers: []
                }
            },
            defines: [ {
                name: "CC_RENDER_MODE",
                type: "number",
                range: [ 0, 4 ]
            }, {
                name: "CC_DRAW_WIRE_FRAME",
                type: "boolean"
            }, {
                name: "CC_USE_WORLD_SPACE",
                type: "boolean"
            }, {
                name: "CC_USE_HDR",
                type: "boolean"
            } ],
            blocks: [ {
                name: "Constants",
                defines: [],
                binding: 0,
                members: [ {
                    name: "mainTiling_Offset",
                    type: 16,
                    count: 1
                }, {
                    name: "frameTile_velLenScale",
                    type: 16,
                    count: 1
                }, {
                    name: "scale",
                    type: 16,
                    count: 1
                } ]
            }, {
                name: "FragConstants",
                defines: [],
                binding: 1,
                members: [ {
                    name: "tintColor",
                    type: 16,
                    count: 1
                } ]
            } ],
            samplers: [ {
                name: "mainTexture",
                type: 28,
                count: 1,
                defines: [],
                binding: 30
            } ]
        } ]
    }, {
        name: "builtin-particle",
        _uuid: "d1346436-ac96-4271-b863-1f4fdead95b0",
        techniques: [ {
            name: "add",
            passes: [ {
                rasterizerState: {
                    cullMode: 0
                },
                blendState: {
                    targets: [ {
                        blend: !0,
                        blendSrc: 2,
                        blendDst: 1,
                        blendSrcAlpha: 2,
                        blendDstAlpha: 1
                    } ]
                },
                program: "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                depthStencilState: {
                    depthTest: !0,
                    depthWrite: !1
                },
                properties: {
                    mainTexture: {
                        value: "grey",
                        type: 28
                    },
                    mainTiling_Offset: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    tintColor: {
                        value: [ .5, .5, .5, .5 ],
                        type: 16
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
            hash: 317180679,
            glsl3: {
                vert: "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
                frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            },
            glsl1: {
                vert: "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
                frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
            },
            builtins: {
                globals: {
                    blocks: [ {
                        name: "CCGlobal",
                        defines: []
                    } ],
                    samplers: []
                },
                locals: {
                    blocks: [ {
                        name: "CCLocal",
                        defines: []
                    } ],
                    samplers: []
                }
            },
            defines: [ {
                name: "CC_RENDER_MODE",
                type: "number",
                range: [ 0, 4 ]
            }, {
                name: "CC_USE_WORLD_SPACE",
                type: "boolean"
            }, {
                name: "CC_USE_HDR",
                type: "boolean"
            } ],
            blocks: [ {
                name: "Constants",
                defines: [],
                binding: 0,
                members: [ {
                    name: "mainTiling_Offset",
                    type: 16,
                    count: 1
                }, {
                    name: "frameTile_velLenScale",
                    type: 16,
                    count: 1
                }, {
                    name: "scale",
                    type: 16,
                    count: 1
                } ]
            }, {
                name: "FragConstants",
                defines: [],
                binding: 1,
                members: [ {
                    name: "tintColor",
                    type: 16,
                    count: 1
                } ]
            } ],
            samplers: [ {
                name: "mainTexture",
                type: 28,
                count: 1,
                defines: [],
                binding: 30
            } ]
        } ]
    }, {
        name: "builtin-sprite",
        _uuid: "60f7195c-ec2a-45eb-ba94-8955f60e81d0",
        techniques: [ {
            passes: [ {
                blendState: {
                    targets: [ {
                        blend: !0,
                        blendSrc: 2,
                        blendDst: 4,
                        blendDstAlpha: 4
                    } ]
                },
                rasterizerState: {
                    cullMode: 0
                },
                program: "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
                priority: 244,
                depthStencilState: {
                    depthTest: !1,
                    depthWrite: !1
                },
                properties: {
                    mainTexture: {
                        value: "white",
                        type: 28
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
            hash: 543960898,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_LOCAL\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\n#endif\nin vec3 a_position;\nin vec4 a_color;\nout vec4 color;\nin vec2 a_texCoord;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nin vec4 color;\n#if USE_TEXTURE\n  in vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture(mainTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 color;\nattribute vec2 a_texCoord;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nvarying vec4 color;\n#if USE_TEXTURE\n  varying vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }"
            },
            builtins: {
                globals: {
                    blocks: [ {
                        name: "CCGlobal",
                        defines: []
                    } ],
                    samplers: []
                },
                locals: {
                    blocks: [ {
                        name: "CCLocal",
                        defines: [ "USE_LOCAL" ]
                    } ],
                    samplers: []
                }
            },
            defines: [ {
                name: "USE_LOCAL",
                type: "boolean"
            }, {
                name: "USE_TEXTURE",
                type: "boolean"
            }, {
                name: "IS_GRAY",
                type: "boolean"
            } ],
            blocks: [],
            samplers: [ {
                name: "mainTexture",
                type: 28,
                count: 1,
                defines: [ "USE_TEXTURE" ],
                binding: 30
            } ]
        } ]
    }, {
        name: "builtin-standard",
        _uuid: "1baf0fc9-befa-459c-8bdd-af1a450a0319",
        techniques: [ {
            name: "opaque",
            passes: [ {
                program: "builtin-standard|standard-vs:vert|standard-fs:frag",
                properties: {
                    tilingOffset: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    mainColor: {
                        value: [ 1, 1, 1, 1 ],
                        type: 16,
                        handleInfo: [ "albedo", 0, 16 ]
                    },
                    albedoScale: {
                        value: [ 1, 1, 1 ],
                        type: 15,
                        handleInfo: [ "albedoScaleAndCutoff", 0, 15 ]
                    },
                    alphaThreshold: {
                        value: [ .5 ],
                        type: 13,
                        handleInfo: [ "albedoScaleAndCutoff", 3, 13 ]
                    },
                    occlusion: {
                        value: [ 1 ],
                        type: 13,
                        handleInfo: [ "pbrParams", 0, 13 ]
                    },
                    roughness: {
                        value: [ .8 ],
                        type: 13,
                        handleInfo: [ "pbrParams", 1, 13 ]
                    },
                    metallic: {
                        value: [ .6 ],
                        type: 13,
                        handleInfo: [ "pbrParams", 2, 13 ]
                    },
                    normalStrenth: {
                        value: [ 1 ],
                        type: 13,
                        handleInfo: [ "pbrParams", 3, 13 ]
                    },
                    emissive: {
                        value: [ 0, 0, 0, 1 ],
                        type: 16
                    },
                    emissiveScale: {
                        value: [ 1, 1, 1 ],
                        type: 15,
                        handleInfo: [ "emissiveScaleParam", 0, 15 ]
                    },
                    mainTexture: {
                        value: "grey",
                        type: 28,
                        handleInfo: [ "albedoMap", 0, 28 ]
                    },
                    normalMap: {
                        value: "normal",
                        type: 28
                    },
                    pbrMap: {
                        value: "grey",
                        type: 28
                    },
                    metallicRoughnessMap: {
                        value: "grey",
                        type: 28
                    },
                    occlusionMap: {
                        value: "white",
                        type: 28
                    },
                    emissiveMap: {
                        value: "grey",
                        type: 28
                    },
                    albedo: {
                        type: 16,
                        value: [ 1, 1, 1, 1 ]
                    },
                    albedoScaleAndCutoff: {
                        type: 16,
                        value: [ 1, 1, 1, .5 ]
                    },
                    pbrParams: {
                        type: 16,
                        value: [ 1, .8, .6, 1 ]
                    },
                    emissiveScaleParam: {
                        type: 16,
                        value: [ 1, 1, 1, 0 ]
                    },
                    albedoMap: {
                        type: 28,
                        value: "grey"
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-standard|standard-vs:vert|standard-fs:frag",
            hash: 3845416769,
            glsl3: {
                vert: "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_BATCHING\n  in float a_dyn_batch_id;\n  uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_tangent;\n#if USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\nuniform CCSkinningTexture {\n  highp vec4 cc_jointsTextureInfo;\n};\nuniform CCSkinningAnimation {\n  highp vec4 cc_jointsAnimInfo;\n};\nuniform sampler2D cc_jointsTexture;\n#if USE_SKINNING == 1\n  highp float decode32 (highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if USE_SKINNING == 1\n  mat4 getJointMatrix (float i) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    vec4 v2 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    vec4 v3 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 10.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 11.5) * invSize, y)))\n    );\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#elif USE_SKINNING == 2\n  mat4 getJointMatrix (float i) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    vec4 v2 = texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    vec4 v3 = texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y));\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n    + getJointMatrix(a_joints.y) * a_weights.y;\n    + getJointMatrix(a_joints.z) * a_weights.z;\n    + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\n#if USE_VERTEX_COLOR\n  in vec3 a_color;\n  out vec3 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\nin vec2 a_texCoord;\nout vec2 v_uv;\nin vec2 a_texCoord1;\nout vec2 v_uv1;\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id + 0.5)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform CCForwardLight {\n  highp vec4 cc_sphereLitPos[2];\n  vec4 cc_sphereLitSizeRange[2];\n  vec4 cc_sphereLitColor[2];\n  highp vec4 cc_spotLitPos[2];\n  vec4 cc_spotLitSizeRangeAngle[2];\n  vec4 cc_spotLitDir[2];\n  vec4 cc_spotLitColor[2];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting (vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL + V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL + V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb) * cc_ambientSky.w;\n    #endif\n    finalColor += env * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.OCCLUSION_CHANNEL;\n    pbr.y *= res.ROUGHNESS_CHANNEL;\n    pbr.z *= res.METALLIC_CHANNEL;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);\n    pbr.z *= metallicRoughness.METALLIC_CHANNEL;\n    pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            },
            glsl1: {
                vert: "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec4 a_tangent;\n#if USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform highp vec4 cc_jointsTextureInfo;\nuniform highp vec4 cc_jointsAnimInfo;\nuniform sampler2D cc_jointsTexture;\n#if USE_SKINNING == 1\n  highp float decode32 (highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if USE_SKINNING == 1\n  mat4 getJointMatrix (float i) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    vec4 v2 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    vec4 v3 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 10.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 11.5) * invSize, y)))\n    );\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#elif USE_SKINNING == 2\n  mat4 getJointMatrix (float i) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    vec4 v2 = texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    vec4 v3 = texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y));\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n    + getJointMatrix(a_joints.y) * a_weights.y;\n    + getJointMatrix(a_joints.z) * a_weights.z;\n    + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform vec4 tilingOffset;\n#if USE_VERTEX_COLOR\n  attribute vec3 a_color;\n  varying vec3 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nattribute vec2 a_texCoord1;\nvarying vec2 v_uv1;\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id + 0.5)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\n  #ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n  #endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp vec4 cc_sphereLitPos[2];\nuniform vec4 cc_sphereLitSizeRange[2];\nuniform vec4 cc_sphereLitColor[2];\nuniform highp vec4 cc_spotLitPos[2];\nuniform vec4 cc_spotLitSizeRangeAngle[2];\nuniform vec4 cc_spotLitDir[2];\nuniform vec4 cc_spotLitColor[2];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting (vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL + V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL + V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb) * cc_ambientSky.w;\n    #endif\n    finalColor += env * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.OCCLUSION_CHANNEL;\n    pbr.y *= res.ROUGHNESS_CHANNEL;\n    pbr.z *= res.METALLIC_CHANNEL;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);\n    pbr.z *= metallicRoughness.METALLIC_CHANNEL;\n    pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"
            },
            builtins: {
                globals: {
                    blocks: [ {
                        name: "CCGlobal",
                        defines: []
                    } ],
                    samplers: [ {
                        name: "cc_environment",
                        defines: [ "CC_USE_IBL" ]
                    } ]
                },
                locals: {
                    blocks: [ {
                        name: "CCLocalBatched",
                        defines: [ "USE_BATCHING" ]
                    }, {
                        name: "CCLocal",
                        defines: []
                    }, {
                        name: "CCSkinningTexture",
                        defines: [ "USE_SKINNING" ]
                    }, {
                        name: "CCSkinningAnimation",
                        defines: [ "USE_SKINNING" ]
                    }, {
                        name: "CCForwardLight",
                        defines: []
                    } ],
                    samplers: [ {
                        name: "cc_jointsTexture",
                        defines: [ "USE_SKINNING" ]
                    } ]
                }
            },
            defines: [ {
                name: "USE_BATCHING",
                type: "boolean"
            }, {
                name: "USE_SKINNING",
                type: "boolean"
            }, {
                name: "USE_VERTEX_COLOR",
                type: "boolean"
            }, {
                name: "USE_NORMAL_MAP",
                type: "boolean"
            }, {
                name: "HAS_SECOND_UV",
                type: "boolean"
            }, {
                name: "CC_USE_IBL",
                type: "number",
                range: [ 0, 2 ]
            }, {
                name: "CC_USE_HDR",
                type: "boolean"
            }, {
                name: "USE_ALBEDO_MAP",
                type: "boolean"
            }, {
                name: "ALBEDO_UV",
                type: "string",
                options: [ "v_uv", "v_uv1" ]
            }, {
                name: "NORMAL_UV",
                type: "string",
                options: [ "v_uv", "v_uv1" ]
            }, {
                name: "USE_PBR_MAP",
                type: "boolean"
            }, {
                name: "PBR_UV",
                type: "string",
                options: [ "v_uv", "v_uv1" ]
            }, {
                name: "USE_METALLIC_ROUGHNESS_MAP",
                type: "boolean"
            }, {
                name: "METALLIC_ROUGHNESS_UV",
                type: "string",
                options: [ "v_uv", "v_uv1" ]
            }, {
                name: "USE_OCCLUSION_MAP",
                type: "boolean"
            }, {
                name: "OCCLUSION_UV",
                type: "string",
                options: [ "v_uv", "v_uv1" ]
            }, {
                name: "USE_EMISSIVE_MAP",
                type: "boolean"
            }, {
                name: "EMISSIVE_UV",
                type: "string",
                options: [ "v_uv", "v_uv1" ]
            }, {
                name: "OCCLUSION_CHANNEL",
                type: "string",
                options: [ "r", "g", "b" ]
            }, {
                name: "ROUGHNESS_CHANNEL",
                type: "string",
                options: [ "g", "b", "r" ]
            }, {
                name: "METALLIC_CHANNEL",
                type: "string",
                options: [ "b", "r", "g" ]
            }, {
                name: "USE_ALPHA_TEST",
                type: "boolean"
            }, {
                name: "ALPHA_TEST_CHANNEL",
                type: "string",
                options: [ "a", "r" ]
            } ],
            blocks: [ {
                name: "Constants",
                defines: [],
                binding: 0,
                members: [ {
                    name: "tilingOffset",
                    type: 16,
                    count: 1
                }, {
                    name: "albedo",
                    type: 16,
                    count: 1
                }, {
                    name: "albedoScaleAndCutoff",
                    type: 16,
                    count: 1
                }, {
                    name: "pbrParams",
                    type: 16,
                    count: 1
                }, {
                    name: "emissive",
                    type: 16,
                    count: 1
                }, {
                    name: "emissiveScaleParam",
                    type: 16,
                    count: 1
                } ]
            } ],
            samplers: [ {
                name: "albedoMap",
                type: 28,
                count: 1,
                defines: [ "USE_ALBEDO_MAP" ],
                binding: 30
            }, {
                name: "normalMap",
                type: 28,
                count: 1,
                defines: [ "USE_NORMAL_MAP" ],
                binding: 31
            }, {
                name: "pbrMap",
                type: 28,
                count: 1,
                defines: [ "USE_PBR_MAP" ],
                binding: 32
            }, {
                name: "metallicRoughnessMap",
                type: 28,
                count: 1,
                defines: [ "USE_METALLIC_ROUGHNESS_MAP" ],
                binding: 33
            }, {
                name: "occlusionMap",
                type: 28,
                count: 1,
                defines: [ "USE_OCCLUSION_MAP" ],
                binding: 34
            }, {
                name: "emissiveMap",
                type: 28,
                count: 1,
                defines: [ "USE_EMISSIVE_MAP" ],
                binding: 35
            } ]
        } ]
    }, {
        name: "builtin-terrain",
        _uuid: "1d08ef62-a503-4ce2-8b9a-46c90873f7d3",
        techniques: [ {
            name: "opaque",
            passes: [ {
                program: "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
                properties: {
                    UVScale: {
                        value: [ 1, 1, 1, 1 ],
                        type: 16
                    },
                    weightMap: {
                        value: "black",
                        type: 28
                    },
                    detailMap0: {
                        value: "grey",
                        type: 28
                    },
                    detailMap1: {
                        value: "grey",
                        type: 28
                    },
                    detailMap2: {
                        value: "grey",
                        type: 28
                    },
                    detailMap3: {
                        value: "grey",
                        type: 28
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
            hash: 1414533658,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout vec2 uvw;\nout vec2 uv0;\nout vec2 uv1;\nout vec2 uv2;\nout vec2 uv3;\nout vec3 diffuse;\nuniform TexCoords {\n  vec4 UVScale;\n};\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  pos = cc_matViewProj * pos;\n  uvw = a_texCoord;\n  uv0 = a_position.xz * UVScale.x;\n  uv1 = a_position.xz * UVScale.y;\n  uv2 = a_position.xz * UVScale.z;\n  uv3 = a_position.xz * UVScale.w;\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 N = a_normal;\n  float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  diffuse = ambDiff + vec3(dot(N, L));\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n  in vec2 uvw;\n  in vec2 uv0;\n  in vec2 uv1;\n  in vec2 uv2;\n  in vec2 uv3;\n  in vec3 diffuse;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n    color += texture(detailMap3, uv3) * w.a;\n  #else\n    color = texture(detailMap0, uv0);\n  #endif\n  color.rgb *= diffuse;\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying vec2 uvw;\nvarying vec2 uv0;\nvarying vec2 uv1;\nvarying vec2 uv2;\nvarying vec2 uv3;\nvarying vec3 diffuse;\nuniform vec4 UVScale;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  pos = cc_matViewProj * pos;\n  uvw = a_texCoord;\n  uv0 = a_position.xz * UVScale.x;\n  uv1 = a_position.xz * UVScale.y;\n  uv2 = a_position.xz * UVScale.z;\n  uv3 = a_position.xz * UVScale.w;\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 N = a_normal;\n  float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  diffuse = ambDiff + vec3(dot(N, L));\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n  varying vec2 uvw;\n  varying vec2 uv0;\n  varying vec2 uv1;\n  varying vec2 uv2;\n  varying vec2 uv3;\n  varying vec3 diffuse;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture2D(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n    color += texture2D(detailMap3, uv3) * w.a;\n  #else\n    color = texture2D(detailMap0, uv0);\n  #endif\n  color.rgb *= diffuse;\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"
            },
            builtins: {
                globals: {
                    blocks: [ {
                        name: "CCGlobal",
                        defines: []
                    } ],
                    samplers: []
                },
                locals: {
                    blocks: [ {
                        name: "CCLocal",
                        defines: []
                    } ],
                    samplers: []
                }
            },
            defines: [ {
                name: "CC_USE_HDR",
                type: "boolean"
            }, {
                name: "LAYERS",
                type: "number",
                range: [ 0, 3 ]
            } ],
            blocks: [ {
                name: "TexCoords",
                defines: [],
                binding: 0,
                members: [ {
                    name: "UVScale",
                    type: 16,
                    count: 1
                } ]
            } ],
            samplers: [ {
                name: "weightMap",
                type: 28,
                count: 1,
                defines: [],
                binding: 30
            }, {
                name: "detailMap0",
                type: 28,
                count: 1,
                defines: [],
                binding: 31
            }, {
                name: "detailMap1",
                type: 28,
                count: 1,
                defines: [],
                binding: 32
            }, {
                name: "detailMap2",
                type: 28,
                count: 1,
                defines: [],
                binding: 33
            }, {
                name: "detailMap3",
                type: 28,
                count: 1,
                defines: [],
                binding: 34
            } ]
        } ]
    }, {
        name: "builtin-unlit",
        _uuid: "a3cd009f-0ab0-420d-9278-b9fdab939bbc",
        techniques: [ {
            name: "opaque",
            passes: [ {
                program: "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
                properties: {
                    mainTexture: {
                        value: "grey",
                        type: 28
                    },
                    tilingOffset: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    mainColor: {
                        value: [ 1, 1, 1, 1 ],
                        type: 16
                    },
                    colorScale: {
                        value: [ 1, 1, 1 ],
                        type: 15,
                        handleInfo: [ "colorScaleAndCutoff", 0, 15 ]
                    },
                    alphaThreshold: {
                        value: [ .5 ],
                        type: 13,
                        handleInfo: [ "colorScaleAndCutoff", 3, 13 ]
                    },
                    color: {
                        type: 16,
                        handleInfo: [ "mainColor", 0, 16 ]
                    },
                    colorScaleAndCutoff: {
                        type: 16,
                        value: [ 1, 1, 1, .5 ]
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
            hash: 1543680674,
            glsl3: {
                vert: "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_BATCHING\n  in float a_dyn_batch_id;\n  uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\n#endif\nin vec3 a_position;\n#if USE_SKINNING\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec4 a_weights;\nin vec4 a_joints;\nuniform CCSkinningTexture {\n  highp vec4 cc_jointsTextureInfo;\n};\nuniform CCSkinningAnimation {\n  highp vec4 cc_jointsAnimInfo;\n};\nuniform sampler2D cc_jointsTexture;\n#if USE_SKINNING == 1\n  highp float decode32 (highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if USE_SKINNING == 1\n  mat4 getJointMatrix (float i) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    vec4 v2 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    vec4 v3 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 10.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 11.5) * invSize, y)))\n    );\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#elif USE_SKINNING == 2\n  mat4 getJointMatrix (float i) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    vec4 v2 = texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    vec4 v3 = texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y));\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n    + getJointMatrix(a_joints.y) * a_weights.y;\n    + getJointMatrix(a_joints.z) * a_weights.z;\n    + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\n#if USE_TEXTURE\n  in vec2 a_texCoord;\n  out vec2 v_uv;\n  uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id + 0.5)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord;\n    #if FLIP_UV\n      v_uv.y = 1.0 - v_uv.y;\n    #endif\n    v_uv = v_uv * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nuniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return CCFragOutput(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            },
            glsl1: {
                vert: "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\n#if USE_SKINNING\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform highp vec4 cc_jointsTextureInfo;\nuniform highp vec4 cc_jointsAnimInfo;\nuniform sampler2D cc_jointsTexture;\n#if USE_SKINNING == 1\n  highp float decode32 (highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if USE_SKINNING == 1\n  mat4 getJointMatrix (float i) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    vec4 v2 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    vec4 v3 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 10.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 11.5) * invSize, y)))\n    );\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#elif USE_SKINNING == 2\n  mat4 getJointMatrix (float i) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    vec4 v2 = texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    vec4 v3 = texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y));\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n    + getJointMatrix(a_joints.y) * a_weights.y;\n    + getJointMatrix(a_joints.z) * a_weights.z;\n    + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\n#if USE_TEXTURE\n  attribute vec2 a_texCoord;\n  varying vec2 v_uv;\n  uniform vec4 tilingOffset;\n#endif\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id + 0.5)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord;\n    #if FLIP_UV\n      v_uv.y = 1.0 - v_uv.y;\n    #endif\n    v_uv = v_uv * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nuniform vec4 mainColor;\nuniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"
            },
            builtins: {
                globals: {
                    blocks: [ {
                        name: "CCGlobal",
                        defines: []
                    } ],
                    samplers: []
                },
                locals: {
                    blocks: [ {
                        name: "CCLocalBatched",
                        defines: [ "USE_BATCHING" ]
                    }, {
                        name: "CCLocal",
                        defines: []
                    }, {
                        name: "CCSkinningTexture",
                        defines: [ "USE_SKINNING" ]
                    }, {
                        name: "CCSkinningAnimation",
                        defines: [ "USE_SKINNING" ]
                    } ],
                    samplers: [ {
                        name: "cc_jointsTexture",
                        defines: [ "USE_SKINNING" ]
                    } ]
                }
            },
            defines: [ {
                name: "USE_BATCHING",
                type: "boolean"
            }, {
                name: "USE_SKINNING",
                type: "boolean"
            }, {
                name: "USE_VERTEX_COLOR",
                type: "boolean"
            }, {
                name: "USE_TEXTURE",
                type: "boolean"
            }, {
                name: "FLIP_UV",
                type: "boolean"
            }, {
                name: "CC_USE_HDR",
                type: "boolean"
            }, {
                name: "USE_ALPHA_TEST",
                type: "boolean"
            }, {
                name: "ALPHA_TEST_CHANNEL",
                type: "string",
                options: [ "a", "r", "g", "b" ]
            } ],
            blocks: [ {
                name: "TexCoords",
                defines: [ "USE_TEXTURE" ],
                binding: 0,
                members: [ {
                    name: "tilingOffset",
                    type: 16,
                    count: 1
                } ]
            }, {
                name: "Constant",
                defines: [],
                binding: 1,
                members: [ {
                    name: "mainColor",
                    type: 16,
                    count: 1
                }, {
                    name: "colorScaleAndCutoff",
                    type: 16,
                    count: 1
                } ]
            } ],
            samplers: [ {
                name: "mainTexture",
                type: 28,
                count: 1,
                defines: [ "USE_TEXTURE" ],
                binding: 30
            } ]
        } ]
    }, {
        name: "pipeline/planar-shadow",
        _uuid: "9361fd90-ba52-4f84-aa93-6e878fd576ca",
        techniques: [ {
            passes: [ {
                phase: "planarShadow",
                blendState: {
                    targets: [ {
                        blend: !0,
                        blendSrc: 2,
                        blendDst: 4,
                        blendDstAlpha: 4
                    } ]
                },
                program: "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
                depthStencilState: {
                    depthTest: !0,
                    depthWrite: !1,
                    stencilTestFront: !0,
                    stencilFuncFront: 5,
                    stencilPassOpFront: 2,
                    stencilRefBack: 128,
                    stencilRefFront: 128,
                    stencilReadMaskBack: 128,
                    stencilReadMaskFront: 128,
                    stencilWriteMaskBack: 128,
                    stencilWriteMaskFront: 128
                }
            } ]
        } ],
        shaders: [ {
            name: "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
            hash: 1086841741,
            glsl3: {
                vert: "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_BATCHING\n  in float a_dyn_batch_id;\n  uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\n#endif\nuniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  lowp vec4 cc_shadowColor;\n};\nin vec3 a_position;\n#if USE_SKINNING\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec4 a_weights;\nin vec4 a_joints;\nuniform CCSkinningTexture {\n  highp vec4 cc_jointsTextureInfo;\n};\nuniform CCSkinningAnimation {\n  highp vec4 cc_jointsAnimInfo;\n};\nuniform sampler2D cc_jointsTexture;\n#if USE_SKINNING == 1\n  highp float decode32 (highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if USE_SKINNING == 1\n  mat4 getJointMatrix (float i) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    vec4 v2 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    vec4 v3 = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 10.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 11.5) * invSize, y)))\n    );\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#elif USE_SKINNING == 2\n  mat4 getJointMatrix (float i) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    vec4 v2 = texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    vec4 v3 = texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y));\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n    + getJointMatrix(a_joints.y) * a_weights.y;\n    + getJointMatrix(a_joints.z) * a_weights.z;\n    + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id + 0.5)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nuniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  lowp vec4 cc_shadowColor;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            },
            glsl1: {
                vert: "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nuniform highp mat4 cc_matLightPlaneProj;\nattribute vec3 a_position;\n#if USE_SKINNING\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform highp vec4 cc_jointsTextureInfo;\nuniform highp vec4 cc_jointsAnimInfo;\nuniform sampler2D cc_jointsTexture;\n#if USE_SKINNING == 1\n  highp float decode32 (highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if USE_SKINNING == 1\n  mat4 getJointMatrix (float i) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    vec4 v2 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    vec4 v3 = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 10.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 11.5) * invSize, y)))\n    );\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#elif USE_SKINNING == 2\n  mat4 getJointMatrix (float i) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    vec4 v1 = texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    vec4 v2 = texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    vec4 v3 = texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y));\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n    + getJointMatrix(a_joints.y) * a_weights.y;\n    + getJointMatrix(a_joints.z) * a_weights.z;\n    + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id + 0.5)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nuniform lowp vec4 cc_shadowColor;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"
            },
            builtins: {
                globals: {
                    blocks: [ {
                        name: "CCGlobal",
                        defines: []
                    }, {
                        name: "CCShadow",
                        defines: []
                    } ],
                    samplers: []
                },
                locals: {
                    blocks: [ {
                        name: "CCLocalBatched",
                        defines: [ "USE_BATCHING" ]
                    }, {
                        name: "CCLocal",
                        defines: []
                    }, {
                        name: "CCSkinningTexture",
                        defines: [ "USE_SKINNING" ]
                    }, {
                        name: "CCSkinningAnimation",
                        defines: [ "USE_SKINNING" ]
                    } ],
                    samplers: [ {
                        name: "cc_jointsTexture",
                        defines: [ "USE_SKINNING" ]
                    } ]
                }
            },
            defines: [ {
                name: "USE_BATCHING",
                type: "boolean"
            }, {
                name: "USE_SKINNING",
                type: "boolean"
            }, {
                name: "CC_USE_HDR",
                type: "boolean"
            } ],
            blocks: [],
            samplers: []
        } ]
    }, {
        name: "pipeline/skybox",
        _uuid: "511d2633-09a7-4bdd-ac42-f778032124b3",
        techniques: [ {
            passes: [ {
                rasterizerState: {
                    cullMode: 0
                },
                program: "pipeline/skybox|sky-vs:vert|sky-fs:frag",
                priority: 245,
                depthStencilState: {
                    depthTest: !0,
                    depthWrite: !1
                }
            } ]
        } ],
        shaders: [ {
            name: "pipeline/skybox|sky-vs:vert|sky-fs:frag",
            hash: 407071991,
            glsl3: {
                vert: "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nin vec3 a_position;\nout vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_screenSize.y * cc_screenSize.z, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb) * cc_ambientSky.w;\n  #endif\n  return CCFragOutput(vec4(c, 1.0));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            },
            glsl1: {
                vert: "\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nattribute vec3 a_position;\nvarying vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_screenSize.y * cc_screenSize.z, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nuniform mediump vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb) * cc_ambientSky.w;\n  #endif\n  return CCFragOutput(vec4(c, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"
            },
            builtins: {
                globals: {
                    blocks: [ {
                        name: "CCGlobal",
                        defines: []
                    } ],
                    samplers: [ {
                        name: "cc_environment",
                        defines: []
                    } ]
                },
                locals: {
                    blocks: [],
                    samplers: []
                }
            },
            defines: [ {
                name: "CC_USE_IBL",
                type: "number",
                range: [ 0, 2 ]
            }, {
                name: "CC_USE_HDR",
                type: "boolean"
            }, {
                name: "USE_RGBE_CUBEMAP",
                type: "boolean"
            } ],
            blocks: [],
            samplers: []
        } ]
    }, {
        name: "util/profiler",
        _uuid: "871c3b6c-7379-419d-bda3-794b239ab90d",
        techniques: [ {
            passes: [ {
                blendState: {
                    targets: [ {
                        blend: !0,
                        blendSrc: 2,
                        blendDst: 4,
                        blendDstAlpha: 4
                    } ]
                },
                rasterizerState: {
                    cullMode: 0
                },
                program: "util/profiler|profiler-vs:vert|profiler-fs:frag",
                depthStencilState: {
                    depthTest: !1,
                    depthWrite: !1
                }
            } ]
        } ],
        shaders: [ {
            name: "util/profiler|profiler-vs:vert|profiler-fs:frag",
            hash: 3428623830,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec2 v_uv;\nuniform Constants {\n  vec4 offset;\n};\nuniform PerFrameInfo {\n  vec4 digits[8 * 9 / 4];\n};\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy + abs(position.xy);\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture(mainTexture, v_uv));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform mediump vec4 cc_screenSize;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec2 v_uv;\nuniform vec4 offset;\nuniform vec4 digits[18];\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy + abs(position.xy);\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
                frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }"
            },
            builtins: {
                globals: {
                    blocks: [ {
                        name: "CCGlobal",
                        defines: []
                    } ],
                    samplers: []
                },
                locals: {
                    blocks: [],
                    samplers: []
                }
            },
            defines: [ {
                name: "CC_USE_HDR",
                type: "boolean"
            } ],
            blocks: [ {
                name: "Constants",
                defines: [],
                binding: 0,
                members: [ {
                    name: "offset",
                    type: 16,
                    count: 1
                } ]
            }, {
                name: "PerFrameInfo",
                defines: [],
                binding: 1,
                members: [ {
                    name: "digits",
                    type: 16,
                    count: 18
                } ]
            } ],
            samplers: [ {
                name: "mainTexture",
                type: 28,
                count: 1,
                defines: [],
                binding: 30
            } ]
        } ]
    } ], BuiltinResMgr = function() {
        function BuiltinResMgr() {
            _classCallCheck(this, BuiltinResMgr), this._device = null, this._resources = {};
        }
        return _createClass(BuiltinResMgr, [ {
            key: "initBuiltinRes",
            value: function initBuiltinRes(device) {
                this._device = device;
                var resources = this._resources, canvas = document.createElement("canvas"), context = canvas.getContext("2d"), imgAsset = new ImageAsset(canvas), l = canvas.width = canvas.height = 2;
                context.fillStyle = "#000", context.fillRect(0, 0, l, l);
                var blackTexture = new Texture2D;
                blackTexture._uuid = "black-texture", blackTexture.image = imgAsset, resources[blackTexture._uuid] = blackTexture;
                var blackCubeTexture = new TextureCube;
                blackCubeTexture._uuid = "black-cube-texture", blackCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), 
                blackCubeTexture.image = {
                    front: new ImageAsset(canvas),
                    back: new ImageAsset(canvas),
                    left: new ImageAsset(canvas),
                    right: new ImageAsset(canvas),
                    top: new ImageAsset(canvas),
                    bottom: new ImageAsset(canvas)
                }, resources[blackCubeTexture._uuid] = blackCubeTexture, context.fillStyle = "#777", 
                context.fillRect(0, 0, l, l);
                var greyTexture = new Texture2D;
                greyTexture._uuid = "grey-texture", greyTexture.image = imgAsset, resources[greyTexture._uuid] = greyTexture, 
                context.fillStyle = "#fff", context.fillRect(0, 0, l, l);
                var whiteTexture = new Texture2D;
                whiteTexture._uuid = "white-texture", whiteTexture.image = imgAsset, resources[whiteTexture._uuid] = whiteTexture;
                var whiteCubeTexture = new TextureCube;
                whiteCubeTexture._uuid = "white-cube-texture", whiteCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), 
                whiteCubeTexture.image = {
                    front: new ImageAsset(canvas),
                    back: new ImageAsset(canvas),
                    left: new ImageAsset(canvas),
                    right: new ImageAsset(canvas),
                    top: new ImageAsset(canvas),
                    bottom: new ImageAsset(canvas)
                }, resources[whiteCubeTexture._uuid] = whiteCubeTexture, context.fillStyle = "#7f7fff", 
                context.fillRect(0, 0, l, l);
                var normalTexture = new Texture2D;
                normalTexture._uuid = "normal-texture", normalTexture.image = imgAsset, resources[normalTexture._uuid] = normalTexture, 
                canvas.width = canvas.height = 16, context.fillStyle = "#ddd", context.fillRect(0, 0, 16, 16), 
                context.fillStyle = "#555", context.fillRect(0, 0, 8, 8), context.fillStyle = "#555", 
                context.fillRect(8, 8, 8, 8);
                var defaultTexture = new Texture2D;
                defaultTexture._uuid = "default-texture", defaultTexture.image = imgAsset, resources[defaultTexture._uuid] = defaultTexture;
                var defaultCubeTexture = new TextureCube;
                defaultCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), defaultCubeTexture._uuid = "default-cube-texture", 
                defaultCubeTexture.image = {
                    front: new ImageAsset(canvas),
                    back: new ImageAsset(canvas),
                    left: new ImageAsset(canvas),
                    right: new ImageAsset(canvas),
                    top: new ImageAsset(canvas),
                    bottom: new ImageAsset(canvas)
                }, resources[defaultCubeTexture._uuid] = defaultCubeTexture;
                var spriteFrame = new SpriteFrame, texture = imgAsset._texture;
                spriteFrame.texture = texture, spriteFrame._uuid = "default-spriteframe", resources[spriteFrame._uuid] = spriteFrame, 
                effects.forEach((function(e) {
                    Object.assign(new cc.EffectAsset, e).onLoaded();
                }));
                var standardMtl = new cc.Material;
                standardMtl._uuid = "standard-material", standardMtl.initialize({
                    effectName: "builtin-standard"
                }), resources[standardMtl._uuid] = standardMtl;
                var missingMtl = new cc.Material;
                missingMtl._uuid = "missing-material", missingMtl.initialize({
                    effectName: "builtin-unlit",
                    defines: {
                        USE_COLOR: !0
                    }
                }), missingMtl.setProperty("color", cc.color("#ff00ff")), resources[missingMtl._uuid] = missingMtl;
                var missingSkinningMtl = new cc.Material;
                missingSkinningMtl._uuid = "missing-skinning-material";
                var type = selectJointsMediumType(device);
                missingSkinningMtl.initialize({
                    effectName: "builtin-unlit",
                    defines: {
                        USE_COLOR: !0,
                        USE_SKINNING: type
                    }
                }), missingSkinningMtl.setProperty("color", cc.color("#ff00ff")), resources[missingSkinningMtl._uuid] = missingSkinningMtl;
                var missingEfxMtl = new cc.Material;
                missingEfxMtl._uuid = "missing-effect-material", missingEfxMtl.initialize({
                    effectName: "builtin-unlit",
                    defines: {
                        USE_COLOR: !0
                    }
                }), missingEfxMtl.setProperty("color", cc.color("#ffff00")), resources[missingEfxMtl._uuid] = missingEfxMtl;
                var spriteMtl = new cc.Material;
                spriteMtl._uuid = "ui-base-material", spriteMtl.initialize({
                    defines: {
                        USE_TEXTURE: !1
                    },
                    effectName: "builtin-sprite"
                }), resources[spriteMtl._uuid] = spriteMtl;
                var spriteColorMtl = new cc.Material;
                spriteColorMtl._uuid = "ui-sprite-material", spriteColorMtl.initialize({
                    defines: {
                        USE_TEXTURE: !0,
                        IS_GRAY: !1
                    },
                    effectName: "builtin-sprite"
                }), resources[spriteColorMtl._uuid] = spriteColorMtl;
                var spriteGrayMtl = new cc.Material;
                spriteGrayMtl._uuid = "ui-sprite-gray-material", spriteGrayMtl.initialize({
                    defines: {
                        USE_TEXTURE: !0,
                        IS_GRAY: !0
                    },
                    effectName: "builtin-sprite"
                }), resources[spriteGrayMtl._uuid] = spriteGrayMtl;
                var defaultParticleMtl = new cc.Material;
                defaultParticleMtl._uuid = "default-particle-material", defaultParticleMtl.initialize({
                    effectName: "builtin-particle"
                }), resources[defaultParticleMtl._uuid] = defaultParticleMtl;
                var defaultTrailMtl = new cc.Material;
                defaultTrailMtl._uuid = "default-trail-material", defaultTrailMtl.initialize({
                    effectName: "builtin-particle-trail"
                }), resources[defaultTrailMtl._uuid] = defaultTrailMtl;
                var defaultBillboardMtl = new cc.Material;
                defaultBillboardMtl._uuid = "default-billboard-material", defaultBillboardMtl.initialize({
                    effectName: "builtin-billboard"
                }), resources[defaultBillboardMtl._uuid] = defaultBillboardMtl;
            }
        }, {
            key: "get",
            value: function get(uuid) {
                return this._resources[uuid];
            }
        } ]), BuiltinResMgr;
    }(), builtinResMgr = cc.builtinResMgr = new BuiltinResMgr, GFXTextureView = function(_GFXObject) {
        function GFXTextureView(device) {
            var _this;
            return _classCallCheck(this, GFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXTextureView).call(this, exports.GFXObjectType.TEXTURE_VIEW)))._texture = null, 
            _this._type = exports.GFXTextureViewType.TV2D, _this._format = exports.GFXFormat.UNKNOWN, 
            _this._baseLevel = 0, _this._levelCount = 1, _this._baseLayer = 0, _this._layerCount = 1, 
            _this._device = device, _this;
        }
        return _inherits(GFXTextureView, _GFXObject), _createClass(GFXTextureView, [ {
            key: "texture",
            get: function get() {
                return this._texture;
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "format",
            get: function get() {
                return this._format;
            }
        }, {
            key: "baseLevel",
            get: function get() {
                return this._baseLevel;
            }
        }, {
            key: "levelCount",
            get: function get() {
                return this._levelCount;
            }
        }, {
            key: "baseLayer",
            get: function get() {
                return this._baseLayer;
            }
        }, {
            key: "layerCount",
            get: function get() {
                return this._layerCount;
            }
        } ]), GFXTextureView;
    }(GFXObject), GFXRasterizerState = function() {
        function GFXRasterizerState() {
            _classCallCheck(this, GFXRasterizerState), this.isDiscard = !1, this.polygonMode = exports.GFXPolygonMode.FILL, 
            this.shadeModel = exports.GFXShadeModel.GOURAND, this.cullMode = exports.GFXCullMode.BACK, 
            this.isFrontFaceCCW = !0, this.depthBias = 0, this.depthBiasClamp = 0, this.depthBiasSlop = 0, 
            this.isDepthClip = !0, this.isMultisample = !1, this.lineWidth = 1;
        }
        return _createClass(GFXRasterizerState, [ {
            key: "compare",
            value: function compare(state) {
                return this.isDiscard === state.isDiscard && this.polygonMode === state.polygonMode && this.shadeModel === state.shadeModel && this.cullMode === state.cullMode && this.isFrontFaceCCW === state.isFrontFaceCCW && this.depthBias === state.depthBias && this.depthBiasClamp === state.depthBiasClamp && this.depthBiasSlop === state.depthBiasSlop && this.isDepthClip === state.isDepthClip && this.lineWidth === state.lineWidth && this.isMultisample === state.isMultisample;
            }
        } ]), GFXRasterizerState;
    }(), GFXDepthStencilState = function() {
        function GFXDepthStencilState() {
            _classCallCheck(this, GFXDepthStencilState), this.depthTest = !0, this.depthWrite = !0, 
            this.depthFunc = exports.GFXComparisonFunc.LESS, this.stencilTestFront = !1, this.stencilFuncFront = exports.GFXComparisonFunc.ALWAYS, 
            this.stencilReadMaskFront = 65535, this.stencilWriteMaskFront = 65535, this.stencilFailOpFront = exports.GFXStencilOp.KEEP, 
            this.stencilZFailOpFront = exports.GFXStencilOp.KEEP, this.stencilPassOpFront = exports.GFXStencilOp.KEEP, 
            this.stencilRefFront = 1, this.stencilTestBack = !1, this.stencilFuncBack = exports.GFXComparisonFunc.ALWAYS, 
            this.stencilReadMaskBack = 65535, this.stencilWriteMaskBack = 65535, this.stencilFailOpBack = exports.GFXStencilOp.KEEP, 
            this.stencilZFailOpBack = exports.GFXStencilOp.KEEP, this.stencilPassOpBack = exports.GFXStencilOp.KEEP, 
            this.stencilRefBack = 1;
        }
        return _createClass(GFXDepthStencilState, [ {
            key: "compare",
            value: function compare(state) {
                return this.depthTest === state.depthTest && this.depthWrite === state.depthWrite && this.depthFunc === state.depthFunc && this.stencilTestFront === state.stencilTestFront && this.stencilFuncFront === state.stencilFuncFront && this.stencilReadMaskFront === state.stencilReadMaskFront && this.stencilWriteMaskFront === state.stencilWriteMaskFront && this.stencilFailOpFront === state.stencilFailOpFront && this.stencilZFailOpFront === state.stencilZFailOpFront && this.stencilPassOpFront === state.stencilPassOpFront && this.stencilRefFront === state.stencilRefFront && this.stencilTestBack === state.stencilTestBack && this.stencilFuncBack === state.stencilFuncBack && this.stencilReadMaskBack === state.stencilReadMaskBack && this.stencilWriteMaskBack === state.stencilWriteMaskBack && this.stencilFailOpBack === state.stencilFailOpBack && this.stencilZFailOpBack === state.stencilZFailOpBack && this.stencilPassOpBack === state.stencilPassOpBack && this.stencilRefBack === state.stencilRefBack;
            }
        } ]), GFXDepthStencilState;
    }(), GFXBlendTarget = function() {
        function GFXBlendTarget() {
            _classCallCheck(this, GFXBlendTarget), this.blend = !1, this.blendSrc = exports.GFXBlendFactor.ONE, 
            this.blendDst = exports.GFXBlendFactor.ZERO, this.blendEq = exports.GFXBlendOp.ADD, 
            this.blendSrcAlpha = exports.GFXBlendFactor.ONE, this.blendDstAlpha = exports.GFXBlendFactor.ZERO, 
            this.blendAlphaEq = exports.GFXBlendOp.ADD, this.blendColorMask = exports.GFXColorMask.ALL;
        }
        return _createClass(GFXBlendTarget, [ {
            key: "compare",
            value: function compare(target) {
                return this.blend === target.blend && this.blendSrc === target.blendSrc && this.blendDst === target.blendDst && this.blendEq === target.blendEq && this.blendSrcAlpha === target.blendSrcAlpha && this.blendDstAlpha === target.blendDstAlpha && this.blendAlphaEq === target.blendAlphaEq && this.blendColorMask === target.blendColorMask;
            }
        } ]), GFXBlendTarget;
    }(), GFXBlendState = function GFXBlendState() {
        _classCallCheck(this, GFXBlendState), this.isA2C = !1, this.isIndepend = !1, this.blendColor = [ 0, 0, 0, 0 ], 
        this.targets = [ new GFXBlendTarget ];
    }, GFXInputState = function GFXInputState() {
        _classCallCheck(this, GFXInputState), this.attributes = [];
    }, GFXPipelineState = function(_GFXObject) {
        function GFXPipelineState(device) {
            var _this;
            return _classCallCheck(this, GFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXPipelineState).call(this, exports.GFXObjectType.PIPELINE_STATE)))._shader = null, 
            _this._primitive = exports.GFXPrimitiveMode.TRIANGLE_LIST, _this._is = null, _this._rs = null, 
            _this._dss = null, _this._bs = null, _this._dynamicStates = [], _this._layout = null, 
            _this._renderPass = null, _this._hash = 0, _this._device = device, _this;
        }
        return _inherits(GFXPipelineState, _GFXObject), _createClass(GFXPipelineState, [ {
            key: "shader",
            get: function get() {
                return this._shader;
            }
        }, {
            key: "primitive",
            get: function get() {
                return this._primitive;
            }
        }, {
            key: "rasterizerState",
            get: function get() {
                return this._rs;
            }
        }, {
            key: "depthStencilState",
            get: function get() {
                return this._dss;
            }
        }, {
            key: "blendState",
            get: function get() {
                return this._bs;
            }
        }, {
            key: "inputState",
            get: function get() {
                return this._is;
            }
        }, {
            key: "dynamicStates",
            get: function get() {
                return this._dynamicStates;
            }
        }, {
            key: "pipelineLayout",
            get: function get() {
                return this._layout;
            }
        }, {
            key: "renderPass",
            get: function get() {
                return this._renderPass;
            }
        }, {
            key: "hash",
            get: function get() {
                return this._hash;
            }
        } ]), GFXPipelineState;
    }(GFXObject), GFXBuffer = function(_GFXObject) {
        function GFXBuffer(device) {
            var _this;
            return _classCallCheck(this, GFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXBuffer).call(this, exports.GFXObjectType.BUFFER)))._usage = exports.GFXBufferUsageBit.NONE, 
            _this._memUsage = exports.GFXMemoryUsageBit.NONE, _this._size = 0, _this._stride = 1, 
            _this._count = 0, _this._flags = exports.GFXBufferFlagBit.NONE, _this._bufferView = null, 
            _this._device = device, _this;
        }
        return _inherits(GFXBuffer, _GFXObject), _createClass(GFXBuffer, [ {
            key: "usage",
            get: function get() {
                return this._usage;
            }
        }, {
            key: "memUsage",
            get: function get() {
                return this._memUsage;
            }
        }, {
            key: "size",
            get: function get() {
                return this._size;
            }
        }, {
            key: "stride",
            get: function get() {
                return this._stride;
            }
        }, {
            key: "count",
            get: function get() {
                return this._count;
            }
        }, {
            key: "flags",
            get: function get() {
                return this._flags;
            }
        }, {
            key: "bufferView",
            get: function get() {
                return this._bufferView;
            }
        } ]), GFXBuffer;
    }(GFXObject), GFXCommandBuffer = function(_GFXObject) {
        function GFXCommandBuffer(device) {
            var _this;
            return _classCallCheck(this, GFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXCommandBuffer).call(this, exports.GFXObjectType.COMMAND_BUFFER)))._allocator = null, 
            _this._type = exports.GFXCommandBufferType.PRIMARY, _this._numDrawCalls = 0, _this._numTris = 0, 
            _this._device = device, _this;
        }
        return _inherits(GFXCommandBuffer, _GFXObject), _createClass(GFXCommandBuffer, [ {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "numDrawCalls",
            get: function get() {
                return this._numDrawCalls;
            }
        }, {
            key: "numTris",
            get: function get() {
                return this._numTris;
            }
        } ]), GFXCommandBuffer;
    }(GFXObject), GFXFramebuffer = function(_GFXObject) {
        function GFXFramebuffer(device) {
            var _this;
            return _classCallCheck(this, GFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXFramebuffer).call(this, exports.GFXObjectType.FRAMEBUFFER)))._renderPass = null, 
            _this._colorViews = [], _this._depthStencilView = null, _this._isOffscreen = !0, 
            _this._device = device, _this;
        }
        return _inherits(GFXFramebuffer, _GFXObject), _createClass(GFXFramebuffer, [ {
            key: "renderPass",
            get: function get() {
                return this._renderPass;
            }
        }, {
            key: "colorViews",
            get: function get() {
                return this._colorViews;
            }
        }, {
            key: "depthStencilView",
            get: function get() {
                return this._depthStencilView;
            }
        }, {
            key: "isOffscreen",
            get: function get() {
                return this._isOffscreen;
            }
        } ]), GFXFramebuffer;
    }(GFXObject), isLittleEndian$1 = cc.sys.isLittleEndian, _typeMap = (_defineProperty(_typeMap2 = {}, exports.GFXFormatType.UNORM, "Uint"), 
    _defineProperty(_typeMap2, exports.GFXFormatType.SNORM, "Int"), _defineProperty(_typeMap2, exports.GFXFormatType.UINT, "Uint"), 
    _defineProperty(_typeMap2, exports.GFXFormatType.INT, "Int"), _defineProperty(_typeMap2, exports.GFXFormatType.UFLOAT, "Float"), 
    _defineProperty(_typeMap2, exports.GFXFormatType.FLOAT, "Float"), _defineProperty(_typeMap2, "default", "Uint"), 
    _typeMap2);
    function _getDataViewType(info) {
        return (_typeMap[info.type] || _typeMap.default) + info.size / info.count * 8;
    }
    function writeBuffer(target, data) {
        var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : exports.GFXFormat.R32F, offset = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, stride = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, info = GFXFormatInfos[format];
        stride || (stride = info.size);
        for (var writer = "set" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(data.length / info.count), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
            var y = x + componentBytesLength * iComponent;
            target[writer](y, data[info.count * iSeg + iComponent], isLittleEndian$1);
        }
    }
    function readBuffer(target) {
        var format = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : exports.GFXFormat.R32F, offset = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, length = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : target.byteLength - offset, stride = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, out = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [], info = GFXFormatInfos[format];
        stride || (stride = info.size);
        for (var reader = "get" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(length / stride), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
            var y = x + componentBytesLength * iComponent;
            out[info.count * iSeg + iComponent] = target[reader](y, isLittleEndian$1);
        }
        return out;
    }
    function mapBuffer(target, callback) {
        var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : exports.GFXFormat.R32F, offset = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, length = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : target.byteLength - offset, stride = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, out = arguments.length > 6 ? arguments[6] : void 0;
        out || (out = new DataView(new ArrayBuffer(target.byteLength)));
        var info = GFXFormatInfos[format];
        stride || (stride = info.size);
        for (var writer = "set" + _getDataViewType(info), reader = "get" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(length / stride), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
            var y = x + componentBytesLength * iComponent, _cur = target[reader](y, isLittleEndian$1);
            out[writer](y, callback(_cur, iComponent, target), isLittleEndian$1);
        }
        return out;
    }
    var GFXInputAssembler = function(_GFXObject) {
        function GFXInputAssembler(device) {
            var _this;
            return _classCallCheck(this, GFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXInputAssembler).call(this, exports.GFXObjectType.INPUT_ASSEMBLER)))._attributes = [], 
            _this._vertexBuffers = [], _this._indexBuffer = null, _this._vertexCount = 0, _this._firstVertex = 0, 
            _this._indexCount = 0, _this._firstIndex = 0, _this._vertexOffset = 0, _this._instanceCount = 0, 
            _this._firstInstance = 0, _this._isIndirect = !1, _this._indirectBuffer = null, 
            _this._device = device, _this;
        }
        return _inherits(GFXInputAssembler, _GFXObject), _createClass(GFXInputAssembler, [ {
            key: "vertexBuffers",
            get: function get() {
                return this._vertexBuffers;
            }
        }, {
            key: "indexBuffer",
            get: function get() {
                return this._indexBuffer;
            }
        }, {
            key: "attributes",
            get: function get() {
                return this._attributes;
            }
        }, {
            key: "vertexCount",
            get: function get() {
                return this._vertexCount;
            },
            set: function set(count) {
                this._vertexCount = count;
            }
        }, {
            key: "firstVertex",
            get: function get() {
                return this._firstVertex;
            },
            set: function set(first) {
                this._firstVertex = first;
            }
        }, {
            key: "indexCount",
            get: function get() {
                return this._indexCount;
            },
            set: function set(count) {
                this._indexCount = count;
            }
        }, {
            key: "firstIndex",
            get: function get() {
                return this._firstIndex;
            },
            set: function set(first) {
                this._firstIndex = first;
            }
        }, {
            key: "vertexOffset",
            get: function get() {
                return this._vertexOffset;
            },
            set: function set(offset) {
                this._vertexOffset = offset;
            }
        }, {
            key: "instanceCount",
            get: function get() {
                return this._instanceCount;
            },
            set: function set(count) {
                this._instanceCount = count;
            }
        }, {
            key: "firstInstance",
            get: function get() {
                return this._firstInstance;
            },
            set: function set(first) {
                this._firstInstance = first;
            }
        }, {
            key: "isIndirect",
            get: function get() {
                return this._isIndirect;
            }
        }, {
            key: "indirectBuffer",
            get: function get() {
                return this._indirectBuffer;
            }
        } ]), _createClass(GFXInputAssembler, [ {
            key: "getVertexBuffer",
            value: function getVertexBuffer() {
                var stream = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return stream < this._vertexBuffers.length ? this._vertexBuffers[stream] : null;
            }
        }, {
            key: "extractDrawInfo",
            value: function extractDrawInfo(drawInfo) {
                drawInfo.vertexCount = this._vertexCount, drawInfo.firstVertex = this._firstVertex, 
                drawInfo.indexCount = this._indexCount, drawInfo.firstIndex = this._firstIndex, 
                drawInfo.vertexOffset = this._vertexOffset, drawInfo.instanceCount = this._instanceCount, 
                drawInfo.firstInstance = this._firstInstance;
            }
        }, {
            key: "updateVertexAttr",
            value: function updateVertexAttr(vbuffer, attr, data) {
                var index = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, _final = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], offset = 0, format = exports.GFXFormat.UNKNOWN, _iterator = this._attributes, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var a = _ref;
                    if (a.name === attr) {
                        format = a.format;
                        break;
                    }
                    offset += GFXFormatInfos[a.format].size;
                }
                var vb = this._vertexBuffers[index];
                format && vb && (writeBuffer(new DataView(vbuffer), data, format, offset, vb.stride), 
                _final && vb.update(vbuffer, 0, vb.stride * vb.count));
            }
        }, {
            key: "updateIndexBuffer",
            value: function updateIndexBuffer(ibuffer, data) {
                var count = this._indexCount, ib = this._indexBuffer;
                count && ib && (writeBuffer(new DataView(ibuffer), data, exports.GFXFormat["R".concat(8 * ib.stride, "UI")]), 
                ib.update(ibuffer, 0, ib.stride * ib.count), this._indexCount = data.length);
            }
        } ]), GFXInputAssembler;
    }(GFXObject), GFXPipelineLayout = function(_GFXObject) {
        function GFXPipelineLayout(device) {
            var _this;
            return _classCallCheck(this, GFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXPipelineLayout).call(this, exports.GFXObjectType.PIPELINE_LAYOUT)))._pushConstantsRanges = [], 
            _this._layouts = [], _this._device = device, _this;
        }
        return _inherits(GFXPipelineLayout, _GFXObject), _createClass(GFXPipelineLayout, [ {
            key: "layouts",
            get: function get() {
                return this._layouts;
            }
        } ]), GFXPipelineLayout;
    }(GFXObject), GFXQueue = function(_GFXObject) {
        function GFXQueue(device) {
            var _this;
            return _classCallCheck(this, GFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXQueue).call(this, exports.GFXObjectType.QUEUE)))._type = exports.GFXQueueType.GRAPHICS, 
            _this._device = device, _this;
        }
        return _inherits(GFXQueue, _GFXObject), _createClass(GFXQueue, [ {
            key: "type",
            get: function get() {
                return this._type;
            }
        } ]), GFXQueue;
    }(GFXObject), GFXRenderPass = function(_GFXObject) {
        function GFXRenderPass(device) {
            var _this;
            return _classCallCheck(this, GFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXRenderPass).call(this, exports.GFXObjectType.RENDER_PASS)))._colorInfos = [], 
            _this._depthStencilInfo = null, _this._device = device, _this;
        }
        return _inherits(GFXRenderPass, _GFXObject), GFXRenderPass;
    }(GFXObject), GFXSamplerState = function() {
        function GFXSamplerState() {
            _classCallCheck(this, GFXSamplerState), this.name = "", this.minFilter = exports.GFXFilter.LINEAR, 
            this.magFilter = exports.GFXFilter.LINEAR, this.mipFilter = exports.GFXFilter.NONE, 
            this.addressU = exports.GFXAddress.WRAP, this.addressV = exports.GFXAddress.WRAP, 
            this.addressW = exports.GFXAddress.WRAP, this.maxAnisotropy = 16, this.cmpFunc = exports.GFXComparisonFunc.NEVER, 
            this.borderColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            }, this.minLOD = 0, this.maxLOD = 0, this.mipLODBias = 0;
        }
        return _createClass(GFXSamplerState, [ {
            key: "compare",
            value: function compare(state) {
                return this.minFilter === state.minFilter && this.magFilter === state.magFilter && this.mipFilter === state.mipFilter && this.addressU === state.addressU && this.addressV === state.addressV && this.addressW === state.addressW && this.maxAnisotropy === state.maxAnisotropy && this.cmpFunc === state.cmpFunc && this.borderColor.r === state.borderColor.r && this.borderColor.g === state.borderColor.g && this.borderColor.b === state.borderColor.b && this.borderColor.a === state.borderColor.a && this.minLOD === state.minLOD && this.maxLOD === state.maxLOD && this.mipLODBias === state.mipLODBias;
            }
        } ]), GFXSamplerState;
    }(), GFXSampler = function(_GFXObject) {
        function GFXSampler(device) {
            var _this;
            return _classCallCheck(this, GFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXSampler).call(this, exports.GFXObjectType.SAMPLER)))._state = new GFXSamplerState, 
            _this._device = device, _this;
        }
        return _inherits(GFXSampler, _GFXObject), _createClass(GFXSampler, [ {
            key: "state",
            get: function get() {
                return this._state;
            }
        } ]), GFXSampler;
    }(GFXObject), GFXShader = function(_GFXObject) {
        function GFXShader(device) {
            var _this;
            return _classCallCheck(this, GFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXShader).call(this, exports.GFXObjectType.SHADER)))._name = "", 
            _this._stages = [], _this._blocks = [], _this._samplers = [], _this._device = device, 
            _this._id = device.genShaderId(), _this;
        }
        return _inherits(GFXShader, _GFXObject), _createClass(GFXShader, [ {
            key: "id",
            get: function get() {
                return this._id;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        } ]), GFXShader;
    }(GFXObject), GFXTexture = function(_GFXObject) {
        function GFXTexture(device) {
            var _this;
            return _classCallCheck(this, GFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXTexture).call(this, exports.GFXObjectType.TEXTURE)))._type = exports.GFXTextureType.TEX2D, 
            _this._usage = exports.GFXTextureUsageBit.NONE, _this._format = exports.GFXFormat.UNKNOWN, 
            _this._width = 0, _this._height = 0, _this._depth = 1, _this._arrayLayer = 1, _this._mipLevel = 1, 
            _this._samples = exports.GFXSampleCount.X1, _this._flags = exports.GFXTextureFlagBit.NONE, 
            _this._isPowerOf2 = !1, _this._size = 0, _this._buffer = null, _this._device = device, 
            _this;
        }
        return _inherits(GFXTexture, _GFXObject), _createClass(GFXTexture, [ {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "usage",
            get: function get() {
                return this._usage;
            }
        }, {
            key: "format",
            get: function get() {
                return this._format;
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        }, {
            key: "depth",
            get: function get() {
                return this._depth;
            }
        }, {
            key: "arrayLayer",
            get: function get() {
                return this._arrayLayer;
            }
        }, {
            key: "mipLevel",
            get: function get() {
                return this._mipLevel;
            }
        }, {
            key: "samples",
            get: function get() {
                return this._samples;
            }
        }, {
            key: "flags",
            get: function get() {
                return this._flags;
            }
        }, {
            key: "size",
            get: function get() {
                return this._size;
            }
        }, {
            key: "buffer",
            get: function get() {
                return this._buffer;
            }
        } ]), GFXTexture;
    }(GFXObject), GFXBindingLayout = function(_GFXObject) {
        function GFXBindingLayout(device) {
            var _this;
            return _classCallCheck(this, GFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXBindingLayout).call(this, exports.GFXObjectType.BINDING_LAYOUT)))._bindingUnits = [], 
            _this._isDirty = !1, _this._device = device, _this;
        }
        return _inherits(GFXBindingLayout, _GFXObject), _createClass(GFXBindingLayout, [ {
            key: "bindBuffer",
            value: function bindBuffer(binding, buffer) {
                var _iterator = this._bindingUnits, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var bindingUnit = _ref;
                    if (bindingUnit.binding === binding) return void (bindingUnit.type === exports.GFXBindingType.UNIFORM_BUFFER ? bindingUnit.buffer !== buffer && (bindingUnit.buffer = buffer, 
                    this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.UNIFORM_BUFFER."));
                }
            }
        }, {
            key: "bindSampler",
            value: function bindSampler(binding, sampler) {
                var _iterator2 = this._bindingUnits, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var bindingUnit = _ref2;
                    if (bindingUnit.binding === binding) return void (bindingUnit.type === exports.GFXBindingType.SAMPLER ? bindingUnit.sampler !== sampler && (bindingUnit.sampler = sampler, 
                    this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.SAMPLER."));
                }
            }
        }, {
            key: "bindTextureView",
            value: function bindTextureView(binding, texView) {
                var _iterator3 = this._bindingUnits, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var bindingUnit = _ref3;
                    if (bindingUnit.binding === binding) return void (bindingUnit.type === exports.GFXBindingType.SAMPLER ? bindingUnit.texView !== texView && (bindingUnit.texView = texView, 
                    this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.SAMPLER."));
                }
            }
        }, {
            key: "getBindingUnit",
            value: function getBindingUnit(binding) {
                var _iterator4 = this._bindingUnits, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var unit = _ref4;
                    if (unit.binding === binding) return unit;
                }
                return null;
            }
        } ]), GFXBindingLayout;
    }(GFXObject), GFXCommandAllocator = function(_GFXObject) {
        function GFXCommandAllocator(device) {
            var _this;
            return _classCallCheck(this, GFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXCommandAllocator).call(this, exports.GFXObjectType.COMMAND_ALLOCATOR)))._device = device, 
            _this;
        }
        return _inherits(GFXCommandAllocator, _GFXObject), GFXCommandAllocator;
    }(GFXObject), GFXWindow = function(_GFXObject) {
        function GFXWindow(device) {
            var _this;
            return _classCallCheck(this, GFXWindow), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXWindow).call(this, exports.GFXObjectType.WINDOW)))._title = "", 
            _this._left = 0, _this._top = 0, _this._width = 0, _this._height = 0, _this._nativeWidth = 0, 
            _this._nativeHeight = 0, _this._colorFmt = exports.GFXFormat.UNKNOWN, _this._depthStencilFmt = exports.GFXFormat.UNKNOWN, 
            _this._isOffscreen = !1, _this._renderPass = null, _this._colorTex = null, _this._colorTexView = null, 
            _this._depthStencilTex = null, _this._depthStencilTexView = null, _this._framebuffer = null, 
            _this._device = device, _this;
        }
        return _inherits(GFXWindow, _GFXObject), _createClass(GFXWindow, [ {
            key: "width",
            get: function get() {
                return this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        }, {
            key: "colorFormat",
            get: function get() {
                return this._colorFmt;
            }
        }, {
            key: "detphStencilFormat",
            get: function get() {
                return this._depthStencilFmt;
            }
        }, {
            key: "isOffscreen",
            get: function get() {
                return this._isOffscreen;
            }
        }, {
            key: "renderPass",
            get: function get() {
                return this._renderPass;
            }
        }, {
            key: "colorTexView",
            get: function get() {
                return this._colorTexView;
            }
        }, {
            key: "depthStencilTexView",
            get: function get() {
                return this._depthStencilTexView;
            }
        }, {
            key: "framebuffer",
            get: function get() {
                return this._framebuffer;
            }
        } ]), GFXWindow;
    }(GFXObject);
    cc.GFXDevice = GFXDevice, cc.GFXBuffer = GFXBuffer, cc.GFXTexture = GFXTexture, 
    cc.GFXTextureView = GFXTextureView, cc.GFXSampler = GFXSampler, cc.GFXShader = GFXShader, 
    cc.GFXInputAssembler = GFXInputAssembler, cc.GFXRenderPass = GFXRenderPass, cc.GFXFramebuffer = GFXFramebuffer, 
    cc.GFXPipelineLayout = GFXPipelineLayout, cc.GFXPipelineState = GFXPipelineState, 
    cc.GFXCommandBuffer = GFXCommandBuffer, cc.GFXQueue = GFXQueue, Object.assign(cc, GFXDefines);
    var phases, phaseNum, _type2reader, _type2writer, _type2default, _localBatched = new UBOLocalBatched, BatchedBuffer = function() {
        function BatchedBuffer(pass) {
            _classCallCheck(this, BatchedBuffer), this.batches = [], this.pass = pass;
        }
        return _createClass(BatchedBuffer, [ {
            key: "destroy",
            value: function destroy() {
                for (var i = 0; i < this.batches.length; ++i) {
                    for (var batch = this.batches[i], j = 0; j < batch.vbs.length; ++j) batch.vbs[j].destroy();
                    batch.vbIdx.destroy(), batch.ia.destroy(), batch.ubo.destroy();
                }
                this.batches.splice(0);
            }
        }, {
            key: "merge",
            value: function merge(subModel, ro, pso) {
                var flatBuffers = subModel.subMeshData.flatBuffers;
                if (0 !== flatBuffers.length) {
                    for (var vbSize = 0, vbIdxSize = 0, vbCount = flatBuffers[0].count, bindingLayout = pso.pipelineLayout.layouts[0], isBatchExist = !1, i = 0; i < this.batches.length; ++i) {
                        var batch = this.batches[i];
                        if (batch.vbs.length === flatBuffers.length && batch.mergeCount < UBOLocalBatched.BATCHING_COUNT) {
                            isBatchExist = !0;
                            for (var j = 0; j < batch.vbs.length; ++j) {
                                if (batch.vbs[j].stride !== flatBuffers[j].stride) {
                                    isBatchExist = !1;
                                    break;
                                }
                            }
                            if (isBatchExist) {
                                for (var _j = 0; _j < batch.vbs.length; ++_j) {
                                    var flatBuff = flatBuffers[_j], batchVB = batch.vbs[_j], vbBuf = batch.vbDatas[_j];
                                    (vbSize = (vbCount + batch.vbCount) * flatBuff.stride) > batchVB.size && (batchVB.resize(vbSize), 
                                    vbBuf = batch.vbDatas[_j] = new Uint8Array(batchVB.bufferView.buffer)), vbBuf.set(flatBuff.buffer, batch.vbCount * flatBuff.stride);
                                }
                                (vbIdxSize = 4 * (vbCount + batch.vbCount)) > batch.vbIdx.size && (batch.vbIdx.resize(vbIdxSize), 
                                batch.vbIdxData = new Float32Array(batch.vbIdx.bufferView.buffer));
                                var start = batch.vbCount, end = start + vbCount, vbIdxBuf = batch.vbIdxData, mergeCount = batch.mergeCount;
                                if (vbIdxBuf[start] !== mergeCount || vbIdxBuf[end - 1] !== mergeCount) for (var _j2 = start; _j2 < end; _j2++) vbIdxBuf[_j2] = mergeCount;
                                return Mat4.toArray(batch.uboData.view, ro.model.transform.worldMatrix, UBOLocalBatched.MAT_WORLDS_OFFSET + 16 * batch.mergeCount), 
                                batch.mergeCount || batch.pso === pso || (bindingLayout.bindBuffer(UBOLocalBatched.BLOCK.binding, batch.ubo), 
                                bindingLayout.update(), batch.pso = pso), ++batch.mergeCount, batch.vbCount += vbCount, 
                                void (batch.ia.vertexCount += vbCount);
                            }
                        }
                    }
                    for (var device = this.pass.device, vbs = [], vbDatas = [], totalVBS = [], _i = 0; _i < flatBuffers.length; ++_i) {
                        var _flatBuff = flatBuffers[_i], newVB = device.createBuffer({
                            usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                            size: _flatBuff.count * _flatBuff.stride,
                            stride: _flatBuff.stride,
                            flags: exports.GFXBufferFlagBit.BAKUP_BUFFER
                        });
                        newVB.update(_flatBuff.buffer.buffer), vbs.push(newVB), vbDatas.push(new Uint8Array(newVB.bufferView.buffer)), 
                        totalVBS.push(newVB);
                    }
                    var vbIdx = device.createBuffer({
                        usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                        size: 4 * vbCount,
                        stride: 4,
                        flags: exports.GFXBufferFlagBit.BAKUP_BUFFER
                    }), vbIndices = new Float32Array(vbCount);
                    vbIndices.fill(0), vbIdx.update(vbIndices), totalVBS.push(vbIdx);
                    for (var vbIdxData = new Float32Array(vbIdx.bufferView.buffer), attributes = subModel.inputAssembler.attributes, attrs = new Array(attributes.length + 1), a = 0; a < attributes.length; ++a) attrs[a] = attributes[a];
                    attrs[attributes.length] = {
                        name: "a_dyn_batch_id",
                        format: exports.GFXFormat.R32F,
                        stream: flatBuffers.length
                    };
                    var ia = device.createInputAssembler({
                        attributes: attrs,
                        vertexBuffers: totalVBS
                    }), ubo = this.pass.device.createBuffer({
                        usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                        size: UBOLocalBatched.SIZE
                    });
                    bindingLayout.bindBuffer(UBOLocalBatched.BLOCK.binding, ubo), bindingLayout.update();
                    var uboData = new UBOLocalBatched;
                    Mat4.toArray(uboData.view, ro.model.transform.worldMatrix, UBOLocalBatched.MAT_WORLDS_OFFSET), 
                    this.batches.push({
                        mergeCount: 1,
                        vbs: vbs,
                        vbDatas: vbDatas,
                        vbIdx: vbIdx,
                        vbIdxData: vbIdxData,
                        vbCount: vbCount,
                        ia: ia,
                        ubo: ubo,
                        uboData: uboData,
                        pso: pso
                    });
                }
            }
        }, {
            key: "clear",
            value: function clear() {
                for (var i = 0; i < this.batches.length; ++i) {
                    var batch = this.batches[i];
                    batch.vbCount = 0, batch.mergeCount = 0, batch.ia.vertexCount = 0;
                }
            }
        }, {
            key: "clearUBO",
            value: function clearUBO() {
                for (var i = 0; i < this.batches.length; ++i) {
                    this.batches[i].ubo.update(_localBatched.view.buffer);
                }
            }
        } ]), BatchedBuffer;
    }(), getPhaseID = (phases = new Map, phaseNum = 0, function(phaseName) {
        return "number" == typeof phaseName ? phaseName : (phases.has(phaseName) || (phases.set(phaseName, 1 << phaseNum), 
        phaseNum++), phases.get(phaseName));
    }), genHandle = function genHandle(bt, binding, type) {
        var offset = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        return bt << 28 & 4026531840 | type << 22 & 264241152 | binding << 14 & 4177920 | 16383 & offset;
    }, getBindingTypeFromHandle = function getBindingTypeFromHandle(handle) {
        return (4026531840 & handle) >>> 28;
    }, getTypeFromHandle = function getTypeFromHandle(handle) {
        return (264241152 & handle) >>> 22;
    }, getBindingFromHandle = function getBindingFromHandle(handle) {
        return (4177920 & handle) >>> 14;
    }, getOffsetFromHandle = function getOffsetFromHandle(handle) {
        return 16383 & handle;
    }, customizeType = function customizeType(handle, type) {
        return -264241153 & handle | type << 22 & 264241152;
    }, type2reader = (_defineProperty(_type2reader = {}, exports.GFXType.UNKNOWN, (function(a, v) {
        return console.warn("illegal uniform handle");
    })), _defineProperty(_type2reader, exports.GFXType.INT, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return a[idx];
    })), _defineProperty(_type2reader, exports.GFXType.INT2, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec2.fromArray(v, a, idx);
    })), _defineProperty(_type2reader, exports.GFXType.INT3, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec3.fromArray(v, a, idx);
    })), _defineProperty(_type2reader, exports.GFXType.INT4, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec4.fromArray(v, a, idx);
    })), _defineProperty(_type2reader, exports.GFXType.FLOAT, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return a[idx];
    })), _defineProperty(_type2reader, exports.GFXType.FLOAT2, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec2.fromArray(v, a, idx);
    })), _defineProperty(_type2reader, exports.GFXType.FLOAT3, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec3.fromArray(v, a, idx);
    })), _defineProperty(_type2reader, exports.GFXType.FLOAT4, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec4.fromArray(v, a, idx);
    })), _defineProperty(_type2reader, exports.GFXType.MAT3, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Mat3.fromArray(v, a, idx);
    })), _defineProperty(_type2reader, exports.GFXType.MAT4, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Mat4.fromArray(v, a, idx);
    })), _type2reader), type2writer = (_defineProperty(_type2writer = {}, exports.GFXType.UNKNOWN, (function(a, v) {
        return console.warn("illegal uniform handle");
    })), _defineProperty(_type2writer, exports.GFXType.INT, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return a[idx] = v;
    })), _defineProperty(_type2writer, exports.GFXType.INT2, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec2.toArray(a, v, idx);
    })), _defineProperty(_type2writer, exports.GFXType.INT3, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec3.toArray(a, v, idx);
    })), _defineProperty(_type2writer, exports.GFXType.INT4, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec4.toArray(a, v, idx);
    })), _defineProperty(_type2writer, exports.GFXType.FLOAT, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return a[idx] = v;
    })), _defineProperty(_type2writer, exports.GFXType.FLOAT2, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec2.toArray(a, v, idx);
    })), _defineProperty(_type2writer, exports.GFXType.FLOAT3, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec3.toArray(a, v, idx);
    })), _defineProperty(_type2writer, exports.GFXType.FLOAT4, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Vec4.toArray(a, v, idx);
    })), _defineProperty(_type2writer, exports.GFXType.MAT3, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Mat3.toArray(a, v, idx);
    })), _defineProperty(_type2writer, exports.GFXType.MAT4, (function(a, v) {
        var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return Mat4.toArray(a, v, idx);
    })), _type2writer), type2default = (_defineProperty(_type2default = {}, exports.GFXType.INT, [ 0 ]), 
    _defineProperty(_type2default, exports.GFXType.INT2, [ 0, 0 ]), _defineProperty(_type2default, exports.GFXType.INT3, [ 0, 0, 0 ]), 
    _defineProperty(_type2default, exports.GFXType.INT4, [ 0, 0, 0, 0 ]), _defineProperty(_type2default, exports.GFXType.FLOAT, [ 0 ]), 
    _defineProperty(_type2default, exports.GFXType.FLOAT2, [ 0, 0 ]), _defineProperty(_type2default, exports.GFXType.FLOAT3, [ 0, 0, 0 ]), 
    _defineProperty(_type2default, exports.GFXType.FLOAT4, [ 0, 0, 0, 0 ]), _defineProperty(_type2default, exports.GFXType.MAT3, [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), 
    _defineProperty(_type2default, exports.GFXType.MAT4, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]), 
    _defineProperty(_type2default, exports.GFXType.SAMPLER2D, "default-texture"), _defineProperty(_type2default, exports.GFXType.SAMPLER_CUBE, "default-cube-texture"), 
    _type2default);
    function assignDefines(target, source) {
        for (var entries = Object.entries(source), isDifferent = !1, i = 0; i < entries.length; i++) target[entries[i][0]] !== entries[i][1] && (target[entries[i][0]] = entries[i][1], 
        isDifferent = !0);
        return isDifferent;
    }
    function getBitCount(cnt) {
        return Math.ceil(Math.log2(Math.max(cnt, 2)));
    }
    function mapDefine(info, def) {
        switch (info.type) {
          case "boolean":
            return ("number" == typeof def ? def : def ? 1 : 0) + "";

          case "string":
            return void 0 !== def ? def : info.options[0];

          case "number":
            return (void 0 !== def ? def : info.range[0]) + "";
        }
        return console.warn("unknown define type '".concat(info.type, "'")), "-1";
    }
    function getShaderInstanceName(name, macros) {
        return name + macros.reduce((function(acc, cur) {
            return cur.isDefault ? acc : "".concat(acc, "|").concat(cur.name).concat(cur.value);
        }), "");
    }
    function insertBuiltinBindings(tmpl, source, type) {
        var target = tmpl.builtins[type], blocks = tmpl.blocks, _iterator2 = target.blocks, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
            var _ref2;
            if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
            } else {
                if ((_i2 = _iterator2.next()).done) break;
                _ref2 = _i2.value;
            }
            var b = _ref2, info = source.get(b.name);
            if (info && info.type === exports.GFXBindingType.UNIFORM_BUFFER) {
                var builtin = Object.assign({
                    defines: b.defines,
                    size: getSize(info.blockInfo),
                    bindingType: exports.GFXBindingType.UNIFORM_BUFFER
                }, info.blockInfo);
                blocks.push(builtin);
            } else console.warn("builtin UBO '".concat(b.name, "' not available!"));
        }
        var samplers = tmpl.samplers, _iterator3 = target.samplers, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
            var _ref3;
            if (_isArray3) {
                if (_i3 >= _iterator3.length) break;
                _ref3 = _iterator3[_i3++];
            } else {
                if ((_i3 = _iterator3.next()).done) break;
                _ref3 = _i3.value;
            }
            var s = _ref3, _info = source.get(s.name);
            if (_info && _info.type === exports.GFXBindingType.SAMPLER) {
                var _builtin = Object.assign({
                    defines: s.defines,
                    bindingType: exports.GFXBindingType.SAMPLER
                }, _info.samplerInfo);
                samplers.push(_builtin);
            } else console.warn("builtin sampler '".concat(s.name, "' not available!"));
        }
    }
    function getSize(block) {
        return block.members.reduce((function(s, m) {
            return s + GFXGetTypeSize(m.type) * m.count;
        }), 0);
    }
    function dependencyCheck(dependencies, defines) {
        for (var i = 0; i < dependencies.length; i++) if (!defines[dependencies[i]]) return !1;
        return !0;
    }
    var programLib = new (function() {
        function ProgramLib() {
            _classCallCheck(this, ProgramLib), this._templates = {}, this._cache = {};
        }
        return _createClass(ProgramLib, [ {
            key: "define",
            value: function define(prog) {
                var curTmpl = this._templates[prog.name];
                if (!curTmpl || curTmpl.hash !== prog.hash) {
                    var tmpl = prog, offset = 0, _loop = function _loop() {
                        if (_isArray4) {
                            if (_i6 >= _iterator4.length) return "break";
                            _ref4 = _iterator4[_i6++];
                        } else {
                            if ((_i6 = _iterator4.next()).done) return "break";
                            _ref4 = _i6.value;
                        }
                        var def = _ref4, cnt = 1;
                        if ("number" === def.type) {
                            var range = def.range;
                            cnt = getBitCount(range[1] - range[0] + 1), def._map = function(value) {
                                return value - range[0];
                            };
                        } else "string" === def.type ? (cnt = getBitCount(def.options.length), def._map = function(value) {
                            return Math.max(0, def.options.findIndex((function(s) {
                                return s === value;
                            })));
                        }) : "boolean" === def.type && (def._map = function(value) {
                            return value ? 1 : 0;
                        });
                        def._offset = offset, offset += cnt;
                    }, _iterator4 = tmpl.defines, _isArray4 = Array.isArray(_iterator4), _i6 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if ("break" === _loop()) break;
                    }
                    offset > 31 && (tmpl.uber = !0), tmpl.blocks.forEach((function(b) {
                        return b.size = getSize(b), b.bindingType = exports.GFXBindingType.UNIFORM_BUFFER;
                    })), tmpl.samplers.forEach((function(s) {
                        return s.bindingType = exports.GFXBindingType.SAMPLER;
                    })), tmpl.handleMap = function genHandles(tmpl) {
                        for (var handleMap = {}, i = 0; i < tmpl.blocks.length; i++) for (var block = tmpl.blocks[i], members = block.members, offset = 0, j = 0; j < members.length; j++) {
                            var uniform = members[j];
                            handleMap[uniform.name] = genHandle(exports.GFXBindingType.UNIFORM_BUFFER, block.binding, uniform.type, offset), 
                            offset += (GFXGetTypeSize(uniform.type) >> 2) * uniform.count;
                        }
                        for (var _i4 = 0; _i4 < tmpl.samplers.length; _i4++) {
                            var sampler = tmpl.samplers[_i4];
                            handleMap[sampler.name] = genHandle(exports.GFXBindingType.SAMPLER, sampler.binding, sampler.type);
                        }
                        return handleMap;
                    }(tmpl), tmpl.localsInited || (insertBuiltinBindings(tmpl, localBindingsDesc, "locals"), 
                    tmpl.localsInited = !0), this._templates[prog.name] = tmpl;
                }
            }
        }, {
            key: "getTemplate",
            value: function getTemplate(name) {
                return this._templates[name];
            }
        }, {
            key: "hasProgram",
            value: function hasProgram(name) {
                return void 0 !== this._templates[name];
            }
        }, {
            key: "getKey",
            value: function getKey(name, defines) {
                var tmpl = this._templates[name], tmplDefs = tmpl.defines;
                if (tmpl.uber) {
                    for (var key = "", i = 0; i < tmplDefs.length; i++) {
                        var tmplDef = tmplDefs[i], _value2 = defines[tmplDef.name];
                        if (void 0 !== _value2 && tmplDef._map) {
                            var mapped = tmplDef._map(_value2);
                            key += tmplDef._offset + (mapped + "|");
                        }
                    }
                    return key + tmpl.hash;
                }
                for (var _key = 0, _i7 = 0; _i7 < tmplDefs.length; _i7++) {
                    var _tmplDef = tmplDefs[_i7], _value3 = defines[_tmplDef.name];
                    if (void 0 !== _value3 && _tmplDef._map) _key |= _tmplDef._map(_value3) << _tmplDef._offset;
                }
                return "".concat(_key.toString(16), "|").concat(tmpl.hash);
            }
        }, {
            key: "destroyShaderByDefines",
            value: function destroyShaderByDefines(defines) {
                var _this = this, names = Object.keys(defines);
                if (names.length) {
                    var regexes = names.map((function(cur) {
                        var val = defines[cur];
                        return "boolean" == typeof val && (val = val ? "1" : "0"), new RegExp(cur + val);
                    })), _iterator5 = Object.keys(this._cache).filter((function(k) {
                        return regexes.every((function(re) {
                            return re.test(_this._cache[k].shader.name);
                        }));
                    })), _isArray5 = Array.isArray(_iterator5), _i8 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i8 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i8++];
                        } else {
                            if ((_i8 = _iterator5.next()).done) break;
                            _ref5 = _i8.value;
                        }
                        var k = _ref5, prog = this._cache[k].shader;
                        console.log("destroyed shader ".concat(prog.name)), prog.destroy(), delete this._cache[k];
                    }
                }
            }
        }, {
            key: "getGFXShader",
            value: function getGFXShader(device, name, defines, pipeline) {
                Object.assign(defines, pipeline.macros), defines.USE_SKINNING && (defines.USE_SKINNING = selectJointsMediumType(device));
                var key = this.getKey(name, defines), res = this._cache[key];
                if (res) return res;
                var tmpl = this._templates[name];
                tmpl.globalsInited || (insertBuiltinBindings(tmpl, pipeline.globalBindings, "globals"), 
                tmpl.globalsInited = !0);
                var macroArray = function prepareDefines(defs, tDefs) {
                    var macros = [], _iterator = tDefs, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var tmpl = _ref, name = tmpl.name, v = defs[name], _value = mapDefine(tmpl, v), isDefault = !v || "0" === v;
                        macros.push({
                            name: name,
                            value: _value,
                            isDefault: isDefault
                        });
                    }
                    return macros;
                }(defines, tmpl.defines), prefix = macroArray.reduce((function(acc, cur) {
                    return "".concat(acc, "#define ").concat(cur.name, " ").concat(cur.value, "\n");
                }), "") + "\n", src = tmpl.glsl3;
                switch (device.gfxAPI) {
                  case exports.GFXAPI.WEBGL2:
                    src = tmpl.glsl3;
                    break;

                  default:
                    src = tmpl.glsl1;
                }
                var blocks = [], samplers = [], bindings = [];
                !function getShaderBindings(tmpl, defines, outBlocks, outSamplers, bindings) {
                    for (var blocks = tmpl.blocks, samplers = tmpl.samplers, lastBinding = -1, i = 0; i < blocks.length; i++) {
                        var block = blocks[i];
                        block.binding !== lastBinding && dependencyCheck(block.defines, defines) && (lastBinding = block.binding, 
                        outBlocks.push(block), bindings.push(block));
                    }
                    for (var _i5 = 0; _i5 < samplers.length; _i5++) {
                        var sampler = samplers[_i5];
                        sampler.binding !== lastBinding && dependencyCheck(sampler.defines, defines) && (lastBinding = sampler.binding, 
                        outSamplers.push(sampler), bindings.push(sampler));
                    }
                }(tmpl, defines, blocks, samplers, bindings);
                var shader = device.createShader({
                    name: getShaderInstanceName(name, macroArray),
                    blocks: blocks,
                    samplers: samplers,
                    stages: [ {
                        type: exports.GFXShaderType.VERTEX,
                        source: prefix + src.vert
                    }, {
                        type: exports.GFXShaderType.FRAGMENT,
                        source: prefix + src.frag
                    } ]
                });
                return this._cache[key] = {
                    shader: shader,
                    bindings: bindings
                };
            }
        } ]), ProgramLib;
    }());
    cc.programLib = programLib;
    var _class$h, _class2$e, _descriptor$c, _descriptor2$8, _descriptor3$6, _class3$a, _temp$f, _bfInfo = {
        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
        size: 0,
        usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST
    }, _blInfo = {
        bindings: null
    }, _plInfo = {
        layouts: null
    }, _psoInfo = {
        primitive: 0,
        shader: null,
        inputState: new GFXInputState,
        rasterizerState: null,
        depthStencilState: null,
        blendState: null,
        dynamicStates: null,
        layout: null,
        renderPass: null,
        hash: 0,
        program: "",
        defines: null,
        stage: 0
    }, Pass = function() {
        function Pass(device) {
            _classCallCheck(this, Pass), this._buffers = {}, this._samplers = {}, this._textureViews = {}, 
            this._resources = [], this._phase = getPhaseID("default"), this._idxInTech = 0, 
            this._programName = "", this._priority = RenderPriority.DEFAULT, this._primitive = exports.GFXPrimitiveMode.TRIANGLE_LIST, 
            this._stage = exports.RenderPassStage.DEFAULT, this._bindings = [], this._bs = new GFXBlendState, 
            this._dss = new GFXDepthStencilState, this._rs = new GFXRasterizerState, this._dynamicStates = [], 
            this._dynamics = {}, this._customizations = [], this._handleMap = {}, this._blocks = [], 
            this._shaderInfo = null, this._defines = {}, this._properties = {}, this._hash = 0, 
            this._renderPass = null, this._shader = null, this._batchedBuffer = null, this._device = device;
        }
        return _createClass(Pass, null, [ {
            key: "fillinPipelineInfo",
            value: function fillinPipelineInfo(target, info) {
                void 0 !== info.priority && (target._priority = info.priority), void 0 !== info.primitive && (target._primitive = info.primitive), 
                void 0 !== info.stage && (target._stage = info.stage), void 0 !== info.dynamicStates && (target._dynamicStates = info.dynamicStates), 
                info.customizations && (target._customizations = info.customizations), info.phase && (target._phase = getPhaseID(info.phase));
                var bs = target._bs;
                if (info.blendState) {
                    var bsInfo = Object.assign({}, info.blendState);
                    bsInfo.targets && bsInfo.targets.forEach((function(t, i) {
                        return Object.assign(bs.targets[i] || (bs.targets[i] = new GFXBlendTarget), t);
                    })), delete bsInfo.targets, Object.assign(bs, bsInfo);
                }
                Object.assign(target._rs, info.rasterizerState), Object.assign(target._dss, info.depthStencilState);
            }
        }, {
            key: "getPSOHash",
            value: function getPSOHash(psoInfo) {
                var shaderKey = programLib.getKey(psoInfo.program, psoInfo.defines), res = "".concat(shaderKey, ",").concat(psoInfo.stage, ",").concat(psoInfo.primitive);
                return res += function serializeBlendState(bs) {
                    var res = ",bs,".concat(bs.isA2C, ",").concat(bs.blendColor), _iterator6 = bs.targets, _isArray6 = Array.isArray(_iterator6), _i7 = 0;
                    for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                        var _ref6;
                        if (_isArray6) {
                            if (_i7 >= _iterator6.length) break;
                            _ref6 = _iterator6[_i7++];
                        } else {
                            if ((_i7 = _iterator6.next()).done) break;
                            _ref6 = _i7.value;
                        }
                        var t = _ref6;
                        res += ",bt,".concat(t.blend, ",").concat(t.blendEq, ",").concat(t.blendAlphaEq, ",").concat(t.blendColorMask), 
                        res += ",".concat(t.blendSrc, ",").concat(t.blendDst, ",").concat(t.blendSrcAlpha, ",").concat(t.blendDstAlpha);
                    }
                    return res;
                }(psoInfo.blendState), res += function serializeDepthStencilState(dss) {
                    var res = ",dss,".concat(dss.depthTest, ",").concat(dss.depthWrite, ",").concat(dss.depthFunc);
                    return res += ",".concat(dss.stencilTestFront, ",").concat(dss.stencilFuncFront, ",").concat(dss.stencilRefFront, ",").concat(dss.stencilReadMaskFront), 
                    res += ",".concat(dss.stencilFailOpFront, ",").concat(dss.stencilZFailOpFront, ",").concat(dss.stencilPassOpFront, ",").concat(dss.stencilWriteMaskFront), 
                    res += ",".concat(dss.stencilTestBack, ",").concat(dss.stencilFuncBack, ",").concat(dss.stencilRefBack, ",").concat(dss.stencilReadMaskBack), 
                    res += ",".concat(dss.stencilFailOpBack, ",").concat(dss.stencilZFailOpBack, ",").concat(dss.stencilPassOpBack, ",").concat(dss.stencilWriteMaskBack);
                }(psoInfo.depthStencilState), murmurhash2_32_gc(res += function serializeRasterizerState(rs) {
                    return ",rs,".concat(rs.cullMode, ",").concat(rs.depthBias, ",").concat(rs.isFrontFaceCCW);
                }(psoInfo.rasterizerState), 666);
            }
        } ]), _createClass(Pass, [ {
            key: "initialize",
            value: function initialize(info) {
                this._doInit(info), this.resetUBOs(), this.resetTextures();
            }
        }, {
            key: "getHandle",
            value: function getHandle(name) {
                var offset = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, targetType = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : exports.GFXType.UNKNOWN, handle = this._handleMap[name];
                if (handle) return targetType ? handle = customizeType(handle, targetType) : offset && (handle = customizeType(handle, getTypeFromHandle(handle) - offset)), 
                handle + offset;
            }
        }, {
            key: "getBinding",
            value: function getBinding(name) {
                var handle = this.getHandle(name);
                if (void 0 !== handle) return Pass.getBindingFromHandle(handle);
            }
        }, {
            key: "setUniform",
            value: function setUniform(handle, value) {
                var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), ofs = Pass.getOffsetFromHandle(handle), block = this._blocks[binding];
                type2writer[type](block.view, value, ofs), block.dirty = !0;
            }
        }, {
            key: "getUniform",
            value: function getUniform(handle, out) {
                var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), ofs = Pass.getOffsetFromHandle(handle), block = this._blocks[binding];
                return type2reader[type](block.view, out, ofs);
            }
        }, {
            key: "setUniformArray",
            value: function setUniformArray(handle, value) {
                for (var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), stride = GFXGetTypeSize(type) >> 2, block = this._blocks[binding], ofs = Pass.getOffsetFromHandle(handle), i = 0; i < value.length; i++, 
                ofs += stride) null !== value[i] && type2writer[type](block.view, value[i], ofs);
                block.dirty = !0;
            }
        }, {
            key: "bindBuffer",
            value: function bindBuffer(binding, value) {
                if (this._buffers[binding] !== value) {
                    this._buffers[binding] = value;
                    for (var len = this._resources.length, i = 0; i < len; i++) {
                        this._resources[i].bindingLayout.bindBuffer(binding, value);
                    }
                }
            }
        }, {
            key: "bindTextureView",
            value: function bindTextureView(binding, value) {
                if (this._textureViews[binding] !== value) {
                    this._textureViews[binding] = value;
                    for (var len = this._resources.length, i = 0; i < len; i++) {
                        this._resources[i].bindingLayout.bindTextureView(binding, value);
                    }
                }
            }
        }, {
            key: "bindSampler",
            value: function bindSampler(binding, value) {
                if (this._samplers[binding] !== value) {
                    this._samplers[binding] = value;
                    for (var len = this._resources.length, i = 0; i < len; i++) {
                        this._resources[i].bindingLayout.bindSampler(binding, value);
                    }
                }
            }
        }, {
            key: "setDynamicState",
            value: function setDynamicState(state, value) {
                var ds = this._dynamics[state];
                ds && ds.value === value || (ds.value = value, ds.dirty = !0);
            }
        }, {
            key: "overridePipelineStates",
            value: function overridePipelineStates(original, overrides) {
                console.warn("base pass cannot override states, please use pass instance instead.");
            }
        }, {
            key: "update",
            value: function update() {
                for (var len = this._blocks.length, i = 0; i < len; i++) {
                    var block = this._blocks[i];
                    block.dirty && (this._buffers[i].update(block.buffer), block.dirty = !1);
                }
                for (var source = cc.director.root.pipeline.globalBindings, target = this._shaderInfo.builtins.globals, samplerLen = target.samplers.length, _i = 0; _i < samplerLen; _i++) {
                    var s = target.samplers[_i], info = source.get(s.name);
                    info.sampler && this.bindSampler(info.samplerInfo.binding, info.sampler), this.bindTextureView(info.samplerInfo.binding, info.textureView);
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var _iterator = this._shaderInfo.blocks, _isArray = Array.isArray(_iterator), _i2 = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i2 >= _iterator.length) break;
                        _ref = _iterator[_i2++];
                    } else {
                        if ((_i2 = _iterator.next()).done) break;
                        _ref = _i2.value;
                    }
                    var u = _ref;
                    isBuiltinBinding(u.binding) || this._buffers[u.binding].destroy();
                }
                this._buffers = {}, this._samplers = {}, this._textureViews = {}, this._batchedBuffer && (this._batchedBuffer.destroy(), 
                this._batchedBuffer = null);
            }
        }, {
            key: "resetUBOs",
            value: function resetUBOs() {
                var _iterator2 = this._shaderInfo.blocks, _isArray2 = Array.isArray(_iterator2), _i3 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i3 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i3++];
                    } else {
                        if ((_i3 = _iterator2.next()).done) break;
                        _ref2 = _i3.value;
                    }
                    var u = _ref2;
                    if (!isBuiltinBinding(u.binding)) {
                        for (var block = this._blocks[u.binding], ofs = 0, i = 0; i < u.members.length; i++) {
                            for (var cur = u.members[i], inf = this._properties[cur.name], givenDefault = inf && inf.value, value = givenDefault || type2default[cur.type], stride = GFXGetTypeSize(cur.type) >> 2, j = 0; j < cur.count; j++) block.view.set(value, ofs + j * stride);
                            ofs += stride * cur.count;
                        }
                        block.dirty = !0;
                    }
                }
            }
        }, {
            key: "resetTextures",
            value: function resetTextures() {
                var _iterator3 = this._shaderInfo.samplers, _isArray3 = Array.isArray(_iterator3), _i4 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i4 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i4++];
                    } else {
                        if ((_i4 = _iterator3.next()).done) break;
                        _ref3 = _i4.value;
                    }
                    var u = _ref3;
                    if (!isBuiltinBinding(u.binding)) {
                        var inf = this._properties[u.name], texName = inf && inf.value ? inf.value + "-texture" : type2default[u.type], texture = builtinResMgr.get(texName), textureView = texture && texture.getGFXTextureView();
                        if (textureView) {
                            this._textureViews[u.binding] = textureView;
                            for (var samplerHash = inf && void 0 !== inf.samplerHash ? inf.samplerHash : texture.getSamplerHash(), sampler = this._samplers[u.binding] = samplerLib.getSampler(this._device, samplerHash), i = 0; i < this._resources.length; i++) {
                                var res = this._resources[i];
                                res.bindingLayout.bindSampler(u.binding, sampler), res.bindingLayout.bindTextureView(u.binding, textureView);
                            }
                        } else console.warn("illegal texture default value: " + texName);
                    }
                }
            }
        }, {
            key: "tryCompile",
            value: function tryCompile() {
                this._defines.USE_BATCHING && this.createBatchedBuffer();
                var pipeline = cc.director.root.pipeline;
                if (!pipeline) return null;
                if (this._renderPass = pipeline.getRenderPass(this._stage), !this._renderPass) return console.warn("illegal pass stage."), 
                !1;
                var res = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline);
                return res.shader ? (this._shader = res.shader, this._bindings = res.bindings, !0) : (console.warn("create shader ".concat(this._programName, " failed")), 
                !1);
            }
        }, {
            key: "createPipelineState",
            value: function createPipelineState() {
                if (!(this._renderPass && this._shader && this._bindings.length || this.tryCompile())) return console.warn("pass resources not complete, create PSO failed"), 
                null;
                var shader = this._shader;
                _blInfo.bindings = this._bindings;
                var bindingLayout = this._device.createBindingLayout(_blInfo);
                for (var b in this._buffers) bindingLayout.bindBuffer(parseInt(b), this._buffers[b]);
                for (var s in this._samplers) bindingLayout.bindSampler(parseInt(s), this._samplers[s]);
                for (var t in this._textureViews) bindingLayout.bindTextureView(parseInt(t), this._textureViews[t]);
                var source = cc.director.root.pipeline.globalBindings, target = this._shaderInfo.builtins.globals, _iterator4 = target.blocks, _isArray4 = Array.isArray(_iterator4), _i5 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i5 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i5++];
                    } else {
                        if ((_i5 = _iterator4.next()).done) break;
                        _ref4 = _i5.value;
                    }
                    var _b = _ref4, info = source.get(_b.name);
                    info && info.type === exports.GFXBindingType.UNIFORM_BUFFER ? bindingLayout.bindBuffer(info.blockInfo.binding, info.buffer) : console.warn("builtin UBO '".concat(_b.name, "' not available!"));
                }
                var _iterator5 = target.samplers, _isArray5 = Array.isArray(_iterator5), _i6 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i6 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i6++];
                    } else {
                        if ((_i6 = _iterator5.next()).done) break;
                        _ref5 = _i6.value;
                    }
                    var _s = _ref5, _info = source.get(_s.name);
                    _info && _info.type === exports.GFXBindingType.SAMPLER ? (_info.sampler && bindingLayout.bindSampler(_info.samplerInfo.binding, _info.sampler), 
                    bindingLayout.bindTextureView(_info.samplerInfo.binding, _info.textureView)) : console.warn("builtin texture '".concat(_s.name, "' not available!"));
                }
                _plInfo.layouts = [ bindingLayout ];
                var pipelineLayout = this._device.createPipelineLayout(_plInfo);
                _psoInfo.primitive = this._primitive, _psoInfo.shader = shader, _psoInfo.rasterizerState = this._rs, 
                _psoInfo.depthStencilState = this._dss, _psoInfo.blendState = this._bs, _psoInfo.dynamicStates = this._dynamicStates, 
                _psoInfo.layout = pipelineLayout, _psoInfo.renderPass = this._renderPass, _psoInfo.program = this._programName, 
                _psoInfo.defines = this._defines, _psoInfo.stage = this._stage, _psoInfo.hash = this._hash;
                var pipelineState = this._device.createPipelineState(_psoInfo);
                return this._resources.push({
                    bindingLayout: bindingLayout,
                    pipelineLayout: pipelineLayout,
                    pipelineState: pipelineState
                }), pipelineState;
            }
        }, {
            key: "destroyPipelineState",
            value: function destroyPipelineState(pipelineStates) {
                var idx = this._resources.findIndex((function(res) {
                    return res.pipelineState === pipelineStates;
                }));
                if (idx >= 0) {
                    var _this$_resources$idx = this._resources[idx], bl = _this$_resources$idx.bindingLayout, pl = _this$_resources$idx.pipelineLayout, ps = _this$_resources$idx.pipelineState;
                    bl.destroy(), pl.destroy(), ps.destroy(), this._resources.splice(idx, 1);
                }
            }
        }, {
            key: "createBatchedBuffer",
            value: function createBatchedBuffer() {
                this._batchedBuffer || (this._bs.targets[0].blend ? console.error("Transparent pass(" + this.program + ") can't use dynamic batching!") : this._batchedBuffer = new BatchedBuffer(this));
            }
        }, {
            key: "beginChangeStatesSilently",
            value: function beginChangeStatesSilently() {}
        }, {
            key: "endChangeStatesSilently",
            value: function endChangeStatesSilently() {}
        }, {
            key: "_doInit",
            value: function _doInit(info) {
                this._idxInTech = info.idxInTech, this._programName = info.program, this._defines = info.defines, 
                this._shaderInfo = programLib.getTemplate(info.program), this._properties = info.properties || this._properties;
                var device = this._device;
                Pass.fillinPipelineInfo(this, info), info.stateOverrides && Pass.fillinPipelineInfo(this, info.stateOverrides), 
                this._hash = Pass.getPSOHash(this);
                for (var blocks = this._shaderInfo.blocks, i = 0; i < blocks.length; i++) {
                    var _blocks$i = blocks[i], size = _blocks$i.size, binding = _blocks$i.binding;
                    if (!isBuiltinBinding(binding)) {
                        _bfInfo.size = 16 * Math.ceil(size / 16), this._buffers[binding] = device.createBuffer(_bfInfo);
                        var buffer = new ArrayBuffer(size);
                        this._blocks[binding] = {
                            buffer: buffer,
                            dirty: !1,
                            view: new Float32Array(buffer)
                        };
                    }
                }
                var directHandleMap = this._handleMap = this._shaderInfo.handleMap, indirectHandleMap = {};
                for (var name in this._properties) {
                    var prop = this._properties[name];
                    prop.handleInfo && (indirectHandleMap[name] = this.getHandle.apply(this, prop.handleInfo));
                }
                Object.assign(directHandleMap, indirectHandleMap), this.tryCompile();
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            }
        }, {
            key: "primitive",
            get: function get() {
                return this._primitive;
            }
        }, {
            key: "stage",
            get: function get() {
                return this._stage;
            }
        }, {
            key: "rasterizerState",
            get: function get() {
                return this._rs;
            }
        }, {
            key: "depthStencilState",
            get: function get() {
                return this._dss;
            }
        }, {
            key: "blendState",
            get: function get() {
                return this._bs;
            }
        }, {
            key: "dynamicStates",
            get: function get() {
                return this._dynamicStates;
            }
        }, {
            key: "customizations",
            get: function get() {
                return this._customizations;
            }
        }, {
            key: "phase",
            get: function get() {
                return this._phase;
            }
        }, {
            key: "device",
            get: function get() {
                return this._device;
            }
        }, {
            key: "shaderInfo",
            get: function get() {
                return this._shaderInfo;
            }
        }, {
            key: "program",
            get: function get() {
                return this._programName;
            }
        }, {
            key: "properties",
            get: function get() {
                return this._properties;
            }
        }, {
            key: "defines",
            get: function get() {
                return this._defines;
            }
        }, {
            key: "idxInTech",
            get: function get() {
                return this._idxInTech;
            }
        }, {
            key: "bindings",
            get: function get() {
                return this._bindings;
            }
        }, {
            key: "shader",
            get: function get() {
                return this._shader;
            }
        }, {
            key: "renderPass",
            get: function get() {
                return this._renderPass;
            }
        }, {
            key: "dynamics",
            get: function get() {
                return this._dynamics;
            }
        }, {
            key: "batchedBuffer",
            get: function get() {
                return this._batchedBuffer;
            }
        }, {
            key: "blocks",
            get: function get() {
                return this._blocks;
            }
        }, {
            key: "hash",
            get: function get() {
                return this._hash;
            }
        } ]), Pass;
    }();
    Pass.getBindingTypeFromHandle = getBindingTypeFromHandle, Pass.getTypeFromHandle = getTypeFromHandle, 
    Pass.getBindingFromHandle = getBindingFromHandle, Pass.getOffsetFromHandle = getOffsetFromHandle;
    var _dec$i, _dec2$9, _class$i, _class2$f, _descriptor$d, _descriptor2$9, _descriptor3$7, _descriptor4$4, _descriptor5$4, effects$1 = {}, EffectAsset = ccclass("cc.EffectAsset")((_temp$f = _class3$a = function(_Asset) {
        function EffectAsset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, EffectAsset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EffectAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "techniques", _descriptor$c, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "shaders", _descriptor2$8, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "combinations", _descriptor3$6, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(EffectAsset, _Asset), _createClass(EffectAsset, [ {
            key: "onLoaded",
            value: function onLoaded() {
                this.shaders.forEach((function(s) {
                    return programLib.define(s);
                })), cc.game.once(cc.Game.EVENT_ENGINE_INITED, this._precompile, this), EffectAsset.register(this);
            }
        }, {
            key: "_precompile",
            value: function _precompile() {
                for (var _this2 = this, root = cc.director.root, _loop = function _loop(i) {
                    var shader = _this2.shaders[i], combination = _this2.combinations[i];
                    if (!combination) return "continue";
                    Object.keys(combination).reduce((function(out, name) {
                        return out.reduce((function(acc, cur) {
                            var choices = combination[name], next = [ cur ].concat(_toConsumableArray(Array(choices.length - 1)).map((function() {
                                return Object.assign({}, cur);
                            })));
                            return next.forEach((function(defines, idx) {
                                return defines[name] = choices[idx];
                            })), acc.concat(next);
                        }), []);
                    }), [ {} ]).forEach((function(defines) {
                        return programLib.getGFXShader(root.device, shader.name, defines, root.pipeline);
                    }));
                }, i = 0; i < this.shaders.length; i++) _loop(i);
            }
        } ], [ {
            key: "register",
            value: function register(asset) {
                effects$1[asset.name] = asset;
            }
        }, {
            key: "remove",
            value: function remove(name) {
                if (effects$1[name]) delete effects$1[name]; else for (var n in effects$1) if (effects$1[n]._uuid === name) return void delete effects$1[n];
            }
        }, {
            key: "get",
            value: function get(name) {
                if (effects$1[name]) return effects$1[name];
                for (var n in effects$1) if (effects$1[n]._uuid === name) return effects$1[n];
                return null;
            }
        }, {
            key: "getAll",
            value: function getAll() {
                return effects$1;
            }
        } ]), EffectAsset;
    }(Asset), _class3$a._effects = {}, _descriptor$c = _applyDecoratedDescriptor((_class2$e = _temp$f).prototype, "techniques", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$8 = _applyDecoratedDescriptor(_class2$e.prototype, "shaders", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor3$6 = _applyDecoratedDescriptor(_class2$e.prototype, "combinations", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$h = _class2$e)) || _class$h;
    cc.EffectAsset = EffectAsset;
    var Material = (_dec$i = ccclass("cc.Material"), _dec2$9 = property(EffectAsset), 
    _dec$i((_descriptor$d = _applyDecoratedDescriptor((_class2$f = function(_Asset) {
        function Material() {
            var _this;
            return _classCallCheck(this, Material), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Material).call(this)), "_effectAsset", _descriptor$d, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_techIdx", _descriptor2$9, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_defines", _descriptor3$7, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_states", _descriptor4$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_props", _descriptor5$4, _assertThisInitialized(_this)), 
            _this._passes = [], _this._hash = 0, _this.loaded = !1, _this;
        }
        return _inherits(Material, _Asset), _createClass(Material, [ {
            key: "effectAsset",
            get: function get() {
                return this._effectAsset;
            }
        }, {
            key: "effectName",
            get: function get() {
                return this._effectAsset ? this._effectAsset.name : "";
            }
        }, {
            key: "technique",
            get: function get() {
                return this._techIdx;
            }
        }, {
            key: "passes",
            get: function get() {
                return this._passes;
            }
        }, {
            key: "hash",
            get: function get() {
                return this._hash;
            }
        }, {
            key: "parent",
            get: function get() {
                return null;
            }
        }, {
            key: "owner",
            get: function get() {
                return null;
            }
        } ], [ {
            key: "getHash",
            value: function getHash(material) {
                var str = "", _iterator = material.passes, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    str += _ref.hash;
                }
                return murmurhash2_32_gc(str, 666);
            }
        } ]), _createClass(Material, [ {
            key: "initialize",
            value: function initialize(info) {
                this._defines || (this._defines = []), this._states || (this._states = []), this._props || (this._props = []), 
                void 0 !== info.technique && (this._techIdx = info.technique), info.effectAsset ? this._effectAsset = info.effectAsset : info.effectName && (this._effectAsset = EffectAsset.get(info.effectName)), 
                info.defines && this._prepareInfo(info.defines, this._defines), info.states && this._prepareInfo(info.states, this._states), 
                this._update();
            }
        }, {
            key: "reset",
            value: function reset(info) {
                this.initialize(info);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this._doDestroy(), _get(_getPrototypeOf(Material.prototype), "destroy", this).call(this);
            }
        }, {
            key: "recompileShaders",
            value: function recompileShaders(overrides, passIdx) {
                console.warn("Shaders in material asset '" + this.name + "' cannot be modified at runtime, please instantiate the material first.");
            }
        }, {
            key: "overridePipelineStates",
            value: function overridePipelineStates(overrides, passIdx) {
                console.warn("Pipeline states in material asset '" + this.name + "' cannot be modified at runtime, please instantiate the material first.");
            }
        }, {
            key: "onLoaded",
            value: function onLoaded() {
                this._update(), this.loaded = !0, this.emit("load");
            }
        }, {
            key: "resetUniforms",
            value: function resetUniforms() {
                var clearPasses = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this._props.length = this._passes.length;
                for (var i = 0; i < this._props.length; i++) this._props[i] = {};
                if (clearPasses) {
                    var _iterator2 = this._passes, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var pass = _ref2;
                        pass.resetUBOs(), pass.resetTextures();
                    }
                }
            }
        }, {
            key: "setProperty",
            value: function setProperty(name, val, passIdx) {
                var success = !1;
                if (void 0 === passIdx) for (var passes = this._passes, len = passes.length, i = 0; i < len; i++) {
                    var pass = passes[i];
                    this._uploadProperty(pass, name, val) && (this._props[i][name] = val, success = !0);
                } else {
                    if (passIdx >= this._passes.length) return void console.warn("illegal pass index: ".concat(passIdx, "."));
                    var _pass = this._passes[passIdx];
                    this._uploadProperty(_pass, name, val) && (this._props[passIdx][name] = val, success = !0);
                }
                success || console.warn("illegal property name: ".concat(name, "."));
            }
        }, {
            key: "getProperty",
            value: function getProperty(name, passIdx) {
                if (void 0 === passIdx) for (var propsArray = this._props, len = propsArray.length, i = 0; i < len; i++) {
                    var props = propsArray[i];
                    for (var p in props) if (p === name) return props[p];
                } else {
                    if (passIdx >= this._props.length) return console.warn("illegal pass index: ".concat(passIdx, ".")), 
                    null;
                    var _props = this._props[passIdx];
                    for (var _p in _props) if (_p === name) return _props[_p];
                }
                return null;
            }
        }, {
            key: "copy",
            value: function copy(mat) {
                this._techIdx = mat._techIdx, this._props.length = mat._props.length;
                for (var i = 0; i < mat._props.length; i++) this._props[i] = Object.assign({}, mat._props[i]);
                this._defines.length = mat._defines.length;
                for (var _i3 = 0; _i3 < mat._defines.length; _i3++) this._defines[_i3] = Object.assign({}, mat._defines[_i3]);
                this._states.length = mat._states.length;
                for (var _i4 = 0; _i4 < mat._states.length; _i4++) this._states[_i4] = Object.assign({}, mat._states[_i4]);
                this._effectAsset = mat._effectAsset, this._update();
            }
        }, {
            key: "_prepareInfo",
            value: function _prepareInfo(patch, cur) {
                if (!Array.isArray(patch)) {
                    var len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
                    patch = Array(len).fill(patch);
                }
                for (var i = 0; i < patch.length; ++i) Object.assign(cur[i] || (cur[i] = {}), patch[i]);
            }
        }, {
            key: "_createPasses",
            value: function _createPasses() {
                var tech = this._effectAsset.techniques[this._techIdx || 0];
                if (!tech) return [];
                for (var passNum = tech.passes.length, passes = [], k = 0; k < passNum; ++k) {
                    var passInfo = tech.passes[k], defs = passInfo.defines = this._defines.length > k ? this._defines[k] : {};
                    if (!passInfo.switch || defs[passInfo.switch]) {
                        passInfo.stateOverrides = this._states.length > k ? this._states[k] : {}, passInfo.idxInTech = k;
                        var pass = new Pass(cc.director.root.device);
                        pass.initialize(passInfo), passes.push(pass);
                    }
                }
                return passes;
            }
        }, {
            key: "_update",
            value: function _update() {
                var _this2 = this, keepProps = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                if (this._effectAsset) {
                    if (this._passes && this._passes.length) {
                        var _iterator3 = this._passes, _isArray3 = Array.isArray(_iterator3), _i5 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i5 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i5++];
                            } else {
                                if ((_i5 = _iterator3.next()).done) break;
                                _ref3 = _i5.value;
                            }
                            var pass = _ref3;
                            pass.destroy();
                        }
                    }
                    this._passes = this._createPasses();
                    var totalPasses = this._effectAsset.techniques[this._techIdx].passes.length;
                    if (this._props.length = totalPasses, keepProps) this._passes.forEach((function(pass, i) {
                        var props = _this2._props[pass.idxInTech];
                        for (var p in props || (props = _this2._props[i] = {}), props) _this2._uploadProperty(pass, p, props[p]);
                    })); else for (var i = 0; i < this._props.length; i++) this._props[i] = {};
                } else {
                    var missing = builtinResMgr.get("missing-effect-material");
                    missing && (this._passes = missing._passes.slice());
                }
                this._hash = Material.getHash(this);
            }
        }, {
            key: "_uploadProperty",
            value: function _uploadProperty(pass, name, val) {
                var handle = pass.getHandle(name);
                if (void 0 === handle) return !1;
                var bindingType = Pass.getBindingTypeFromHandle(handle);
                if (bindingType === exports.GFXBindingType.UNIFORM_BUFFER) Array.isArray(val) ? pass.setUniformArray(handle, val) : pass.setUniform(handle, val); else if (bindingType === exports.GFXBindingType.SAMPLER) {
                    var binding = Pass.getBindingFromHandle(handle);
                    if (val instanceof GFXTextureView) pass.bindTextureView(binding, val); else if (val instanceof TextureBase || val instanceof SpriteFrame) {
                        var textureView = val.getGFXTextureView();
                        if (!textureView || !textureView.texture.width || !textureView.texture.height) return !1;
                        pass.bindTextureView(binding, textureView), val instanceof TextureBase && pass.bindSampler(binding, samplerLib.getSampler(cc.director.root.device, val.getSamplerHash()));
                    }
                }
                return !0;
            }
        }, {
            key: "_doDestroy",
            value: function _doDestroy() {
                if (this._passes && this._passes.length) {
                    var _iterator4 = this._passes, _isArray4 = Array.isArray(_iterator4), _i6 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i6 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i6++];
                        } else {
                            if ((_i6 = _iterator4.next()).done) break;
                            _ref4 = _i6.value;
                        }
                        _ref4.destroy();
                    }
                }
                this._effectAsset = null, this._passes.length = 0, this._props.length = 0, this._defines.length = 0, 
                this._states.length = 0;
            }
        } ]), Material;
    }(Asset)).prototype, "_effectAsset", [ _dec2$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$9 = _applyDecoratedDescriptor(_class2$f.prototype, "_techIdx", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor3$7 = _applyDecoratedDescriptor(_class2$f.prototype, "_defines", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor4$4 = _applyDecoratedDescriptor(_class2$f.prototype, "_states", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor5$4 = _applyDecoratedDescriptor(_class2$f.prototype, "_props", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$i = _class2$f)) || _class$i);
    cc.Material = Material;
    var _dec$j, _dec2$a, _dec3$3, _dec4$2, _class$j, _class2$g, _descriptor$e, _descriptor2$a, _dec$k, _dec2$b, _dec3$4, _dec4$3, _dec5$2, _class$k, _class2$h, _descriptor$f, _descriptor2$b, _class3$b, _temp$i, PassInstance = function(_Pass) {
        function PassInstance(parent, owner) {
            var _this;
            _classCallCheck(this, PassInstance), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PassInstance).call(this, parent.device)))._dontNotify = !1, 
            _this._parent = parent, _this._owner = owner, _this._doInit(_this._parent), _this._defines = Object.assign({}, parent.defines);
            var _iterator = _this._shaderInfo.blocks, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var u = _ref;
                if (!isBuiltinBinding(u.binding)) {
                    var block = _this._blocks[u.binding], parentBlock = _this._parent.blocks[u.binding];
                    block.view.set(parentBlock.view), block.dirty = !0;
                }
            }
            var _iterator2 = _this._shaderInfo.samplers, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var _u = _ref2;
                isBuiltinBinding(_u.binding) || (_this._textureViews[_u.binding] = _this._parent._textureViews[_u.binding], 
                _this._samplers[_u.binding] = _this._parent._samplers[_u.binding]);
            }
            return _this;
        }
        return _inherits(PassInstance, _Pass), _createClass(PassInstance, [ {
            key: "parent",
            get: function get() {
                return this._parent;
            }
        } ]), _createClass(PassInstance, [ {
            key: "overridePipelineStates",
            value: function overridePipelineStates(original, overrides) {
                this._bs = new GFXBlendState, this._dss = new GFXDepthStencilState, this._rs = new GFXRasterizerState, 
                Pass.fillinPipelineInfo(this, original), Pass.fillinPipelineInfo(this, overrides), 
                this._onStateChange();
            }
        }, {
            key: "tryCompile",
            value: function tryCompile(defineOverrides) {
                if (defineOverrides && !assignDefines(this._defines, defineOverrides)) return !1;
                var res = _get(_getPrototypeOf(PassInstance.prototype), "tryCompile", this).call(this);
                return this._onStateChange(), res;
            }
        }, {
            key: "createBatchedBuffer",
            value: function createBatchedBuffer() {
                console.warn("pass instance have no batched buffer.");
            }
        }, {
            key: "beginChangeStatesSilently",
            value: function beginChangeStatesSilently() {
                this._dontNotify = !0;
            }
        }, {
            key: "endChangeStatesSilently",
            value: function endChangeStatesSilently() {
                this._dontNotify = !1;
            }
        }, {
            key: "_onStateChange",
            value: function _onStateChange() {
                this._hash = Pass.getPSOHash(this), this._owner.onPassStateChange(this._dontNotify);
            }
        } ]), PassInstance;
    }(Pass), MaterialInstance = function(_Material) {
        function MaterialInstance(info) {
            var _this;
            return _classCallCheck(this, MaterialInstance), (_this = _possibleConstructorReturn(this, _getPrototypeOf(MaterialInstance).call(this)))._passes = [], 
            _this._subModelIdx = 0, _this._parent = info.parent, _this._owner = info.owner || null, 
            _this._subModelIdx = info.subModelIdx || 0, _this.copy(_this._parent), _this;
        }
        return _inherits(MaterialInstance, _Material), _createClass(MaterialInstance, [ {
            key: "parent",
            get: function get() {
                return this._parent;
            }
        }, {
            key: "owner",
            get: function get() {
                return this._owner;
            }
        } ]), _createClass(MaterialInstance, [ {
            key: "recompileShaders",
            value: function recompileShaders(overrides, passIdx) {
                if (this._passes && this.effectAsset) if (void 0 === passIdx) {
                    var _iterator = this._passes, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        _ref.tryCompile(overrides);
                    }
                } else this._passes[passIdx].tryCompile(overrides);
            }
        }, {
            key: "overridePipelineStates",
            value: function overridePipelineStates(overrides, passIdx) {
                if (this._passes && this.effectAsset) {
                    var passInfos = this.effectAsset.techniques[this.technique].passes;
                    if (void 0 === passIdx) for (var i = 0; i < this._passes.length; i++) {
                        var pass = this._passes[i];
                        this._states[i] = overrides, pass.overridePipelineStates(passInfos[pass.idxInTech], overrides);
                    } else this._states[passIdx] = overrides, this._passes[passIdx].overridePipelineStates(passInfos[passIdx], overrides);
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this._doDestroy(), !0;
            }
        }, {
            key: "onPassStateChange",
            value: function onPassStateChange(dontNotify) {
                this._hash = Material.getHash(this), !dontNotify && this._owner && this._owner._onRebuildPSO(this._subModelIdx, this);
            }
        }, {
            key: "_createPasses",
            value: function _createPasses() {
                var passes = [], parentPasses = this._parent.passes;
                if (!parentPasses) return passes;
                for (var k = 0; k < parentPasses.length; ++k) passes.push(new PassInstance(parentPasses[k], this));
                return passes;
            }
        } ]), MaterialInstance;
    }(Material), _matInsInfo = {
        parent: null,
        owner: null,
        subModelIdx: 0
    }, RenderableComponent = (_dec$j = ccclass("cc.RenderableComponent"), _dec2$a = property({
        type: [ Material ],
        tooltip: "材质"
    }), _dec3$3 = property({
        visible: !1
    }), _dec4$2 = property({
        type: Material,
        displayName: "Materials",
        tooltip: "源材质"
    }), _dec$j((_descriptor$e = _applyDecoratedDescriptor((_class2$g = function(_Component) {
        function RenderableComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, RenderableComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderableComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_materials", _descriptor$e, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_visFlags", _descriptor2$a, _assertThisInitialized(_this)), 
            _this._materialInstances = [], _this._models = [], _this;
        }
        return _inherits(RenderableComponent, _Component), _createClass(RenderableComponent, [ {
            key: "getMaterial",
            value: function getMaterial(idx) {
                return idx < 0 || idx >= this._materials.length ? null : this._materials[idx];
            }
        }, {
            key: "setMaterial",
            value: function setMaterial(material, index) {
                material && material instanceof MaterialInstance && console.error("Can't set a material instance to a sharedMaterial slot"), 
                this._materials[index] = material, this._materialInstances[index] ? this._materialInstances[index].parent !== this._materials[index] && (this._materialInstances[index].destroy(), 
                this._materialInstances[index] = null, this._onMaterialModified(index, this._materials[index])) : this._onMaterialModified(index, this._materials[index]);
            }
        }, {
            key: "getMaterialInstance",
            value: function getMaterialInstance(idx) {
                if (!this._materials[idx]) return null;
                if (null == this._materialInstances[idx]) {
                    _matInsInfo.parent = this._materials[idx], _matInsInfo.owner = this, _matInsInfo.subModelIdx = idx;
                    var instantiated = new MaterialInstance(_matInsInfo);
                    this.setMaterialInstance(idx, instantiated);
                }
                return this._materialInstances[idx];
            }
        }, {
            key: "setMaterialInstance",
            value: function setMaterialInstance(index, matInst) {
                matInst && matInst.parent ? matInst !== this._materialInstances[index] && (this._materialInstances[index] = matInst, 
                this._onMaterialModified(index, matInst)) : matInst !== this._materials[index] && this.setMaterial(matInst, index);
            }
        }, {
            key: "getRenderMaterial",
            value: function getRenderMaterial(index) {
                return this._materialInstances[index] || this._materials[index];
            }
        }, {
            key: "_collectModels",
            value: function _collectModels() {
                return this._models;
            }
        }, {
            key: "_attachToScene",
            value: function _attachToScene() {}
        }, {
            key: "_detachFromScene",
            value: function _detachFromScene() {}
        }, {
            key: "_onMaterialModified",
            value: function _onMaterialModified(index, material) {}
        }, {
            key: "_onRebuildPSO",
            value: function _onRebuildPSO(index, material) {}
        }, {
            key: "_clearMaterials",
            value: function _clearMaterials() {}
        }, {
            key: "_onVisiblityChange",
            value: function _onVisiblityChange(val) {}
        }, {
            key: "visibility",
            get: function get() {
                return this._visFlags;
            },
            set: function set(val) {
                this._visFlags = val, this._onVisiblityChange(val);
            }
        }, {
            key: "sharedMaterials",
            get: function get() {
                return this._materials.slice();
            },
            set: function set(val) {
                for (var i = 0; i < val.length; i++) val[i] !== this._materials[i] && this.setMaterial(val[i], i);
                if (val.length < this._materials.length) {
                    for (var _i = val.length; _i < this._materials.length; _i++) this.setMaterial(null, _i);
                    this._materials.splice(val.length);
                }
            }
        }, {
            key: "materials",
            get: function get() {
                for (var i = 0; i < this._materials.length; i++) this._materialInstances[i] = this.getMaterialInstance(i);
                return this._materialInstances;
            },
            set: function set(val) {
                var dLen = val.length - this._materials.length;
                if (dLen > 0) this._materials.length = val.length, this._materialInstances.length = val.length; else if (dLen < 0) for (var i = this._materials.length - dLen; i < this._materials.length; ++i) this.setMaterialInstance(i, null);
                for (var _i2 = 0; _i2 < this._materialInstances.length; _i2++) this._materialInstances[_i2] != val[_i2] && this.setMaterialInstance(_i2, val[_i2]);
            }
        }, {
            key: "sharedMaterial",
            get: function get() {
                return this.getMaterial(0);
            }
        }, {
            key: "material",
            get: function get() {
                return this.getMaterialInstance(0);
            },
            set: function set(val) {
                1 === this._materials.length && this._materials[0] === val || this.setMaterialInstance(0, val);
            }
        } ]), RenderableComponent;
    }(Component)).prototype, "_materials", [ _dec2$a ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$a = _applyDecoratedDescriptor(_class2$g.prototype, "_visFlags", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Layers.Enum.NONE;
        }
    }), _applyDecoratedDescriptor(_class2$g.prototype, "visibility", [ _dec3$3 ], Object.getOwnPropertyDescriptor(_class2$g.prototype, "visibility"), _class2$g.prototype), 
    _applyDecoratedDescriptor(_class2$g.prototype, "sharedMaterials", [ _dec4$2 ], Object.getOwnPropertyDescriptor(_class2$g.prototype, "sharedMaterials"), _class2$g.prototype), 
    _class$j = _class2$g)) || _class$j), ModelShadowCastingMode = Enum({
        OFF: 0,
        ON: 1
    }), ModelComponent = (_dec$k = ccclass("cc.ModelComponent"), _dec2$b = executionOrder(100), 
    _dec3$4 = menu("Components/Model"), _dec4$3 = property({
        type: ModelShadowCastingMode,
        tooltip: "投射阴影方式"
    }), _dec5$2 = property({
        type: Mesh,
        tooltip: "模型网格"
    }), _dec$k(_class$k = _dec2$b(_class$k = _dec3$4(_class$k = executeInEditMode((_temp$i = _class3$b = function(_RenderableComponent) {
        function ModelComponent() {
            var _this;
            return _classCallCheck(this, ModelComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(ModelComponent).call(this)), "_mesh", _descriptor$f, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_shadowCastingMode", _descriptor2$b, _assertThisInitialized(_this)), 
            _this._model = null, _this._modelType = Model, _this;
        }
        return _inherits(ModelComponent, _RenderableComponent), _createClass(ModelComponent, [ {
            key: "shadowCastingMode",
            get: function get() {
                return this._shadowCastingMode;
            },
            set: function set(val) {
                this._shadowCastingMode = val, this._updateCastShadow();
            }
        }, {
            key: "mesh",
            get: function get() {
                return this._mesh;
            },
            set: function set(val) {
                var old = this._mesh;
                this._mesh = val, this._onMeshChanged(old), this._updateModels(), this.node.activeInHierarchy && this._attachToScene();
            }
        }, {
            key: "model",
            get: function get() {
                return this._model;
            }
        } ]), _createClass(ModelComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this._updateModels(), this._updateCastShadow();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._model || this._updateModels(), this._model && this._attachToScene();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._model && this._detachFromScene();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._model && (cc.director.root.destroyModel(this._model), this._model = null, 
                this._models.length = 0);
            }
        }, {
            key: "_updateModels",
            value: function _updateModels() {
                this.enabledInHierarchy && this._mesh && (this._model ? this._model.destroy() : this._createModel(), 
                this._updateModelParams(), this._model && (this._model.createBoundingShape(this._mesh.minPosition, this._mesh.maxPosition), 
                this._model.enabled = !0));
            }
        }, {
            key: "_createModel",
            value: function _createModel() {
                this._model = cc.director.root.createModel(this._modelType), this._model.visFlags = this.visibility, 
                this._model.initialize(this.node), this._models.length = 0, this._models.push(this._model);
            }
        }, {
            key: "_attachToScene",
            value: function _attachToScene() {
                if (this.node.scene && this._model) {
                    var scene = this._getRenderScene();
                    null != this._model.scene && this._detachFromScene(), scene.addModel(this._model);
                }
            }
        }, {
            key: "_detachFromScene",
            value: function _detachFromScene() {
                this._model && this._model.scene && this._model.scene.removeModel(this._model);
            }
        }, {
            key: "_updateModelParams",
            value: function _updateModelParams() {
                if (this._mesh && this._model) {
                    this.node.hasChangedFlags = this._model.transform.hasChangedFlags = TransformBit.POSITION, 
                    (this._model.isDynamicBatching = this._isBatchingEnabled()) && this._mesh.createFlatBuffers();
                    for (var meshCount = this._mesh ? this._mesh.subMeshCount : 0, i = 0; i < meshCount; ++i) {
                        var material = this.getRenderMaterial(i), renderingMesh = this._mesh.renderingMesh;
                        if (renderingMesh) {
                            var subMeshData = renderingMesh.getSubmesh(i);
                            subMeshData && this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
                        }
                    }
                }
            }
        }, {
            key: "_onMaterialModified",
            value: function _onMaterialModified(idx, material) {
                this._model && this._model.inited && this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
            }
        }, {
            key: "_onRebuildPSO",
            value: function _onRebuildPSO(idx, material) {
                this._model && this._model.inited && ((this._model.isDynamicBatching = this._isBatchingEnabled()) && this._mesh && this._mesh.createFlatBuffers(), 
                this._model.setSubModelMaterial(idx, material));
            }
        }, {
            key: "_onMeshChanged",
            value: function _onMeshChanged(old) {}
        }, {
            key: "_clearMaterials",
            value: function _clearMaterials() {
                if (this._model) for (var i = 0; i < this._model.subModelNum; ++i) this._onMaterialModified(i, null);
            }
        }, {
            key: "_getBuiltinMaterial",
            value: function _getBuiltinMaterial() {
                return builtinResMgr.get("missing-material");
            }
        }, {
            key: "_onVisiblityChange",
            value: function _onVisiblityChange(val) {
                this._model && (this._model.visFlags = val);
            }
        }, {
            key: "_updateCastShadow",
            value: function _updateCastShadow() {
                this._model && (this._shadowCastingMode === ModelShadowCastingMode.OFF ? this._model.castShadow = !1 : this._shadowCastingMode === ModelShadowCastingMode.ON ? this._model.castShadow = !0 : console.warn("ShadowCastingMode ".concat(this._shadowCastingMode, " is not supported.")));
            }
        }, {
            key: "_isBatchingEnabled",
            value: function _isBatchingEnabled() {
                if (!this._model || !this._mesh) return !1;
                for (var i = 0; i < this._materials.length; ++i) {
                    var mat = this._materials[i];
                    if (mat) for (var p = 0; p < mat.passes.length; ++p) {
                        if (mat.passes[p].batchedBuffer) return !0;
                    }
                }
                return !1;
            }
        } ]), ModelComponent;
    }(RenderableComponent), _class3$b.ShadowCastingMode = ModelShadowCastingMode, _descriptor$f = _applyDecoratedDescriptor((_class2$h = _temp$i).prototype, "_mesh", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$b = _applyDecoratedDescriptor(_class2$h.prototype, "_shadowCastingMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return ModelShadowCastingMode.OFF;
        }
    }), _applyDecoratedDescriptor(_class2$h.prototype, "shadowCastingMode", [ _dec4$3 ], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowCastingMode"), _class2$h.prototype), 
    _applyDecoratedDescriptor(_class2$h.prototype, "mesh", [ _dec5$2 ], Object.getOwnPropertyDescriptor(_class2$h.prototype, "mesh"), _class2$h.prototype), 
    _class$k = _class2$h)) || _class$k) || _class$k) || _class$k) || _class$k);
    function checkMaterialisSame(comp1, comp2) {
        if (comp1._materials.length !== comp2._materials.length) return !1;
        for (var matNum = comp1._materials.length, i = 0; i < matNum; i++) if (comp1.getRenderMaterial(i) !== comp2.getRenderMaterial(i)) return !1;
        return !0;
    }
    var BatchingUtility = function() {
        function BatchingUtility() {
            _classCallCheck(this, BatchingUtility);
        }
        return _createClass(BatchingUtility, null, [ {
            key: "batchStaticModel",
            value: function batchStaticModel(staticModelRoot, batchedRoot) {
                var modelComponents = staticModelRoot.getComponentsInChildren(ModelComponent);
                if (modelComponents.length < 2) return console.error("the number of static models to batch is less than 2,it needn't batch."), 
                !1;
                for (var i = 1; i < modelComponents.length; i++) {
                    if (!modelComponents[0].mesh.validateMergingMesh(modelComponents[i].mesh)) return console.error("the meshes of " + modelComponents[0].node.name + " and " + modelComponents[i].node.name + " can't be merged"), 
                    !1;
                    if (!checkMaterialisSame(modelComponents[0], modelComponents[i])) return console.error("the materials of " + modelComponents[0].node.name + " and " + modelComponents[i].node.name + " can't be merged"), 
                    !1;
                }
                var batchedMesh = new Mesh, worldMat = new Mat4, rootWorldMatInv = new Mat4;
                staticModelRoot.getWorldMatrix(rootWorldMatInv), Mat4.invert(rootWorldMatInv, rootWorldMatInv);
                for (var _i = 0; _i < modelComponents.length; _i++) modelComponents[_i].node.getWorldMatrix(worldMat), 
                Mat4.multiply(worldMat, rootWorldMatInv, worldMat), batchedMesh.merge(modelComponents[_i].mesh, worldMat);
                var batchedModelComponent = batchedRoot.addComponent(ModelComponent);
                return batchedModelComponent.mesh = batchedMesh, batchedModelComponent.sharedMaterials = modelComponents[0]._materials, 
                !0;
            }
        } ]), BatchingUtility;
    }(), _vec3 = new Vec3;
    function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
        out || (out = new Vec3), mainCamera.convertToUINode(wpos, uiNode, out);
        var pos = uiNode.position;
        return out.add(pos), out;
    }
    function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
        return out || (out = new Vec3), mainCamera.worldToScreen(wpos, out), out.x = out.x / cc.view.getScaleX(), 
        out.y = out.y / cc.view.getScaleY(), out;
    }
    var _dec$l, _dec2$c, _class$l, _class2$i, _descriptor$g, _dec3$5, _dec4$4, _dec5$3, _dec6$2, _class4$1, _class5$1, _descriptor2$c, _descriptor3$8, convertUtils = {
        WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
        WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI
    };
    cc.pipelineUtils = convertUtils, exports.replaceProperty(cc.pipelineUtils, "cc.pipelineUtils", [ {
        name: "WorldNode3DToLocalNodeUI",
        newName: "convertToUINode",
        targetName: "cc.CameraComponent.prototype",
        customFunction: function customFunction() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            var camera = args[0], out = args[3] || _vec3;
            return camera.convertToUINode(args[1], args[2], out), out.add(args[2].position), 
            args[3] || out.clone();
        }
    } ]);
    var MissingClass = (_dec$l = ccclass("cc.MissingClass"), _dec2$c = property({
        visible: !1,
        editorOnly: !0
    }), _dec$l((_descriptor$g = _applyDecoratedDescriptor((_class2$i = function MissingClass() {
        _classCallCheck(this, MissingClass), _initializerDefineProperty(this, "_$erialized", _descriptor$g, this);
    }).prototype, "_$erialized", [ _dec2$c ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$l = _class2$i)) || _class$l), MissingScript = (_dec3$5 = ccclass("cc.MissingScript"), 
    _dec4$4 = inspector("packages://inspector/inspectors/comps/missing-script.js"), 
    _dec5$3 = property({
        serializable: !1
    }), _dec6$2 = property({
        visible: !1,
        editorOnly: !0
    }), _dec3$5(_class4$1 = _dec4$4((_descriptor2$c = _applyDecoratedDescriptor((_class5$1 = function(_Component) {
        function MissingScript() {
            var _this;
            return _classCallCheck(this, MissingScript), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(MissingScript).call(this)), "compiled", _descriptor2$c, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_$erialized", _descriptor3$8, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(MissingScript, _Component), _createClass(MissingScript, null, [ {
            key: "safeFindClass",
            value: function safeFindClass(id, data) {
                var cls = _getClassById(id);
                return cls || (id ? (cc.deserialize.reportMissingClass(id), MissingScript.getMissingWrapper(id, data)) : null);
            }
        }, {
            key: "getMissingWrapper",
            value: function getMissingWrapper(id, data) {
                return data.node && (/^[0-9a-zA-Z+/]{23}$/.test(id) || BUILTIN_CLASSID_RE.test(id)) ? MissingScript : MissingClass;
            }
        } ]), _createClass(MissingScript, [ {
            key: "onLoad",
            value: function onLoad() {
                cc.warnID(4600, this.node.name);
            }
        } ]), MissingScript;
    }(Component)).prototype, "compiled", [ _dec5$3 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$8 = _applyDecoratedDescriptor(_class5$1.prototype, "_$erialized", [ _dec6$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class4$1 = _class5$1)) || _class4$1) || _class4$1);
    cc._MissingScript = MissingScript;
    var Details = function() {
        function Details() {
            _classCallCheck(this, Details), this.uuidList = [], this.uuidObjList = [], this.uuidPropList = [], 
            this._stillUseUrl = createMap(!0);
        }
        return _createClass(Details, [ {
            key: "reset",
            value: function reset() {
                this.uuidList.length = 0, this.uuidObjList.length = 0, this.uuidPropList.length = 0, 
                clear(this._stillUseUrl);
            }
        }, {
            key: "push",
            value: function push(obj, propName, uuid, _stillUseUrl) {
                _stillUseUrl && (this._stillUseUrl[this.uuidList.length] = !0), this.uuidList.push(uuid), 
                this.uuidObjList.push(obj), this.uuidPropList.push(propName);
            }
        } ]), Details;
    }();
    Details.pool = new Pool((function(obj) {
        obj.reset();
    }), 10), Details.pool.get = function() {
        return this._get() || new Details;
    };
    var compileDeserialize = function(self, klass) {
        var shouldCopyRawData, fastMode = BUILTIN_CLASSID_RE.test(_getClassId(klass)), shouldCopyId = cc.js.isChildClassOf(klass, cc._BaseNode) || cc.js.isChildClassOf(klass, cc.Component), simpleProps = [], simplePropsToRead = simpleProps, advancedProps = [], advancedPropsToRead = advancedProps, advancedPropsUseUrl = [], advancedPropsValueType = [];
        return function() {
            var props = klass.__values__;
            shouldCopyRawData = "_$erialized" === props[props.length - 1];
            for (var attrs = getClassAttrs(klass), p = 0; p < props.length; p++) {
                var propName = props[p], propNameToRead = propName;
                attrs[propName + "$_$formerlySerializedAs"] && (propNameToRead = attrs[propName + "$_$formerlySerializedAs"]);
                var stillUseUrl = attrs[propName + "$_$saveUrlAsAsset"], defaultValue = CCClass.getDefault(attrs[propName + "$_$default"]), isPrimitiveType = !1;
                if (fastMode) {
                    var userType = attrs[propName + "$_$type"];
                    if (void 0 === defaultValue && userType) isPrimitiveType = userType === cc.String || userType === cc.Integer || userType === cc.Float || userType === cc.Boolean; else {
                        var defaultType = _typeof(defaultValue);
                        isPrimitiveType = "string" === defaultType && !stillUseUrl || "number" === defaultType || "boolean" === defaultType;
                    }
                }
                fastMode && isPrimitiveType ? (propNameToRead !== propName && simplePropsToRead === simpleProps && (simplePropsToRead = simpleProps.slice()), 
                simpleProps.push(propName), simplePropsToRead !== simpleProps && simplePropsToRead.push(propNameToRead)) : (propNameToRead !== propName && advancedPropsToRead === advancedProps && (advancedPropsToRead = advancedProps.slice()), 
                advancedProps.push(propName), advancedPropsToRead !== advancedProps && advancedPropsToRead.push(propNameToRead), 
                advancedPropsUseUrl.push(stillUseUrl), advancedPropsValueType.push(defaultValue instanceof cc.ValueType && defaultValue.constructor));
            }
        }(), function(s, o, d, k, t) {
            for (var i = 0; i < simpleProps.length; ++i) {
                var prop = d[simplePropsToRead[i]];
                void 0 !== prop && (o[simpleProps[i]] = prop);
            }
            for (var _i = 0; _i < advancedProps.length; ++_i) {
                var propName = advancedProps[_i], _prop = d[advancedPropsToRead[_i]];
                if (void 0 !== _prop) if (fastMode || "object" === _typeof(_prop)) {
                    var valueTypeCtor = advancedPropsValueType[_i];
                    valueTypeCtor ? fastMode || _prop ? s._deserializeTypedObject(o[propName], _prop, valueTypeCtor) : o[propName] = null : _prop ? s._deserializeObjField(o, _prop, propName, null, advancedPropsUseUrl[_i]) : o[propName] = null;
                } else o[propName] = _prop;
            }
            shouldCopyId && d._id && (o._id = d._id), shouldCopyRawData && (o._$erialized = JSON.parse(JSON.stringify(d)), 
            s._deserializePrimitiveObject(o._$erialized, d));
        };
    };
    function _deserializeFireClass(self, obj, serialized, klass, target) {
        var deserialize;
        klass.hasOwnProperty("__deserialize__") ? deserialize = klass.__deserialize__ : (deserialize = compileDeserialize(self, klass), 
        value(klass, "__deserialize__", deserialize, !0)), deserialize(self, obj, serialized, klass, target), 
        obj.__postDeserialize && obj.__postDeserialize();
    }
    var _Deserializer = function() {
        function _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly) {
            _classCallCheck(this, _Deserializer), this.result = result, this.customEnv = customEnv, 
            this.deserializedList = [], this.deserializedData = null, this._classFinder = classFinder, 
            this._idList = [], this._idObjList = [], this._idPropList = [];
        }
        return _createClass(_Deserializer, [ {
            key: "deserialize",
            value: function deserialize(jsonObj) {
                if (Array.isArray(jsonObj)) {
                    var jsonArray = jsonObj, refCount = jsonArray.length;
                    this.deserializedList.length = refCount;
                    for (var i = 0; i < refCount; i++) {
                        if (jsonArray[i]) this.deserializedList[i] = this._deserializeObject(jsonArray[i], !1);
                    }
                    this.deserializedData = refCount > 0 ? this.deserializedList[0] : [];
                } else this.deserializedList.length = 1, this.deserializedData = jsonObj ? this._deserializeObject(jsonObj, !1) : null, 
                this.deserializedList[0] = this.deserializedData;
                return function _dereference(self) {
                    var i, propName, id, deserializedList = self.deserializedList, idPropList = self._idPropList, idList = self._idList, idObjList = self._idObjList;
                    for (self._classFinder && self._classFinder.onDereferenced, i = 0; i < idList.length; i++) propName = idPropList[i], 
                    id = idList[i], idObjList[i][propName] = deserializedList[id];
                }(this), this.deserializedData;
            }
        }, {
            key: "_deserializeObject",
            value: function _deserializeObject(serialized, _stillUseUrl, target, owner, propName) {
                var prop, obj = null, klass = null, type = serialized.__type__;
                if ("TypedArray" === type) {
                    var array = serialized.array;
                    obj = new window[serialized.ctor](array.length);
                    for (var i = 0; i < array.length; ++i) obj[i] = array[i];
                    return obj;
                }
                if (type) {
                    var deserializeByType = function deserializeByType() {
                        (obj = new klass)._deserialize ? obj._deserialize(serialized.content, self) : cc.Class._isCCClass(klass) ? _deserializeFireClass(self, obj, serialized, klass, target) : self._deserializeTypedObject(obj, serialized, klass);
                    };
                    if (!(klass = this._classFinder(type, serialized, owner, propName))) return this._classFinder === _getClassById && cc.deserialize.reportMissingClass(type), 
                    null;
                    var self = this;
                    deserializeByType();
                } else if (Array.isArray(serialized)) {
                    obj = new Array(serialized.length);
                    for (var _i2 = 0; _i2 < serialized.length; _i2++) "object" === _typeof(prop = serialized[_i2]) && prop ? this._deserializeObjField(obj, prop, "" + _i2, null, _stillUseUrl) : obj[_i2] = prop;
                } else obj = {}, this._deserializePrimitiveObject(obj, serialized);
                return obj;
            }
        }, {
            key: "_deserializeObjField",
            value: function _deserializeObjField(obj, jsonObj, propName, target, _stillUseUrl) {
                var id = jsonObj.__id__;
                if (void 0 === id) {
                    var uuid = jsonObj.__uuid__;
                    uuid ? this.result.push(obj, propName, uuid, _stillUseUrl) : obj[propName] = this._deserializeObject(jsonObj, _stillUseUrl);
                } else {
                    var dObj = this.deserializedList[id];
                    dObj ? obj[propName] = dObj : (this._idList.push(id), this._idObjList.push(obj), 
                    this._idPropList.push(propName));
                }
            }
        }, {
            key: "_deserializePrimitiveObject",
            value: function _deserializePrimitiveObject(instance, serialized) {
                for (var propName in serialized) if (serialized.hasOwnProperty(propName)) {
                    var prop = serialized[propName];
                    "object" !== _typeof(prop) ? "__type__" !== propName && (instance[propName] = prop) : prop ? this._deserializeObjField(instance, prop, propName) : instance[propName] = null;
                }
            }
        }, {
            key: "_deserializeTypedObject",
            value: function _deserializeTypedObject(instance, serialized, klass) {
                if (klass === cc.Vec2) return instance.x = serialized.x || 0, void (instance.y = serialized.y || 0);
                if (klass === cc.Vec3) return instance.x = serialized.x || 0, instance.y = serialized.y || 0, 
                void (instance.z = serialized.z || 0);
                if (klass !== cc.Color) {
                    if (klass === cc.Size) return instance.width = serialized.width || 0, void (instance.height = serialized.height || 0);
                    for (var attrs = getClassAttrs(klass), fastDefinedProps = klass.__props__ || Object.keys(instance), i = 0; i < fastDefinedProps.length; i++) {
                        var propName = fastDefinedProps[i], value = serialized[propName];
                        void 0 !== value && serialized.hasOwnProperty(propName) || (value = CCClass.getDefault(attrs[propName + "$_$default"])), 
                        "object" !== _typeof(value) ? instance[propName] = value : value ? this._deserializeObjField(instance, value, propName) : instance[propName] = null;
                    }
                } else {
                    instance.r = serialized.r || 0, instance.g = serialized.g || 0, instance.b = serialized.b || 0;
                    var a = serialized.a;
                    instance.a = void 0 === a ? 255 : a;
                }
            }
        } ]), _Deserializer;
    }();
    function deserialize(data, details, options) {
        var classFinder = (options = options || {}).classFinder || _getClassById, createAssetRefs = options.createAssetRefs || cc.sys.platform === cc.sys.EDITOR_CORE, customEnv = options.customEnv, ignoreEditorOnly = options.ignoreEditorOnly;
        "string" == typeof data && (data = JSON.parse(data));
        var tempDetails = !details;
        details = details || Details.pool.get();
        var deserializer = _Deserializer.pool.get(details, !1, classFinder, customEnv, ignoreEditorOnly);
        cc.game._isCloning = !0;
        var res = deserializer.deserialize(data);
        return cc.game._isCloning = !1, _Deserializer.pool.put(deserializer), createAssetRefs && details.assignAssetsBy(Editor.serialize.asAsset), 
        tempDetails && Details.pool.put(details), res;
    }
    _Deserializer.pool = new Pool((function(obj) {
        obj.result = null, obj.customEnv = null, obj.deserializedList.length = 0, obj.deserializedData = null, 
        obj._classFinder = null, obj._idList.length = 0, obj._idObjList.length = 0, obj._idPropList.length = 0;
    }), 1), _Deserializer.pool.get = function(result, target, classFinder, customEnv, ignoreEditorOnly) {
        var cache = this._get();
        return cache ? (cache.result = result, cache.customEnv = customEnv, cache._classFinder = classFinder, 
        cache) : new _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly);
    }, deserialize.Details = Details, deserialize.reportMissingClass = function(id) {
        warnID(5302, id);
    }, cc.deserialize = deserialize;
    var _class$m, _class2$j, _descriptor$h, _descriptor2$d, _descriptor3$9, _descriptor4$5, _class3$c, _temp$k, _BuiltinElementTypeTr, StorageUnit, ElementType, Destroyed$1 = CCObject.Flags.Destroyed, PersistentMask$1 = CCObject.Flags.PersistentMask, objsToClearTmpVar = [];
    function instantiate(original, internal_force) {
        if (!internal_force) {
            if ("object" !== _typeof(original) || Array.isArray(original)) return null;
            if (!original) return null;
            if (!cc.isValid(original)) return null;
            0;
        }
        var clone;
        if (original instanceof CCObject) {
            if ((original = original)._instantiate) return cc.game._isCloning = !0, clone = original._instantiate(), 
            cc.game._isCloning = !1, clone;
            if (original instanceof cc.Asset) return null;
        }
        return cc.game._isCloning = !0, clone = doInstantiate(original), cc.game._isCloning = !1, 
        clone;
    }
    function doInstantiate(obj, parent) {
        if (Array.isArray(obj)) return null;
        if (isDomNode && isDomNode(obj)) return null;
        var clone;
        if (obj._iN$t) clone = obj._iN$t; else if (obj.constructor) {
            clone = new (0, obj.constructor);
        } else clone = Object.create(null);
        enumerateObject(obj, clone, parent);
        for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) objsToClearTmpVar[i]._iN$t = null;
        return objsToClearTmpVar.length = 0, clone;
    }
    function enumerateObject(obj, clone, parent) {
        value(obj, "_iN$t", clone, !0), objsToClearTmpVar.push(obj);
        var klass = obj.constructor;
        if (cc.Class._isCCClass(klass)) !function enumerateCCClass(klass, obj, clone, parent) {
            for (var props = klass.__values__, p = 0; p < props.length; p++) {
                var key = props[p], value = obj[key];
                if ("object" === _typeof(value) && value) {
                    var initValue = clone[key];
                    initValue instanceof ValueType && initValue.constructor === value.constructor ? initValue.set(value) : clone[key] = value._iN$t || instantiateObj(value, parent);
                } else clone[key] = value;
            }
        }(klass, obj, clone, parent); else for (var key in obj) if (obj.hasOwnProperty(key) && (95 !== key.charCodeAt(0) || 95 !== key.charCodeAt(1) || "__type__" === key)) {
            var value$1 = obj[key];
            if ("object" === _typeof(value$1) && value$1) {
                if (value$1 === clone) continue;
                clone[key] = value$1._iN$t || instantiateObj(value$1, parent);
            } else clone[key] = value$1;
        }
        obj instanceof CCObject && (clone._objFlags &= PersistentMask$1);
    }
    function instantiateObj(obj, parent) {
        if (obj instanceof ValueType) return obj.clone();
        if (obj instanceof cc.Asset) return obj;
        var clone;
        if (Array.isArray(obj)) {
            var len = obj.length;
            clone = new Array(len), obj._iN$t = clone;
            for (var i = 0; i < len; ++i) {
                var value = obj[i];
                "object" === _typeof(value) && value ? clone[i] = value._iN$t || instantiateObj(value, parent) : clone[i] = value;
            }
            return objsToClearTmpVar.push(obj), clone;
        }
        if (obj._objFlags & Destroyed$1) return null;
        var ctor = obj.constructor;
        if (cc.Class._isCCClass(ctor)) {
            if (parent) if (parent instanceof cc.Component) {
                if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return obj;
            } else if (parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
                if (!obj.isChildOf(parent)) return obj;
            } else if (obj instanceof cc.Component && !obj.node.isChildOf(parent)) return obj;
            clone = new ctor;
        } else if (ctor === Object) clone = {}; else {
            if (ctor) return obj;
            clone = Object.create(null);
        }
        return enumerateObject(obj, clone, parent), clone;
    }
    instantiate._clone = doInstantiate, cc.instantiate = instantiate, function(StorageUnit) {
        StorageUnit[StorageUnit.Uint8 = 0] = "Uint8", StorageUnit[StorageUnit.Uint16 = 1] = "Uint16", 
        StorageUnit[StorageUnit.Uint32 = 2] = "Uint32", StorageUnit[StorageUnit.Int8 = 3] = "Int8", 
        StorageUnit[StorageUnit.Int16 = 4] = "Int16", StorageUnit[StorageUnit.Int32 = 5] = "Int32", 
        StorageUnit[StorageUnit.Float32 = 6] = "Float32", StorageUnit[StorageUnit.Float64 = 7] = "Float64";
    }(StorageUnit || (StorageUnit = {})), function(ElementType) {
        ElementType[ElementType.Scalar = 0] = "Scalar", ElementType[ElementType.Vec2 = 1] = "Vec2", 
        ElementType[ElementType.Vec3 = 2] = "Vec3", ElementType[ElementType.Vec4 = 3] = "Vec4", 
        ElementType[ElementType.Quat = 4] = "Quat", ElementType[ElementType.Mat4 = 5] = "Mat4";
    }(ElementType || (ElementType = {}));
    function combineStorageUnitElementType(unit, elementType) {
        return (elementType << 3) + unit;
    }
    var CompactValueTypeArray = ccclass("cc.CompactValueTypeArray")((_temp$k = _class3$c = function() {
        function CompactValueTypeArray() {
            _classCallCheck(this, CompactValueTypeArray), _initializerDefineProperty(this, "_byteOffset", _descriptor$h, this), 
            _initializerDefineProperty(this, "_unitCount", _descriptor2$d, this), _initializerDefineProperty(this, "_unitElement", _descriptor3$9, this), 
            _initializerDefineProperty(this, "_length", _descriptor4$5, this);
        }
        return _createClass(CompactValueTypeArray, [ {
            key: "decompress",
            value: function decompress(arrayBuffer) {
                for (var _extractStorageUnitEl = function extractStorageUnitElementType(combined) {
                    return {
                        storageUnit: 7 & combined,
                        elementType: combined >> 3
                    };
                }(this._unitElement), storageUnit = _extractStorageUnitEl.storageUnit, elementTraits = getElementTraits(_extractStorageUnitEl.elementType), storage = new (getStorageConstructor$1(storageUnit))(arrayBuffer, this._byteOffset, this._unitCount), result = new Array(this._length), i = 0; i < this._length; ++i) result[i] = elementTraits.decompress(storage, i);
                return result;
            }
        } ], [ {
            key: "lengthFor",
            value: function lengthFor(values, elementType, unit) {
                return getElementTraits(elementType).requiredUnits * values.length * getStorageConstructor$1(unit).BYTES_PER_ELEMENT;
            }
        }, {
            key: "compress",
            value: function compress(values, elementType, unit, arrayBuffer, byteOffset, presumedByteOffset) {
                for (var elementTraits = getElementTraits(elementType), storageConstructor = getStorageConstructor$1(unit), unitCount = elementTraits.requiredUnits * values.length, storage = new storageConstructor(arrayBuffer, byteOffset, unitCount), i = 0; i < values.length; ++i) elementTraits.compress(storage, i, values[i]);
                var result = new CompactValueTypeArray;
                return result._unitElement = combineStorageUnitElementType(unit, elementType), result._byteOffset = presumedByteOffset, 
                result._unitCount = unitCount, result._length = values.length, result;
            }
        } ]), CompactValueTypeArray;
    }(), _class3$c.StorageUnit = StorageUnit, _class3$c.ElementType = ElementType, _descriptor$h = _applyDecoratedDescriptor((_class2$j = _temp$k).prototype, "_byteOffset", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor2$d = _applyDecoratedDescriptor(_class2$j.prototype, "_unitCount", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor3$9 = _applyDecoratedDescriptor(_class2$j.prototype, "_unitElement", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return combineStorageUnitElementType(StorageUnit.Uint8, ElementType.Scalar);
        }
    }), _descriptor4$5 = _applyDecoratedDescriptor(_class2$j.prototype, "_length", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$m = _class2$j)) || _class$m;
    function getElementTraits(elementType) {
        return BuiltinElementTypeTraits[elementType];
    }
    function getStorageConstructor$1(unit) {
        switch (unit) {
          case StorageUnit.Uint8:
            return Uint8Array;

          case StorageUnit.Uint16:
            return Uint16Array;

          case StorageUnit.Uint32:
            return Uint32Array;

          case StorageUnit.Int8:
            return Int8Array;

          case StorageUnit.Int16:
            return Int16Array;

          case StorageUnit.Int32:
            return Int32Array;

          case StorageUnit.Float32:
            return Float32Array;

          case StorageUnit.Float64:
            return Float64Array;
        }
    }
    var BuiltinElementTypeTraits = (_defineProperty(_BuiltinElementTypeTr = {}, ElementType.Scalar, {
        requiredUnits: 1,
        compress: function compress(storage, index, value) {
            storage[index] = value;
        },
        decompress: function decompress(storage, index) {
            return storage[index];
        }
    }), _defineProperty(_BuiltinElementTypeTr, ElementType.Vec2, {
        requiredUnits: 2,
        compress: function compress(storage, index, value) {
            storage[2 * index] = value.x, storage[2 * index + 1] = value.y;
        },
        decompress: function decompress(storage, index) {
            return new Vec3(storage[2 * index], storage[2 * index + 1]);
        }
    }), _defineProperty(_BuiltinElementTypeTr, ElementType.Vec3, {
        requiredUnits: 3,
        compress: function compress(storage, index, value) {
            storage[3 * index] = value.x, storage[3 * index + 1] = value.y, storage[3 * index + 2] = value.z;
        },
        decompress: function decompress(storage, index) {
            return new Vec3(storage[3 * index], storage[3 * index + 1], storage[3 * index + 2]);
        }
    }), _defineProperty(_BuiltinElementTypeTr, ElementType.Vec4, {
        requiredUnits: 4,
        compress: function compress(storage, index, value) {
            storage[4 * index] = value.x, storage[4 * index + 1] = value.y, storage[4 * index + 2] = value.z, 
            storage[4 * index + 3] = value.w;
        },
        decompress: function decompress(storage, index) {
            return new Vec4(storage[4 * index], storage[4 * index + 1], storage[4 * index + 2], storage[4 * index + 3]);
        }
    }), _defineProperty(_BuiltinElementTypeTr, ElementType.Quat, {
        requiredUnits: 4,
        compress: function compress(storage, index, value) {
            storage[4 * index] = value.x, storage[4 * index + 1] = value.y, storage[4 * index + 2] = value.z, 
            storage[4 * index + 3] = value.w;
        },
        decompress: function decompress(storage, index) {
            return new Quat(storage[4 * index], storage[4 * index + 1], storage[4 * index + 2], storage[4 * index + 3]);
        }
    }), _defineProperty(_BuiltinElementTypeTr, ElementType.Mat4, {
        requiredUnits: 16,
        compress: function compress(storage, index, value) {
            Mat4.toArray(storage, value, 16 * index);
        },
        decompress: function decompress(storage, index) {
            return Mat4.fromArray(new Mat4, storage, 16 * index);
        }
    }), _BuiltinElementTypeTr);
    function flattenCodeArray(array) {
        var strList = [];
        return function deepFlatten(strList, array) {
            var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var item = _ref;
                Array.isArray(item) ? deepFlatten(strList, item) : strList.push(item);
            }
        }(strList, array), strList.join("");
    }
    cc._decorator = _decorator;
    var Destroyed$2 = CCObject.Flags.Destroyed, PersistentMask$2 = CCObject.Flags.PersistentMask, IDENTIFIER_RE$1 = CCClass.IDENTIFIER_RE, DEFAULT_MODULE_CACHE = {
        "cc.Node": "cc.Node",
        "cc.Sprite": "cc.Sprite",
        "cc.Label": "cc.Label",
        "cc.Button": "cc.Button",
        "cc.Widget": "cc.Widget",
        "cc.Animation": "cc.Animation",
        "cc.ClickEvent": !1,
        "cc.PrefabInfo": !1
    }, escapeForJS$1 = CCClass.escapeForJS, Declaration = function() {
        function Declaration(varName, expression) {
            _classCallCheck(this, Declaration), this.varName = varName, this.expression = expression;
        }
        return _createClass(Declaration, [ {
            key: "toString",
            value: function toString() {
                return "var " + this.varName + "=" + this.expression + ";";
            }
        } ]), Declaration;
    }();
    function mergeDeclaration(statement, expression) {
        return expression instanceof Declaration ? new Declaration(expression.varName, statement + expression.expression) : statement + expression;
    }
    function writeAssignment(codeArray, statement, expression) {
        Array.isArray(expression) ? (expression[0] = mergeDeclaration(statement, expression[0]), 
        codeArray.push(expression)) : codeArray.push(mergeDeclaration(statement, expression) + ";");
    }
    var Assignments = function() {
        function Assignments(targetExpression) {
            _classCallCheck(this, Assignments), this._exps = [], this._targetExp = targetExpression;
        }
        return _createClass(Assignments, [ {
            key: "append",
            value: function append(key, expression) {
                this._exps.push([ key, expression ]);
            }
        }, {
            key: "writeCode",
            value: function writeCode(codeArray) {
                var targetVar;
                if (this._exps.length > 1) codeArray.push("t=" + this._targetExp + ";"), targetVar = "t"; else {
                    if (1 !== this._exps.length) return;
                    targetVar = this._targetExp;
                }
                for (var i = 0; i < this._exps.length; i++) {
                    var pair = this._exps[i];
                    writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
                }
            }
        } ]), Assignments;
    }();
    function getPropAccessor(key) {
        return IDENTIFIER_RE$1.test(key) ? "." + key : "[" + escapeForJS$1(key) + "]";
    }
    Assignments.pool = new Pool((function(obj) {
        obj._exps.length = 0, obj._targetExp = null;
    }), 1), Assignments.pool.get = function(targetExpression) {
        var cache = this._get() || new Assignments;
        return cache._targetExp = targetExpression, cache;
    };
    var _class$n, _class2$k, _descriptor$i, _descriptor2$e, _descriptor3$a, _class3$d, _temp$l, Parser = function() {
        function Parser(obj, parent) {
            var globalVariablesDeclaration;
            _classCallCheck(this, Parser), this.parent = parent, this.objsToClear_iN$t = [], 
            this.codeArray = [], this.objs = [], this.funcs = [], this.funcModuleCache = createMap(), 
            mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE), this.globalVariables = [], this.globalVariableId = 0, 
            this.localVariableId = 0, this.codeArray.push("var o,t;", "if(R){", "o=R;", "}else{", "o=R=new " + this.getFuncModule(obj.constructor, !0) + "();", "}"), 
            obj._iN$t = {
                globalVar: "R"
            }, this.objsToClear_iN$t.push(obj), this.enumerateObject(this.codeArray, obj), this.globalVariables.length > 0 && (globalVariablesDeclaration = "var " + this.globalVariables.join(",") + ";");
            var code = flattenCodeArray([ "return (function(R){", globalVariablesDeclaration || [], this.codeArray, "return o;", "})" ]);
            this.result = Function("O", "F", code)(this.objs, this.funcs);
            for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) this.objsToClear_iN$t[i]._iN$t = null;
            this.objsToClear_iN$t.length = 0;
        }
        return _createClass(Parser, [ {
            key: "getFuncModule",
            value: function getFuncModule(func, usedInNew) {
                var clsName = getClassName(func);
                if (clsName) {
                    var cache = this.funcModuleCache[clsName];
                    if (cache) return cache;
                    if (void 0 === cache) {
                        var clsNameIsModule = -1 !== clsName.indexOf(".");
                        if (clsNameIsModule) try {
                            if (clsNameIsModule = func === Function("return " + clsName)()) return this.funcModuleCache[clsName] = clsName, 
                            clsName;
                        } catch (e) {}
                    }
                }
                var index = this.funcs.indexOf(func);
                index < 0 && (index = this.funcs.length, this.funcs.push(func));
                var res = "F[" + index + "]";
                return usedInNew && (res = "(" + res + ")"), this.funcModuleCache[clsName] = res, 
                res;
            }
        }, {
            key: "getObjRef",
            value: function getObjRef(obj) {
                var index = this.objs.indexOf(obj);
                return index < 0 && (index = this.objs.length, this.objs.push(obj)), "O[" + index + "]";
            }
        }, {
            key: "setValueType",
            value: function setValueType(codeArray, defaultValue, srcValue, targetExpression) {
                var assignments = Assignments.pool.get(targetExpression), fastDefinedProps = defaultValue.constructor.__props__;
                fastDefinedProps || (fastDefinedProps = Object.keys(defaultValue));
                for (var i = 0; i < fastDefinedProps.length; i++) {
                    var propName = fastDefinedProps[i], prop = srcValue[propName];
                    if (defaultValue[propName] !== prop) {
                        var expression = this.enumerateField(srcValue, propName, prop);
                        assignments.append(propName, expression);
                    }
                }
                assignments.writeCode(codeArray), Assignments.pool.put(assignments);
            }
        }, {
            key: "enumerateCCClass",
            value: function enumerateCCClass(codeArray, obj, klass) {
                for (var props = klass.__values__, attrs = getClassAttrs(klass), p = 0; p < props.length; p++) {
                    var key = props[p], val = obj[key], defaultValue = attrs[key + "$_$default"];
                    if (!equalsToDefault(defaultValue, val)) if ("object" === _typeof(val) && val instanceof cc.ValueType && (defaultValue = CCClass.getDefault(defaultValue)) && defaultValue.constructor === val.constructor) {
                        var targetExpression = "o" + getPropAccessor(key);
                        this.setValueType(codeArray, defaultValue, val, targetExpression);
                    } else this.setObjProp(codeArray, obj, key, val);
                }
            }
        }, {
            key: "instantiateArray",
            value: function instantiateArray(value) {
                if (0 === value.length) return "[]";
                var arrayVar = "a" + ++this.localVariableId, codeArray = [ new Declaration(arrayVar, "new Array(" + value.length + ")") ];
                value._iN$t = {
                    globalVar: "",
                    source: codeArray
                }, this.objsToClear_iN$t.push(value);
                for (var i = 0; i < value.length; ++i) {
                    writeAssignment(codeArray, arrayVar + "[" + i + "]=", this.enumerateField(value, i, value[i]));
                }
                return codeArray;
            }
        }, {
            key: "enumerateField",
            value: function enumerateField(obj, key, value) {
                if ("object" === _typeof(value) && value) {
                    var _iN$t = value._iN$t;
                    if (_iN$t) {
                        var globalVar = _iN$t.globalVar;
                        if (!globalVar) {
                            globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId, this.globalVariables.push(globalVar);
                            var line = _iN$t.source[0];
                            _iN$t.source[0] = mergeDeclaration(globalVar + "=", line);
                        }
                        return globalVar;
                    }
                    return Array.isArray(value) ? this.instantiateArray(value) : this.instantiateObj(value);
                }
                return "function" == typeof value ? this.getFuncModule(value) : "string" == typeof value ? escapeForJS$1(value) : ("_objFlags" === key && obj instanceof CCObject && (value &= PersistentMask$2), 
                value);
            }
        }, {
            key: "setObjProp",
            value: function setObjProp(codeArray, obj, key, value) {
                writeAssignment(codeArray, "o" + getPropAccessor(key) + "=", this.enumerateField(obj, key, value));
            }
        }, {
            key: "enumerateObject",
            value: function enumerateObject(codeArray, obj) {
                var klass = obj.constructor;
                if (cc.Class._isCCClass(klass)) this.enumerateCCClass(codeArray, obj, klass); else for (var key in obj) if (obj.hasOwnProperty(key) && (95 !== key.charCodeAt(0) || 95 !== key.charCodeAt(1) || "__type__" === key)) {
                    var value = obj[key];
                    "object" === _typeof(value) && value && value === obj._iN$t || this.setObjProp(codeArray, obj, key, value);
                }
            }
        }, {
            key: "instantiateObj",
            value: function instantiateObj(obj) {
                if (obj instanceof cc.ValueType) return CCClass.getNewValueTypeCode(obj);
                if (obj instanceof cc.Asset) return this.getObjRef(obj);
                if (obj._objFlags & Destroyed$2) return null;
                var createCode, ctor = obj.constructor;
                if (cc.Class._isCCClass(ctor)) {
                    if (this.parent) if (this.parent instanceof cc.Component) {
                        if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return this.getObjRef(obj);
                    } else if (this.parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
                        if (!obj.isChildOf(this.parent)) return this.getObjRef(obj);
                    } else if (obj instanceof cc.Component && !obj.node.isChildOf(this.parent)) return this.getObjRef(obj);
                    createCode = new Declaration("o", "new " + this.getFuncModule(ctor, !0) + "()");
                } else if (ctor === Object) createCode = new Declaration("o", "{}"); else {
                    if (ctor) return this.getObjRef(obj);
                    createCode = new Declaration("o", "Object.create(null)");
                }
                var codeArray = [ createCode ];
                return obj._iN$t = {
                    globalVar: "",
                    source: codeArray
                }, this.objsToClear_iN$t.push(obj), this.enumerateObject(codeArray, obj), [ "(function(){", codeArray, "return o;})();" ];
            }
        } ]), Parser;
    }();
    function equalsToDefault(def, value) {
        if ("function" == typeof def) try {
            def = def();
        } catch (e) {
            return !1;
        }
        if (def === value) return !0;
        if (def && value) {
            if (def instanceof cc.ValueType && def.equals(value)) return !0;
            if (Array.isArray(def) && Array.isArray(value) || def.constructor === Object && value.constructor === Object) try {
                return Array.isArray(def) && Array.isArray(value) && 0 === def.length && 0 === value.length;
            } catch (e) {}
        }
        return !1;
    }
    function compile(node) {
        var root = node instanceof cc._BaseNode && node;
        return new Parser(node, root).result;
    }
    var _class$o, _class2$l, _descriptor$j, _descriptor2$f, OptimizationPolicy = Enum({
        AUTO: 0,
        SINGLE_INSTANCE: 1,
        MULTI_INSTANCE: 2
    }), Prefab = ccclass("cc.Prefab")((_temp$l = _class3$d = function(_Asset) {
        function Prefab() {
            var _this;
            return _classCallCheck(this, Prefab), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Prefab).call(this)), "data", _descriptor$i, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "optimizationPolicy", _descriptor2$e, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor3$a, _assertThisInitialized(_this)), 
            _this._createFunction = null, _this._instantiatedTimes = 0, _this;
        }
        return _inherits(Prefab, _Asset), _createClass(Prefab, [ {
            key: "createNode",
            value: function createNode(cb) {
                var node = cc.instantiate(this);
                node.name = this.name, cb(null, node);
            }
        }, {
            key: "compileCreateFunction",
            value: function compileCreateFunction() {
                this._createFunction = compile(this.data);
            }
        }, {
            key: "_doInstantiate",
            value: function _doInstantiate(rootToRedirect) {
                return this.data._prefab ? this.data._prefab._synced = !0 : cc.warnID(3700), this._createFunction || this.compileCreateFunction(), 
                this._createFunction(rootToRedirect);
            }
        }, {
            key: "_instantiate",
            value: function _instantiate() {
                var node, useJit = !1;
                return useJit ? (node = this._doInstantiate(), this.data._instantiate(node)) : (this.data._prefab._synced = !0, 
                node = this.data._instantiate()), ++this._instantiatedTimes, node;
            }
        } ]), Prefab;
    }(Asset), _class3$d.OptimizationPolicy = OptimizationPolicy, _class3$d.OptimizationPolicyThreshold = 3, 
    _descriptor$i = _applyDecoratedDescriptor((_class2$k = _temp$l).prototype, "data", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$e = _applyDecoratedDescriptor(_class2$k.prototype, "optimizationPolicy", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return OptimizationPolicy.AUTO;
        }
    }), _descriptor3$a = _applyDecoratedDescriptor(_class2$k.prototype, "asyncLoadAssets", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _class$n = _class2$k)) || _class$n;
    cc.Prefab = Prefab, cc._Prefab = Prefab;
    var _class$p, _class2$m, _descriptor$k, SceneAsset = ccclass("cc.SceneAsset")((_descriptor$j = _applyDecoratedDescriptor((_class2$l = function(_Asset) {
        function SceneAsset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SceneAsset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SceneAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "scene", _descriptor$j, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor2$f, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(SceneAsset, _Asset), SceneAsset;
    }(Asset)).prototype, "scene", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$f = _applyDecoratedDescriptor(_class2$l.prototype, "asyncLoadAssets", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _class$o = _class2$l)) || _class$o;
    cc.SceneAsset = SceneAsset;
    var _class$q, _class2$n, _descriptor$l, SpriteAtlas = ccclass("cc.SpriteAtlas")((_descriptor$k = _applyDecoratedDescriptor((_class2$m = function(_Asset) {
        function SpriteAtlas() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SpriteAtlas);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteAtlas)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "spriteFrames", _descriptor$k, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(SpriteAtlas, _Asset), _createClass(SpriteAtlas, [ {
            key: "getTexture",
            value: function getTexture() {
                var keys = Object.keys(this.spriteFrames);
                if (keys.length > 0) {
                    var spriteFrame = this.spriteFrames[keys[0]];
                    return spriteFrame && spriteFrame._image;
                }
                return null;
            }
        }, {
            key: "getSpriteFrame",
            value: function getSpriteFrame(key) {
                var sf = this.spriteFrames[key];
                return sf ? (sf.name || (sf.name = key), sf) : null;
            }
        }, {
            key: "getSpriteFrames",
            value: function getSpriteFrames() {
                for (var frames = [], spriteFrames = this.spriteFrames, _i = 0, _Object$keys = Object.keys(spriteFrames); _i < _Object$keys.length; _i++) {
                    var _key2 = _Object$keys[_i];
                    frames.push(spriteFrames[_key2]);
                }
                return frames;
            }
        }, {
            key: "_serialize",
            value: function _serialize(exporting) {
                for (var frames = [], _i2 = 0, _Object$keys2 = Object.keys(this.spriteFrames); _i2 < _Object$keys2.length; _i2++) {
                    var _key3 = _Object$keys2[_i2], spriteFrame = this.spriteFrames[_key3], id = spriteFrame ? spriteFrame._uuid : "";
                    id && exporting && (id = Editor.Utils.UuidUtils.compressUuid(id, !0)), frames.push(_key3), 
                    frames.push(id);
                }
                return {
                    name: this._name,
                    spriteFrames: frames
                };
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(serializeData, handle) {
                var data = serializeData;
                this._name = data.name;
                var frames = data.spriteFrames;
                this.spriteFrames = createMap();
                for (var i = 0; i < frames.length; i += 2) handle.result.push(this.spriteFrames, frames[i], frames[i + 1]);
            }
        } ]), SpriteAtlas;
    }(Asset)).prototype, "spriteFrames", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return createMap();
        }
    }), _class$p = _class2$m)) || _class$p;
    cc.SpriteAtlas = SpriteAtlas;
    var _class$r, _class2$o, _descriptor$m, TextAsset = ccclass("cc.TextAsset")((_descriptor$l = _applyDecoratedDescriptor((_class2$n = function(_Asset) {
        function TextAsset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, TextAsset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TextAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "text", _descriptor$l, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(TextAsset, _Asset), _createClass(TextAsset, [ {
            key: "toString",
            value: function toString() {
                return this.text;
            }
        } ]), TextAsset;
    }(Asset)).prototype, "text", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _class$q = _class2$n)) || _class$q;
    cc.TextAsset = TextAsset;
    var JsonAsset = ccclass("cc.JsonAsset")((_descriptor$m = _applyDecoratedDescriptor((_class2$o = function(_Asset) {
        function JsonAsset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, JsonAsset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(JsonAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "json", _descriptor$m, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(JsonAsset, _Asset), JsonAsset;
    }(Asset)).prototype, "json", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$r = _class2$o)) || _class$r;
    cc.JsonAsset = JsonAsset;
    var HexChars = "0123456789abcdef".split(""), _t = [ "", "", "", "" ], UuidTemplate = _t.concat(_t, "-", _t, "-", _t, "-", _t, "-", _t, _t, _t), Indices = UuidTemplate.map((function(x, i) {
        return "-" === x ? NaN : i;
    })).filter(isFinite);
    function decodeUuid(base64) {
        var uuid = base64.split("@")[0];
        if (22 !== uuid.length) return base64;
        UuidTemplate[0] = base64[0], UuidTemplate[1] = base64[1];
        for (var i = 2, j = 2; i < 22; i += 2) {
            var lhs = BASE64_VALUES[base64.charCodeAt(i)], rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
            UuidTemplate[Indices[j++]] = HexChars[lhs >> 2], UuidTemplate[Indices[j++]] = HexChars[(3 & lhs) << 2 | rhs >> 4], 
            UuidTemplate[Indices[j++]] = HexChars[15 & rhs];
        }
        return base64.replace(uuid, UuidTemplate.join(""));
    }
    var url = {
        _rawAssets: "",
        normalize: function normalize(url) {
            return url && (46 === url.charCodeAt(0) && 47 === url.charCodeAt(1) ? url = url.slice(2) : 47 === url.charCodeAt(0) && (url = url.slice(1))), 
            url;
        },
        raw: function raw(url) {
            if ((url = this.normalize(url)).startsWith("resources/")) {
                var uuid = cc.loader._getResUuid(url.slice(10), cc.Asset, null, !0);
                if (uuid) return cc.AssetLibrary.getLibUrlNoExt(uuid, !0) + cc.path.extname(url);
            } else cc.errorID(7002, url);
            return this._rawAssets + url;
        },
        _init: function _init(assets) {
            this._rawAssets = cc.path.stripSep(assets) + "/";
        }
    };
    cc.url = url;
    var Entry = function Entry(uuid, type) {
        _classCallCheck(this, Entry), this.uuid = uuid, this.type = type;
    };
    function isMatchByWord(path, test) {
        return !(path.length > test.length) || 47 === path.charCodeAt(test.length);
    }
    var AssetTable = function() {
        function AssetTable() {
            _classCallCheck(this, AssetTable), this._pathToUuid = createMap(!0);
        }
        return _createClass(AssetTable, [ {
            key: "getUuid",
            value: function getUuid(path, type) {
                path = url.normalize(path);
                var item = this._pathToUuid[path];
                if (item) if (Array.isArray(item)) {
                    if (!type) return item[0].uuid;
                    for (var i = 0; i < item.length; i++) {
                        var entry = item[i];
                        if (isChildClassOf(entry.type, type)) return entry.uuid;
                    }
                    if (isChildClassOf(type, SpriteFrame)) for (var _i = 0; _i < item.length; _i++) {
                        if (isChildClassOf(item[_i].type, SpriteAtlas)) {
                            errorID(4932, path);
                            break;
                        }
                    }
                } else {
                    if (!type || isChildClassOf(item.type, type)) return item.uuid;
                    isChildClassOf(type, SpriteFrame) && isChildClassOf(item.type, SpriteAtlas) && errorID(4932, path);
                }
                return "";
            }
        }, {
            key: "getUuidArray",
            value: function getUuidArray(path, type, out_urls) {
                "/" === (path = url.normalize(path))[path.length - 1] && (path = path.slice(0, -1));
                var _foundAtlasUrl, path2uuid = this._pathToUuid, uuids = [];
                for (var p in path2uuid) if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
                    var item = path2uuid[p];
                    if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
                        var entry = item[i];
                        !type || isChildClassOf(entry.type, type) ? (uuids.push(entry.uuid), out_urls && out_urls.push(p)) : entry.type === SpriteAtlas && (_foundAtlasUrl = p);
                    } else !type || isChildClassOf(item.type, type) ? (uuids.push(item.uuid), out_urls && out_urls.push(p)) : item.type === SpriteAtlas && (_foundAtlasUrl = p);
                }
                return 0 === uuids.length && _foundAtlasUrl && isChildClassOf(type, SpriteFrame) && errorID(4932, _foundAtlasUrl), 
                uuids;
            }
        }, {
            key: "add",
            value: function add(path, uuid, type, isMainAsset) {
                isMainAsset && (path = path.substring(0, path.length - extname(path).length));
                var newEntry = new Entry(uuid, type);
                pushToMap(this._pathToUuid, path, newEntry, isMainAsset);
            }
        }, {
            key: "_getInfo_DEBUG",
            value: function _getInfo_DEBUG(uuid, out_info) {
                for (var path2uuid = this._pathToUuid, paths = Object.keys(path2uuid), p = 0; p < paths.length; ++p) {
                    var path = paths[p], item = path2uuid[path];
                    if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
                        var entry = item[i];
                        if (entry.uuid === uuid) return out_info.path = path, out_info.type = entry.type, 
                        !0;
                    } else if (item.uuid === uuid) return out_info.path = path, out_info.type = item.type, 
                    !0;
                }
                return !1;
            }
        }, {
            key: "reset",
            value: function reset() {
                this._pathToUuid = createMap(!0);
            }
        } ]), AssetTable;
    }();
    function parseDepends(key, parsed) {
        var item = cc.loader.getItem(key);
        if (item) {
            var depends = item.dependKeys;
            if (depends) for (var i = 0; i < depends.length; i++) {
                var depend = depends[i];
                parsed[depend] || (parsed[depend] = !0, parseDepends(depend, parsed));
            }
        }
    }
    function visitAsset(asset, excludeMap) {
        if (asset._uuid) {
            var key = cc.loader._getReferenceKey(asset);
            excludeMap[key] || (excludeMap[key] = !0, parseDepends(key, excludeMap));
        }
    }
    function visitComponent(comp, excludeMap) {
        for (var props = Object.getOwnPropertyNames(comp), i = 0; i < props.length; i++) {
            var value = comp[props[i]];
            if ("object" === _typeof(value) && value) if (Array.isArray(value)) for (var j = 0; j < value.length; j++) {
                var val = value[j];
                val instanceof RawAsset && visitAsset(val, excludeMap);
            } else if (value.constructor && value.constructor !== Object) value instanceof RawAsset && visitAsset(value, excludeMap); else for (var keys = Object.getOwnPropertyNames(value), _j = 0; _j < keys.length; _j++) {
                var _val = value[keys[_j]];
                _val instanceof RawAsset && visitAsset(_val, excludeMap);
            }
        }
    }
    function visitNode(node, excludeMap) {
        for (var i = 0; i < node._components.length; i++) visitComponent(node._components[i], excludeMap);
        for (var _i = 0; _i < node._children.length; _i++) visitNode(node._children[_i], excludeMap);
    }
    function getDependsRecursively(key) {
        var depends = {};
        return parseDepends(key, depends), Object.keys(depends);
    }
    var ItemState, _qid = 0 | 998 * Math.random(), _queues = createMap(!0), _pool = [];
    !function(ItemState) {
        ItemState[ItemState.WORKING = 0] = "WORKING", ItemState[ItemState.COMPLETE = 1] = "COMPLETE", 
        ItemState[ItemState.ERROR = 2] = "ERROR";
    }(ItemState || (ItemState = {}));
    var _queueDeps = createMap(!0);
    function _parseUrlParam(url) {
        if (url) {
            var split = url.split("?");
            if (split && split[0] && split[1]) {
                var urlParam = {};
                return split[1].split("&").forEach((function(item) {
                    var itemSplit = item.split("=");
                    urlParam[itemSplit[0]] = itemSplit[1];
                })), urlParam;
            }
        }
    }
    function createItem(id, queueId) {
        var url = "object" === _typeof(id) ? id.url : id, result = {
            queueId: queueId,
            id: url,
            url: url,
            rawUrl: void 0,
            urlParam: _parseUrlParam(url),
            type: "",
            error: null,
            content: null,
            complete: !1,
            states: {},
            deps: null,
            isScene: id.uuid && cc.game._sceneInfos.find((function(info) {
                return info.uuid === id.uuid;
            }))
        };
        if ("object" === _typeof(id) && (mixin(result, id), id.skips)) for (var i = 0; i < id.skips.length; i++) {
            var skip = id.skips[i];
            result.states[skip] = ItemState.COMPLETE;
        }
        return result.rawUrl = result.url, url && !result.type && (result.type = extname(url).toLowerCase().substr(1)), 
        result;
    }
    var _checkedIds = [];
    function checkCircleReference(owner, item, recursiveCall) {
        if (!owner || !item) return !1;
        var result = !1;
        if (_checkedIds.push(item.id), item.deps) {
            var i, subDep, deps = item.deps;
            for (i = 0; i < deps.length; i++) {
                if ((subDep = deps[i]).id === owner.id) {
                    result = !0;
                    break;
                }
                if (!(_checkedIds.indexOf(subDep.id) >= 0) && (subDep.deps && checkCircleReference(owner, subDep, !0))) {
                    result = !0;
                    break;
                }
            }
        }
        return recursiveCall || (_checkedIds.length = 0), result;
    }
    var LoadingItems = function(_CallbacksInvoker) {
        function LoadingItems(pipeline, urlList, onProgress, onComplete) {
            var _this;
            return _classCallCheck(this, LoadingItems), (_this = _possibleConstructorReturn(this, _getPrototypeOf(LoadingItems).call(this))).map = createMap(!0), 
            _this.completed = {}, _this.totalCount = 0, _this.completedCount = 0, _this._errorUrls = [], 
            _this._appending = !1, _this._ownerQueue = null, _this._id = ++_qid, _queues[_this._id] = _assertThisInitialized(_this), 
            _this._pipeline = pipeline, _this.onProgress = onProgress, _this.onComplete = onComplete, 
            _this._pipeline ? _this.active = !0 : _this.active = !1, urlList && (urlList.length > 0 ? _this.append(urlList) : _this.allComplete()), 
            _this;
        }
        return _inherits(LoadingItems, _CallbacksInvoker), _createClass(LoadingItems, [ {
            key: "append",
            value: function append(urlList, owner) {
                var _this2 = this;
                if (!this.active) return [];
                owner && !owner.deps && (owner.deps = []), this._appending = !0;
                var i, url, item, id, accepted = [];
                for (i = 0; i < urlList.length; ++i) {
                    if ((url = urlList[i]).queueId && !this.map[url.id]) {
                        if (this.map[url.id] = url, owner && owner.deps.push(url), url.complete || checkCircleReference(owner, url)) {
                            this.totalCount++, this.itemComplete(url.id);
                            continue;
                        }
                        if ("continue" === function() {
                            var self = _this2, queue = _queues[url.queueId];
                            return queue && (_this2.totalCount++, LoadingItems.registerQueueDep(owner || _this2._id, url.id), 
                            queue.addListener(url.id, (function(item) {
                                self.itemComplete(item.id);
                            }))), "continue";
                        }()) continue;
                    }
                    if ("string" == typeof ((id = url).url || id)) {
                        var key = (item = createItem(url, this._id)).id;
                        this.map[key] || (this.map[key] = item, this.totalCount++, owner && owner.deps.push(item), 
                        LoadingItems.registerQueueDep(owner || this._id, key), accepted.push(item));
                    }
                }
                return this._appending = !1, this.completedCount === this.totalCount ? this.allComplete() : this._pipeline.flowIn(accepted), 
                accepted;
            }
        }, {
            key: "_childOnProgress",
            value: function _childOnProgress(item) {
                if (this.onProgress) {
                    var dep = _queueDeps[this._id];
                    this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
                }
            }
        }, {
            key: "allComplete",
            value: function allComplete() {
                var errors = 0 === this._errorUrls.length ? null : this._errorUrls;
                this.onComplete && this.onComplete(errors, this);
            }
        }, {
            key: "isCompleted",
            value: function isCompleted() {
                return this.completedCount >= this.totalCount;
            }
        }, {
            key: "isItemCompleted",
            value: function isItemCompleted(id) {
                return !!this.completed[id];
            }
        }, {
            key: "exists",
            value: function exists(id) {
                return !!this.map[id];
            }
        }, {
            key: "getContent",
            value: function getContent(id) {
                var item = this.map[id], ret = null;
                return item && (item.content ? ret = item.content : item.alias && (ret = item.alias.content)), 
                ret;
            }
        }, {
            key: "getError",
            value: function getError(id) {
                var item = this.map[id], ret = null;
                return item && (item.error ? ret = item.error : item.alias && (ret = item.alias.error)), 
                ret;
            }
        }, {
            key: "removeItem",
            value: function removeItem(url) {
                var item = this.map[url];
                item && this.completed[item.alias || url] && (delete this.completed[url], delete this.map[url], 
                item.alias && (delete this.completed[item.alias.id], delete this.map[item.alias.id]), 
                this.completedCount--, this.totalCount--);
            }
        }, {
            key: "itemComplete",
            value: function itemComplete(id) {
                var item = this.map[id];
                if (item) {
                    var errorListId = this._errorUrls.indexOf(id);
                    if (item.error && -1 === errorListId ? this._errorUrls.push(id) : item.error || -1 === errorListId || this._errorUrls.splice(errorListId, 1), 
                    this.completed[id] = item, this.completedCount++, LoadingItems.finishDep(item.id), 
                    this.onProgress) {
                        var dep = _queueDeps[this._id];
                        this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
                    }
                    this.emit(id, item), this.removeAll(id), !this._appending && this.completedCount >= this.totalCount && this.allComplete();
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.active = !1, this._appending = !1, this._pipeline = null, this._ownerQueue = null, 
                this._errorUrls.length = 0, this.onProgress = void 0, this.onComplete = void 0, 
                this.map = createMap(!0), this.completed = {}, this.totalCount = 0, this.completedCount = 0, 
                CallbacksInvoker.call(this), _queues[this._id] = null, _queueDeps[this._id] && (_queueDeps[this._id].completed.length = 0, 
                _queueDeps[this._id].deps.length = 0), -1 === _pool.indexOf(this) && _pool.length < 10 && _pool.push(this);
            }
        }, {
            key: "addListener",
            value: function addListener(key, callback, target) {
                return _get(_getPrototypeOf(LoadingItems.prototype), "on", this).call(this, key, callback, target);
            }
        }, {
            key: "hasListener",
            value: function hasListener(key, callback, target) {
                return _get(_getPrototypeOf(LoadingItems.prototype), "hasEventListener", this).call(this, key, callback, target);
            }
        }, {
            key: "removeListener",
            value: function removeListener(key, callback, target) {
                return _get(_getPrototypeOf(LoadingItems.prototype), "off", this).call(this, key, callback, target);
            }
        }, {
            key: "removeAllListeners",
            value: function removeAllListeners(key) {
                _get(_getPrototypeOf(LoadingItems.prototype), "removeAll", this).call(this, key);
            }
        } ], [ {
            key: "create",
            value: function create(pipeline, urlList, onProgress, onComplete) {
                void 0 === onProgress ? "function" == typeof urlList && (onComplete = urlList, urlList = onProgress = null) : void 0 === onComplete && ("function" == typeof urlList ? (onComplete = onProgress, 
                onProgress = urlList, urlList = null) : (onComplete = onProgress, onProgress = null));
                var queue = _pool.pop();
                return queue ? (queue._pipeline = pipeline, queue.onProgress = onProgress, queue.onComplete = onComplete, 
                _queues[queue._id] = queue, queue._pipeline && (queue.active = !0), urlList && queue.append(urlList)) : queue = new LoadingItems(pipeline, urlList, onProgress, onComplete), 
                queue;
            }
        }, {
            key: "getQueue",
            value: function getQueue(item) {
                return item.queueId ? _queues[item.queueId] : null;
            }
        }, {
            key: "itemComplete",
            value: function itemComplete(item) {
                var queue = _queues[item.queueId];
                queue && queue.itemComplete(item.id);
            }
        }, {
            key: "initQueueDeps",
            value: function initQueueDeps(queue) {
                var dep = _queueDeps[queue._id];
                dep ? (dep.completed.length = 0, dep.deps.length = 0) : dep = _queueDeps[queue._id] = {
                    completed: [],
                    deps: []
                };
            }
        }, {
            key: "registerQueueDep",
            value: function registerQueueDep(owner, depId) {
                var queueId = owner.queueId || owner;
                if (!queueId) return !1;
                var queueDepList = _queueDeps[queueId];
                if (queueDepList) -1 === queueDepList.deps.indexOf(depId) && queueDepList.deps.push(depId); else if (owner.id) for (var id in _queueDeps) {
                    var queue = _queueDeps[id];
                    -1 !== queue.deps.indexOf(owner.id) && -1 === queue.deps.indexOf(depId) && queue.deps.push(depId);
                }
            }
        }, {
            key: "finishDep",
            value: function finishDep(depId) {
                for (var id in _queueDeps) {
                    var queue = _queueDeps[id];
                    -1 !== queue.deps.indexOf(depId) && -1 === queue.completed.indexOf(depId) && queue.completed.push(depId);
                }
            }
        } ]), LoadingItems;
    }(CallbacksInvoker);
    LoadingItems.ItemState = new cc.Enum(ItemState), cc.LoadingItems = LoadingItems;
    var ItemState$1 = LoadingItems.ItemState;
    function flow(pipe, item) {
        var pipeId = pipe.id, itemState = item.states[pipeId], next = pipe.next, pipeline = pipe.pipeline;
        if (!item.error && itemState !== ItemState$1.WORKING && itemState !== ItemState$1.ERROR) if (itemState === ItemState$1.COMPLETE) next ? flow(next, item) : pipeline.flowOut(item); else {
            item.states[pipeId] = ItemState$1.WORKING;
            var result = pipe.handle(item, (function(err, result) {
                err ? (item.error = err, item.states[pipeId] = ItemState$1.ERROR, pipeline.flowOut(item)) : (result && (item.content = result), 
                item.states[pipeId] = ItemState$1.COMPLETE, next ? flow(next, item) : pipeline.flowOut(item));
            }));
            result instanceof Error ? (item.error = result, item.states[pipeId] = ItemState$1.ERROR, 
            pipeline.flowOut(item)) : void 0 !== result && (null !== result && (item.content = result), 
            item.states[pipeId] = ItemState$1.COMPLETE, next ? flow(next, item) : pipeline.flowOut(item));
        }
    }
    var Pipeline = function() {
        function Pipeline(pipes) {
            _classCallCheck(this, Pipeline), this._cache = createMap(!0), this._pipes = pipes;
            for (var i = 0; i < pipes.length; ++i) {
                var pipe = pipes[i];
                pipe.handle && pipe.id && (pipe.pipeline = this, pipe.next = i < pipes.length - 1 ? pipes[i + 1] : null);
            }
        }
        return _createClass(Pipeline, [ {
            key: "insertPipe",
            value: function insertPipe(pipe, index) {
                if (!pipe.handle || !pipe.id || index > this._pipes.length) cc.warnID(4921); else if (this._pipes.indexOf(pipe) > 0) cc.warnID(4922); else {
                    pipe.pipeline = this;
                    var nextPipe = null;
                    index < this._pipes.length && (nextPipe = this._pipes[index]);
                    var previousPipe = null;
                    index > 0 && (previousPipe = this._pipes[index - 1]), previousPipe && (previousPipe.next = pipe), 
                    pipe.next = nextPipe, this._pipes.splice(index, 0, pipe);
                }
            }
        }, {
            key: "insertPipeAfter",
            value: function insertPipeAfter(refPipe, newPipe) {
                var index = this._pipes.indexOf(refPipe);
                index < 0 || this.insertPipe(newPipe, index + 1);
            }
        }, {
            key: "appendPipe",
            value: function appendPipe(pipe) {
                pipe.handle && pipe.id && (pipe.pipeline = this, pipe.next = null, this._pipes.length > 0 && (this._pipes[this._pipes.length - 1].next = pipe), 
                this._pipes.push(pipe));
            }
        }, {
            key: "flowIn",
            value: function flowIn(items) {
                var i, item, pipe = this._pipes[0];
                if (pipe) {
                    for (i = 0; i < items.length; i++) (item = items[i]).isScene || (this._cache[item.id] = item);
                    for (i = 0; i < items.length; i++) flow(pipe, item = items[i]);
                } else for (i = 0; i < items.length; i++) this.flowOut(items[i]);
            }
        }, {
            key: "flowInDeps",
            value: function flowInDeps(owner, urlList, callback) {
                return LoadingItems.create(this, (function(errors, items) {
                    callback(errors, items), items.destroy();
                })).append(urlList, owner);
            }
        }, {
            key: "flowOut",
            value: function flowOut(item) {
                item.error ? delete this._cache[item.id] : this._cache[item.id] || item.isScene || (this._cache[item.id] = item), 
                item.complete = !0, LoadingItems.itemComplete(item);
            }
        }, {
            key: "copyItemStates",
            value: function copyItemStates(srcItem, dstItems) {
                if (dstItems instanceof Array) for (var i = 0; i < dstItems.length; ++i) dstItems[i].states = srcItem.states; else dstItems.states = srcItem.states;
            }
        }, {
            key: "getItem",
            value: function getItem(id) {
                var item = this._cache[id];
                return item ? (item.alias && (item = item.alias), item) : item;
            }
        }, {
            key: "removeItem",
            value: function removeItem(id) {
                var removed = this._cache[id];
                removed && removed.complete && delete this._cache[id];
                return removed;
            }
        }, {
            key: "clear",
            value: function clear() {
                for (var id in this._cache) {
                    var _item = this._cache[id];
                    delete this._cache[id], _item.complete || (_item.error = new Error("Canceled manually"), 
                    this.flowOut(_item));
                }
            }
        } ]), Pipeline;
    }();
    Pipeline.ItemState = ItemState$1, cc.Pipeline = Pipeline;
    var ID = "MD5Pipe", ExtnameRegex = /(\.[^.\n\\/]*)$/, UuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
    var MD5Pipe = function() {
        function MD5Pipe(md5AssetsMap, md5NativeAssetsMap, libraryBase) {
            _classCallCheck(this, MD5Pipe), this.id = ID, this.async = !1, this.pipeline = null, 
            this.id = ID, this.async = !1, this.pipeline = null, this.md5AssetsMap = md5AssetsMap, 
            this.md5NativeAssetsMap = md5NativeAssetsMap, this.libraryBase = libraryBase;
        }
        return _createClass(MD5Pipe, [ {
            key: "handle",
            value: function handle(item) {
                var hashPatchInFolder = !1;
                return "ttf" === item.type && (hashPatchInFolder = !0), item.url = this.transformURL(item.url, hashPatchInFolder), 
                item;
            }
        }, {
            key: "transformURL",
            value: function transformURL(url, hashPatchInFolder) {
                var uuid = function getUuidFromURL(url) {
                    var matches = url.match(UuidRegex);
                    return matches ? matches[1] : "";
                }(url);
                if (uuid) {
                    var hashValue = (!url.match(this.libraryBase) ? this.md5NativeAssetsMap : this.md5AssetsMap)[uuid];
                    if (hashValue) if (hashPatchInFolder) {
                        var dirname = cc.path.dirname(url), basename = cc.path.basename(url);
                        url = "".concat(dirname, ".").concat(hashValue, "/").concat(basename);
                    } else {
                        var matched = !1;
                        url = url.replace(ExtnameRegex, (function(match, p1) {
                            return matched = !0, "." + hashValue + p1;
                        })), matched || (url = url + "." + hashValue);
                    }
                }
                return url;
            }
        } ]), MD5Pipe;
    }();
    MD5Pipe.ID = ID, Pipeline.MD5Pipe = MD5Pipe;
    var PackState, JsonUnpacker = function() {
        function JsonUnpacker() {
            _classCallCheck(this, JsonUnpacker), this.jsons = {};
        }
        return _createClass(JsonUnpacker, [ {
            key: "load",
            value: function load(indices, packedJson) {
                packedJson.length !== indices.length && cc.errorID(4915);
                for (var i = 0; i < indices.length; i++) {
                    var key = indices[i], json = packedJson[i];
                    this.jsons[key] = json;
                }
            }
        }, {
            key: "retrieve",
            value: function retrieve(key) {
                return this.jsons[key] || null;
            }
        } ]), JsonUnpacker;
    }(), TextureUnpacker = function() {
        function TextureUnpacker() {
            _classCallCheck(this, TextureUnpacker), this.contents = {};
        }
        return _createClass(TextureUnpacker, [ {
            key: "load",
            value: function load(indices, packedJson) {
                var datas = packedJson.data;
                datas.length !== indices.length && cc.errorID(4915);
                for (var i = 0; i < indices.length; i++) this.contents[indices[i]] = {
                    base: datas[i][0],
                    mipmaps: datas[i][1]
                };
            }
        }, {
            key: "retrieve",
            value: function retrieve(key) {
                var content = this.contents[key];
                return content ? {
                    __type__: cc.js._getClassId(cc.Texture2D),
                    content: content
                } : null;
            }
        } ]), TextureUnpacker;
    }(), _noCacheRex = /\?/;
    function urlAppendTimestamp(url) {
        return cc.game.config.noCache && "string" == typeof url && (_noCacheRex.test(url) ? url += "&_t=" + (new Date - 0) : url += "?_t=" + (new Date - 0)), 
        url;
    }
    !function(PackState) {
        PackState[PackState.Invalid = 0] = "Invalid", PackState[PackState.Removed = 1] = "Removed", 
        PackState[PackState.Downloading = 2] = "Downloading", PackState[PackState.Loaded = 3] = "Loaded";
    }(PackState || (PackState = {}));
    var UnpackerData = function UnpackerData() {
        _classCallCheck(this, UnpackerData), this.unpacker = null, this.state = PackState.Invalid;
    }, uuidToPack = {}, packIndices = {}, globalUnpackers = {};
    function error$1(uuid, packUuid) {
        return new Error("Can not retrieve " + uuid + " from packer " + packUuid);
    }
    function initPacks(packs) {
        for (var packUuid in packIndices = packs, packs) for (var uuids = packs[packUuid], i = 0; i < uuids.length; i++) {
            var uuid = uuids[i], pushFront = 1 === uuids.length;
            pushToMap(uuidToPack, uuid, packUuid, pushFront);
        }
    }
    function _loadNewPack(uuid, packUuid, callback) {
        var packUrl = cc.AssetLibrary.getLibUrlNoExt(packUuid) + ".json";
        cc.loader.load({
            url: packUrl,
            ignoreMaxConcurrency: !0
        }, (function(err, packJson) {
            if (err) return errorID(4916, uuid), callback(err);
            var res = _doLoadNewPack(uuid, packUuid, packJson);
            res ? callback(null, res) : callback(error$1(uuid, packUuid));
        }));
    }
    function _doPreload(packUuid, packJson) {
        var unpackerData = globalUnpackers[packUuid];
        unpackerData || ((unpackerData = globalUnpackers[packUuid] = new UnpackerData).state = PackState.Downloading), 
        unpackerData.state !== PackState.Loaded && (unpackerData.unpacker = new JsonUnpacker, 
        unpackerData.unpacker.load(packIndices[packUuid], packJson), unpackerData.state = PackState.Loaded);
    }
    function _doLoadNewPack(uuid, packUuid, packedJson) {
        var unpackerData = globalUnpackers[packUuid];
        unpackerData.state !== PackState.Loaded && ("string" == typeof packedJson && (packedJson = JSON.parse(packedJson)), 
        Array.isArray(packedJson) ? unpackerData.unpacker = new JsonUnpacker : packedJson.type === _getClassId(Texture2D) && (unpackerData.unpacker = new TextureUnpacker), 
        unpackerData.unpacker.load(packIndices[packUuid], packedJson), unpackerData.state = PackState.Loaded);
        return unpackerData.unpacker.retrieve(uuid);
    }
    function _selectLoadedPack(packUuids) {
        for (var existsPackState = PackState.Invalid, existsPackUuid = "", i = 0; i < packUuids.length; i++) {
            var packUuid = packUuids[i], unpackerData = globalUnpackers[packUuid];
            if (unpackerData) {
                var state = unpackerData.state;
                if (state === PackState.Loaded) return packUuid;
                state > existsPackState && (existsPackState = state, existsPackUuid = packUuid);
            }
        }
        return existsPackState !== PackState.Invalid ? existsPackUuid : packUuids[0];
    }
    function load(item, callback) {
        var uuid = item.uuid, packUuid = uuidToPack[uuid];
        if (packUuid) {
            Array.isArray(packUuid) && (packUuid = _selectLoadedPack(packUuid));
            var unpackerData = globalUnpackers[packUuid];
            if (unpackerData && unpackerData.state === PackState.Loaded) {
                var json = unpackerData.unpacker.retrieve(uuid);
                return json || error$1(uuid, packUuid);
            }
            return unpackerData || (console.log("Create unpacker %s for %s", packUuid, uuid), 
            (unpackerData = globalUnpackers[packUuid] = new UnpackerData).state = PackState.Downloading), 
            _loadNewPack(uuid, packUuid, callback), null;
        }
    }
    var PackDownloader = Object.freeze({
        __proto__: null,
        initPacks: initPacks,
        _loadNewPack: _loadNewPack,
        _doPreload: _doPreload,
        _doLoadNewPack: _doLoadNewPack,
        _selectLoadedPack: _selectLoadedPack,
        load: load
    }), UuidRegex$1 = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
    var _uuidToSubPack = Object.create(null), SubPackPipe = function() {
        function SubPackPipe(subpackage) {
            _classCallCheck(this, SubPackPipe), this.id = "SubPackPipe", this.async = !1, this.pipeline = null;
            var _loop = function _loop(packName) {
                var pack = subpackage[packName];
                pack.uuids && pack.uuids.forEach((function(val) {
                    var uuid = decodeUuid(val), uuids = uuid.split("@").map((function(name) {
                        return encodeURIComponent(name);
                    }));
                    uuid = uuids.join("@"), _uuidToSubPack[uuid] = pack.path;
                }));
            };
            for (var packName in subpackage) _loop(packName);
        }
        return _createClass(SubPackPipe, [ {
            key: "handle",
            value: function handle(item) {
                return item.url = this.transformURL(item.url), null;
            }
        }, {
            key: "transformURL",
            value: function transformURL(url) {
                var uuid = function getUuidFromURL$1(url) {
                    var matches = url.match(UuidRegex$1);
                    return matches ? matches[1] : "";
                }(url);
                if (uuid) {
                    var subpackage = _uuidToSubPack[uuid];
                    if (subpackage) return url.replace("res/raw-assets/", subpackage + "raw-assets/");
                }
                return url;
            }
        } ]), SubPackPipe;
    }();
    SubPackPipe.ID = "SubPackPipe", Pipeline.SubPackPipe = SubPackPipe;
    var _libraryBase = "", _rawAssetsBase = "", _uuidToRawAsset = createMap(!0);
    function RawAssetEntry(url, type) {
        this.url = url, this.type = type;
    }
    var _class$s, AssetLibrary = {
        _uuidToAsset: {},
        loadAsset: function loadAsset(uuid, callback, options) {
            if ("string" != typeof uuid) return callInNextTick(callback, new Error("[AssetLibrary] uuid must be string"), null);
            var item = {
                uuid: uuid,
                type: "uuid"
            };
            options && options.existingAsset && (item.existingAsset = options.existingAsset), 
            cc.loader.load(item, (function(error$1, asset) {
                if (error$1 || !asset) error$1 = new Error("[AssetLibrary] loading JSON or dependencies failed: " + (error$1 ? error$1.message : "Unknown error")); else if (asset.constructor === cc.SceneAsset) {
                    var key = cc.loader._getReferenceKey(uuid);
                    asset.scene.dependAssets = getDependsRecursively(key);
                }
                callback && callback(error$1, asset);
            }));
        },
        getLibUrlNoExt: function getLibUrlNoExt(uuid, inRawAssetsDir) {
            var uuids = (uuid = decodeUuid(uuid)).split("@").map((function(name) {
                return encodeURIComponent(name);
            }));
            return uuid = uuids.join("@"), (inRawAssetsDir ? _rawAssetsBase + "assets/" : _libraryBase) + uuid.slice(0, 2) + "/" + uuid;
        },
        _queryAssetInfoInEditor: function _queryAssetInfoInEditor(uuid, callback) {
            callback(new Error("Unable to load resource: EditorExtends is not defined."));
        },
        _getAssetInfoInRuntime: function _getAssetInfoInRuntime(uuid, result) {
            result = result || {
                url: null,
                raw: !1
            };
            var info = _uuidToRawAsset[uuid];
            return info && !isChildClassOf(info.type, cc.Asset) ? (result.url = _rawAssetsBase + info.url, 
            result.raw = !0) : (result.url = this.getLibUrlNoExt(uuid) + ".json", result.raw = !1), 
            result;
        },
        _uuidInSettings: function _uuidInSettings(uuid) {
            return uuid in _uuidToRawAsset;
        },
        queryAssetInfo: function queryAssetInfo(uuid, callback) {
            var info = this._getAssetInfoInRuntime(uuid);
            callback(null, info.url, info.raw);
        },
        parseUuidInEditor: function parseUuidInEditor(url) {},
        loadJson: function loadJson(json, callback) {
            var randomUuid = "" + ((new Date).getTime() + Math.random()), item = {
                uuid: randomUuid,
                type: "uuid",
                content: json,
                skips: [ cc.loader.assetLoader.id, cc.loader.downloader.id ]
            };
            cc.loader.load(item, (function(error, asset) {
                if (error) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + error.message); else {
                    if (asset.constructor === cc.SceneAsset) {
                        var key = cc.loader._getReferenceKey(randomUuid);
                        asset.scene.dependAssets = getDependsRecursively(key);
                    }
                    if (function isScene(asset) {
                        return asset && (asset.constructor === cc.SceneAsset || asset instanceof cc.Scene);
                    }(asset)) {
                        var id = cc.loader._getReferenceKey(randomUuid);
                        cc.loader.removeItem(id);
                    }
                }
                asset._uuid = "", callback && callback(error, asset);
            }));
        },
        getAssetByUuid: function getAssetByUuid(uuid) {
            return AssetLibrary._uuidToAsset[uuid] || null;
        },
        init: function init(options) {
            var libraryPath = options.libraryPath;
            libraryPath = libraryPath.replace(/\\/g, "/"), _libraryBase = cc.path.stripSep(libraryPath) + "/", 
            _rawAssetsBase = options.rawAssetsBase;
            var md5AssetsMap = options.md5AssetsMap;
            if (md5AssetsMap && md5AssetsMap.import) {
                var i = 0, md5ImportMap = createMap(!0), md5Entries = md5AssetsMap.import;
                for (i = 0; i < md5Entries.length; i += 2) {
                    var uuids = decodeUuid(md5Entries[i]).split("@").map((function(name) {
                        return encodeURIComponent(name);
                    }));
                    md5ImportMap[uuids.join("@")] = md5Entries[i + 1];
                }
                var md5RawAssetsMap = createMap(!0);
                for (md5Entries = md5AssetsMap["raw-assets"], i = 0; i < md5Entries.length; i += 2) {
                    var _uuids = decodeUuid(md5Entries[i]).split("@").map((function(name) {
                        return encodeURIComponent(name);
                    }));
                    md5RawAssetsMap[_uuids.join("@")] = md5Entries[i + 1];
                }
                var md5Pipe = new MD5Pipe(md5ImportMap, md5RawAssetsMap, _libraryBase);
                cc.loader.insertPipeAfter(cc.loader.assetLoader, md5Pipe), cc.loader.md5Pipe = md5Pipe;
            }
            if (options.subpackages) {
                var subPackPipe = new SubPackPipe(options.subpackages);
                cc.loader.insertPipeAfter(cc.loader.assetLoader, subPackPipe), cc.loader.subPackPipe = subPackPipe;
            }
            var assetTables = cc.loader._assetTables;
            for (var mount in assetTables) assetTables[mount].reset();
            var rawAssets = options.rawAssets;
            if (rawAssets) for (var mountPoint in rawAssets) {
                var assets = rawAssets[mountPoint];
                for (var _uuid in assets) {
                    var info = assets[_uuid], url = info[0], typeId = info[1], type = _getClassById(typeId);
                    if (type) {
                        _uuidToRawAsset[_uuid] = new RawAssetEntry(mountPoint + "/" + url, type);
                        var isSubAsset = 1 === info[2];
                        assetTables[mountPoint] || (assetTables[mountPoint] = new AssetTable), assetTables[mountPoint].add(url, _uuid, type, !isSubAsset);
                    } else cc.error("Cannot get", typeId);
                }
            }
            options.packedAssets && initPacks(options.packedAssets), cc.url._init(options.mountPaths && options.mountPaths.assets || _rawAssetsBase + "assets");
        }
    };
    cc.AssetLibrary = AssetLibrary;
    var _dec$t, _dec2$d, _class$t, _class2$p, _descriptor$n, Font = ccclass("cc.Font")(_class$s = function(_Asset) {
        function Font() {
            return _classCallCheck(this, Font), _possibleConstructorReturn(this, _getPrototypeOf(Font).apply(this, arguments));
        }
        return _inherits(Font, _Asset), Font;
    }(Asset)) || _class$s;
    cc.Font = Font;
    var _dec$u, _dec2$e, _class$u, _class2$q, _descriptor$o, _descriptor2$g, _descriptor3$b, _descriptor4$6, TTFFont = (_dec$t = ccclass("cc.TTFFont"), 
    _dec2$d = property({
        override: !0
    }), _dec$t((_descriptor$n = _applyDecoratedDescriptor((_class2$p = function(_Font) {
        function TTFFont() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, TTFFont);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TTFFont)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_fontFamily", _descriptor$n, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(TTFFont, _Font), _createClass(TTFFont, [ {
            key: "_nativeAsset",
            get: function get() {
                return this._fontFamily;
            },
            set: function set(value) {
                this._fontFamily = value || "Arial";
            }
        } ]), TTFFont;
    }(Font)).prototype, "_fontFamily", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _applyDecoratedDescriptor(_class2$p.prototype, "_nativeAsset", [ _dec2$d, string ], Object.getOwnPropertyDescriptor(_class2$p.prototype, "_nativeAsset"), _class2$p.prototype), 
    _class$t = _class2$p)) || _class$t);
    cc.TTFFont = TTFFont;
    var _class$v, BitmapFont = (_dec$u = ccclass("cc.BitmapFont"), _dec2$e = property({
        type: SpriteFrame
    }), _dec$u((_descriptor$o = _applyDecoratedDescriptor((_class2$q = function(_Font) {
        function BitmapFont() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, BitmapFont);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BitmapFont)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "fntDataStr", _descriptor$o, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "spriteFrame", _descriptor2$g, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "fontSize", _descriptor3$b, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "fntConfig", _descriptor4$6, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(BitmapFont, _Font), BitmapFont;
    }(Font)).prototype, "fntDataStr", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor2$g = _applyDecoratedDescriptor(_class2$q.prototype, "spriteFrame", [ _dec2$e ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$b = _applyDecoratedDescriptor(_class2$q.prototype, "fontSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return -1;
        }
    }), _descriptor4$6 = _applyDecoratedDescriptor(_class2$q.prototype, "fntConfig", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$u = _class2$q)) || _class$u);
    cc.BitmapFont = BitmapFont;
    var LabelAtlas = ccclass("cc.LabelAtlas")(_class$v = function(_BitmapFont) {
        function LabelAtlas() {
            return _classCallCheck(this, LabelAtlas), _possibleConstructorReturn(this, _getPrototypeOf(LabelAtlas).apply(this, arguments));
        }
        return _inherits(LabelAtlas, _BitmapFont), LabelAtlas;
    }(BitmapFont)) || _class$v;
    cc.LabelAtlas = LabelAtlas;
    var reusedArray = [], AssetLoader = function() {
        function AssetLoader() {
            _classCallCheck(this, AssetLoader), this.id = "AssetLoader", this.async = !0, this.pipeline = null;
        }
        return _createClass(AssetLoader, [ {
            key: "handle",
            value: function handle(item, callback) {
                var uuid = item.uuid;
                if (!uuid) return item.content || null;
                cc.AssetLibrary.queryAssetInfo(uuid, (function(error, url, isRawAsset) {
                    if (error) callback(error); else if (item.url = item.rawUrl = url, item.isRawAsset = isRawAsset, 
                    isRawAsset) {
                        var ext = extname(url).toLowerCase();
                        if (!ext) return void callback(new Error(getError(4931, uuid, url)));
                        ext = ext.substr(1);
                        var queue = LoadingItems.getQueue(item);
                        reusedArray[0] = {
                            queueId: item.queueId,
                            id: url,
                            url: url,
                            type: ext,
                            error: null,
                            alias: item,
                            complete: !0
                        }, queue.append(reusedArray), item.type = ext, callback(null, item.content);
                    } else item.type = "uuid", callback(null, item.content);
                }));
            }
        } ]), AssetLoader;
    }();
    function downloadBinary(item, callback) {
        var url = item.url, xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load binary data failed: " + url;
        xhr.open("GET", url, !0), xhr.responseType = "arraybuffer", xhr.onload = function() {
            var arrayBuffer = xhr.response;
            arrayBuffer ? callback(null, arrayBuffer) : callback({
                status: xhr.status,
                errorMessage: errInfo + "(no response)"
            });
        }, xhr.onerror = function() {
            callback({
                status: xhr.status,
                errorMessage: errInfo + "(error)"
            });
        }, xhr.ontimeout = function() {
            callback({
                status: xhr.status,
                errorMessage: errInfo + "(time out)"
            });
        }, xhr.send(null);
    }
    function downloadText(item, callback) {
        var url = item.url;
        url = urlAppendTimestamp(url);
        var xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load text file failed: " + url;
        xhr.open("GET", url, !0), xhr.overrideMimeType && xhr.overrideMimeType("text/plain; charset=utf-8"), 
        xhr.onload = function() {
            4 === xhr.readyState ? 200 === xhr.status || 0 === xhr.status ? callback(null, xhr.responseText) : callback({
                status: xhr.status,
                errorMessage: errInfo + "(wrong status)"
            }) : callback({
                status: xhr.status,
                errorMessage: errInfo + "(wrong readyState)"
            });
        }, xhr.onerror = function() {
            callback({
                status: xhr.status,
                errorMessage: errInfo + "(error)"
            });
        }, xhr.ontimeout = function() {
            callback({
                status: xhr.status,
                errorMessage: errInfo + "(time out)"
            });
        }, xhr.send(null);
    }
    AssetLoader.ID = "AssetLoader", Pipeline.AssetLoader = AssetLoader;
    var PlayingState = {
        INITIALIZING: 0,
        PLAYING: 1,
        STOPPED: 2
    }, AudioPlayer = function() {
        function AudioPlayer(info) {
            var _this = this;
            _classCallCheck(this, AudioPlayer), this._state = PlayingState.STOPPED, this._duration = 0, 
            this._interrupted = !1, this._blocking = !1, this._duration = info.duration, this._eventTarget = info.eventTarget, 
            this._onHide = function() {
                _this._blocking = !0, _this._state === PlayingState.PLAYING && (_this.pause(), _this._interrupted = !0);
            }, this._onShow = function() {
                _this._blocking = !1, _this._interrupted && (_this.play(), _this._interrupted = !1);
            }, cc.game.on(cc.Game.EVENT_HIDE, this._onHide), cc.game.on(cc.Game.EVENT_SHOW, this._onShow);
        }
        return _createClass(AudioPlayer, [ {
            key: "getState",
            value: function getState() {
                return this._state;
            }
        }, {
            key: "getDuration",
            value: function getDuration() {
                return this._duration;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                cc.game.off(cc.Game.EVENT_HIDE, this._onHide), cc.game.off(cc.Game.EVENT_SHOW, this._onShow);
            }
        } ]), AudioPlayer;
    }();
    cc.internal.AudioPlayer = AudioPlayer;
    var _dec$w, _dec2$f, _class$w, _class2$r, _descriptor$p, _descriptor2$h, _class3$e, _temp$s, AudioPlayerDOM = function(_AudioPlayer) {
        function AudioPlayerDOM(info) {
            var _this;
            return _classCallCheck(this, AudioPlayerDOM), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayerDOM).call(this, info)))._volume = 1, 
            _this._loop = !1, _this._oneShoting = !1, _this._cbRegistered = !1, _this._audio = info.clip, 
            _this._remove_cb = function() {
                _this._cbRegistered && (cc.game.canvas.removeEventListener("touchend", _this._on_gesture), 
                cc.game.canvas.removeEventListener("mouseup", _this._on_gesture), _this._cbRegistered = !1);
            }, _this._post_play = function() {
                _this._state = PlayingState.PLAYING, _this._eventTarget.emit("started"), _this._remove_cb();
            }, _this._post_gesture = function() {
                _this._interrupted ? (_this._post_play(), _this._interrupted = !1) : (_this._audio.pause(), 
                _this._audio.currentTime = 0);
            }, _this._on_gesture = function() {
                if (_this._audio) {
                    var promise = _this._audio.play();
                    if (!promise) return _this._state = PlayingState.PLAYING, void cc.director.once(cc.Director.EVENT_AFTER_UPDATE, _this._post_gesture);
                    promise.then(_this._post_gesture), _this._remove_cb();
                }
            }, _this._audio.volume = _this._volume, _this._audio.loop = _this._loop, _this._audio.addEventListener("ended", (function() {
                _this._oneShoting || (_this._state = PlayingState.STOPPED, _this._audio.currentTime = 0, 
                _this._eventTarget.emit("ended"));
            })), cc.game.canvas.addEventListener("touchend", _this._on_gesture), cc.game.canvas.addEventListener("mouseup", _this._on_gesture), 
            _this._cbRegistered = !0, _this;
        }
        return _inherits(AudioPlayerDOM, _AudioPlayer), _createClass(AudioPlayerDOM, [ {
            key: "play",
            value: function play() {
                var _this2 = this;
                if (this._audio && this._state !== PlayingState.PLAYING) if (this._blocking) this._interrupted = !0; else {
                    var promise = this._audio.play();
                    if (!promise) return this._state = PlayingState.PLAYING, void cc.director.once(cc.Director.EVENT_AFTER_UPDATE, this._post_play);
                    promise.then(this._post_play).catch((function() {
                        _this2._interrupted = !0;
                    }));
                }
            }
        }, {
            key: "pause",
            value: function pause() {
                this._audio && this._state === PlayingState.PLAYING && (this._audio.pause(), this._state = PlayingState.STOPPED, 
                this._oneShoting = !1);
            }
        }, {
            key: "stop",
            value: function stop() {
                this._audio && (this._audio.currentTime = 0, this._state === PlayingState.PLAYING && (this._audio.pause(), 
                this._state = PlayingState.STOPPED, this._oneShoting = !1));
            }
        }, {
            key: "playOneShot",
            value: function playOneShot() {
                var _this3 = this, volume = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, clip = this._audio;
                clip && (clip.currentTime = 0, clip.volume = volume, this._oneShoting || (clip.loop = !1, 
                this._oneShoting = !0, clip.play().then((function() {
                    clip.addEventListener("ended", (function() {
                        clip.currentTime = 0, clip.volume = _this3._volume, clip.loop = _this3._loop, _this3._oneShoting = !1;
                    }), {
                        once: !0
                    });
                })).catch((function() {
                    _this3._oneShoting = !1;
                }))));
            }
        }, {
            key: "setCurrentTime",
            value: function setCurrentTime(val) {
                this._audio && (this._audio.currentTime = clamp(val, 0, this._duration));
            }
        }, {
            key: "getCurrentTime",
            value: function getCurrentTime() {
                return this._audio ? this._audio.currentTime : 0;
            }
        }, {
            key: "setVolume",
            value: function setVolume(val, immediate) {
                this._volume = val, this._audio && (this._audio.volume = val);
            }
        }, {
            key: "getVolume",
            value: function getVolume() {
                return this._audio ? this._audio.volume : this._volume;
            }
        }, {
            key: "setLoop",
            value: function setLoop(val) {
                this._loop = val, this._audio && (this._audio.loop = val);
            }
        }, {
            key: "getLoop",
            value: function getLoop() {
                return this._loop;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._audio && (this._audio.src = ""), _get(_getPrototypeOf(AudioPlayerDOM.prototype), "destroy", this).call(this);
            }
        } ]), AudioPlayerDOM;
    }(AudioPlayer), audioSupport = sys.__audioSupport, AudioPlayerWeb = function(_AudioPlayer) {
        function AudioPlayerWeb(info) {
            var _this;
            return _classCallCheck(this, AudioPlayerWeb), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayerWeb).call(this, info)))._startTime = 0, 
            _this._offset = 0, _this._volume = 1, _this._loop = !1, _this._currentTimer = 0, 
            _this._startInvoked = !1, _this._audio = info.clip, _this._context = audioSupport.context, 
            _this._sourceNode = _this._context.createBufferSource(), _this._gainNode = _this._context.createGain(), 
            _this._gainNode.connect(_this._context.destination), _this._onEndedCB = _this._onEnded.bind(_assertThisInitialized(_this)), 
            _this._onGestureCB = _this._onGesture.bind(_assertThisInitialized(_this)), _this._onGestureProceedCB = _this._onGestureProceed.bind(_assertThisInitialized(_this)), 
            "running" !== _this._context.state && _this._context.resume && (cc.game.canvas.addEventListener("touchend", _this._onGestureCB), 
            cc.game.canvas.addEventListener("mouseup", _this._onGestureCB)), _this;
        }
        return _inherits(AudioPlayerWeb, _AudioPlayer), _createClass(AudioPlayerWeb, [ {
            key: "play",
            value: function play() {
                this._audio && this._state !== PlayingState.PLAYING && (this._blocking || "running" !== this._context.state ? this._interrupted = !0 : this._doPlay());
            }
        }, {
            key: "pause",
            value: function pause() {
                this._state === PlayingState.PLAYING && (this._doStop(), this._offset += this._context.currentTime - this._startTime, 
                this._state = PlayingState.STOPPED, clearInterval(this._currentTimer));
            }
        }, {
            key: "stop",
            value: function stop() {
                this._offset = 0, this._state === PlayingState.PLAYING && (this._doStop(), this._state = PlayingState.STOPPED, 
                clearInterval(this._currentTimer));
            }
        }, {
            key: "playOneShot",
            value: function playOneShot() {
                var volume = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                if (this._audio) {
                    var gainNode = this._context.createGain();
                    gainNode.connect(this._context.destination), gainNode.gain.value = volume;
                    var sourceNode = this._context.createBufferSource();
                    sourceNode.buffer = this._audio, sourceNode.loop = !1, sourceNode.connect(gainNode), 
                    sourceNode.start();
                }
            }
        }, {
            key: "setCurrentTime",
            value: function setCurrentTime(val) {
                this._offset = clamp(val, 0, this._audio && this._audio.duration || this._duration), 
                this._state === PlayingState.PLAYING && (this._doStop(), this._doPlay());
            }
        }, {
            key: "getCurrentTime",
            value: function getCurrentTime() {
                return this._state !== PlayingState.PLAYING ? this._offset : this._context.currentTime - this._startTime + this._offset;
            }
        }, {
            key: "setVolume",
            value: function setVolume(val, immediate) {
                this._volume = val, !immediate && this._gainNode.gain.setTargetAtTime ? this._gainNode.gain.setTargetAtTime(val, this._context.currentTime, .01) : this._gainNode.gain.value = val;
            }
        }, {
            key: "getVolume",
            value: function getVolume() {
                return this._volume;
            }
        }, {
            key: "setLoop",
            value: function setLoop(val) {
                this._loop = val, this._sourceNode.loop = val;
            }
        }, {
            key: "getLoop",
            value: function getLoop() {
                return this._loop;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(AudioPlayerWeb.prototype), "destroy", this).call(this);
            }
        }, {
            key: "_doPlay",
            value: function _doPlay() {
                var _this2 = this;
                this._state = PlayingState.PLAYING, this._sourceNode = this._context.createBufferSource(), 
                this._sourceNode.buffer = this._audio, this._sourceNode.loop = this._loop, this._sourceNode.connect(this._gainNode), 
                this._startTime = this._context.currentTime, this._startInvoked = !1, cc.director.once(cc.Director.EVENT_AFTER_UPDATE, this._playAndEmit, this), 
                clearInterval(this._currentTimer), this._currentTimer = window.setInterval((function() {
                    _this2._onEnded(), clearInterval(_this2._currentTimer), _this2._sourceNode.loop && (_this2._currentTimer = window.setInterval(_this2._onEndedCB, 1e3 * _this2._audio.duration));
                }), 1e3 * (this._audio.duration - this._offset));
            }
        }, {
            key: "_doStop",
            value: function _doStop() {
                this._startInvoked ? this._sourceNode.stop() : cc.director.off(cc.Director.EVENT_AFTER_UPDATE, this._playAndEmit, this);
            }
        }, {
            key: "_playAndEmit",
            value: function _playAndEmit() {
                this._sourceNode.start(0, this._offset), this._eventTarget.emit("started"), this._startInvoked = !0;
            }
        }, {
            key: "_onEnded",
            value: function _onEnded() {
                this._offset = 0, this._startTime = this._context.currentTime, this._sourceNode.loop || (this._eventTarget.emit("ended"), 
                this._state = PlayingState.STOPPED);
            }
        }, {
            key: "_onGestureProceed",
            value: function _onGestureProceed() {
                this._interrupted && (this._doPlay(), this._interrupted = !1), cc.game.canvas.removeEventListener("touchend", this._onGestureCB), 
                cc.game.canvas.removeEventListener("mouseup", this._onGestureCB);
            }
        }, {
            key: "_onGesture",
            value: function _onGesture() {
                "running" !== this._context.state ? this._context.resume().then(this._onGestureProceedCB) : this._onGestureProceed();
            }
        } ]), AudioPlayerWeb;
    }(AudioPlayer), AudioType = Enum({
        WEB_AUDIO: 0,
        DOM_AUDIO: 1,
        JSB_AUDIO: 2,
        UNKNOWN_AUDIO: 3
    }), AudioClip = (_dec$w = ccclass("cc.AudioClip"), _dec2$f = property({
        type: AudioType
    }), _dec$w((_temp$s = _class3$e = function(_Asset) {
        function AudioClip() {
            var _this;
            return _classCallCheck(this, AudioClip), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioClip).call(this)), "_duration", _descriptor$p, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_loadMode", _descriptor2$h, _assertThisInitialized(_this)), 
            _this._audio = null, _this._player = null, _this.loaded = !1, _this;
        }
        return _inherits(AudioClip, _Asset), _createClass(AudioClip, [ {
            key: "destroy",
            value: function destroy() {
                return this._player && this._player.destroy(), _get(_getPrototypeOf(AudioClip.prototype), "destroy", this).call(this);
            }
        }, {
            key: "play",
            value: function play() {
                this._player && this._player.play();
            }
        }, {
            key: "pause",
            value: function pause() {
                this._player && this._player.pause();
            }
        }, {
            key: "stop",
            value: function stop() {
                this._player && this._player.stop();
            }
        }, {
            key: "playOneShot",
            value: function playOneShot(volume) {
                this._player && this._player.playOneShot(volume);
            }
        }, {
            key: "setCurrentTime",
            value: function setCurrentTime(val) {
                this._player && this._player.setCurrentTime(val);
            }
        }, {
            key: "getCurrentTime",
            value: function getCurrentTime() {
                return this._player ? this._player.getCurrentTime() : 0;
            }
        }, {
            key: "getDuration",
            value: function getDuration() {
                return this._player ? this._player.getDuration() : this._duration;
            }
        }, {
            key: "setVolume",
            value: function setVolume(val, immediate) {
                this._player && this._player.setVolume(val, immediate || !1);
            }
        }, {
            key: "getVolume",
            value: function getVolume() {
                return this._player ? this._player.getVolume() : 1;
            }
        }, {
            key: "setLoop",
            value: function setLoop(val) {
                this._player && this._player.setLoop(val);
            }
        }, {
            key: "getLoop",
            value: function getLoop() {
                return !!this._player && this._player.getLoop();
            }
        }, {
            key: "_getPlayer",
            value: function _getPlayer(clip) {
                var ctor;
                return "undefined" != typeof AudioBuffer && clip instanceof AudioBuffer ? (ctor = AudioPlayerWeb, 
                this._loadMode = AudioType.WEB_AUDIO) : (ctor = AudioPlayerDOM, this._loadMode = AudioType.DOM_AUDIO), 
                ctor;
            }
        }, {
            key: "_nativeAsset",
            set: function set(clip) {
                if (this._audio = clip, clip) {
                    var ctor = this._getPlayer(clip);
                    this._player = new ctor({
                        clip: clip,
                        duration: this._duration,
                        eventTarget: this
                    }), this.loaded = !0, this.emit("load");
                } else this._player = null, this._loadMode = AudioType.UNKNOWN_AUDIO, this._duration = 0, 
                this.loaded = !1;
            },
            get: function get() {
                return this._audio;
            }
        }, {
            key: "loadMode",
            get: function get() {
                return this._loadMode;
            }
        }, {
            key: "state",
            get: function get() {
                return this._player ? this._player.getState() : PlayingState.INITIALIZING;
            }
        } ]), AudioClip;
    }(Asset), _class3$e.PlayingState = PlayingState, _class3$e.AudioType = AudioType, 
    _class3$e.preventDeferredLoadDependents = !0, _descriptor$p = _applyDecoratedDescriptor((_class2$r = _temp$s).prototype, "_duration", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor2$h = _applyDecoratedDescriptor(_class2$r.prototype, "_loadMode", [ _dec2$f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return AudioType.UNKNOWN_AUDIO;
        }
    }), _class$w = _class2$r)) || _class$w);
    cc.AudioClip = AudioClip;
    var __audioSupport$1 = sys.__audioSupport, formatSupport$1 = __audioSupport$1.format;
    function loadDomAudio(item, callback) {
        var dom = document.createElement("audio");
        dom.src = item.url;
        var clearEvent = function clearEvent() {
            clearTimeout(timer), dom.removeEventListener("canplaythrough", success, !1), dom.removeEventListener("error", failure, !1), 
            __audioSupport$1.USE_LOADER_EVENT && dom.removeEventListener(__audioSupport$1.USE_LOADER_EVENT, success, !1);
        }, timer = setTimeout((function() {
            0 === dom.readyState ? failure() : success();
        }), 8e3), success = function success() {
            clearEvent(), callback(null, dom);
        }, failure = function failure() {
            clearEvent();
            var message = "load audio failure - " + item.url;
            log(message), callback(message);
        };
        dom.addEventListener("canplaythrough", success, !1), dom.addEventListener("error", failure, !1), 
        __audioSupport$1.USE_LOADER_EVENT && dom.addEventListener(__audioSupport$1.USE_LOADER_EVENT, success, !1);
    }
    function loadWebAudio(item, callback) {
        var context = __audioSupport$1.context;
        context || callback(new Error(getError(4926)));
        var request = cc.loader.getXMLHttpRequest();
        request.open("GET", item.url, !0), request.responseType = "arraybuffer", request.onload = function() {
            context.decodeAudioData(request.response, (function(buffer) {
                callback(null, buffer);
            }), (function() {
                callback("decode error - " + item.id, null);
            }));
        }, request.onerror = function() {
            callback("request error - " + item.id, null);
        }, request.send();
    }
    function downloadAudio(item, callback) {
        if (0 === formatSupport$1.length) return new Error(getError(4927));
        var audioLoader;
        __audioSupport$1.WEB_AUDIO ? audioLoader = item._owner instanceof AudioClip ? item._owner.loadMode === AudioType.WEB_AUDIO ? loadWebAudio : loadDomAudio : item.urlParam && item.urlParam.useDom ? loadDomAudio : loadWebAudio : audioLoader = loadDomAudio;
        audioLoader(item, callback);
    }
    function skip() {
        return null;
    }
    function downloadScript(item, callback, isAsync) {
        var url = item.url, d = document, s = document.createElement("script");
        function loadHandler() {
            s.parentNode && s.parentNode.removeChild(s), s.removeEventListener("load", loadHandler, !1), 
            s.removeEventListener("error", errorHandler, !1), callback(null, url);
        }
        function errorHandler() {
            s.parentNode && s.parentNode.removeChild(s), s.removeEventListener("load", loadHandler, !1), 
            s.removeEventListener("error", errorHandler, !1), callback(new Error(getError(4928, url)));
        }
        s.async = !!isAsync, s.src = urlAppendTimestamp(url), s.addEventListener("load", loadHandler, !1), 
        s.addEventListener("error", errorHandler, !1), d.body.appendChild(s);
    }
    function downloadImage(item, callback, isCrossOrigin, img) {
        void 0 === isCrossOrigin && (isCrossOrigin = !0);
        var url = urlAppendTimestamp(item.url);
        function loadCallback() {
            img.removeEventListener("load", loadCallback), img.removeEventListener("error", errorCallback), 
            img.id = item.id, callback(null, img);
        }
        function errorCallback() {
            img.removeEventListener("load", loadCallback), img.removeEventListener("error", errorCallback), 
            "https:" !== window.location.protocol && img.crossOrigin && "anonymous" === img.crossOrigin.toLowerCase() ? downloadImage(item, callback, !1, img) : callback(new Error(getError(4930, url)));
        }
        if (img = img || new Image, isCrossOrigin && "file:" !== window.location.protocol ? img.crossOrigin = "anonymous" : img.crossOrigin = null, 
        img.complete && img.naturalWidth > 0 && img.src === url) return img;
        img.addEventListener("load", loadCallback), img.addEventListener("error", errorCallback), 
        img.src = url;
    }
    var defaultMap = {
        js: downloadScript,
        png: downloadImage,
        jpg: downloadImage,
        bmp: downloadImage,
        jpeg: downloadImage,
        gif: downloadImage,
        ico: downloadImage,
        tiff: downloadImage,
        webp: downloadImage,
        image: downloadImage,
        pvr: downloadBinary,
        pkm: downloadBinary,
        mp3: downloadAudio,
        ogg: downloadAudio,
        wav: downloadAudio,
        m4a: downloadAudio,
        txt: downloadText,
        xml: downloadText,
        vsh: downloadText,
        fsh: downloadText,
        atlas: downloadText,
        tmx: downloadText,
        tsx: downloadText,
        json: downloadText,
        ExportJson: downloadText,
        plist: downloadText,
        fnt: downloadText,
        font: skip,
        eot: skip,
        ttf: skip,
        woff: skip,
        svg: skip,
        ttc: skip,
        uuid: function downloadUuid(item, callback) {
            var result = load(item, callback);
            return void 0 === result ? this.extMap.json(item, callback) : result || void 0;
        },
        binary: downloadBinary,
        bin: downloadBinary,
        default: downloadText
    }, Downloader = function() {
        function Downloader(extMap) {
            _classCallCheck(this, Downloader), this.id = "Downloader", this.async = !0, this.pipeline = null, 
            this._curConcurrent = 0, this._loadQueue = [], this._subpackages = {}, this.extMap = mixin(extMap, defaultMap);
        }
        return _createClass(Downloader, [ {
            key: "addHandlers",
            value: function addHandlers(extMap) {
                mixin(this.extMap, extMap);
            }
        }, {
            key: "_handleLoadQueue",
            value: function _handleLoadQueue() {
                for (;this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT; ) {
                    var nextOne = this._loadQueue.shift();
                    if (!nextOne) break;
                    var syncRet = this.handle(nextOne.item, nextOne.callback);
                    void 0 !== syncRet && (syncRet instanceof Error ? nextOne.callback(syncRet) : nextOne.callback(null, syncRet));
                }
            }
        }, {
            key: "handle",
            value: function handle(item, callback) {
                var self = this, downloadFunc = this.extMap[item.type] || this.extMap.default, syncRet = void 0;
                if (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
                    if (this._curConcurrent++, void 0 !== (syncRet = downloadFunc.call(this, item, (function(err, result) {
                        self._curConcurrent = Math.max(0, self._curConcurrent - 1), self._handleLoadQueue(), 
                        callback && callback(err, result);
                    })))) return this._curConcurrent = Math.max(0, this._curConcurrent - 1), this._handleLoadQueue(), 
                    syncRet;
                } else if (item.ignoreMaxConcurrency) {
                    if (void 0 !== (syncRet = downloadFunc.call(this, item, callback))) return syncRet;
                } else this._loadQueue.push({
                    item: item,
                    callback: callback
                });
            }
        }, {
            key: "loadSubpackage",
            value: function loadSubpackage(name, completeCallback) {
                var pac = this._subpackages[name];
                pac ? pac.loaded ? completeCallback && completeCallback() : downloadScript({
                    url: pac.path
                }, (function(err) {
                    err || (pac.loaded = !0), completeCallback && completeCallback(err);
                })) : completeCallback && completeCallback(new Error("Can't find subpackage ".concat(name)));
            }
        } ]), Downloader;
    }();
    Downloader.ID = "Downloader", Downloader.PackDownloader = PackDownloader, Pipeline.Downloader = Downloader;
    var plistParser = new (function(_SAXParser) {
        function PlistParser() {
            return _classCallCheck(this, PlistParser), _possibleConstructorReturn(this, _getPrototypeOf(PlistParser).apply(this, arguments));
        }
        return _inherits(PlistParser, _SAXParser), _createClass(PlistParser, [ {
            key: "parse",
            value: function parse(xmlTxt) {
                var xmlDoc = this._parseXML(xmlTxt), plist = xmlDoc.documentElement;
                if ("plist" !== plist.tagName) return cc.warnID(5100), {};
                for (var node = null, i = 0, len = plist.childNodes.length; i < len && 1 !== (node = plist.childNodes[i]).nodeType; i++) ;
                return xmlDoc = null, this._parseNode(node);
            }
        }, {
            key: "_parseNode",
            value: function _parseNode(node) {
                var data = null, tagName = node.tagName;
                if ("dict" === tagName) data = this._parseDict(node); else if ("array" === tagName) data = this._parseArray(node); else if ("string" === tagName) if (1 === node.childNodes.length) data = node.firstChild.nodeValue; else {
                    data = "";
                    for (var i = 0; i < node.childNodes.length; i++) data += node.childNodes[i].nodeValue;
                } else "false" === tagName ? data = !1 : "true" === tagName ? data = !0 : "real" === tagName ? data = parseFloat(node.firstChild.nodeValue) : "integer" === tagName && (data = parseInt(node.firstChild.nodeValue, 10));
                return data;
            }
        }, {
            key: "_parseArray",
            value: function _parseArray(node) {
                for (var data = [], i = 0, len = node.childNodes.length; i < len; i++) {
                    var child = node.childNodes[i];
                    1 === child.nodeType && data.push(this._parseNode(child));
                }
                return data;
            }
        }, {
            key: "_parseDict",
            value: function _parseDict(node) {
                for (var data = {}, key = null, i = 0, len = node.childNodes.length; i < len; i++) {
                    var child = node.childNodes[i];
                    1 === child.nodeType && ("key" === child.tagName ? key = child.firstChild.nodeValue : data[key] = this._parseNode(child));
                }
                return data;
            }
        } ]), PlistParser;
    }(function() {
        function SAXParser() {
            _classCallCheck(this, SAXParser), window.DOMParser ? (this._isSupportDOMParser = !0, 
            this._parser = new DOMParser) : (this._isSupportDOMParser = !1, this._parser = null);
        }
        return _createClass(SAXParser, [ {
            key: "parse",
            value: function parse(xmlTxt) {
                return this._parseXML(xmlTxt);
            }
        }, {
            key: "_parseXML",
            value: function _parseXML(textxml) {
                var xmlDoc;
                return this._isSupportDOMParser ? xmlDoc = this._parser.parseFromString(textxml, "text/xml") : ((xmlDoc = new ActiveXObject("Microsoft.XMLDOM")).async = "false", 
                xmlDoc.loadXML(textxml)), xmlDoc;
            }
        } ]), SAXParser;
    }()));
    function isSceneObj(json) {
        return json && (json[0] && "cc.Scene" === json[0].__type__ || json[1] && "cc.Scene" === json[1].__type__ || json[0] && "cc.Prefab" === json[0].__type__);
    }
    function loadUuid(item, callback) {
        var json, classFinder;
        if ("string" == typeof item.content) try {
            json = JSON.parse(item.content);
        } catch (e) {
            return new Error(getError(4923, item.id, e.stack));
        } else {
            if ("object" !== _typeof(item.content)) return new Error(getError(4924));
            json = item.content;
        }
        if (null == json) return new Error(getError(4923, item.id));
        var isScene = isSceneObj(json);
        classFinder = isScene ? cc._MissingScript.safeFindClass : function classFinder(id) {
            var cls = _getClassById(id);
            return cls || (cc.warnID(4903, id), Object);
        };
        var asset, tdInfo = cc.deserialize.Details.pool.get();
        try {
            asset = cc.deserialize(json, tdInfo, {
                classFinder: classFinder,
                target: item.existingAsset,
                customEnv: item
            });
        } catch (e) {
            return cc.deserialize.Details.pool.put(tdInfo), console.error(e), new Error("Failed to load asset ".concat(item.id, ", exception occurs during deserialization: ").concat(e + "\n" + e.stack, "."));
        }
        asset._uuid = item.uuid;
        var deferredLoad = function canDeferredLoad(asset, item, isScene) {
            var res = item.deferredLoadRaw;
            return res ? asset instanceof cc.Asset && asset.constructor.preventDeferredLoadDependents && (res = !1) : isScene && (asset instanceof cc.SceneAsset || asset instanceof cc.Prefab) && (res = asset.asyncLoadAssets), 
            res;
        }(asset, item, isScene), depends = function parseDepends$1(item, asset, tdInfo, deferredLoadRawAssetsInRuntime) {
            var depends, i, dependUuid, uuidList = tdInfo.uuidList, objList = tdInfo.uuidObjList, propList = tdInfo.uuidPropList, stillUseUrl = tdInfo._stillUseUrl, dependKeys = item.dependKeys = [];
            if (deferredLoadRawAssetsInRuntime) for (depends = [], i = 0; i < uuidList.length; i++) {
                dependUuid = uuidList[i];
                var obj = objList[i], prop = propList[i], info = cc.AssetLibrary._getAssetInfoInRuntime(dependUuid);
                if (info.raw) {
                    var url = info.url;
                    obj[prop] = url, dependKeys.push(url);
                } else depends.push({
                    type: "uuid",
                    uuid: dependUuid,
                    deferredLoadRaw: !0,
                    _owner: obj,
                    _ownerProp: prop,
                    _stillUseUrl: stillUseUrl[i]
                });
            } else {
                for (depends = new Array(uuidList.length), i = 0; i < uuidList.length; i++) dependUuid = uuidList[i], 
                depends[i] = {
                    type: "uuid",
                    uuid: dependUuid,
                    _owner: objList[i],
                    _ownerProp: propList[i],
                    _stillUseUrl: stillUseUrl[i]
                };
                asset._native && !asset.constructor.preventPreloadNativeObject && depends.push({
                    url: asset.nativeUrl,
                    _owner: asset,
                    _ownerProp: "_nativeAsset"
                });
            }
            return depends;
        }(item, asset, tdInfo, deferredLoad);
        cc.deserialize.Details.pool.put(tdInfo);
        var wrappedCallback = function wrappedCallback(err, asset) {
            if (!err && asset.onLoaded) try {
                asset.onLoaded();
            } catch (error) {
                err = error;
            }
            callback(err, asset);
        };
        if (0 === depends.length) return wrappedCallback(null, asset);
        !function loadDepends(pipeline, item, asset, depends, callback) {
            item.content = asset;
            var dependKeys = item.dependKeys;
            pipeline.flowInDeps(item, depends, (function(errors, items) {
                var item, itemsMap = items.map;
                for (var src in itemsMap) (item = itemsMap[src]).uuid && item.content && (item.content._uuid = item.uuid);
                for (var i = 0; i < depends.length; i++) {
                    var loadCallback = function loadCallback(item) {
                        var value = item.content;
                        this._stillUseUrl && (value = value ? value.nativeUrl : item.rawUrl), this._owner[this._ownerProp] = value, 
                        item.uuid !== asset._uuid && dependKeys.indexOf(item.id) < 0 && dependKeys.push(item.id);
                    }, dep = depends[i], dependSrc = dep.uuid, dependUrl = dep.url;
                    dep._owner, dep._ownerProp;
                    if (item = itemsMap[dependUrl]) {
                        var loadCallbackCtx = dep;
                        if (item.complete || item.content) {
                            if (item.error) cc._throw(item.error); else loadCallback.call(loadCallbackCtx, item);
                        } else {
                            var queue = LoadingItems.getQueue(item), list = queue._callbackTable[dependSrc];
                            list ? list.unshift(loadCallback, loadCallbackCtx) : queue.addListener(dependSrc, loadCallback, loadCallbackCtx);
                        }
                    }
                }
                callback(errors, asset);
            }));
        }(this.pipeline, item, asset, depends, wrappedCallback);
    }
    loadUuid.isSceneObj = isSceneObj;
    var _canvasContext = null, _fontFaces = {}, _intervalId = -1, _loadingFonts = [];
    function _checkFontLoaded() {
        for (var allFontsLoaded = !0, now = Date.now(), i = _loadingFonts.length - 1; i >= 0; i--) {
            var fontLoadHandle = _loadingFonts[i], fontFamily = fontLoadHandle.fontFamilyName;
            if (now - fontLoadHandle.startTime > 6e4) cc.warnID(4933, fontFamily), fontLoadHandle.callback(null, fontFamily), 
            _loadingFonts.splice(i, 1); else {
                var oldWidth = fontLoadHandle.refWidth;
                _canvasContext.font = "40px " + fontFamily, oldWidth !== safeMeasureText(_canvasContext, "BES bswy:->@") ? (_loadingFonts.splice(i, 1), 
                fontLoadHandle.callback(null, fontFamily)) : allFontsLoaded = !1;
            }
        }
        allFontsLoaded && (clearInterval(_intervalId), _intervalId = -1);
    }
    function loadFont(item, callback) {
        var url = item.url, fontFamilyName = function _getFontFamily(fontHandle) {
            var ttfIndex = fontHandle.lastIndexOf(".ttf");
            if (-1 === ttfIndex) return fontHandle;
            var fontFamilyName, slashPos = fontHandle.lastIndexOf("/");
            fontFamilyName = -1 === slashPos ? fontHandle.substring(0, ttfIndex) + "_LABEL" : fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
            -1 !== fontFamilyName.indexOf(" ") && (fontFamilyName = '"' + fontFamilyName + '"');
            return fontFamilyName;
        }(url);
        if (_fontFaces[fontFamilyName]) return fontFamilyName;
        if (!_canvasContext) {
            var labelCanvas = document.createElement("canvas");
            labelCanvas.width = 100, labelCanvas.height = 100, _canvasContext = labelCanvas.getContext("2d");
        }
        var fontDesc = "40px " + fontFamilyName;
        _canvasContext.font = fontDesc;
        var refWidth = safeMeasureText(_canvasContext, "BES bswy:->@"), fontStyle = document.createElement("style");
        fontStyle.type = "text/css";
        var fontStr = "";
        isNaN(fontFamilyName - 0) ? fontStr += "@font-face { font-family:" + fontFamilyName + "; src:" : fontStr += "@font-face { font-family:'" + fontFamilyName + "'; src:", 
        fontStr += "url('" + url + "');", fontStyle.textContent = fontStr + "}", document.body.appendChild(fontStyle);
        var preloadDiv = document.createElement("div"), divStyle = preloadDiv.style;
        divStyle.fontFamily = fontFamilyName, preloadDiv.innerHTML = ".", divStyle.position = "absolute", 
        divStyle.left = "-100px", divStyle.top = "-100px", document.body.appendChild(preloadDiv);
        var fontLoadHandle = {
            fontFamilyName: fontFamilyName,
            refWidth: refWidth,
            callback: callback,
            startTime: Date.now()
        };
        _loadingFonts.push(fontLoadHandle), _fontFaces[fontFamilyName] = fontStyle, -1 === _intervalId && (_intervalId = setInterval(_checkFontLoaded, 100));
    }
    function loadJSON(item) {
        if ("string" != typeof item.content) return new Error("JSON Loader: Input item doesn't contain string content");
        try {
            return JSON.parse(item.content);
        } catch (e) {
            return new Error("JSON Loader: Parse json [" + item.id + "] failed : " + e);
        }
    }
    function loadImage(item) {
        if (item._owner instanceof cc.Asset) return null;
        var image = item.content;
        if (cc.sys.platform !== cc.sys.FB_PLAYABLE_ADS && !(image instanceof Image)) return new Error("Image Loader: Input item doesn't contain Image content");
        var rawUrl = item.rawUrl, imageAsset = item.imageAsset || new ImageAsset;
        return imageAsset._uuid = item.uuid, imageAsset._url = rawUrl, imageAsset._setRawAsset(rawUrl, !1), 
        imageAsset._nativeAsset = image, imageAsset;
    }
    function loadAudioAsAsset(item, callback) {
        if (item._owner instanceof cc.Asset) return null;
        var audioClip = new cc.AudioClip;
        return audioClip._setRawAsset(item.rawUrl, !1), audioClip._nativeAsset = item.content, 
        audioClip;
    }
    function loadBinary(item) {
        return item.load ? item.load(item.content) : item.content;
    }
    function readBEUint16(header, offset) {
        return header[offset] << 8 | header[offset + 1];
    }
    var defaultMap$1 = {
        png: loadImage,
        jpg: loadImage,
        bmp: loadImage,
        jpeg: loadImage,
        gif: loadImage,
        ico: loadImage,
        tiff: loadImage,
        webp: loadImage,
        image: loadImage,
        pvr: function loadPVRTex(item) {
            var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer, header = new Int32Array(buffer, 0, 13);
            if (55727696 === header[0]) {
                var width = header[7], height = header[6], dataOffset = header[12] + 52;
                return buffer = buffer.slice(dataOffset, buffer.byteLength), {
                    _data: new Uint8Array(buffer),
                    _compressed: !0,
                    width: width,
                    height: height
                };
            }
            if (559044176 === header[11]) {
                var headerLength = header[0], _height = header[1], _width = header[2];
                return buffer = buffer.slice(headerLength, buffer.byteLength), {
                    _data: new Uint8Array(buffer),
                    _compressed: !0,
                    width: _width,
                    height: _height
                };
            }
            return new Error("Invalid magic number in PVR header");
        },
        pkm: function loadPKMTex(item) {
            var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer, header = new Uint8Array(buffer), format = readBEUint16(header, 6);
            if (0 !== format && 1 !== format && 3 !== format) return new Error("Invalid magic number in ETC header");
            var width = readBEUint16(header, 12), height = readBEUint16(header, 14);
            return readBEUint16(header, 8), readBEUint16(header, 10), buffer = buffer.slice(16, buffer.byteLength), 
            {
                _data: new Uint8Array(buffer),
                _compressed: !0,
                width: width,
                height: height
            };
        },
        mp3: loadAudioAsAsset,
        ogg: loadAudioAsAsset,
        wav: loadAudioAsAsset,
        m4a: loadAudioAsAsset,
        json: loadJSON,
        ExportJson: loadJSON,
        plist: function loadPlist(item) {
            if ("string" != typeof item.content) return new Error("Plist Loader: Input item doesn't contain string content");
            var result = plistParser.parse(item.content);
            return result || new Error("Plist Loader: Parse [" + item.id + "] failed");
        },
        uuid: loadUuid,
        prefab: loadUuid,
        fire: loadUuid,
        scene: loadUuid,
        binary: loadBinary,
        bin: loadBinary,
        font: loadFont,
        eot: loadFont,
        ttf: loadFont,
        woff: loadFont,
        svg: loadFont,
        ttc: loadFont,
        default: function loadNothing() {
            return null;
        }
    }, Loader = function() {
        function Loader(extMap) {
            _classCallCheck(this, Loader), this.id = "Loader", this.async = !0, this.pipeline = null, 
            this.extMap = mixin(extMap, defaultMap$1);
        }
        return _createClass(Loader, [ {
            key: "addHandlers",
            value: function addHandlers(extMap) {
                this.extMap = mixin(this.extMap, extMap);
            }
        }, {
            key: "handle",
            value: function handle(item, callback) {
                return (this.extMap[item.type] || this.extMap.default).call(this, item, callback);
            }
        } ]), Loader;
    }();
    Loader.ID = "Loader", Pipeline.Loader = Loader;
    var _tmpInfo = null;
    function doCheckCouldRelease(releasedKey, refOwnerItem, caches) {
        caches[releasedKey] || cc.log('"'.concat(releasedKey, '" was released but maybe still referenced by ').concat(function getItemDesc(item) {
            return item.uuid ? (_tmpInfo || (_tmpInfo = {
                path: "",
                type: null
            }), cc.loader._assetTables.assets._getInfo_DEBUG(item.uuid, _tmpInfo) ? (_tmpInfo.path = "resources/" + _tmpInfo.path, 
            '"'.concat(_tmpInfo.path, '" (type: ').concat(getClassName(_tmpInfo.type), ", uuid: ").concat(item.uuid, ")")) : '"'.concat(item.rawUrl, '" (').concat(item.uuid, ")")) : '"'.concat(item.rawUrl, '"');
        }(refOwnerItem)));
    }
    var ReleasedAssetChecker = function() {
        function ReleasedAssetChecker() {
            _classCallCheck(this, ReleasedAssetChecker), this._releasedKeys = createMap(!0), 
            this._dirty = !1;
        }
        return _createClass(ReleasedAssetChecker, [ {
            key: "setReleased",
            value: function setReleased(item, releasedKey) {
                this._releasedKeys[releasedKey] = !0, this._dirty = !0;
            }
        }, {
            key: "checkCouldRelease",
            value: function checkCouldRelease(caches) {
                if (this._dirty) {
                    this._dirty = !1;
                    var released = this._releasedKeys;
                    for (var id in caches) {
                        var item = caches[id];
                        item.alias && (item = item.alias);
                        var depends = item.dependKeys;
                        if (depends) for (var i = 0; i < depends.length; ++i) {
                            var depend = depends[i];
                            released[depend] && (doCheckCouldRelease(depend, item, caches), delete released[depend]);
                        }
                    }
                    clear(released);
                }
            }
        } ]), ReleasedAssetChecker;
    }(), assetTables = Object.create(null);
    function getXMLHttpRequest() {
        return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP");
    }
    assetTables.assets = new AssetTable, assetTables.internal = new AssetTable;
    var _info = {
        url: null,
        raw: !1
    };
    function getResWithUrl(res) {
        var id, result, isUuid;
        if ("object" === _typeof(res)) {
            if (result = res, res.url) return result;
            id = res.uuid;
        } else result = {}, id = res;
        return isUuid = result.type ? "uuid" === result.type : cc.AssetLibrary._uuidInSettings(id), 
        cc.AssetLibrary._getAssetInfoInRuntime(id, _info), result.url = isUuid ? _info.url : id, 
        _info.url && "uuid" === result.type && _info.raw ? (result.type = null, result.isRawAsset = !0) : isUuid || (result.isRawAsset = !0), 
        result;
    }
    var _sharedResources = [], _sharedList = [], CCLoader = function(_Pipeline) {
        function CCLoader() {
            var _this;
            _classCallCheck(this, CCLoader);
            var assetLoader = new AssetLoader, downloader = new Downloader, loader = new Loader;
            return (_this = _possibleConstructorReturn(this, _getPrototypeOf(CCLoader).call(this, [ assetLoader, downloader, loader ]))).getXMLHttpRequest = getXMLHttpRequest, 
            _this.assetLoader = assetLoader, _this.md5Pipe = null, _this.downloader = downloader, 
            _this.loader = loader, _this.onProgress = null, _this._assetTables = assetTables, 
            _this._autoReleaseSetting = createMap(!0), _this._releasedAssetChecker_DEBUG = new ReleasedAssetChecker, 
            _this;
        }
        return _inherits(CCLoader, _Pipeline), _createClass(CCLoader, [ {
            key: "init",
            value: function init(director) {
                var self = this;
                director.on(cc.Director.EVENT_AFTER_UPDATE, (function() {
                    self._releasedAssetChecker_DEBUG.checkCouldRelease(self._cache);
                }));
            }
        }, {
            key: "addDownloadHandlers",
            value: function addDownloadHandlers(extMap) {
                this.downloader.addHandlers(extMap);
            }
        }, {
            key: "addLoadHandlers",
            value: function addLoadHandlers(extMap) {
                this.loader.addHandlers(extMap);
            }
        }, {
            key: "load",
            value: function load(resources, progressCallback, completeCallback) {
                void 0 === completeCallback && (completeCallback = progressCallback, progressCallback = this.onProgress || null);
                var res, self = this, singleRes = !1;
                resources instanceof Array || (resources ? (singleRes = !0, resources = [ resources ]) : resources = []), 
                _sharedResources.length = 0;
                for (var i = 0; i < resources.length; ++i) {
                    var resource = resources[i];
                    if (resource && resource.id && (cc.warnID(4920, resource.id), resource.uuid || resource.url || (resource.url = resource.id)), 
                    (res = getResWithUrl(resource)).url || res.uuid) {
                        var item = this._cache[res.url];
                        _sharedResources.push(item || res);
                    }
                }
                var queue = LoadingItems.create(this, progressCallback, (function(errors, items) {
                    callInNextTick((function() {
                        if (completeCallback) {
                            if (singleRes) {
                                var id = res.url;
                                completeCallback.call(self, items.getError(id), items.getContent(id));
                            } else completeCallback.call(self, errors, items);
                            completeCallback = null;
                        }
                        items.destroy();
                    }));
                }));
                LoadingItems.initQueueDeps(queue), queue.append(_sharedResources), _sharedResources.length = 0;
            }
        }, {
            key: "flowInDeps",
            value: function flowInDeps(owner, urlList, callback) {
                _sharedList.length = 0;
                for (var i = 0; i < urlList.length; ++i) {
                    var res = getResWithUrl(urlList[i]);
                    if (res.url || res.uuid) {
                        var item = this._cache[res.url];
                        item ? _sharedList.push(item) : _sharedList.push(res);
                    }
                }
                var queue = LoadingItems.create(this, owner ? function(completedCount, totalCount, item) {
                    queue._ownerQueue && queue._ownerQueue.onProgress && queue._ownerQueue._childOnProgress(item);
                } : null, (function(errors, items) {
                    callback(errors, items), owner && owner.deps && (owner.deps.length = 0), items.destroy();
                }));
                if (owner) {
                    var ownerQueue = LoadingItems.getQueue(owner);
                    queue._ownerQueue = ownerQueue && ownerQueue._ownerQueue || ownerQueue;
                }
                var accepted = queue.append(_sharedList, owner);
                return _sharedList.length = 0, accepted;
            }
        }, {
            key: "loadRes",
            value: function loadRes(url, type, mount, progressCallback, completeCallback) {
                5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
                mount = "assets");
                var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
                type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
                var self = this, uuid = self._getResUuid(url, type, mount, !0);
                uuid ? this.load({
                    type: "uuid",
                    uuid: uuid
                }, progressCallback, (function(err, asset) {
                    asset && self.setAutoReleaseRecursively(uuid, !1), completeCallback && completeCallback(err, asset);
                })) : self._urlNotFound(url, type, completeCallback);
            }
        }, {
            key: "loadResDir",
            value: function loadResDir(url, type, mount, progressCallback, completeCallback) {
                if (5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
                mount = "assets"), assetTables[mount]) {
                    var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
                    type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
                    var urls = [], uuids = assetTables[mount].getUuidArray(url, type, urls);
                    this._loadResUuids(uuids, progressCallback, (function(errors, assetRes, urlRes) {
                        for (var assetResLength = assetRes.length, i = 0; i < assetResLength; ++i) if (assetRes[i] instanceof cc.SpriteAtlas) {
                            var spriteFrames = assetRes[i].getSpriteFrames();
                            for (var k in spriteFrames) {
                                var sf = spriteFrames[k];
                                assetRes.push(sf), urlRes && urlRes.push("".concat(urlRes[i], "/").concat(sf.name));
                            }
                        }
                        completeCallback && completeCallback(errors, assetRes, urlRes);
                    }), urls);
                }
            }
        }, {
            key: "loadResArray",
            value: function loadResArray(urls, type, mount, progressCallback, completeCallback) {
                5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
                mount = "assets");
                var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
                type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
                for (var uuids = [], i = 0; i < urls.length; i++) {
                    var _url = urls[i], uuid = this._getResUuid(_url, type, mount, !0);
                    if (!uuid) return void this._urlNotFound(_url, type, completeCallback);
                    uuids.push(uuid);
                }
                this._loadResUuids(uuids, progressCallback, completeCallback);
            }
        }, {
            key: "getRes",
            value: function getRes(url, type) {
                var item = this._cache[url];
                if (!item) {
                    var uuid = this._getResUuid(url, type, null, !0);
                    if (!uuid) return null;
                    var ref = this._getReferenceKey(uuid);
                    item = this._cache[ref];
                }
                return item && item.alias && (item = item.alias), item && item.complete ? item.content : null;
            }
        }, {
            key: "getResCount",
            value: function getResCount() {
                return Object.keys(this._cache).length;
            }
        }, {
            key: "getDependsRecursively",
            value: function getDependsRecursively$1(owner) {
                if (owner) {
                    var key = this._getReferenceKey(owner), assets = getDependsRecursively(key);
                    return assets.push(key), assets;
                }
                return [];
            }
        }, {
            key: "release",
            value: function release(asset) {
                if (Array.isArray(asset)) for (var i = 0; i < asset.length; i++) {
                    var key = asset[i];
                    this.release(key);
                } else if (asset) {
                    var id = this._getReferenceKey(asset), item = this.getItem(id);
                    if (item) {
                        var removed = this.removeItem(id);
                        if ((asset = item.content) instanceof cc.Asset) {
                            var nativeUrl = asset.nativeUrl;
                            nativeUrl && this.release(nativeUrl), asset.destroy();
                        }
                        removed && this._releasedAssetChecker_DEBUG.setReleased(item, id);
                    }
                }
            }
        }, {
            key: "releaseAsset",
            value: function releaseAsset(asset) {
                var uuid = asset._uuid;
                uuid && this.release(uuid);
            }
        }, {
            key: "releaseRes",
            value: function releaseRes(url, type, mount) {
                var uuid = this._getResUuid(url, type, mount, !0);
                uuid ? this.release(uuid) : cc.errorID(4914, url);
            }
        }, {
            key: "releaseResDir",
            value: function releaseResDir(url, type, mount) {
                if (assetTables[mount = mount || "assets"]) for (var uuids = assetTables[mount].getUuidArray(url, type), i = 0; i < uuids.length; i++) {
                    var uuid = uuids[i];
                    this.release(uuid);
                }
            }
        }, {
            key: "releaseAll",
            value: function releaseAll() {
                for (var id in this._cache) this.release(id);
            }
        }, {
            key: "removeItem",
            value: function removeItem(key) {
                var removed = Pipeline.prototype.removeItem.call(this, key);
                return delete this._autoReleaseSetting[key], removed;
            }
        }, {
            key: "setAutoRelease",
            value: function setAutoRelease(assetOrUrlOrUuid, autoRelease) {
                var key = this._getReferenceKey(assetOrUrlOrUuid);
                key && (this._autoReleaseSetting[key] = !!autoRelease);
            }
        }, {
            key: "setAutoReleaseRecursively",
            value: function setAutoReleaseRecursively(assetOrUrlOrUuid, autoRelease) {
                autoRelease = !!autoRelease;
                var key = this._getReferenceKey(assetOrUrlOrUuid);
                if (key) {
                    this._autoReleaseSetting[key] = autoRelease;
                    for (var depends = getDependsRecursively(key), i = 0; i < depends.length; i++) {
                        var depend = depends[i];
                        this._autoReleaseSetting[depend] = autoRelease;
                    }
                } else 0;
            }
        }, {
            key: "isAutoRelease",
            value: function isAutoRelease(assetOrUrl) {
                var key = this._getReferenceKey(assetOrUrl);
                return !!key && !!this._autoReleaseSetting[key];
            }
        }, {
            key: "_getResUuid",
            value: function _getResUuid(url, type, mount, quiet) {
                var uuid = "", assetTable = assetTables[mount = mount || "assets"];
                if (url && assetTable) {
                    var index = url.indexOf("?");
                    if (-1 !== index && (url = url.substr(0, index)), !(uuid = assetTable.getUuid(url, type))) {
                        var extname = cc.path.extname(url);
                        extname && (url = url.slice(0, -extname.length), (uuid = assetTable.getUuid(url, type)) && !quiet && cc.warnID(4901, url, extname));
                    }
                }
                return !uuid && type && (isChildClassOf(type, SpriteFrame) || isChildClassOf(type, Texture2D) || isChildClassOf(type, TextureCube)) && cc.warnID(4934), 
                uuid;
            }
        }, {
            key: "_getReferenceKey",
            value: function _getReferenceKey(assetOrUrlOrUuid) {
                var key;
                return "object" === _typeof(assetOrUrlOrUuid) ? key = assetOrUrlOrUuid._uuid || null : "string" == typeof assetOrUrlOrUuid && (key = this._getResUuid(assetOrUrlOrUuid, null, null, !0) || assetOrUrlOrUuid), 
                key ? (cc.AssetLibrary._getAssetInfoInRuntime(key, _info), this._cache[_info.url] ? _info.url : key) : (cc.warnID(4800, assetOrUrlOrUuid), 
                key);
            }
        }, {
            key: "_urlNotFound",
            value: function _urlNotFound(url, type, completeCallback) {
                callInNextTick((function() {
                    url = cc.url.normalize(url);
                    var info = "".concat(type ? getClassName(type) : "Asset", ' in "resources/').concat(url, '" does not exist.');
                    completeCallback && completeCallback(new Error(info), []);
                }));
            }
        }, {
            key: "_parseLoadResArgs",
            value: function _parseLoadResArgs(type, onProgress, onComplete) {
                if (void 0 === onComplete) {
                    var isValidType = isChildClassOf(type, cc.RawAsset);
                    onProgress ? (onComplete = onProgress, isValidType && (onProgress = this.onProgress || null)) : void 0 !== onProgress || isValidType || (onComplete = type, 
                    onProgress = this.onProgress || null, type = null), void 0 === onProgress || isValidType || (onProgress = type, 
                    type = null);
                }
                return {
                    type: type,
                    onProgress: onProgress,
                    onComplete: onComplete
                };
            }
        }, {
            key: "_loadResUuids",
            value: function _loadResUuids(uuids, progressCallback, completeCallback, urls) {
                if (uuids.length > 0) {
                    var self = this, res = uuids.map((function(uuid) {
                        return {
                            type: "uuid",
                            uuid: uuid
                        };
                    }));
                    this.load(res, progressCallback, (function(errors, items) {
                        if (completeCallback) {
                            for (var assetRes = [], urlRes = urls && [], i = 0; i < res.length; ++i) {
                                var uuid = res[i].uuid, id = self._getReferenceKey(uuid), item = items.getContent(id);
                                item && (self.setAutoReleaseRecursively(uuid, !1), assetRes.push(item), urlRes && urlRes.push(urls[i]));
                            }
                            urls ? completeCallback(errors, assetRes, urlRes) : completeCallback(errors, assetRes);
                        }
                    }));
                } else completeCallback && callInNextTick((function() {
                    urls ? completeCallback(null, [], []) : completeCallback(null, []);
                }));
            }
        } ]), CCLoader;
    }(Pipeline), loader = cc.loader = new CCLoader;
    var _dec$x, _dec2$g, _dec3$6, _class$x, _class2$s, _descriptor$q, _descriptor2$i, _descriptor3$c, CameraProjection, CameraAperture, CameraISO, CameraShutter, textureUtil = Object.freeze({
        __proto__: null,
        loadImage: function loadImage$1(url, callback, target) {
            assertID(!!url, 3103);
            var imageAsset = loader.getRes(url);
            return imageAsset ? imageAsset.loaded ? (callback && callback.call(target, null, imageAsset), 
            imageAsset) : (imageAsset.once("load", (function() {
                callback && callback.call(target, null, imageAsset);
            }), target), imageAsset) : (imageAsset = new ImageAsset, loader.load({
                url: url,
                imageAsset: imageAsset
            }, (function(err, asset) {
                if (err) return callback && callback.call(target, err || new Error("Unknown error")), 
                imageAsset;
                callback && callback.call(target, null, asset);
            })), imageAsset);
        },
        cacheImage: function cacheImage(url, image) {
            if (url && image) {
                var imageAsset = new ImageAsset(image), item = {
                    id: url,
                    url: url,
                    error: null,
                    content: imageAsset,
                    complete: !1
                };
                return loader.flowOut(item), imageAsset;
            }
        },
        postLoadImage: function postLoadImage(imageAsset, callback) {
            imageAsset.loaded ? callback && callback() : imageAsset.nativeUrl ? loader.load({
                url: imageAsset.nativeUrl,
                skips: imageAsset.isCompressed ? void 0 : [ "Loader" ]
            }, (function(err, image) {
                if (image) {
                    if (image instanceof ImageAsset) return error("internal error: loader handle pipe must be skipped");
                    imageAsset.loaded || (imageAsset._nativeAsset = image);
                }
                callback && callback(err);
            })) : callback && callback();
        }
    }), Skeleton = (_dec$x = ccclass("cc.Skeleton"), _dec2$g = property([ CCString ]), 
    _dec3$6 = property([ Mat4 ]), _dec$x((_descriptor$q = _applyDecoratedDescriptor((_class2$s = function(_Asset) {
        function Skeleton() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Skeleton);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Skeleton)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_joints", _descriptor$q, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_bindposes", _descriptor2$i, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_hash", _descriptor3$c, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(Skeleton, _Asset), _createClass(Skeleton, [ {
            key: "destroy",
            value: function destroy() {
                return cc.director.root.dataPoolManager.releaseSkeleton(this), _get(_getPrototypeOf(Skeleton.prototype), "destroy", this).call(this);
            }
        }, {
            key: "bindposes",
            get: function get() {
                return this._bindposes;
            },
            set: function set(value) {
                this._bindposes = value;
            }
        }, {
            key: "joints",
            get: function get() {
                return this._joints;
            },
            set: function set(value) {
                this._joints = value;
            }
        }, {
            key: "hash",
            get: function get() {
                if (!this._hash) {
                    for (var str = "", i = 0; i < this._bindposes.length; i++) {
                        var ibm = this._bindposes[i];
                        str += ibm.m00.toPrecision(2) + " " + ibm.m01.toPrecision(2) + " " + ibm.m02.toPrecision(2) + " " + ibm.m03.toPrecision(2) + " " + ibm.m04.toPrecision(2) + " " + ibm.m05.toPrecision(2) + " " + ibm.m06.toPrecision(2) + " " + ibm.m07.toPrecision(2) + " " + ibm.m08.toPrecision(2) + " " + ibm.m09.toPrecision(2) + " " + ibm.m10.toPrecision(2) + " " + ibm.m11.toPrecision(2) + " " + ibm.m12.toPrecision(2) + " " + ibm.m13.toPrecision(2) + " " + ibm.m14.toPrecision(2) + " " + ibm.m15.toPrecision(2) + "\n";
                    }
                    this._hash = murmurhash2_32_gc(str, 666);
                }
                return this._hash;
            }
        } ]), Skeleton;
    }(Asset)).prototype, "_joints", [ _dec2$g ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$i = _applyDecoratedDescriptor(_class2$s.prototype, "_bindposes", [ _dec3$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor3$c = _applyDecoratedDescriptor(_class2$s.prototype, "_hash", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$x = _class2$s)) || _class$x);
    cc.Skeleton = Skeleton, function(CameraProjection) {
        CameraProjection[CameraProjection.ORTHO = 0] = "ORTHO", CameraProjection[CameraProjection.PERSPECTIVE = 1] = "PERSPECTIVE";
    }(CameraProjection || (CameraProjection = {})), function(CameraAperture) {
        CameraAperture[CameraAperture.F1_8 = 0] = "F1_8", CameraAperture[CameraAperture.F2_0 = 1] = "F2_0", 
        CameraAperture[CameraAperture.F2_2 = 2] = "F2_2", CameraAperture[CameraAperture.F2_5 = 3] = "F2_5", 
        CameraAperture[CameraAperture.F2_8 = 4] = "F2_8", CameraAperture[CameraAperture.F3_2 = 5] = "F3_2", 
        CameraAperture[CameraAperture.F3_5 = 6] = "F3_5", CameraAperture[CameraAperture.F4_0 = 7] = "F4_0", 
        CameraAperture[CameraAperture.F4_5 = 8] = "F4_5", CameraAperture[CameraAperture.F5_0 = 9] = "F5_0", 
        CameraAperture[CameraAperture.F5_6 = 10] = "F5_6", CameraAperture[CameraAperture.F6_3 = 11] = "F6_3", 
        CameraAperture[CameraAperture.F7_1 = 12] = "F7_1", CameraAperture[CameraAperture.F8_0 = 13] = "F8_0", 
        CameraAperture[CameraAperture.F9_0 = 14] = "F9_0", CameraAperture[CameraAperture.F10_0 = 15] = "F10_0", 
        CameraAperture[CameraAperture.F11_0 = 16] = "F11_0", CameraAperture[CameraAperture.F13_0 = 17] = "F13_0", 
        CameraAperture[CameraAperture.F14_0 = 18] = "F14_0", CameraAperture[CameraAperture.F16_0 = 19] = "F16_0", 
        CameraAperture[CameraAperture.F18_0 = 20] = "F18_0", CameraAperture[CameraAperture.F20_0 = 21] = "F20_0", 
        CameraAperture[CameraAperture.F22_0 = 22] = "F22_0";
    }(CameraAperture || (CameraAperture = {})), function(CameraISO) {
        CameraISO[CameraISO.ISO100 = 0] = "ISO100", CameraISO[CameraISO.ISO200 = 1] = "ISO200", 
        CameraISO[CameraISO.ISO400 = 2] = "ISO400", CameraISO[CameraISO.ISO800 = 3] = "ISO800";
    }(CameraISO || (CameraISO = {})), function(CameraShutter) {
        CameraShutter[CameraShutter.D1 = 0] = "D1", CameraShutter[CameraShutter.D2 = 1] = "D2", 
        CameraShutter[CameraShutter.D4 = 2] = "D4", CameraShutter[CameraShutter.D8 = 3] = "D8", 
        CameraShutter[CameraShutter.D15 = 4] = "D15", CameraShutter[CameraShutter.D30 = 5] = "D30", 
        CameraShutter[CameraShutter.D60 = 6] = "D60", CameraShutter[CameraShutter.D125 = 7] = "D125", 
        CameraShutter[CameraShutter.D250 = 8] = "D250", CameraShutter[CameraShutter.D500 = 9] = "D500", 
        CameraShutter[CameraShutter.D1000 = 10] = "D1000", CameraShutter[CameraShutter.D2000 = 11] = "D2000", 
        CameraShutter[CameraShutter.D4000 = 12] = "D4000";
    }(CameraShutter || (CameraShutter = {}));
    var _dec$y, _dec2$h, _dec3$7, _class$y, _class2$t, _descriptor$r, _descriptor2$j, _descriptor3$d, _dec4$5, _dec5$4, _dec6$3, _dec7$1, _dec8, _dec9, _class4$2, _class5$2, _descriptor4$7, _descriptor5$5, _descriptor6$1, _descriptor7$1, _dec10, _dec11, _dec12, _dec13, _dec14, _class7, _class8, _descriptor8$1, _descriptor9$1, _descriptor10$1, _descriptor11, _dec15, _dec16, _class10, _class11, _descriptor12, _descriptor13, _descriptor14, FSTOPS = [ 1.8, 2, 2.2, 2.5, 2.8, 3.2, 3.5, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10, 11, 13, 14, 16, 18, 20, 22 ], SHUTTERS = [ 1, .5, .25, 1 / 8, 1 / 15, 1 / 30, 1 / 60, .008, .004, .002, .001, 5e-4, 25e-5 ], ISOS = [ 100, 200, 400, 800 ], v_a = new Vec3, v_b = new Vec3, _tempMat1 = new Mat4, _tempMat2 = new Mat4, SKYBOX_FLAG = exports.GFXClearFlag.STENCIL << 1, Camera = function() {
        function Camera() {
            _classCallCheck(this, Camera), this._scene = null, this._name = null, this._enabled = !1, 
            this._proj = -1, this._isWindowSize = !0, this._orthoHeight = 10, this._fov = toRadian(45), 
            this._nearClip = 1, this._farClip = 1e3, this._clearStencil = 0, this._clearDepth = 1, 
            this._clearFlag = exports.GFXClearFlag.NONE, this._clearColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            }, this._viewport = new Rect(0, 0, 1, 1), this._isProjDirty = !0, this._matView = new Mat4, 
            this._matViewInv = null, this._matProj = new Mat4, this._matProjInv = new Mat4, 
            this._matViewProj = new Mat4, this._matViewProjInv = new Mat4, this._frustum = new frustum, 
            this._forward = new Vec3, this._position = new Vec3, this._node = null, this._view = null, 
            this._visibility = CameraDefaultMask, this._priority = 0, this._aperture = CameraAperture.F16_0, 
            this._shutter = CameraShutter.D125, this._shutterValue = 0, this._iso = CameraISO.ISO100, 
            this._isoValue = 0, this._ec = 0, this._exposure = 0, this._apertureValue = FSTOPS[this._aperture], 
            this._shutterValue = SHUTTERS[this._shutter], this._isoValue = ISOS[this._iso], 
            this.updateExposure(), this._aspect = this._width = this._height = this._screenScale = 1;
        }
        return _createClass(Camera, [ {
            key: "initialize",
            value: function initialize(info) {
                this._name = info.name, this._node = info.node, this._proj = info.projection, this._priority = info.priority || 0, 
                this._view = cc.director.root.createView({
                    camera: this,
                    name: this._name,
                    priority: this._priority,
                    flows: info.flows
                }), this.changeTargetWindow(info.window), console.log("Created Camera: " + this._name + " " + this._width + "x" + this._height);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                cc.director.root.destroyView(this._view), this._view = null, this._name = null;
            }
        }, {
            key: "attachToScene",
            value: function attachToScene(scene) {
                this._scene = scene, this._view && this._view.enable(!0);
            }
        }, {
            key: "detachFromScene",
            value: function detachFromScene() {
                this._scene = null, this._view && this._view.enable(!1);
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._width = width, this._height = height, this._aspect = this._width / this._height, 
                this._isProjDirty = !0;
            }
        }, {
            key: "setFixedSize",
            value: function setFixedSize(width, height) {
                this._width = width, this._height = height, this._aspect = this._width / this._height, 
                this._isWindowSize = !1;
            }
        }, {
            key: "update",
            value: function update() {
                var forceUpdate = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                if (this._node) {
                    if ((this._node.hasChangedFlags || forceUpdate) && (Mat4.invert(this._matView, this.node.worldMatrix), 
                    this._forward.x = -this._matView.m02, this._forward.y = -this._matView.m06, this._forward.z = -this._matView.m10, 
                    this._node.getWorldPosition(this._position)), this._isProjDirty) {
                        if (this._proj === CameraProjection.PERSPECTIVE) Mat4.perspective(this._matProj, this._fov, this._aspect, this._nearClip, this._farClip); else {
                            var x = this._orthoHeight * this._aspect, y = this._orthoHeight;
                            Mat4.ortho(this._matProj, -x, x, -y, y, this._nearClip, this._farClip);
                        }
                        Mat4.invert(this._matProjInv, this._matProj);
                    }
                    (this._node.hasChangedFlags || this._isProjDirty || forceUpdate) && (Mat4.multiply(this._matViewProj, this._matProj, this._matView), 
                    Mat4.invert(this._matViewProjInv, this._matViewProj), this._frustum.update(this._matViewProj, this._matViewProjInv)), 
                    this._isProjDirty = !1;
                }
            }
        }, {
            key: "getSplitFrustum",
            value: function getSplitFrustum(out, nearClip, farClip) {
                if (this._node) {
                    if (nearClip = Math.max(nearClip, this._nearClip), farClip = Math.min(farClip, this._farClip), 
                    Mat4.invert(this._matView, this.node.worldMatrix), this._proj === CameraProjection.PERSPECTIVE) Mat4.perspective(_tempMat1, this._fov, this._aspect, nearClip, farClip); else {
                        var x = this._orthoHeight * this._aspect, y = this._orthoHeight;
                        Mat4.ortho(_tempMat1, -x, x, -y, y, nearClip, farClip);
                    }
                    Mat4.multiply(_tempMat2, _tempMat1, this._matView), Mat4.invert(_tempMat1, _tempMat2), 
                    out.update(_tempMat2, _tempMat1);
                }
            }
        }, {
            key: "changeTargetWindow",
            value: function changeTargetWindow() {
                var window = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, win = window || cc.director.root.mainWindow;
                win && this._view && (this._view.window = win, this.resize(win.width, win.height));
            }
        }, {
            key: "screenPointToRay",
            value: function screenPointToRay(out, x, y) {
                var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
                return Vec3.set(v_a, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, 1), Vec3.transformMat4(v_a, v_a, this._matViewProjInv), 
                this._proj === CameraProjection.PERSPECTIVE ? this._node && this._node.getWorldPosition(v_b) : (Vec3.set(v_b, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, -1), 
                Vec3.transformMat4(v_b, v_b, this._matViewProjInv)), ray.fromPoints(out, v_b, v_a);
            }
        }, {
            key: "screenToWorld",
            value: function screenToWorld(out, screenPos) {
                var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
                return this._proj === CameraProjection.PERSPECTIVE ? (Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 1), 
                Vec3.transformMat4(out, out, this._matViewProjInv), this._node && this._node.getWorldPosition(v_a), 
                Vec3.lerp(out, v_a, out, lerp(this._nearClip / this._farClip, 1, screenPos.z))) : (Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 2 * screenPos.z - 1), 
                Vec3.transformMat4(out, out, this.matViewProjInv)), out;
            }
        }, {
            key: "worldToScreen",
            value: function worldToScreen(out, worldPos) {
                var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
                return Vec3.transformMat4(out, worldPos, this.matViewProj), out.x = cx + .5 * (out.x + 1) * cw, 
                out.y = cy + .5 * (out.y + 1) * ch, out.z = .5 * out.z + .5, out;
            }
        }, {
            key: "updateExposure",
            value: function updateExposure() {
                var ev100 = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100 / this._isoValue);
                this._exposure = .833333 / Math.pow(2, ev100);
            }
        }, {
            key: "screenScale",
            set: function set(val) {
                this._screenScale = val;
            },
            get: function get() {
                return this._screenScale;
            }
        }, {
            key: "enabled",
            set: function set(val) {
                this._enabled = val, this._view && this._view.enable(val);
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "view",
            get: function get() {
                return this._view;
            }
        }, {
            key: "node",
            set: function set(val) {
                this._node = val;
            },
            get: function get() {
                return this._node;
            }
        }, {
            key: "isWindowSize",
            get: function get() {
                return this._isWindowSize;
            },
            set: function set(value) {
                this._isWindowSize = value;
            }
        }, {
            key: "orthoHeight",
            set: function set(val) {
                this._orthoHeight = val, this._isProjDirty = !0;
            },
            get: function get() {
                return this._orthoHeight;
            }
        }, {
            key: "projectionType",
            set: function set(val) {
                this._proj = val, this._isProjDirty = !0;
            },
            get: function get() {
                return this._proj;
            }
        }, {
            key: "viewport",
            set: function set(v) {
                this._viewport = v;
            },
            get: function get() {
                return this._viewport;
            }
        }, {
            key: "fov",
            set: function set(fov) {
                this._fov = fov, this._isProjDirty = !0;
            },
            get: function get() {
                return this._fov;
            }
        }, {
            key: "nearClip",
            set: function set(nearClip) {
                this._nearClip = nearClip, this._isProjDirty = !0;
            },
            get: function get() {
                return this._nearClip;
            }
        }, {
            key: "farClip",
            set: function set(farClip) {
                this._farClip = farClip, this._isProjDirty = !0;
            },
            get: function get() {
                return this._farClip;
            }
        }, {
            key: "clearColor",
            set: function set(val) {
                this._clearColor.r = val.r, this._clearColor.g = val.g, this._clearColor.b = val.b, 
                this._clearColor.a = val.a;
            },
            get: function get() {
                return this._clearColor;
            }
        }, {
            key: "clearDepth",
            set: function set(val) {
                this._clearDepth = val;
            },
            get: function get() {
                return this._clearDepth;
            }
        }, {
            key: "clearStencil",
            set: function set(val) {
                this._clearStencil = val;
            },
            get: function get() {
                return this._clearStencil;
            }
        }, {
            key: "clearFlag",
            set: function set(val) {
                this._clearFlag = val;
            },
            get: function get() {
                return this._clearFlag;
            }
        }, {
            key: "scene",
            get: function get() {
                return this._scene;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        }, {
            key: "aspect",
            get: function get() {
                return this._aspect;
            }
        }, {
            key: "matView",
            set: function set(val) {
                this._matView = val;
            },
            get: function get() {
                return this._matView;
            }
        }, {
            key: "matViewInv",
            set: function set(val) {
                this._matViewInv = val;
            },
            get: function get() {
                return this._matViewInv || this._node.worldMatrix;
            }
        }, {
            key: "matProj",
            set: function set(val) {
                this._matProj = val;
            },
            get: function get() {
                return this._matProj;
            }
        }, {
            key: "matProjInv",
            set: function set(val) {
                this._matProjInv = val;
            },
            get: function get() {
                return this._matProjInv;
            }
        }, {
            key: "matViewProj",
            set: function set(val) {
                this._matViewProj = val;
            },
            get: function get() {
                return this._matViewProj;
            }
        }, {
            key: "matViewProjInv",
            set: function set(val) {
                this._matViewProjInv = val;
            },
            get: function get() {
                return this._matViewProjInv;
            }
        }, {
            key: "frustum",
            set: function set(val) {
                this._frustum = val;
            },
            get: function get() {
                return this._frustum;
            }
        }, {
            key: "forward",
            set: function set(val) {
                this._forward = val;
            },
            get: function get() {
                return this._forward;
            }
        }, {
            key: "position",
            set: function set(val) {
                this._position = val;
            },
            get: function get() {
                return this._position;
            }
        }, {
            key: "visibility",
            set: function set(vis) {
                this._visibility = vis, this._view && (this._view.visibility = vis);
            },
            get: function get() {
                return this._visibility;
            }
        }, {
            key: "priority",
            get: function get() {
                return this._view ? this._view.priority : -1;
            },
            set: function set(val) {
                this._priority = val, this._view && (this._view.priority = this._priority);
            }
        }, {
            key: "aperture",
            set: function set(val) {
                this._aperture = val, this._apertureValue = FSTOPS[this._aperture], this.updateExposure();
            },
            get: function get() {
                return this._aperture;
            }
        }, {
            key: "apertureValue",
            get: function get() {
                return this._apertureValue;
            }
        }, {
            key: "shutter",
            set: function set(val) {
                this._shutter = val, this._shutterValue = SHUTTERS[this._shutter], this.updateExposure();
            },
            get: function get() {
                return this._shutter;
            }
        }, {
            key: "shutterValue",
            get: function get() {
                return this._shutterValue;
            }
        }, {
            key: "iso",
            set: function set(val) {
                this._iso = val, this._isoValue = ISOS[this._iso], this.updateExposure();
            },
            get: function get() {
                return this._iso;
            }
        }, {
            key: "isoValue",
            get: function get() {
                return this._isoValue;
            }
        }, {
            key: "ec",
            set: function set(val) {
                this._ec = val;
            },
            get: function get() {
                return this._ec;
            }
        }, {
            key: "exposure",
            get: function get() {
                return this._exposure;
            }
        }, {
            key: "flows",
            set: function set(val) {
                this._view && this._view.setExecuteFlows(val);
            }
        } ]), Camera;
    }(), Ambient = function() {
        function Ambient(scene) {
            _classCallCheck(this, Ambient), this._enabled = !0, this._skyColor = Float32Array.from([ .2, .5, .8, 1 ]), 
            this._skyIllum = Ambient.SKY_ILLUM, this._groundAlbedo = Float32Array.from([ .2, .2, .2, 1 ]), 
            this._scene = scene;
        }
        return _createClass(Ambient, [ {
            key: "enabled",
            set: function set(val) {
                this._enabled = val;
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "skyColor",
            get: function get() {
                return this._skyColor;
            },
            set: function set(color) {
                this._skyColor = color;
            }
        }, {
            key: "skyIllum",
            set: function set(illum) {
                this._skyIllum = illum;
            },
            get: function get() {
                return this._skyIllum;
            }
        }, {
            key: "groundAlbedo",
            get: function get() {
                return this._groundAlbedo;
            },
            set: function set(color) {
                this._groundAlbedo = color;
            }
        } ]), _createClass(Ambient, [ {
            key: "update",
            value: function update() {}
        } ]), Ambient;
    }();
    Ambient.SUN_ILLUM = 65e3, Ambient.SKY_ILLUM = 2e4;
    var _up = new Vec3(0, 1, 0), _v3 = new Vec3, _qt = new Quat, AmbientInfo = (_dec$y = ccclass("cc.AmbientInfo"), 
    _dec2$h = property({
        type: Color
    }), _dec3$7 = property({
        type: Color
    }), _dec$y((_descriptor$r = _applyDecoratedDescriptor((_class2$t = function() {
        function AmbientInfo() {
            _classCallCheck(this, AmbientInfo), _initializerDefineProperty(this, "_skyColor", _descriptor$r, this), 
            _initializerDefineProperty(this, "_skyIllum", _descriptor2$j, this), _initializerDefineProperty(this, "_groundAlbedo", _descriptor3$d, this), 
            this._resource = null;
        }
        return _createClass(AmbientInfo, [ {
            key: "skyColor",
            set: function set(val) {
                this._skyColor.set(val), this._resource && Color.toArray(this._resource.skyColor, this.skyColor);
            },
            get: function get() {
                return this._skyColor;
            }
        }, {
            key: "skyIllum",
            set: function set(val) {
                this._skyIllum = val, this._resource && (this._resource.skyIllum = this.skyIllum);
            },
            get: function get() {
                return this._skyIllum;
            }
        }, {
            key: "groundAlbedo",
            set: function set(val) {
                this._groundAlbedo.set(val), this._resource && Vec3.toArray(this._resource.groundAlbedo, this.groundAlbedo);
            },
            get: function get() {
                return this._groundAlbedo;
            }
        }, {
            key: "renderScene",
            set: function set(rs) {
                this._resource = rs.ambient, this.skyColor = this._skyColor, this.skyIllum = this._skyIllum, 
                this.groundAlbedo = this._groundAlbedo;
            }
        } ]), AmbientInfo;
    }()).prototype, "_skyColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(51, 128, 204, 1);
        }
    }), _descriptor2$j = _applyDecoratedDescriptor(_class2$t.prototype, "_skyIllum", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Ambient.SKY_ILLUM;
        }
    }), _descriptor3$d = _applyDecoratedDescriptor(_class2$t.prototype, "_groundAlbedo", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(51, 51, 51, 255);
        }
    }), _applyDecoratedDescriptor(_class2$t.prototype, "skyColor", [ _dec2$h ], Object.getOwnPropertyDescriptor(_class2$t.prototype, "skyColor"), _class2$t.prototype), 
    _applyDecoratedDescriptor(_class2$t.prototype, "skyIllum", [ _float ], Object.getOwnPropertyDescriptor(_class2$t.prototype, "skyIllum"), _class2$t.prototype), 
    _applyDecoratedDescriptor(_class2$t.prototype, "groundAlbedo", [ _dec3$7 ], Object.getOwnPropertyDescriptor(_class2$t.prototype, "groundAlbedo"), _class2$t.prototype), 
    _class$y = _class2$t)) || _class$y);
    cc.AmbientInfo = AmbientInfo;
    var SkyboxInfo = (_dec4$5 = ccclass("cc.SkyboxInfo"), _dec5$4 = property(TextureCube), 
    _dec6$3 = property({
        type: CCBoolean
    }), _dec7$1 = property({
        type: CCBoolean
    }), _dec8 = property({
        type: TextureCube
    }), _dec9 = property({
        type: CCBoolean
    }), _dec4$5((_descriptor4$7 = _applyDecoratedDescriptor((_class5$2 = function() {
        function SkyboxInfo() {
            _classCallCheck(this, SkyboxInfo), _initializerDefineProperty(this, "_envmap", _descriptor4$7, this), 
            _initializerDefineProperty(this, "_isRGBE", _descriptor5$5, this), _initializerDefineProperty(this, "_enabled", _descriptor6$1, this), 
            _initializerDefineProperty(this, "_useIBL", _descriptor7$1, this), this._resource = null;
        }
        return _createClass(SkyboxInfo, [ {
            key: "enabled",
            set: function set(val) {
                this._enabled = val, this._resource && (this._resource.enabled = this._enabled);
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "useIBL",
            set: function set(val) {
                this._useIBL = val, this._resource && (this._resource.useIBL = this._useIBL);
            },
            get: function get() {
                return this._useIBL;
            }
        }, {
            key: "envmap",
            set: function set(val) {
                this._envmap = val, this._resource && (this._resource.envmap = this._envmap);
            },
            get: function get() {
                return this._envmap;
            }
        }, {
            key: "isRGBE",
            set: function set(val) {
                this._isRGBE = val, this._resource && (this._resource.isRGBE = this._isRGBE);
            },
            get: function get() {
                return this._isRGBE;
            }
        }, {
            key: "renderScene",
            set: function set(val) {
                this._resource = val.skybox, this.isRGBE = this._isRGBE, this.envmap = this._envmap, 
                this.enabled = this._enabled, this.useIBL = this._useIBL;
            }
        } ]), SkyboxInfo;
    }()).prototype, "_envmap", [ _dec5$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor5$5 = _applyDecoratedDescriptor(_class5$2.prototype, "_isRGBE", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor6$1 = _applyDecoratedDescriptor(_class5$2.prototype, "_enabled", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor7$1 = _applyDecoratedDescriptor(_class5$2.prototype, "_useIBL", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _applyDecoratedDescriptor(_class5$2.prototype, "enabled", [ _dec6$3 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "enabled"), _class5$2.prototype), 
    _applyDecoratedDescriptor(_class5$2.prototype, "useIBL", [ _dec7$1 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "useIBL"), _class5$2.prototype), 
    _applyDecoratedDescriptor(_class5$2.prototype, "envmap", [ _dec8 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "envmap"), _class5$2.prototype), 
    _applyDecoratedDescriptor(_class5$2.prototype, "isRGBE", [ _dec9 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "isRGBE"), _class5$2.prototype), 
    _class4$2 = _class5$2)) || _class4$2);
    cc.SkyboxInfo = SkyboxInfo;
    var PlanarShadowInfo = (_dec10 = ccclass("cc.PlanarShadowInfo"), _dec11 = property({
        type: CCBoolean
    }), _dec12 = property({
        type: Vec3
    }), _dec13 = property({
        type: CCFloat
    }), _dec14 = property({
        type: Color
    }), _dec10((_descriptor8$1 = _applyDecoratedDescriptor((_class8 = function() {
        function PlanarShadowInfo() {
            _classCallCheck(this, PlanarShadowInfo), _initializerDefineProperty(this, "_enabled", _descriptor8$1, this), 
            _initializerDefineProperty(this, "_normal", _descriptor9$1, this), _initializerDefineProperty(this, "_distance", _descriptor10$1, this), 
            _initializerDefineProperty(this, "_shadowColor", _descriptor11, this), this._resource = null;
        }
        return _createClass(PlanarShadowInfo, [ {
            key: "setPlaneFromNode",
            value: function setPlaneFromNode(node) {
                node.getWorldRotation(_qt), this.normal = Vec3.transformQuat(_v3, _up, _qt), node.getWorldPosition(_v3), 
                this.distance = Vec3.dot(this._normal, _v3);
            }
        }, {
            key: "enabled",
            set: function set(val) {
                this._enabled = val, this._resource && (this._resource.enabled = val);
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "normal",
            set: function set(val) {
                Vec3.copy(this._normal, val), this._resource && (this._resource.normal = val);
            },
            get: function get() {
                return this._normal;
            }
        }, {
            key: "distance",
            set: function set(val) {
                this._distance = val, this._resource && (this._resource.distance = val);
            },
            get: function get() {
                return this._distance;
            }
        }, {
            key: "shadowColor",
            set: function set(val) {
                this._shadowColor.set(val), this._resource && (this._resource.shadowColor = val);
            },
            get: function get() {
                return this._shadowColor;
            }
        }, {
            key: "renderScene",
            set: function set(val) {
                this._resource = val.planarShadows, this.normal = this._normal, this.distance = this._distance, 
                this.shadowColor = this._shadowColor, this.enabled = this._enabled;
            }
        } ]), PlanarShadowInfo;
    }()).prototype, "_enabled", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor9$1 = _applyDecoratedDescriptor(_class8.prototype, "_normal", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(0, 1, 0);
        }
    }), _descriptor10$1 = _applyDecoratedDescriptor(_class8.prototype, "_distance", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor11 = _applyDecoratedDescriptor(_class8.prototype, "_shadowColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(0, 0, 0, 76);
        }
    }), _applyDecoratedDescriptor(_class8.prototype, "enabled", [ _dec11 ], Object.getOwnPropertyDescriptor(_class8.prototype, "enabled"), _class8.prototype), 
    _applyDecoratedDescriptor(_class8.prototype, "normal", [ _dec12 ], Object.getOwnPropertyDescriptor(_class8.prototype, "normal"), _class8.prototype), 
    _applyDecoratedDescriptor(_class8.prototype, "distance", [ _dec13 ], Object.getOwnPropertyDescriptor(_class8.prototype, "distance"), _class8.prototype), 
    _applyDecoratedDescriptor(_class8.prototype, "shadowColor", [ _dec14 ], Object.getOwnPropertyDescriptor(_class8.prototype, "shadowColor"), _class8.prototype), 
    _class7 = _class8)) || _class7);
    cc.PlanarShadowInfo = PlanarShadowInfo;
    var _class$z, _class2$u, _descriptor$s, _descriptor2$k, SceneGlobals = (_dec15 = ccclass("cc.SceneGlobals"), 
    _dec16 = property({
        type: SkyboxInfo
    }), _dec15((_descriptor12 = _applyDecoratedDescriptor((_class11 = function() {
        function SceneGlobals() {
            _classCallCheck(this, SceneGlobals), _initializerDefineProperty(this, "ambient", _descriptor12, this), 
            _initializerDefineProperty(this, "planarShadows", _descriptor13, this), _initializerDefineProperty(this, "_skybox", _descriptor14, this);
        }
        return _createClass(SceneGlobals, [ {
            key: "skybox",
            get: function get() {
                return this._skybox;
            },
            set: function set(value) {
                this._skybox = value;
            }
        }, {
            key: "renderScene",
            set: function set(rs) {
                this.ambient.renderScene = rs, this.skybox.renderScene = rs, this.planarShadows.renderScene = rs;
            }
        } ]), SceneGlobals;
    }()).prototype, "ambient", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new AmbientInfo;
        }
    }), _descriptor13 = _applyDecoratedDescriptor(_class11.prototype, "planarShadows", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new PlanarShadowInfo;
        }
    }), _descriptor14 = _applyDecoratedDescriptor(_class11.prototype, "_skybox", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new SkyboxInfo;
        }
    }), _applyDecoratedDescriptor(_class11.prototype, "skybox", [ _dec16 ], Object.getOwnPropertyDescriptor(_class11.prototype, "skybox"), _class11.prototype), 
    _class10 = _class11)) || _class10);
    cc.SceneGlobals = SceneGlobals;
    var _class$A, Scene = ccclass("cc.Scene")((_descriptor$s = _applyDecoratedDescriptor((_class2$u = function(_BaseNode) {
        function Scene(name) {
            var _this;
            return _classCallCheck(this, Scene), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Scene).call(this, name)), "autoReleaseAssets", _descriptor$s, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_globals", _descriptor2$k, _assertThisInitialized(_this)), 
            _this._renderScene = null, _this.dependAssets = null, _this._prefabSyncedInLiveReload = !1, 
            _this._pos = Vec3.ZERO, _this._rot = Quat.IDENTITY, _this._scale = Vec3.ONE, _this._mat = Mat4.IDENTITY, 
            _this._dirtyFlags = 0, _this._activeInHierarchy = !1, cc.director && cc.director.root && (_this._renderScene = cc.director.root.createScene({})), 
            _this._inited = !cc.game || !cc.game._isCloning, _this;
        }
        return _inherits(Scene, _BaseNode), _createClass(Scene, [ {
            key: "renderScene",
            get: function get() {
                return this._renderScene;
            }
        }, {
            key: "globals",
            get: function get() {
                return this._globals;
            }
        } ]), _createClass(Scene, [ {
            key: "destroy",
            value: function destroy() {
                var success = _get(_getPrototypeOf(Scene.prototype), "destroy", this).call(this);
                return cc.director.root.destroyScene(this._renderScene), this._activeInHierarchy = !1, 
                success;
            }
        }, {
            key: "addComponent",
            value: function addComponent(typeOrClassName) {
                return warnID(3822), null;
            }
        }, {
            key: "_onHierarchyChanged",
            value: function _onHierarchyChanged() {}
        }, {
            key: "_onBatchCreated",
            value: function _onBatchCreated() {
                _get(_getPrototypeOf(Scene.prototype), "_onBatchCreated", this).call(this);
                for (var len = this._children.length, i = 0; i < len; ++i) this._children[i]._onBatchCreated();
            }
        }, {
            key: "_onBatchRestored",
            value: function _onBatchRestored() {
                this._onBatchCreated();
            }
        }, {
            key: "getPosition",
            value: function getPosition(out) {
                return Vec3.copy(out || new Vec3, Vec3.ZERO);
            }
        }, {
            key: "getRotation",
            value: function getRotation(out) {
                return Quat.copy(out || new Quat, Quat.IDENTITY);
            }
        }, {
            key: "getScale",
            value: function getScale(out) {
                return Vec3.copy(out || new Vec3, Vec3.ONE);
            }
        }, {
            key: "getWorldPosition",
            value: function getWorldPosition(out) {
                return Vec3.copy(out || new Vec3, Vec3.ZERO);
            }
        }, {
            key: "getWorldRotation",
            value: function getWorldRotation(out) {
                return Quat.copy(out || new Quat, Quat.IDENTITY);
            }
        }, {
            key: "getWorldScale",
            value: function getWorldScale(out) {
                return Vec3.copy(out || new Vec3, Vec3.ONE);
            }
        }, {
            key: "getWorldMatrix",
            value: function getWorldMatrix(out) {
                return Mat4.copy(out || new Mat4, Mat4.IDENTITY);
            }
        }, {
            key: "getWorldRS",
            value: function getWorldRS(out) {
                return Mat4.copy(out || new Mat4, Mat4.IDENTITY);
            }
        }, {
            key: "getWorldRT",
            value: function getWorldRT(out) {
                return Mat4.copy(out || new Mat4, Mat4.IDENTITY);
            }
        }, {
            key: "updateWorldTransform",
            value: function updateWorldTransform() {}
        }, {
            key: "_instantiate",
            value: function _instantiate() {}
        }, {
            key: "_load",
            value: function _load() {
                this._inited || (this._onBatchCreated(), this._inited = !0), this.walk(BaseNode._setScene);
            }
        }, {
            key: "_activate",
            value: function _activate(active) {
                active = !1 !== active, cc.director._nodeActivator.activateNode(this, active), this._globals.renderScene = this._renderScene;
            }
        }, {
            key: "position",
            get: function get() {
                return Vec3.ZERO;
            }
        }, {
            key: "worldPosition",
            get: function get() {
                return Vec3.ZERO;
            }
        }, {
            key: "rotation",
            get: function get() {
                return Quat.IDENTITY;
            }
        }, {
            key: "worldRotation",
            get: function get() {
                return Quat.IDENTITY;
            }
        }, {
            key: "scale",
            get: function get() {
                return Vec3.ONE;
            }
        }, {
            key: "worldScale",
            get: function get() {
                return Vec3.ONE;
            }
        }, {
            key: "eulerAngles",
            get: function get() {
                return Vec3.ZERO;
            }
        }, {
            key: "worldMatrix",
            get: function get() {
                return Mat4.IDENTITY;
            }
        } ]), Scene;
    }(BaseNode)).prototype, "autoReleaseAssets", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$k = _applyDecoratedDescriptor(_class2$u.prototype, "_globals", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new SceneGlobals;
        }
    }), _class$z = _class2$u)) || _class$z;
    function find(path, referenceNode) {
        if (referenceNode) 0; else {
            var scene = cc.director.getScene();
            if (!scene) return null;
            referenceNode = scene;
        }
        return referenceNode.getChildByPath(path);
    }
    cc.Scene = Scene, cc.find = find;
    var HideInHierarchy$1 = CCObject.Flags.HideInHierarchy, PrivateNode = ccclass("cc.PrivateNode")(_class$A = function(_Node) {
        function PrivateNode(name) {
            var _this;
            return _classCallCheck(this, PrivateNode), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PrivateNode).call(this, name)))._objFlags |= HideInHierarchy$1, 
            _this;
        }
        return _inherits(PrivateNode, _Node), PrivateNode;
    }(Node$1)) || _class$A;
    cc.PrivateNode = PrivateNode;
    var fastRemoveAt$2 = array.fastRemoveAt, IsStartCalled$1 = CCObject.Flags.IsStartCalled, IsOnEnableCalled$2 = CCObject.Flags.IsOnEnableCalled, callStart = (CCObject.Flags.IsEditorOnEnableCalled, 
    function(c) {
        c.start(), c._objFlags |= IsStartCalled$1;
    }), callUpdate = function(c, dt) {
        c.update(dt);
    }, callLateUpdate = function(c, dt) {
        c.lateUpdate(dt);
    };
    function sortedIndex(array, comp) {
        for (var order = comp.constructor._executionOrder, id = comp._id, l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
            var test = array[m], testOrder = test.constructor._executionOrder;
            if (testOrder > order) h = m - 1; else if (testOrder < order) l = m + 1; else {
                var testId = test._id;
                if (testId > id) h = m - 1; else {
                    if (!(testId < id)) return m;
                    l = m + 1;
                }
            }
        }
        return ~l;
    }
    function stableRemoveInactive(iterator, flagToClear) {
        for (var array = iterator.array, next = iterator.i + 1; next < array.length; ) {
            var comp = array[next];
            comp._enabled && comp.node._activeInHierarchy ? ++next : (iterator.removeAt(next), 
            flagToClear && (comp._objFlags &= ~flagToClear));
        }
    }
    var LifeCycleInvoker = function LifeCycleInvoker(invokeFunc) {
        _classCallCheck(this, LifeCycleInvoker);
        var Iterator = MutableForwardIterator;
        this._zero = new Iterator([]), this._neg = new Iterator([]), this._pos = new Iterator([]), 
        this._invoke = invokeFunc;
    };
    function compareOrder(a, b) {
        return a.constructor._executionOrder - b.constructor._executionOrder;
    }
    LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;
    var OneOffInvoker = function(_LifeCycleInvoker) {
        function OneOffInvoker() {
            return _classCallCheck(this, OneOffInvoker), _possibleConstructorReturn(this, _getPrototypeOf(OneOffInvoker).apply(this, arguments));
        }
        return _inherits(OneOffInvoker, _LifeCycleInvoker), _createClass(OneOffInvoker, [ {
            key: "add",
            value: function add(comp) {
                var order = comp.constructor._executionOrder;
                (0 === order ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
            }
        }, {
            key: "remove",
            value: function remove(comp) {
                var order = comp.constructor._executionOrder;
                (0 === order ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
            }
        }, {
            key: "cancelInactive",
            value: function cancelInactive(flagToClear) {
                stableRemoveInactive(this._zero, flagToClear), stableRemoveInactive(this._neg, flagToClear), 
                stableRemoveInactive(this._pos, flagToClear);
            }
        }, {
            key: "invoke",
            value: function invoke() {
                var compsNeg = this._neg;
                compsNeg.array.length > 0 && (compsNeg.array.sort(compareOrder), this._invoke(compsNeg), 
                compsNeg.array.length = 0), this._invoke(this._zero), this._zero.array.length = 0;
                var compsPos = this._pos;
                compsPos.array.length > 0 && (compsPos.array.sort(compareOrder), this._invoke(compsPos), 
                compsPos.array.length = 0);
            }
        } ]), OneOffInvoker;
    }(LifeCycleInvoker), ReusableInvoker = function(_LifeCycleInvoker2) {
        function ReusableInvoker() {
            return _classCallCheck(this, ReusableInvoker), _possibleConstructorReturn(this, _getPrototypeOf(ReusableInvoker).apply(this, arguments));
        }
        return _inherits(ReusableInvoker, _LifeCycleInvoker2), _createClass(ReusableInvoker, [ {
            key: "add",
            value: function add(comp) {
                var order = comp.constructor._executionOrder;
                if (0 === order) this._zero.array.push(comp); else {
                    var _array = order < 0 ? this._neg.array : this._pos.array, i = sortedIndex(_array, comp);
                    i < 0 && _array.splice(~i, 0, comp);
                }
            }
        }, {
            key: "remove",
            value: function remove(comp) {
                var order = comp.constructor._executionOrder;
                if (0 === order) this._zero.fastRemove(comp); else {
                    var iterator = order < 0 ? this._neg : this._pos, i = sortedIndex(iterator.array, comp);
                    i >= 0 && iterator.removeAt(i);
                }
            }
        }, {
            key: "invoke",
            value: function invoke(dt) {
                this._neg.array.length > 0 && this._invoke(this._neg, dt), this._invoke(this._zero, dt), 
                this._pos.array.length > 0 && this._invoke(this._pos, dt);
            }
        } ]), ReusableInvoker;
    }(LifeCycleInvoker);
    function createInvokeImpl(funcOrCode, useDt) {
        if ("function" == typeof funcOrCode) return useDt ? function(iterator, dt) {
            var array = iterator.array;
            for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                var comp = array[iterator.i];
                funcOrCode(comp, dt);
            }
        } : function(iterator) {
            var array = iterator.array;
            for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                var comp = array[iterator.i];
                funcOrCode(comp);
            }
        };
        var body = "var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];" + funcOrCode + "}";
        return useDt ? Function("it", "dt", body) : Function("it", body);
    }
    var ComponentScheduler = function() {
        function ComponentScheduler() {
            _classCallCheck(this, ComponentScheduler), this.unscheduleAll();
        }
        return _createClass(ComponentScheduler, [ {
            key: "unscheduleAll",
            value: function unscheduleAll() {
                this.startInvoker = new OneOffInvoker(createInvokeImpl(callStart)), this.updateInvoker = new ReusableInvoker(createInvokeImpl(callUpdate, !0)), 
                this.lateUpdateInvoker = new ReusableInvoker(createInvokeImpl(callLateUpdate, !0)), 
                this.scheduleInNextFrame = [], this._updating = !1;
            }
        }, {
            key: "_onEnabled",
            value: function _onEnabled(comp) {
                cc.director.getScheduler().resumeTarget(comp), comp._objFlags |= IsOnEnableCalled$2, 
                this._updating ? this.scheduleInNextFrame.push(comp) : this._scheduleImmediate(comp);
            }
        }, {
            key: "_onDisabled",
            value: function _onDisabled(comp) {
                cc.director.getScheduler().pauseTarget(comp), comp._objFlags &= ~IsOnEnableCalled$2;
                var index = this.scheduleInNextFrame.indexOf(comp);
                index >= 0 ? fastRemoveAt$2(this.scheduleInNextFrame, index) : (!comp.start || comp._objFlags & IsStartCalled$1 || this.startInvoker.remove(comp), 
                comp.update && this.updateInvoker.remove(comp), comp.lateUpdate && this.lateUpdateInvoker.remove(comp));
            }
        }, {
            key: "enableComp",
            value: function enableComp(comp, invoker) {
                if (!(comp._objFlags & IsOnEnableCalled$2)) {
                    if (comp.onEnable) {
                        if (invoker) return void invoker.add(comp);
                        if (comp.onEnable(), !comp.node._activeInHierarchy) return;
                    }
                    this._onEnabled(comp);
                }
            }
        }, {
            key: "disableComp",
            value: function disableComp(comp) {
                comp._objFlags & IsOnEnableCalled$2 && (comp.onDisable && comp.onDisable(), this._onDisabled(comp));
            }
        }, {
            key: "startPhase",
            value: function startPhase() {
                this._updating = !0, this.scheduleInNextFrame.length > 0 && this._deferredSchedule(), 
                this.startInvoker.invoke();
            }
        }, {
            key: "updatePhase",
            value: function updatePhase(dt) {
                this.updateInvoker.invoke(dt);
            }
        }, {
            key: "lateUpdatePhase",
            value: function lateUpdatePhase(dt) {
                this.lateUpdateInvoker.invoke(dt), this._updating = !1;
            }
        }, {
            key: "_scheduleImmediate",
            value: function _scheduleImmediate(comp) {
                !comp.start || comp._objFlags & IsStartCalled$1 || this.startInvoker.add(comp), 
                comp.update && this.updateInvoker.add(comp), comp.lateUpdate && this.lateUpdateInvoker.add(comp);
            }
        }, {
            key: "_deferredSchedule",
            value: function _deferredSchedule() {
                for (var comps = this.scheduleInNextFrame, i = 0, len = comps.length; i < len; i++) {
                    var comp = comps[i];
                    this._scheduleImmediate(comp);
                }
                comps.length = 0;
            }
        } ]), ComponentScheduler;
    }();
    ComponentScheduler.LifeCycleInvoker = LifeCycleInvoker, ComponentScheduler.OneOffInvoker = OneOffInvoker, 
    ComponentScheduler.createInvokeImpl = createInvokeImpl, ComponentScheduler.invokeOnEnable = function(iterator) {
        var compScheduler = cc.director._compScheduler, array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
            var comp = array[iterator.i];
            if (comp._enabled) comp.onEnable(), !comp.node._activeInHierarchy || compScheduler._onEnabled(comp);
        }
    };
    var IsPreloadStarted$1 = CCObject.Flags.IsPreloadStarted, IsOnLoadStarted$1 = CCObject.Flags.IsOnLoadStarted, IsOnLoadCalled$2 = CCObject.Flags.IsOnLoadCalled, Deactivating$2 = CCObject.Flags.Deactivating, callPreload = function(c) {
        c.__preload();
    }, callOnLoad = function(c) {
        c.onLoad(), c._objFlags |= IsOnLoadCalled$2;
    }, UnsortedInvoker = function(_ComponentScheduler$L) {
        function UnsortedInvoker() {
            return _classCallCheck(this, UnsortedInvoker), _possibleConstructorReturn(this, _getPrototypeOf(UnsortedInvoker).apply(this, arguments));
        }
        return _inherits(UnsortedInvoker, _ComponentScheduler$L), _createClass(UnsortedInvoker, [ {
            key: "add",
            value: function add(comp) {
                this._zero.array.push(comp);
            }
        }, {
            key: "remove",
            value: function remove(comp) {
                this._zero.fastRemove(comp);
            }
        }, {
            key: "cancelInactive",
            value: function cancelInactive(flagToClear) {
                ComponentScheduler.LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
            }
        }, {
            key: "invoke",
            value: function invoke() {
                this._invoke(this._zero), this._zero.array.length = 0;
            }
        } ]), UnsortedInvoker;
    }(ComponentScheduler.LifeCycleInvoker), invokePreload = ComponentScheduler.createInvokeImpl(callPreload), invokeOnLoad = ComponentScheduler.createInvokeImpl(callOnLoad), activateTasksPool = new Pool(4);
    function _componentCorrupted(node, comp, index) {
        comp ? node._removeComponent(comp) : array.removeAt(node._components, index);
    }
    activateTasksPool.get = function getActivateTask() {
        var task = this._get() || {
            preload: new UnsortedInvoker(invokePreload),
            onLoad: new ComponentScheduler.OneOffInvoker(invokeOnLoad),
            onEnable: new ComponentScheduler.OneOffInvoker(ComponentScheduler.invokeOnEnable)
        };
        task.preload._zero.i = -1;
        var invoker = task.onLoad;
        return invoker._zero.i = -1, invoker._neg.i = -1, invoker._pos.i = -1, (invoker = task.onEnable)._zero.i = -1, 
        invoker._neg.i = -1, invoker._pos.i = -1, task;
    };
    var _dec$B, _dec2$i, _dec3$8, _dec4$6, _dec5$5, _class$B, _class2$v, _descriptor$t, _descriptor2$l, _descriptor3$e, _descriptor4$8, _descriptor5$6, _descriptor6$2, _descriptor7$2, _dec6$4, _dec7$2, _class4$3, _class5$3, _descriptor8$2, _descriptor9$2, _descriptor10$2, _descriptor11$1, _dec8$1, _dec9$1, _dec10$1, _dec11$1, _dec12$1, _dec13$1, _class7$1, _class8$1, _descriptor12$1, _descriptor13$1, _descriptor14$1, _descriptor15, _descriptor16, _descriptor17, _dec14$1, _dec15$1, _dec16$1, _dec17, _dec18, _dec19, _dec20, _dec21, _class10$1, _class11$1, _descriptor18, _descriptor19, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _dec22, _dec23, _dec24, _class13, _class14, _descriptor26, _descriptor27, _descriptor28, RenderFlowType, NodeActivator = function() {
        function NodeActivator() {
            _classCallCheck(this, NodeActivator), this.reset();
        }
        return _createClass(NodeActivator, [ {
            key: "reset",
            value: function reset() {
                this._activatingStack = [];
            }
        }, {
            key: "activateNode",
            value: function activateNode(node, active) {
                if (active) {
                    var task = activateTasksPool.get();
                    this._activatingStack.push(task), this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable), 
                    task.preload.invoke(), task.onLoad.invoke(), task.onEnable.invoke(), this._activatingStack.pop(), 
                    activateTasksPool.put(task);
                } else {
                    this._deactivateNodeRecursively(node);
                    var _iterator = this._activatingStack, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var lastTask = _ref;
                        lastTask.preload.cancelInactive(IsPreloadStarted$1), lastTask.onLoad.cancelInactive(IsOnLoadStarted$1), 
                        lastTask.onEnable.cancelInactive();
                    }
                }
                node.emit("active-in-hierarchy-changed", node);
            }
        }, {
            key: "activateComp",
            value: function activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (comp._objFlags & IsPreloadStarted$1 || (comp._objFlags |= IsPreloadStarted$1, 
                comp.__preload && (preloadInvoker ? preloadInvoker.add(comp) : comp.__preload())), 
                comp._objFlags & IsOnLoadStarted$1 || (comp._objFlags |= IsOnLoadStarted$1, comp.onLoad ? onLoadInvoker ? onLoadInvoker.add(comp) : (comp.onLoad(), 
                comp._objFlags |= IsOnLoadCalled$2) : comp._objFlags |= IsOnLoadCalled$2), comp._enabled) {
                    if (!comp.node._activeInHierarchy) return;
                    cc.director._compScheduler.enableComp(comp, onEnableInvoker);
                }
            }
        }, {
            key: "destroyComp",
            value: function destroyComp(comp) {
                cc.director._compScheduler.disableComp(comp), comp.onDestroy && comp._objFlags & IsOnLoadCalled$2 && comp.onDestroy();
            }
        }, {
            key: "_activateNodeRecursively",
            value: function _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (node._objFlags & Deactivating$2) cc.errorID(3816, node.name); else {
                    node._activeInHierarchy = !0;
                    for (var originCount = node._components.length, i = 0; i < originCount; ++i) {
                        var component = node._components[i];
                        component instanceof cc.Component ? this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker) : (_componentCorrupted(node, component, i), 
                        --i, --originCount);
                    }
                    node._childArrivalOrder = node._children.length;
                    for (var _i2 = 0, len = node._children.length; _i2 < len; ++_i2) {
                        var child = node._children[_i2];
                        child._active && this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
                    }
                    node._onPostActivated(!0);
                }
            }
        }, {
            key: "_deactivateNodeRecursively",
            value: function _deactivateNodeRecursively(node) {
                node._objFlags |= Deactivating$2, node._activeInHierarchy = !1;
                for (var originCount = node._components.length, c = 0; c < originCount; ++c) {
                    var component = node._components[c];
                    if (component._enabled && (cc.director._compScheduler.disableComp(component), node._activeInHierarchy)) return void (node._objFlags &= ~Deactivating$2);
                }
                for (var i = 0, len = node._children.length; i < len; ++i) {
                    var child = node._children[i];
                    if (child._activeInHierarchy && (this._deactivateNodeRecursively(child), node._activeInHierarchy)) return void (node._objFlags &= ~Deactivating$2);
                }
                node._onPostActivated(!1), node._objFlags &= ~Deactivating$2;
            }
        } ]), NodeActivator;
    }();
    exports.replaceProperty(BaseNode.prototype, "BaseNode", [ {
        name: "childrenCount",
        newName: "children.length",
        customGetter: function customGetter() {
            return this.children.length;
        }
    } ]), exports.removeProperty(Node$1.prototype, "Node.prototype", [ {
        name: "addLayer"
    }, {
        name: "removeLayer"
    } ]), exports.removeProperty(Layers, "Layers", [ {
        name: "All"
    }, {
        name: "RaycastMask"
    }, {
        name: "check"
    } ]), exports.replaceProperty(Layers, "Layers", [ {
        name: "Default",
        newName: "DEFAULT",
        target: Layers.Enum,
        targetName: "Layers.Enum"
    }, {
        name: "Always",
        newName: "ALWAYS",
        target: Layers.Enum,
        targetName: "Layers.Enum"
    }, {
        name: "IgnoreRaycast",
        newName: "IGNORE_RAYCAST",
        target: Layers.Enum,
        targetName: "Layers.Enum"
    }, {
        name: "Gizmos",
        newName: "GIZMOS",
        target: Layers.Enum,
        targetName: "Layers.Enum"
    }, {
        name: "Editor",
        newName: "EDITOR",
        target: Layers.Enum,
        targetName: "Layers.Enum"
    }, {
        name: "UI",
        newName: "UI_3D",
        target: Layers.Enum,
        targetName: "Layers.Enum"
    }, {
        name: "UI2D",
        newName: "UI_2D",
        target: Layers.Enum,
        targetName: "Layers.Enum"
    }, {
        name: "SceneGizmo",
        newName: "SCENE_GIZMO",
        target: Layers.Enum,
        targetName: "Layers.Enum"
    }, {
        name: "makeInclusiveMask",
        newName: "makeMaskInclude",
        target: Layers,
        targetName: "Layers"
    }, {
        name: "makeExclusiveMask",
        newName: "makeMaskExclude",
        target: Layers,
        targetName: "Layers"
    } ]), exports.removeProperty(Layers.Enum, "Layers.Enum", [ {
        name: "ALWAYS"
    } ]), exports.removeProperty(Layers.BitMask, "Layers.BitMask", [ {
        name: "ALWAYS"
    } ]), ccenum(exports.GFXTextureType), ccenum(exports.GFXTextureViewType), ccenum(exports.GFXTextureUsageBit), 
    ccenum(exports.GFXStoreOp), ccenum(exports.GFXLoadOp), ccenum(exports.GFXTextureLayout), 
    function(RenderFlowType) {
        RenderFlowType[RenderFlowType.SCENE = 0] = "SCENE", RenderFlowType[RenderFlowType.POSTPROCESS = 1] = "POSTPROCESS", 
        RenderFlowType[RenderFlowType.UI = 2] = "UI";
    }(RenderFlowType || (RenderFlowType = {})), ccenum(RenderFlowType);
    var RenderTextureDesc = (_dec$B = ccclass("RenderTextureDesc"), _dec2$i = property({
        type: exports.GFXTextureType
    }), _dec3$8 = property({
        type: exports.GFXTextureViewType
    }), _dec4$6 = property({
        type: exports.GFXTextureUsageBit
    }), _dec5$5 = property({
        type: exports.GFXFormat
    }), _dec$B((_descriptor$t = _applyDecoratedDescriptor((_class2$v = function RenderTextureDesc() {
        _classCallCheck(this, RenderTextureDesc), _initializerDefineProperty(this, "name", _descriptor$t, this), 
        _initializerDefineProperty(this, "type", _descriptor2$l, this), _initializerDefineProperty(this, "viewType", _descriptor3$e, this), 
        _initializerDefineProperty(this, "usage", _descriptor4$8, this), _initializerDefineProperty(this, "format", _descriptor5$6, this), 
        _initializerDefineProperty(this, "width", _descriptor6$2, this), _initializerDefineProperty(this, "height", _descriptor7$2, this);
    }).prototype, "name", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor2$l = _applyDecoratedDescriptor(_class2$v.prototype, "type", [ _dec2$i ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXTextureType.TEX2D;
        }
    }), _descriptor3$e = _applyDecoratedDescriptor(_class2$v.prototype, "viewType", [ _dec3$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXTextureViewType.TV2D;
        }
    }), _descriptor4$8 = _applyDecoratedDescriptor(_class2$v.prototype, "usage", [ _dec4$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXTextureUsageBit.COLOR_ATTACHMENT;
        }
    }), _descriptor5$6 = _applyDecoratedDescriptor(_class2$v.prototype, "format", [ _dec5$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXFormat.UNKNOWN;
        }
    }), _descriptor6$2 = _applyDecoratedDescriptor(_class2$v.prototype, "width", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return -1;
        }
    }), _descriptor7$2 = _applyDecoratedDescriptor(_class2$v.prototype, "height", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return -1;
        }
    }), _class$B = _class2$v)) || _class$B), FrameBufferDesc = (_dec6$4 = ccclass("FrameBufferDesc"), 
    _dec7$2 = property({
        type: [ CCString ]
    }), _dec6$4((_descriptor8$2 = _applyDecoratedDescriptor((_class5$3 = function FrameBufferDesc() {
        _classCallCheck(this, FrameBufferDesc), _initializerDefineProperty(this, "name", _descriptor8$2, this), 
        _initializerDefineProperty(this, "renderPass", _descriptor9$2, this), _initializerDefineProperty(this, "colorViews", _descriptor10$2, this), 
        _initializerDefineProperty(this, "depthStencilView", _descriptor11$1, this);
    }).prototype, "name", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor9$2 = _applyDecoratedDescriptor(_class5$3.prototype, "renderPass", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor10$2 = _applyDecoratedDescriptor(_class5$3.prototype, "colorViews", [ _dec7$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor11$1 = _applyDecoratedDescriptor(_class5$3.prototype, "depthStencilView", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _class4$3 = _class5$3)) || _class4$3), ColorDesc = (_dec8$1 = ccclass("ColorDesc"), 
    _dec9$1 = property({
        type: exports.GFXFormat
    }), _dec10$1 = property({
        type: exports.GFXLoadOp
    }), _dec11$1 = property({
        type: exports.GFXStoreOp
    }), _dec12$1 = property({
        type: exports.GFXTextureLayout
    }), _dec13$1 = property({
        type: exports.GFXTextureLayout
    }), _dec8$1((_descriptor12$1 = _applyDecoratedDescriptor((_class8$1 = function ColorDesc() {
        _classCallCheck(this, ColorDesc), _initializerDefineProperty(this, "format", _descriptor12$1, this), 
        _initializerDefineProperty(this, "loadOp", _descriptor13$1, this), _initializerDefineProperty(this, "storeOp", _descriptor14$1, this), 
        _initializerDefineProperty(this, "sampleCount", _descriptor15, this), _initializerDefineProperty(this, "beginLayout", _descriptor16, this), 
        _initializerDefineProperty(this, "endLayout", _descriptor17, this);
    }).prototype, "format", [ _dec9$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXFormat.UNKNOWN;
        }
    }), _descriptor13$1 = _applyDecoratedDescriptor(_class8$1.prototype, "loadOp", [ _dec10$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXLoadOp.CLEAR;
        }
    }), _descriptor14$1 = _applyDecoratedDescriptor(_class8$1.prototype, "storeOp", [ _dec11$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXStoreOp.STORE;
        }
    }), _descriptor15 = _applyDecoratedDescriptor(_class8$1.prototype, "sampleCount", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor16 = _applyDecoratedDescriptor(_class8$1.prototype, "beginLayout", [ _dec12$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL;
        }
    }), _descriptor17 = _applyDecoratedDescriptor(_class8$1.prototype, "endLayout", [ _dec13$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL;
        }
    }), _class7$1 = _class8$1)) || _class7$1), DepthStencilDesc = (_dec14$1 = ccclass("DepthStencilDesc"), 
    _dec15$1 = property({
        type: exports.GFXFormat
    }), _dec16$1 = property({
        type: exports.GFXLoadOp
    }), _dec17 = property({
        type: exports.GFXStoreOp
    }), _dec18 = property({
        type: exports.GFXLoadOp
    }), _dec19 = property({
        type: exports.GFXStoreOp
    }), _dec20 = property({
        type: exports.GFXTextureLayout
    }), _dec21 = property({
        type: exports.GFXTextureLayout
    }), _dec14$1((_descriptor18 = _applyDecoratedDescriptor((_class11$1 = function DepthStencilDesc() {
        _classCallCheck(this, DepthStencilDesc), _initializerDefineProperty(this, "format", _descriptor18, this), 
        _initializerDefineProperty(this, "depthLoadOp", _descriptor19, this), _initializerDefineProperty(this, "depthStoreOp", _descriptor20, this), 
        _initializerDefineProperty(this, "stencilLoadOp", _descriptor21, this), _initializerDefineProperty(this, "stencilStoreOp", _descriptor22, this), 
        _initializerDefineProperty(this, "sampleCount", _descriptor23, this), _initializerDefineProperty(this, "beginLayout", _descriptor24, this), 
        _initializerDefineProperty(this, "endLayout", _descriptor25, this);
    }).prototype, "format", [ _dec15$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXFormat.UNKNOWN;
        }
    }), _descriptor19 = _applyDecoratedDescriptor(_class11$1.prototype, "depthLoadOp", [ _dec16$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXLoadOp.CLEAR;
        }
    }), _descriptor20 = _applyDecoratedDescriptor(_class11$1.prototype, "depthStoreOp", [ _dec17 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXStoreOp.STORE;
        }
    }), _descriptor21 = _applyDecoratedDescriptor(_class11$1.prototype, "stencilLoadOp", [ _dec18 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXLoadOp.CLEAR;
        }
    }), _descriptor22 = _applyDecoratedDescriptor(_class11$1.prototype, "stencilStoreOp", [ _dec19 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXStoreOp.STORE;
        }
    }), _descriptor23 = _applyDecoratedDescriptor(_class11$1.prototype, "sampleCount", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor24 = _applyDecoratedDescriptor(_class11$1.prototype, "beginLayout", [ _dec20 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL;
        }
    }), _descriptor25 = _applyDecoratedDescriptor(_class11$1.prototype, "endLayout", [ _dec21 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL;
        }
    }), _class10$1 = _class11$1)) || _class10$1), RenderPassDesc = (_dec22 = ccclass("RenderPassDesc"), 
    _dec23 = property({
        type: [ ColorDesc ]
    }), _dec24 = property({
        type: DepthStencilDesc
    }), _dec22((_descriptor26 = _applyDecoratedDescriptor((_class14 = function RenderPassDesc() {
        _classCallCheck(this, RenderPassDesc), _initializerDefineProperty(this, "index", _descriptor26, this), 
        _initializerDefineProperty(this, "colorAttachments", _descriptor27, this), _initializerDefineProperty(this, "depthStencilAttachment", _descriptor28, this);
    }).prototype, "index", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return -1;
        }
    }), _descriptor27 = _applyDecoratedDescriptor(_class14.prototype, "colorAttachments", [ _dec23 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor28 = _applyDecoratedDescriptor(_class14.prototype, "depthStencilAttachment", [ _dec24 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new DepthStencilDesc;
        }
    }), _class13 = _class14)) || _class13);
    function opaqueCompareFn(a, b) {
        return a.hash === b.hash ? a.depth === b.depth ? a.shaderId - b.shaderId : a.depth - b.depth : a.hash - b.hash;
    }
    function transparentCompareFn(a, b) {
        return a.hash === b.hash ? a.depth === b.depth ? a.shaderId - b.shaderId : b.depth - a.depth : a.hash - b.hash;
    }
    var _dec$C, _dec2$j, _dec3$9, _class$C, _class2$w, _descriptor$u, _descriptor2$m, _descriptor3$f, _dec4$7, _dec5$6, _dec6$5, _dec7$3, _dec8$2, _class4$4, _class5$4, _descriptor4$9, _descriptor5$7, _descriptor6$3, _descriptor7$3, RenderQueueSortMode, RenderQueue = function() {
        function RenderQueue(desc) {
            _classCallCheck(this, RenderQueue), this.cmdBuffCount = 0, this._passDesc = desc, 
            this._passPool = new RecyclePool((function() {
                return {
                    hash: 0,
                    depth: 0,
                    shaderId: 0,
                    subModel: null,
                    cmdBuff: null
                };
            }), 64), this.cmdBuffs = new CachedArray(64), this.queue = new CachedArray(64, this._passDesc.sortFunc);
        }
        return _createClass(RenderQueue, [ {
            key: "clear",
            value: function clear() {
                this.queue.clear(), this._passPool.reset(), this.cmdBuffCount = 0;
            }
        }, {
            key: "insertRenderPass",
            value: function insertRenderPass(renderObj, modelIdx, passIdx) {
                var subModel = renderObj.model.getSubModel(modelIdx), pass = subModel.passes[passIdx], pso = subModel.psos[passIdx];
                if (pso.blendState.targets[0].blend !== this._passDesc.isTransparent || !(pass.phase & this._passDesc.phases)) return !1;
                var hash = 0 | pass.priority << 16 | subModel.priority << 8 | passIdx, rp = this._passPool.add();
                return rp.hash = hash, rp.depth = renderObj.depth, rp.shaderId = pso.shader.id, 
                rp.subModel = subModel, rp.cmdBuff = subModel.commandBuffers[passIdx], this.queue.push(rp), 
                !0;
            }
        }, {
            key: "sort",
            value: function sort() {
                this.queue.sort(), this.cmdBuffCount = this.queue.length;
                for (var i = 0; i < this.queue.length; ++i) this.cmdBuffs.array[i] = this.queue.array[i].cmdBuff;
            }
        } ]), RenderQueue;
    }(), _colors = [ {
        r: 0,
        g: 0,
        b: 0,
        a: 1
    } ], bufs = [];
    !function(RenderQueueSortMode) {
        RenderQueueSortMode[RenderQueueSortMode.FRONT_TO_BACK = 0] = "FRONT_TO_BACK", RenderQueueSortMode[RenderQueueSortMode.BACK_TO_FRONT = 1] = "BACK_TO_FRONT";
    }(RenderQueueSortMode || (RenderQueueSortMode = {})), ccenum(RenderQueueSortMode);
    var _dec$D, _dec2$k, _dec3$a, _dec4$8, _dec5$7, _dec6$6, _class$D, _class2$x, _descriptor$v, _descriptor2$n, _descriptor3$g, _descriptor4$a, _descriptor5$8, RenderQueueDesc = (_dec$C = ccclass("RenderQueueDesc"), 
    _dec2$j = property({
        type: RenderQueueSortMode
    }), _dec3$9 = property({
        type: [ CCString ]
    }), _dec$C((_descriptor$u = _applyDecoratedDescriptor((_class2$w = function RenderQueueDesc() {
        _classCallCheck(this, RenderQueueDesc), _initializerDefineProperty(this, "isTransparent", _descriptor$u, this), 
        _initializerDefineProperty(this, "sortMode", _descriptor2$m, this), _initializerDefineProperty(this, "stages", _descriptor3$f, this);
    }).prototype, "isTransparent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$m = _applyDecoratedDescriptor(_class2$w.prototype, "sortMode", [ _dec2$j ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return RenderQueueSortMode.FRONT_TO_BACK;
        }
    }), _descriptor3$f = _applyDecoratedDescriptor(_class2$w.prototype, "stages", [ _dec3$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$C = _class2$w)) || _class$C), RenderStage = (_dec4$7 = ccclass("RenderStage"), 
    _dec5$6 = property({
        displayOrder: 0,
        visible: !0
    }), _dec6$5 = property({
        displayOrder: 1,
        visible: !0
    }), _dec7$3 = property({
        displayOrder: 2,
        visible: !0
    }), _dec8$2 = property({
        type: [ RenderQueueDesc ],
        displayOrder: 3,
        visible: !0
    }), _dec4$7((_descriptor4$9 = _applyDecoratedDescriptor((_class5$4 = function() {
        function RenderStage() {
            _classCallCheck(this, RenderStage), _initializerDefineProperty(this, "_name", _descriptor4$9, this), 
            _initializerDefineProperty(this, "_priority", _descriptor5$7, this), _initializerDefineProperty(this, "frameBuffer", _descriptor6$3, this), 
            _initializerDefineProperty(this, "renderQueues", _descriptor7$3, this), this._renderQueues = [], 
            this._flow = null, this._pipeline = null, this._device = null, this._framebuffer = null, 
            this._cmdBuff = null, this._clearColors = null, this._clearDepth = 1, this._clearStencil = 0, 
            this._renderArea = null, this._pass = null, this._pso = null;
        }
        return _createClass(RenderStage, [ {
            key: "flow",
            get: function get() {
                return this._flow;
            }
        }, {
            key: "pipeline",
            get: function get() {
                return this._pipeline;
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            }
        }, {
            key: "framebuffer",
            get: function get() {
                return this._framebuffer;
            }
        } ]), _createClass(RenderStage, [ {
            key: "initialize",
            value: function initialize(info) {
                return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                info.framebuffer && (this.frameBuffer = info.framebuffer), info.renderQueues && (this.renderQueues = info.renderQueues), 
                !0;
            }
        }, {
            key: "activate",
            value: function activate(flow) {
                if (this._flow = flow, this._pipeline = flow.pipeline, this._device = flow.device, 
                !this._flow.pipeline.root.device) throw new Error("");
                this._device = this._flow.pipeline.root.device, this._clearColors = [ {
                    r: .3,
                    g: .6,
                    b: .9,
                    a: 1
                } ], this._renderArea = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
                for (var i = 0; i < this.renderQueues.length; i++) {
                    for (var phase = 0, j = 0; j < this.renderQueues[i].stages.length; j++) phase |= getPhaseID(this.renderQueues[i].stages[j]);
                    var sortFunc = opaqueCompareFn;
                    switch (this.renderQueues[i].sortMode) {
                      case RenderQueueSortMode.BACK_TO_FRONT:
                        sortFunc = transparentCompareFn;
                        break;

                      case RenderQueueSortMode.FRONT_TO_BACK:
                        sortFunc = opaqueCompareFn;
                    }
                    this._renderQueues[i] = new RenderQueue({
                        isTransparent: this.renderQueues[i].isTransparent,
                        phases: phase,
                        sortFunc: sortFunc
                    });
                }
                "window" === this.frameBuffer ? this._framebuffer = this._flow.pipeline.root.mainWindow.framebuffer : this._framebuffer = this._flow.pipeline.getFrameBuffer(this.frameBuffer);
            }
        }, {
            key: "setClearColor",
            value: function setClearColor(color) {
                this._clearColors.length > 0 ? this._clearColors[0] = color : this._clearColors.push(color);
            }
        }, {
            key: "setClearColors",
            value: function setClearColors(colors) {
                this._clearColors = colors;
            }
        }, {
            key: "setClearDepth",
            value: function setClearDepth(depth) {
                this._clearDepth = depth;
            }
        }, {
            key: "setClearStencil",
            value: function setClearStencil(stencil) {
                this._clearStencil = stencil;
            }
        }, {
            key: "setRenderArea",
            value: function setRenderArea(width, height) {
                this._renderArea.width = width, this._renderArea.height = height;
            }
        }, {
            key: "sortRenderQueue",
            value: function sortRenderQueue() {
                this._renderQueues.forEach(this.renderQueueClearFunc);
                for (var renderObjects = this._pipeline.renderObjects, i = 0; i < renderObjects.length; ++i) for (var ro = renderObjects[i], l = 0; l < ro.model.subModelNum; l++) for (var j = 0; j < ro.model.getSubModel(l).passes.length; j++) for (var k = 0; k < this._renderQueues.length; k++) this._renderQueues[k].insertRenderPass(ro, l, j);
                this._renderQueues.forEach(this.renderQueueSortFunc);
            }
        }, {
            key: "executeCommandBuffer",
            value: function executeCommandBuffer(view) {
                var camera = view.camera, cmdBuff = this._cmdBuff, vp = camera.viewport;
                this._renderArea.x = vp.x * camera.width, this._renderArea.y = vp.y * camera.height, 
                this._renderArea.width = vp.width * camera.width * this.pipeline.shadingScale, this._renderArea.height = vp.height * camera.height * this.pipeline.shadingScale, 
                camera.clearFlag & exports.GFXClearFlag.COLOR && (_colors[0].a = camera.clearColor.a, 
                _colors[0].r = camera.clearColor.r, _colors[0].g = camera.clearColor.g, _colors[0].b = camera.clearColor.b), 
                this._framebuffer || (this._framebuffer = view.window.framebuffer), cmdBuff.begin(), 
                cmdBuff.beginRenderPass(this._framebuffer, this._renderArea, camera.clearFlag, _colors, camera.clearDepth, camera.clearStencil);
                for (var i = 0; i < this._renderQueues.length; i++) cmdBuff.execute(this._renderQueues[i].cmdBuffs.array, this._renderQueues[i].cmdBuffCount);
                cmdBuff.endRenderPass(), cmdBuff.end(), bufs[0] = cmdBuff, this._device.queue.submit(bufs);
            }
        }, {
            key: "createCmdBuffer",
            value: function createCmdBuffer() {
                this._cmdBuff = this._device.createCommandBuffer({
                    allocator: this._device.commandAllocator,
                    type: exports.GFXCommandBufferType.PRIMARY
                });
            }
        }, {
            key: "renderQueueClearFunc",
            value: function renderQueueClearFunc(rq) {
                rq.clear();
            }
        }, {
            key: "renderQueueSortFunc",
            value: function renderQueueSortFunc(rq) {
                rq.sort();
            }
        } ]), RenderStage;
    }()).prototype, "_name", [ _dec5$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor5$7 = _applyDecoratedDescriptor(_class5$4.prototype, "_priority", [ _dec6$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$3 = _applyDecoratedDescriptor(_class5$4.prototype, "frameBuffer", [ _dec7$3 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor7$3 = _applyDecoratedDescriptor(_class5$4.prototype, "renderQueues", [ _dec8$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class4$4 = _class5$4)) || _class4$4);
    cc.RenderStage = RenderStage;
    var _dec$E, _dec2$l, _dec3$b, _dec4$9, _dec5$8, _class$E, _class2$y, _descriptor$w, _descriptor2$o, _descriptor3$h, _descriptor4$b, RenderFlow = (_dec$D = ccclass("RenderFlow"), 
    _dec2$k = property({
        displayOrder: 0,
        visible: !0
    }), _dec3$a = property({
        displayOrder: 1,
        visible: !0
    }), _dec4$8 = property({
        type: cc.Material,
        displayOrder: 2,
        visible: !0
    }), _dec5$7 = property({
        type: RenderFlowType,
        displayOrder: 3,
        visible: !0
    }), _dec6$6 = property({
        type: [ RenderStage ],
        displayOrder: 4,
        visible: !0
    }), _dec$D((_descriptor$v = _applyDecoratedDescriptor((_class2$x = function() {
        function RenderFlow() {
            _classCallCheck(this, RenderFlow), this._device = null, this._pipeline = null, _initializerDefineProperty(this, "_name", _descriptor$v, this), 
            _initializerDefineProperty(this, "_priority", _descriptor2$n, this), _initializerDefineProperty(this, "_material", _descriptor3$g, this), 
            _initializerDefineProperty(this, "_type", _descriptor4$a, this), _initializerDefineProperty(this, "_stages", _descriptor5$8, this);
        }
        return _createClass(RenderFlow, [ {
            key: "device",
            get: function get() {
                return this._device;
            }
        }, {
            key: "pipeline",
            get: function get() {
                return this._pipeline;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            }
        }, {
            key: "stages",
            get: function get() {
                return this._stages;
            }
        }, {
            key: "material",
            get: function get() {
                return this._material;
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        } ]), _createClass(RenderFlow, [ {
            key: "initialize",
            value: function initialize(info) {
                void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                info.material && (this._material = info.material), info.type && (this._type = info.type);
            }
        }, {
            key: "activate",
            value: function activate(pipeline) {
                this._device = pipeline.device, this._pipeline = pipeline, pipeline.activateFlow(this), 
                this._activateStages();
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                for (var i = 0; i < this._stages.length; i++) this._stages[i].resize(width, height);
            }
        }, {
            key: "render",
            value: function render(view) {
                for (var i = 0; i < this._stages.length; i++) this._stages[i].render(view);
            }
        }, {
            key: "destroyStages",
            value: function destroyStages() {
                for (var i = 0; i < this._stages.length; i++) this._stages[i].destroy();
                this._stages = [];
            }
        }, {
            key: "_activateStages",
            value: function _activateStages() {
                for (var i = 0; i < this._stages.length; i++) this._stages[i].activate(this);
                this._stages.sort((function(a, b) {
                    return a.priority - b.priority;
                }));
            }
        } ]), RenderFlow;
    }()).prototype, "_name", [ _dec2$k ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor2$n = _applyDecoratedDescriptor(_class2$x.prototype, "_priority", [ _dec3$a ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor3$g = _applyDecoratedDescriptor(_class2$x.prototype, "_material", [ _dec4$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor4$a = _applyDecoratedDescriptor(_class2$x.prototype, "_type", [ _dec5$7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return RenderFlowType.SCENE;
        }
    }), _descriptor5$8 = _applyDecoratedDescriptor(_class2$x.prototype, "_stages", [ _dec6$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$D = _class2$x)) || _class$D);
    cc.RenderFlow = RenderFlow;
    var _dec$F, _dec2$m, _class$F, _class2$z, _descriptor$x, v3_1$5 = new Vec3, RenderPipeline = (_dec$E = ccclass("RenderPipeline"), 
    _dec2$l = property({
        type: [ RenderFlow ],
        visible: !0
    }), _dec3$b = property({
        type: [ RenderTextureDesc ]
    }), _dec4$9 = property({
        type: [ FrameBufferDesc ]
    }), _dec5$8 = property({
        type: [ RenderPassDesc ]
    }), _dec$E((_descriptor$w = _applyDecoratedDescriptor((_class2$y = function() {
        function RenderPipeline() {
            _classCallCheck(this, RenderPipeline), this._root = null, this._device = null, this._renderObjects = [], 
            _initializerDefineProperty(this, "_flows", _descriptor$w, this), this._activeFlows = [], 
            this._isHDRSupported = !1, this._isHDR = !1, this._lightMeterScale = 1e4, this._fboCount = 0, 
            this._colorFmt = exports.GFXFormat.UNKNOWN, this._depthStencilFmt = exports.GFXFormat.UNKNOWN, 
            this._shadingWidth = 0, this._shadingHeight = 0, this._shadingScale = 1, this._curIdx = "shading", 
            this._prevIdx = "shading1", this._usePostProcess = !1, this._useMSAA = !1, this._useSMAA = !1, 
            this._quadVB = null, this._quadIB = null, this._quadIA = null, this._uboGlobal = new UBOGlobal, 
            this._globalBindings = new Map, this._defaultTex = null, this._defaultTexView = null, 
            this._fpScale = 1 / 1024, this._fpScaleInv = 1024, this._macros = {}, this._useDynamicBatching = !1, 
            _initializerDefineProperty(this, "renderTextures", _descriptor2$o, this), _initializerDefineProperty(this, "framebuffers", _descriptor3$h, this), 
            _initializerDefineProperty(this, "renderPasses", _descriptor4$b, this), this._renderTextures = new Map, 
            this._textureViews = new Map, this._frameBuffers = new Map, this._renderPasses = new Map;
        }
        return _createClass(RenderPipeline, [ {
            key: "root",
            get: function get() {
                return this._root;
            }
        }, {
            key: "device",
            get: function get() {
                return this._device;
            }
        }, {
            key: "name",
            get: function get() {
                return js.getClassName(this.constructor);
            }
        }, {
            key: "renderObjects",
            get: function get() {
                return this._renderObjects;
            }
        }, {
            key: "flows",
            get: function get() {
                return this._flows;
            }
        }, {
            key: "activeFlows",
            get: function get() {
                return this._activeFlows;
            }
        }, {
            key: "usePostProcess",
            get: function get() {
                return this._usePostProcess;
            }
        }, {
            key: "isHDRSupported",
            get: function get() {
                return this._isHDRSupported;
            }
        }, {
            key: "isHDR",
            get: function get() {
                return this._isHDR;
            }
        }, {
            key: "shadingScale",
            get: function get() {
                return this._shadingScale;
            }
        }, {
            key: "lightMeterScale",
            set: function set(scale) {
                this._lightMeterScale = scale;
            },
            get: function get() {
                return this._lightMeterScale;
            }
        }, {
            key: "useMSAA",
            get: function get() {
                return this._useMSAA;
            }
        }, {
            key: "useSMAA",
            get: function get() {
                return this._useSMAA;
            }
        }, {
            key: "quadIA",
            get: function get() {
                return this._quadIA;
            }
        }, {
            key: "globalBindings",
            get: function get() {
                return this._globalBindings;
            }
        }, {
            key: "defaultTexture",
            get: function get() {
                return this._defaultTex;
            }
        }, {
            key: "fpScale",
            get: function get() {
                return this._fpScale;
            }
        }, {
            key: "fpScaleInv",
            get: function get() {
                return this._fpScaleInv;
            }
        }, {
            key: "macros",
            get: function get() {
                return this._macros;
            }
        }, {
            key: "defaultGlobalUBOData",
            get: function get() {
                return this._uboGlobal.view;
            }
        }, {
            key: "currShading",
            get: function get() {
                return this._curIdx;
            }
        }, {
            key: "prevShading",
            get: function get() {
                return this._prevIdx;
            }
        }, {
            key: "useDynamicBatching",
            get: function get() {
                return this._useDynamicBatching;
            }
        } ]), _createClass(RenderPipeline, [ {
            key: "getTextureView",
            value: function getTextureView(name) {
                return this._textureViews.get(name);
            }
        }, {
            key: "getRenderTexture",
            value: function getRenderTexture(name) {
                return this._renderTextures.get(name);
            }
        }, {
            key: "getFrameBuffer",
            value: function getFrameBuffer(name) {
                return this._frameBuffers.get(name);
            }
        }, {
            key: "initialize",
            value: function initialize(info) {
                void 0 !== info.enablePostProcess ? this._usePostProcess = info.enablePostProcess : this._usePostProcess = !1, 
                this._isHDR = void 0 !== info.enableHDR && info.enableHDR, this._useSMAA = void 0 !== info.enableSMAA && info.enableSMAA, 
                this._useMSAA = void 0 !== info.enableMSAA && info.enableMSAA, info.renderTextures && (this.renderTextures = info.renderTextures), 
                info.framebuffers && (this.framebuffers = info.framebuffers), info.renderPasses && (this.renderPasses = info.renderPasses);
            }
        }, {
            key: "activate",
            value: function activate(root) {
                if (this._root = root, this._device = root.device, !this._initRenderResource()) return console.error("RenderPipeline:" + this.name + " startup failed!"), 
                !1;
                for (var i = 0; i < this._flows.length; i++) this._flows[i].type === RenderFlowType.SCENE && this._flows[i].activate(this);
                return !0;
            }
        }, {
            key: "render",
            value: function render(view) {
                for (var i = 0; i < view.flows.length; i++) view.flows[i].render(view);
            }
        }, {
            key: "rebuild",
            value: function rebuild() {
                this.updateMacros();
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                var w = Math.floor(width * this._shadingScale), h = Math.floor(height * this._shadingScale);
                (w > this._shadingWidth || h > this._shadingHeight) && this.resizeFBOs(w, h);
                for (var i = 0; i < this._flows.length; i++) this._flows[i].resize(width, height);
            }
        }, {
            key: "swapFBOs",
            value: function swapFBOs() {
                var temp = this._curIdx;
                this._curIdx = this._prevIdx, this._prevIdx = temp;
            }
        }, {
            key: "addRenderPass",
            value: function addRenderPass(stage, renderPass) {
                renderPass && this._renderPasses.set(stage, renderPass);
            }
        }, {
            key: "getRenderPass",
            value: function getRenderPass(stage) {
                var renderPass = this._renderPasses.get(stage);
                return renderPass || null;
            }
        }, {
            key: "removeRenderPass",
            value: function removeRenderPass(stage) {
                this._renderPasses.delete(stage);
            }
        }, {
            key: "clearRenderPasses",
            value: function clearRenderPasses() {
                this._renderPasses.clear();
            }
        }, {
            key: "destroyFlows",
            value: function destroyFlows() {
                for (var i = 0; i < this._flows.length; i++) this._flows[i].destroy();
                this._flows = [];
            }
        }, {
            key: "getFlow",
            value: function getFlow(name) {
                for (var i = 0; i < this._flows.length; i++) if (this._flows[i].name === name) return this._flows[i];
                return null;
            }
        }, {
            key: "updateMacros",
            value: function updateMacros() {
                programLib.destroyShaderByDefines(this._macros), this._macros.CC_USE_HDR = this._isHDR;
                for (var i = 0; i < this._root.scenes.length; i++) this._root.scenes[i].onGlobalPipelineStateChanged();
            }
        }, {
            key: "updateUBOs",
            value: function updateUBOs(view) {
                var camera = view.camera, scene = camera.scene, device = this._root.device, mainLight = scene.mainLight, ambient = scene.ambient, fv = this._uboGlobal.view;
                fv[UBOGlobal.TIME_OFFSET] = this._root.cumulativeTime, fv[UBOGlobal.TIME_OFFSET + 1] = this._root.frameTime, 
                fv[UBOGlobal.TIME_OFFSET + 2] = cc.director.getTotalFrames(), fv[UBOGlobal.SCREEN_SIZE_OFFSET] = device.width, 
                fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1] = device.height, fv[UBOGlobal.SCREEN_SIZE_OFFSET + 2] = 1 / fv[UBOGlobal.SCREEN_SIZE_OFFSET], 
                fv[UBOGlobal.SCREEN_SIZE_OFFSET + 3] = 1 / fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1], 
                fv[UBOGlobal.SCREEN_SCALE_OFFSET] = camera.width / this._shadingWidth * this._shadingScale, 
                fv[UBOGlobal.SCREEN_SCALE_OFFSET + 1] = camera.height / this._shadingHeight * this._shadingScale, 
                fv[UBOGlobal.SCREEN_SCALE_OFFSET + 2] = 1 / fv[UBOGlobal.SCREEN_SCALE_OFFSET], fv[UBOGlobal.SCREEN_SCALE_OFFSET + 3] = 1 / fv[UBOGlobal.SCREEN_SCALE_OFFSET + 1], 
                fv[UBOGlobal.NATIVE_SIZE_OFFSET] = this._shadingWidth, fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1] = this._shadingHeight, 
                fv[UBOGlobal.NATIVE_SIZE_OFFSET + 2] = 1 / fv[UBOGlobal.NATIVE_SIZE_OFFSET], fv[UBOGlobal.NATIVE_SIZE_OFFSET + 3] = 1 / fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1], 
                Mat4.toArray(fv, camera.matView, UBOGlobal.MAT_VIEW_OFFSET), Mat4.toArray(fv, camera.node.worldMatrix, UBOGlobal.MAT_VIEW_INV_OFFSET), 
                Mat4.toArray(fv, camera.matProj, UBOGlobal.MAT_PROJ_OFFSET), Mat4.toArray(fv, camera.matProjInv, UBOGlobal.MAT_PROJ_INV_OFFSET), 
                Mat4.toArray(fv, camera.matViewProj, UBOGlobal.MAT_VIEW_PROJ_OFFSET), Mat4.toArray(fv, camera.matViewProjInv, UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET), 
                Vec3.toArray(fv, camera.position, UBOGlobal.CAMERA_POS_OFFSET);
                var exposure = camera.exposure;
                if (fv[UBOGlobal.EXPOSURE_OFFSET] = exposure, fv[UBOGlobal.EXPOSURE_OFFSET + 1] = 1 / exposure, 
                fv[UBOGlobal.EXPOSURE_OFFSET + 2] = this._isHDR ? 1 : 0, fv[UBOGlobal.EXPOSURE_OFFSET + 3] = this._fpScale / exposure, 
                mainLight) {
                    if (Vec3.toArray(fv, mainLight.direction, UBOGlobal.MAIN_LIT_DIR_OFFSET), Vec3.toArray(fv, mainLight.color, UBOGlobal.MAIN_LIT_COLOR_OFFSET), 
                    mainLight.useColorTemperature) {
                        var colorTempRGB = mainLight.colorTemperatureRGB;
                        fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET] *= colorTempRGB.x, fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 1] *= colorTempRGB.y, 
                        fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 2] *= colorTempRGB.z;
                    }
                    this._isHDR ? fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * this._fpScale : fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * exposure;
                } else Vec3.toArray(fv, Vec3.UNIT_Z, UBOGlobal.MAIN_LIT_DIR_OFFSET), Vec4.toArray(fv, Vec4.ZERO, UBOGlobal.MAIN_LIT_COLOR_OFFSET);
                var skyColor = ambient.skyColor;
                this._isHDR ? skyColor[3] = ambient.skyIllum * this._fpScale : skyColor[3] = ambient.skyIllum * exposure, 
                this._uboGlobal.view.set(skyColor, UBOGlobal.AMBIENT_SKY_OFFSET), this._uboGlobal.view.set(ambient.groundAlbedo, UBOGlobal.AMBIENT_GROUND_OFFSET), 
                this._globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this._uboGlobal.view.buffer);
            }
        }, {
            key: "sceneCulling",
            value: function sceneCulling(view) {
                var camera = view.camera, scene = camera.scene;
                this._renderObjects.length = 0;
                var mainLight = scene.mainLight, planarShadows = scene.planarShadows;
                mainLight && (mainLight.update(), planarShadows.enabled && mainLight.node.hasChangedFlags && planarShadows.updateDirLight(mainLight)), 
                scene.skybox.enabled && camera.clearFlag & SKYBOX_FLAG && this.addVisibleModel(scene.skybox, camera);
                for (var models = scene.models, i = 0; i < models.length; i++) {
                    var model = models[i];
                    if (model._resetUBOUpdateFlag(), model.enabled) if (view.visibility & Layers.BitMask.UI_2D) (model.node && view.visibility === model.node.layer || view.visibility === model.visFlags) && (model.updateTransform(), 
                    model.updateUBOs(), this.addVisibleModel(model, camera)); else if (model.node && (view.visibility & model.node.layer) === model.node.layer || view.visibility & model.visFlags) {
                        if (model.updateTransform(), model.worldBounds && !intersect.aabb_frustum(model.worldBounds, camera.frustum)) continue;
                        model.updateUBOs(), this.addVisibleModel(model, camera);
                    }
                }
                planarShadows.enabled && planarShadows.updateCommandBuffers(camera.frustum);
            }
        }, {
            key: "_initRenderResource",
            value: function _initRenderResource() {
                this._usePostProcess && ((this._device.hasFeature(exports.GFXFeature.FORMAT_R11G11B10F) || this._device.hasFeature(exports.GFXFeature.TEXTURE_HALF_FLOAT) || this._device.hasFeature(exports.GFXFeature.TEXTURE_FLOAT)) && (this._isHDRSupported = !0), 
                this._fboCount = 1, this._useMSAA && (this._useMSAA = this.device.hasFeature(exports.GFXFeature.MSAA))), 
                this._isHDR && this._isHDRSupported && (this._device.hasFeature(exports.GFXFeature.COLOR_HALF_FLOAT) && this._device.hasFeature(exports.GFXFeature.TEXTURE_HALF_FLOAT_LINEAR) ? this._device.hasFeature(exports.GFXFeature.FORMAT_R11G11B10F) ? (this._colorFmt = exports.GFXFormat.R11G11B10F, 
                this._isHDR = !0) : this._device.hasFeature(exports.GFXFeature.TEXTURE_HALF_FLOAT) && (this._colorFmt = exports.GFXFormat.RGBA16F, 
                this._isHDR = !0) : this._device.hasFeature(exports.GFXFeature.COLOR_FLOAT) && this._device.hasFeature(exports.GFXFeature.TEXTURE_FLOAT_LINEAR) && this._device.hasFeature(exports.GFXFeature.TEXTURE_FLOAT) && (this._colorFmt = exports.GFXFormat.RGBA32F, 
                this._isHDR = !0), this._isHDR = !1), this._isHDR || (this._colorFmt = exports.GFXFormat.RGBA8), 
                24 === this._device.depthBits ? 8 === this._device.stencilBits ? this._depthStencilFmt = exports.GFXFormat.D24S8 : this._depthStencilFmt = exports.GFXFormat.D24 : this._depthStencilFmt = exports.GFXFormat.D16, 
                this._shadingScale = 1, this._shadingWidth = Math.floor(this._device.width), this._shadingHeight = Math.floor(this._device.height), 
                console.info("USE_POST_PROCESS: " + this._usePostProcess), this._usePostProcess && (console.info("USE_MSAA: " + this._useMSAA), 
                console.info("USE_SMAA: " + this._useSMAA), console.info("USE_HDR: " + this._isHDR)), 
                console.info("SHADING_SIZE: " + this._shadingWidth + " x " + this._shadingHeight), 
                console.info("SHADING_SCALE: " + this._shadingScale.toFixed(4)), console.info("SHADING_COLOR_FORMAT: " + GFXFormatInfos[this._colorFmt].name), 
                console.info("SHADING_DEPTH_FORMAT: " + GFXFormatInfos[this._depthStencilFmt].name);
                for (var i = 0; i < this.renderTextures.length; i++) {
                    var rtd = this.renderTextures[i];
                    this._renderTextures.set(rtd.name, this._device.createTexture({
                        type: rtd.type,
                        usage: rtd.usage,
                        format: this._getTextureFormat(rtd.format, rtd.usage),
                        width: -1 === rtd.width ? this._shadingWidth : rtd.width,
                        height: -1 === rtd.height ? this._shadingHeight : rtd.height
                    }));
                    var rt = this._renderTextures.get(rtd.name);
                    if (null == rt) return console.error("RenderTexture:" + rtd.name + " not found!"), 
                    !1;
                    this._textureViews.set(rtd.name, this._device.createTextureView({
                        texture: rt,
                        type: rtd.viewType,
                        format: this._getTextureFormat(rtd.format, rtd.usage)
                    }));
                }
                for (var _i = 0; _i < this.renderPasses.length; _i++) {
                    var rpd = this.renderPasses[_i];
                    this._renderPasses.set(rpd.index, this._device.createRenderPass({
                        colorAttachments: rpd.colorAttachments,
                        depthStencilAttachment: rpd.depthStencilAttachment
                    }));
                }
                for (var _i2 = 0; _i2 < this.framebuffers.length; _i2++) {
                    var fbd = this.framebuffers[_i2], rp = this._renderPasses.get(fbd.renderPass);
                    if (null == rp) return console.error("RenderPass:" + fbd.renderPass + " not found!"), 
                    !1;
                    for (var tvs = [], j = 0; j < fbd.colorViews.length; j++) {
                        var tv = this._textureViews.get(fbd.colorViews[j]);
                        if (null == tv) return console.error("TextureView:" + fbd.colorViews[j] + " not found!"), 
                        !1;
                        tvs.push(tv);
                    }
                    var dsv = this._textureViews.get(fbd.depthStencilView);
                    this._frameBuffers.set(fbd.name, this._device.createFramebuffer({
                        renderPass: rp,
                        colorViews: tvs,
                        depthStencilView: dsv
                    }));
                }
                if (!this.createQuadInputAssembler()) return !1;
                if (!this.createUBOs()) return !1;
                var mainWindow = this._root.mainWindow, windowPass = null;
                return mainWindow && (windowPass = mainWindow.renderPass), windowPass ? (this.addRenderPass(exports.RenderPassStage.DEFAULT, windowPass), 
                this.updateMacros(), !0) : (console.error("RenderPass of main window is null."), 
                !1);
            }
        }, {
            key: "_destroy",
            value: function _destroy() {
                this.destroyFlows(), this.clearRenderPasses(), this.destroyQuadInputAssembler(), 
                this.destroyUBOs();
                for (var rtIter = this._renderTextures.values(), rtRes = rtIter.next(); !rtRes.done; ) rtRes.value.destroy(), 
                rtRes = rtIter.next();
                for (var tvIter = this._textureViews.values(), tvRes = tvIter.next(); !tvRes.done; ) tvRes.value.destroy(), 
                tvRes = tvIter.next();
                for (var rpIter = this._renderPasses.values(), rpRes = rpIter.next(); !rpRes.done; ) rpRes.value.destroy(), 
                rpRes = rpIter.next();
                for (var fbIter = this._frameBuffers.values(), fbRes = fbIter.next(); !fbRes.done; ) fbRes.value.destroy(), 
                fbRes = fbIter.next();
            }
        }, {
            key: "resizeFBOs",
            value: function resizeFBOs(width, height) {
                var _this = this;
                this._shadingWidth = width, this._shadingHeight = height;
                for (var i = 0; i < this.renderTextures.length; i++) {
                    var rt = this.renderTextures[i];
                    this._renderTextures.get(rt.name).resize(width, height), this._textureViews.get(rt.name).destroy(), 
                    this._textureViews.get(rt.name).initialize({
                        texture: this._renderTextures.get(rt.name),
                        type: rt.viewType,
                        format: this._getTextureFormat(rt.format, rt.usage)
                    });
                }
                for (var _i3 = 0; _i3 < this.framebuffers.length; _i3++) {
                    var fb = this.framebuffers[_i3];
                    this._frameBuffers.get(fb.name).destroy(), this._frameBuffers.get(fb.name).initialize({
                        renderPass: this._renderPasses.get(fb.renderPass),
                        colorViews: fb.colorViews.map((function(value) {
                            return _this._textureViews.get(value);
                        }), this),
                        depthStencilView: this._textureViews.get(fb.depthStencilView)
                    });
                }
                console.info("Resizing shading fbos: " + this._shadingWidth + "x" + this._shadingHeight);
            }
        }, {
            key: "createQuadInputAssembler",
            value: function createQuadInputAssembler() {
                var vbStride = 4 * Float32Array.BYTES_PER_ELEMENT, vbSize = 4 * vbStride;
                if (this._quadVB = this._device.createBuffer({
                    usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: vbSize,
                    stride: vbStride
                }), !this._quadVB) return !1;
                var verts = new Float32Array(16), n = 0;
                verts[n++] = -1, verts[n++] = -1, verts[n++] = 0, verts[n++] = 0, verts[n++] = 1, 
                verts[n++] = -1, verts[n++] = 1, verts[n++] = 0, verts[n++] = -1, verts[n++] = 1, 
                verts[n++] = 0, verts[n++] = 1, verts[n++] = 1, verts[n++] = 1, verts[n++] = 1, 
                verts[n++] = 1, this._quadVB.update(verts);
                var ibStride = Uint8Array.BYTES_PER_ELEMENT, ibSize = 6 * ibStride;
                if (this._quadIB = this._device.createBuffer({
                    usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: ibSize,
                    stride: ibStride
                }), !this._quadIB) return !1;
                var indices = new Uint8Array(6);
                indices[0] = 0, indices[1] = 1, indices[2] = 2, indices[3] = 1, indices[4] = 3, 
                indices[5] = 2, this._quadIB.update(indices);
                var attributes = [ {
                    name: "a_position",
                    format: exports.GFXFormat.RG32F
                }, {
                    name: "a_texCoord",
                    format: exports.GFXFormat.RG32F
                } ];
                return this._quadIA = this._device.createInputAssembler({
                    attributes: attributes,
                    vertexBuffers: [ this._quadVB ],
                    indexBuffer: this._quadIB
                }), !0;
            }
        }, {
            key: "destroyQuadInputAssembler",
            value: function destroyQuadInputAssembler() {
                this._quadVB && (this._quadVB.destroy(), this._quadVB = null), this._quadIB && (this._quadIB.destroy(), 
                this._quadIB = null), this._quadIA && (this._quadIA.destroy(), this._quadIA = null);
            }
        }, {
            key: "createUBOs",
            value: function createUBOs() {
                if (!this._globalBindings.get(UBOGlobal.BLOCK.name)) {
                    var globalUBO = this._root.device.createBuffer({
                        usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                        size: UBOGlobal.SIZE
                    });
                    this._globalBindings.set(UBOGlobal.BLOCK.name, {
                        type: exports.GFXBindingType.UNIFORM_BUFFER,
                        blockInfo: UBOGlobal.BLOCK,
                        buffer: globalUBO
                    });
                }
                if (!this._globalBindings.get(UBOShadow.BLOCK.name)) {
                    var shadowUBO = this._root.device.createBuffer({
                        usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                        size: UBOShadow.SIZE
                    });
                    this._globalBindings.set(UBOShadow.BLOCK.name, {
                        type: exports.GFXBindingType.UNIFORM_BUFFER,
                        blockInfo: UBOShadow.BLOCK,
                        buffer: shadowUBO
                    });
                }
                return this._globalBindings.get(UNIFORM_ENVIRONMENT.name) || this._globalBindings.set(UNIFORM_ENVIRONMENT.name, {
                    type: exports.GFXBindingType.SAMPLER,
                    samplerInfo: UNIFORM_ENVIRONMENT
                }), !0;
            }
        }, {
            key: "destroyUBOs",
            value: function destroyUBOs() {
                var globalUBO = this._globalBindings.get(UBOGlobal.BLOCK.name);
                globalUBO && (globalUBO.buffer.destroy(), this._globalBindings.delete(UBOGlobal.BLOCK.name));
                var shadowUBO = this._globalBindings.get(UBOShadow.BLOCK.name);
                shadowUBO && (shadowUBO.buffer.destroy(), this._globalBindings.delete(UBOShadow.BLOCK.name));
            }
        }, {
            key: "addVisibleModel",
            value: function addVisibleModel(model, camera) {
                var depth = 0;
                model.node && (Vec3.subtract(v3_1$5, model.node.worldPosition, camera.position), 
                depth = Vec3.dot(v3_1$5, camera.forward)), this._renderObjects.push({
                    model: model,
                    depth: depth
                });
            }
        }, {
            key: "activateFlow",
            value: function activateFlow(flow) {
                this._activeFlows.push(flow), this._activeFlows.sort((function(a, b) {
                    return a.priority - b.priority;
                }));
            }
        }, {
            key: "_getTextureFormat",
            value: function _getTextureFormat(format, usage) {
                return format === exports.GFXFormat.UNKNOWN ? usage & exports.GFXTextureUsageBit.COLOR_ATTACHMENT ? this._colorFmt : usage & exports.GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT ? this._depthStencilFmt : exports.GFXFormat.UNKNOWN : format;
            }
        } ]), RenderPipeline;
    }()).prototype, "_flows", [ _dec2$l ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$o = _applyDecoratedDescriptor(_class2$y.prototype, "renderTextures", [ _dec3$b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor3$h = _applyDecoratedDescriptor(_class2$y.prototype, "framebuffers", [ _dec4$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor4$b = _applyDecoratedDescriptor(_class2$y.prototype, "renderPasses", [ _dec5$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$E = _class2$y)) || _class$E);
    cc.RenderPipeline = RenderPipeline;
    var RenderPipelineAsset = (_dec$F = ccclass("cc.RenderPipelineAsset"), _dec2$m = property({
        type: RenderPipeline
    }), _dec$F((_descriptor$x = _applyDecoratedDescriptor((_class2$z = function(_Asset) {
        function RenderPipelineAsset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, RenderPipelineAsset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderPipelineAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "renderPipeline", _descriptor$x, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(RenderPipelineAsset, _Asset), RenderPipelineAsset;
    }(Asset)).prototype, "renderPipeline", [ _dec2$m ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$F = _class2$z)) || _class$F);
    cc.RenderPipelineAsset = RenderPipelineAsset, cc.textureUtil = textureUtil;
    var macro = {
        SUPPORT_TEXTURE_FORMATS: [ ".pkm", ".pvr", ".webp", ".jpg", ".jpeg", ".bmp", ".png" ],
        KEY: {
            none: 0,
            back: 6,
            menu: 18,
            backspace: 8,
            tab: 9,
            enter: 13,
            shift: 16,
            ctrl: 17,
            alt: 18,
            pause: 19,
            capslock: 20,
            escape: 27,
            space: 32,
            pageup: 33,
            pagedown: 34,
            end: 35,
            home: 36,
            left: 37,
            up: 38,
            right: 39,
            down: 40,
            select: 41,
            insert: 45,
            Delete: 46,
            0: 48,
            1: 49,
            2: 50,
            3: 51,
            4: 52,
            5: 53,
            6: 54,
            7: 55,
            8: 56,
            9: 57,
            a: 65,
            b: 66,
            c: 67,
            d: 68,
            e: 69,
            f: 70,
            g: 71,
            h: 72,
            i: 73,
            j: 74,
            k: 75,
            l: 76,
            m: 77,
            n: 78,
            o: 79,
            p: 80,
            q: 81,
            r: 82,
            s: 83,
            t: 84,
            u: 85,
            v: 86,
            w: 87,
            x: 88,
            y: 89,
            z: 90,
            num0: 96,
            num1: 97,
            num2: 98,
            num3: 99,
            num4: 100,
            num5: 101,
            num6: 102,
            num7: 103,
            num8: 104,
            num9: 105,
            "*": 106,
            "+": 107,
            "-": 109,
            numdel: 110,
            "/": 111,
            f1: 112,
            f2: 113,
            f3: 114,
            f4: 115,
            f5: 116,
            f6: 117,
            f7: 118,
            f8: 119,
            f9: 120,
            f10: 121,
            f11: 122,
            f12: 123,
            numlock: 144,
            scrolllock: 145,
            ";": 186,
            semicolon: 186,
            equal: 187,
            "=": 187,
            ",": 188,
            comma: 188,
            dash: 189,
            ".": 190,
            period: 190,
            forwardslash: 191,
            grave: 192,
            "[": 219,
            openbracket: 219,
            backslash: 220,
            "]": 221,
            closebracket: 221,
            quote: 222,
            dpadLeft: 1e3,
            dpadRight: 1001,
            dpadUp: 1003,
            dpadDown: 1004,
            dpadCenter: 1005
        },
        ImageFormat: cc.Enum({
            JPG: 0,
            PNG: 1,
            TIFF: 2,
            WEBP: 3,
            PVR: 4,
            ETC: 5,
            S3TC: 6,
            ATITC: 7,
            TGA: 8,
            RAWDATA: 9,
            UNKNOWN: 10
        }),
        RAD: Math.PI / 180,
        DEG: 180 / Math.PI,
        REPEAT_FOREVER: Number.MAX_VALUE - 1,
        FLT_EPSILON: 1.192092896e-7,
        MIN_ZINDEX: -Math.pow(2, 15),
        MAX_ZINDEX: Math.pow(2, 15) - 1,
        ORIENTATION_PORTRAIT: 1,
        ORIENTATION_LANDSCAPE: 2,
        ORIENTATION_AUTO: 3,
        DENSITYDPI_DEVICE: "device-dpi",
        DENSITYDPI_HIGH: "high-dpi",
        DENSITYDPI_MEDIUM: "medium-dpi",
        DENSITYDPI_LOW: "low-dpi",
        FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX: !0,
        DIRECTOR_STATS_POSITION: new Vec2(0, 0),
        ENABLE_STACKABLE_ACTIONS: !0,
        TOUCH_TIMEOUT: 5e3,
        BATCH_VERTEX_COUNT: 2e4,
        ENABLE_TILEDMAP_CULLING: !0,
        DOWNLOAD_MAX_CONCURRENT: 64,
        ENABLE_TRANSPARENT_CANVAS: !1,
        ENABLE_WEBGL_ANTIALIAS: !1,
        ENABLE_CULLING: !1,
        CLEANUP_IMAGE_CACHE: !1,
        SHOW_MESH_WIREFRAME: !1,
        ENABLE_MULTI_TOUCH: !0
    };
    cc.macro = macro;
    var RenderViewPriority, visibleRect = {
        topLeft: cc.v2(0, 0),
        topRight: cc.v2(0, 0),
        top: cc.v2(0, 0),
        bottomLeft: cc.v2(0, 0),
        bottomRight: cc.v2(0, 0),
        bottom: cc.v2(0, 0),
        center: cc.v2(0, 0),
        left: cc.v2(0, 0),
        right: cc.v2(0, 0),
        width: 0,
        height: 0,
        init: function init(visibleRect_) {
            var w = this.width = visibleRect_.width, h = this.height = visibleRect_.height, l = visibleRect_.x, b = visibleRect_.y, t = b + h, r = l + w;
            this.topLeft.x = l, this.topLeft.y = t, this.topRight.x = r, this.topRight.y = t, 
            this.top.x = l + w / 2, this.top.y = t, this.bottomLeft.x = l, this.bottomLeft.y = b, 
            this.bottomRight.x = r, this.bottomRight.y = b, this.bottom.x = l + w / 2, this.bottom.y = b, 
            this.center.x = l + w / 2, this.center.y = b + h / 2, this.left.x = l, this.left.y = b + h / 2, 
            this.right.x = r, this.right.y = b + h / 2;
        }
    };
    cc.visibleRect = visibleRect, function(RenderViewPriority) {
        RenderViewPriority[RenderViewPriority.GENERAL = 100] = "GENERAL";
    }(RenderViewPriority || (RenderViewPriority = {}));
    var LightType, RenderView = function() {
        function RenderView(root, camera) {
            _classCallCheck(this, RenderView), this._name = "", this._window = null, this._priority = 0, 
            this._visibility = CameraDefaultMask, this._isEnable = !1, this._flows = [], this._root = root, 
            this._camera = camera;
        }
        return _createClass(RenderView, [ {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "window",
            get: function get() {
                return this._window;
            },
            set: function set(val) {
                this._window = val;
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            },
            set: function set(val) {
                this._priority = val, cc.director.root && cc.director.root.sortViews();
            }
        }, {
            key: "visibility",
            set: function set(vis) {
                this._visibility = vis;
            },
            get: function get() {
                return this._visibility;
            }
        }, {
            key: "camera",
            get: function get() {
                return this._camera;
            }
        }, {
            key: "isEnable",
            get: function get() {
                return this._isEnable;
            }
        }, {
            key: "flows",
            get: function get() {
                return this._flows;
            }
        } ], [ {
            key: "registerCreateFunc",
            value: function registerCreateFunc(root) {
                root._createViewFun = function(_root, _camera) {
                    return new RenderView(_root, _camera);
                };
            }
        } ]), _createClass(RenderView, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._name = info.name, this.priority = info.priority, this.setExecuteFlows(info.flows), 
                !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._window = null, this._priority = 0;
            }
        }, {
            key: "enable",
            value: function enable(isEnable) {
                this._isEnable = isEnable;
            }
        }, {
            key: "setExecuteFlows",
            value: function setExecuteFlows(flows) {
                if (this.flows.length = 0, flows && 1 === flows.length && "UIFlow" === flows[0]) this._flows.push(cc.director.root.pipeline.getFlow("UIFlow")); else {
                    var _iterator = cc.director.root.pipeline.activeFlows, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var f = _ref;
                        (f.type === RenderFlowType.SCENE || flows && -1 !== flows.indexOf(f.name)) && this.flows.push(f);
                    }
                }
            }
        } ]), RenderView;
    }();
    function ColorTemperatureToRGB(rgb, kelvin) {
        kelvin < 1e3 ? kelvin = 1e3 : kelvin > 15e3 && (kelvin = 15e3);
        var kSqr = kelvin * kelvin, u = (.860117757 + .000154118254 * kelvin + 1.28641212e-7 * kSqr) / (1 + .000842420235 * kelvin + 7.08145163e-7 * kSqr), v = (.317398726 + 422806245e-13 * kelvin + 4.20481691e-8 * kSqr) / (1 - 289741816e-13 * kelvin + 1.61456053e-7 * kSqr), d = 2 * u - 8 * v + 4, x = 3 * u / d, y = 2 * v / d, X = 1 / y * x, Z = 1 / y * (1 - x - y);
        rgb.x = 3.2404542 * X - 1.5371385 + -.4985314 * Z, rgb.y = -.969266 * X + 1.8760108 + .041556 * Z, 
        rgb.z = .0556434 * X - .2040259 + 1.0572252 * Z;
    }
    !function(LightType) {
        LightType[LightType.DIRECTIONAL = 0] = "DIRECTIONAL", LightType[LightType.SPHERE = 1] = "SPHERE", 
        LightType[LightType.SPOT = 2] = "SPOT", LightType[LightType.UNKNOWN = 3] = "UNKNOWN";
    }(LightType || (LightType = {}));
    var nt2lm = function nt2lm(size) {
        return 4 * Math.PI * Math.PI * size * size;
    }, Light = function() {
        function Light() {
            _classCallCheck(this, Light), this._color = new Vec3(1, 1, 1), this._useColorTemp = !1, 
            this._colorTemp = 6550, this._colorTempRGB = new Vec3(1, 1, 1), this._scene = null, 
            this._node = null, this._name = null, this._type = LightType.UNKNOWN;
        }
        return _createClass(Light, [ {
            key: "color",
            set: function set(color) {
                this._color.set(color);
            },
            get: function get() {
                return this._color;
            }
        }, {
            key: "useColorTemperature",
            set: function set(enable) {
                this._useColorTemp = enable;
            },
            get: function get() {
                return this._useColorTemp;
            }
        }, {
            key: "colorTemperature",
            set: function set(val) {
                this._colorTemp = val, ColorTemperatureToRGB(this._colorTempRGB, this._colorTemp);
            },
            get: function get() {
                return this._colorTemp;
            }
        }, {
            key: "colorTemperatureRGB",
            get: function get() {
                return this._colorTempRGB;
            }
        }, {
            key: "node",
            set: function set(n) {
                this._node = n, this._node && (this._node.hasChangedFlags = TransformBit.ROTATION);
            },
            get: function get() {
                return this._node;
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "scene",
            get: function get() {
                return this._scene;
            }
        } ]), _createClass(Light, [ {
            key: "initialize",
            value: function initialize(name, node) {
                this._name = name, this._type = LightType.UNKNOWN, this._node = node;
            }
        }, {
            key: "attachToScene",
            value: function attachToScene(scene) {
                this._scene = scene;
            }
        }, {
            key: "detachFromScene",
            value: function detachFromScene() {
                this._scene = null;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._name = null, this._type = LightType.UNKNOWN, this._node = null;
            }
        }, {
            key: "update",
            value: function update() {}
        } ]), Light;
    }();
    function cullSphereLight(light, model) {
        return !(!model.worldBounds || intersect.aabb_aabb(model.worldBounds, light.aabb));
    }
    function cullSpotLight(light, model) {
        return !(!model.worldBounds || intersect.aabb_aabb(model.worldBounds, light.aabb) && intersect.aabb_frustum(model.worldBounds, light.frustum));
    }
    (lightFrustum = new frustum).accurate = !0;
    var lightFrustum, ForwardStagePriority, ForwardFlowPriority, calcDirectionalLightCullFrustum = function() {
        var lightPos = new Vec3, lightViewCenter = new Vec3, lightRot = new Quat, camFrustum = new frustum;
        camFrustum.accurate = !0;
        var lightViewMat = new Mat4, lightVeiwMatInv = new Mat4, minBoxCorner = new Vec3, maxBoxCorner = new Vec3;
        return function(out, sceneCamera, light, near, far, nearBias) {
            Mat4.fromRT(lightViewMat, light.node.getWorldRotation(lightRot), sceneCamera.node.getWorldPosition(lightPos)), 
            Mat4.invert(lightVeiwMatInv, lightViewMat), sceneCamera.getSplitFrustum(camFrustum, near, far), 
            camFrustum.transform(lightVeiwMatInv), Vec3.set(minBoxCorner, camFrustum.vertices[0].x, camFrustum.vertices[0].y, camFrustum.vertices[0].z), 
            Vec3.copy(maxBoxCorner, minBoxCorner);
            for (var i = 1; i < camFrustum.vertices.length; i++) minBoxCorner.x = Math.min(minBoxCorner.x, camFrustum.vertices[i].x), 
            minBoxCorner.y = Math.min(minBoxCorner.y, camFrustum.vertices[i].y), minBoxCorner.z = Math.min(minBoxCorner.z, camFrustum.vertices[i].z), 
            maxBoxCorner.x = Math.max(maxBoxCorner.x, camFrustum.vertices[i].x), maxBoxCorner.y = Math.max(maxBoxCorner.y, camFrustum.vertices[i].y), 
            maxBoxCorner.z = Math.max(maxBoxCorner.z, camFrustum.vertices[i].z);
            Vec3.set(lightViewCenter, (minBoxCorner.x + maxBoxCorner.x) / 2, (minBoxCorner.y + maxBoxCorner.y) / 2, maxBoxCorner.z), 
            lightViewCenter.z += nearBias, Vec3.transformMat4(lightPos, lightViewCenter, lightViewMat), 
            Mat4.fromRT(lightViewMat, light.node.getWorldRotation(lightRot), lightPos), frustum.createOrtho(out, maxBoxCorner.x - minBoxCorner.x, maxBoxCorner.y - minBoxCorner.y, 0, minBoxCorner.z - nearBias - maxBoxCorner.z, lightViewMat);
        };
    }();
    !function(ForwardStagePriority) {
        ForwardStagePriority[ForwardStagePriority.FORWARD = 0] = "FORWARD";
    }(ForwardStagePriority || (ForwardStagePriority = {})), function(ForwardFlowPriority) {
        ForwardFlowPriority[ForwardFlowPriority.FORWARD = 0] = "FORWARD", ForwardFlowPriority[ForwardFlowPriority.UI = 10] = "UI";
    }(ForwardFlowPriority || (ForwardFlowPriority = {}));
    var bufs$1 = [], colors = [], UIStage = function(_RenderStage) {
        function UIStage() {
            return _classCallCheck(this, UIStage), _possibleConstructorReturn(this, _getPrototypeOf(UIStage).call(this));
        }
        return _inherits(UIStage, _RenderStage), _createClass(UIStage, [ {
            key: "activate",
            value: function activate(flow) {
                _get(_getPrototypeOf(UIStage.prototype), "activate", this).call(this, flow), this._cmdBuff = this._device.createCommandBuffer({
                    allocator: this._device.commandAllocator,
                    type: exports.GFXCommandBufferType.PRIMARY
                });
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
            }
        }, {
            key: "resize",
            value: function resize(width, height) {}
        }, {
            key: "rebuild",
            value: function rebuild() {}
        }, {
            key: "render",
            value: function render(view) {
                this._renderQueues[0].clear();
                var _iterator = this._pipeline.renderObjects, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    for (var ro = _ref, i = 0; i < ro.model.subModelNum; i++) for (var j = 0; j < ro.model.getSubModel(i).passes.length; j++) this._renderQueues[0].insertRenderPass(ro, i, j);
                }
                this._renderQueues[0].sort();
                var framebuffer = view.window.framebuffer, cmdBuff = this._cmdBuff, camera = view.camera, vp = camera.viewport;
                this._renderArea.x = vp.x * camera.width, this._renderArea.y = vp.y * camera.height, 
                this._renderArea.width = vp.width * camera.width, this._renderArea.height = vp.height * camera.height, 
                colors[0] = camera.clearColor, cmdBuff.begin(), cmdBuff.beginRenderPass(framebuffer, this._renderArea, camera.clearFlag, [ camera.clearColor ], camera.clearDepth, camera.clearStencil), 
                cmdBuff.execute(this._renderQueues[0].cmdBuffs.array, this._renderQueues[0].cmdBuffCount), 
                cmdBuff.endRenderPass(), cmdBuff.end(), bufs$1[0] = cmdBuff, this._device.queue.submit(bufs$1);
            }
        } ]), UIStage;
    }(RenderStage);
    UIStage.initInfo = {
        name: "UIStage",
        priority: 0,
        renderQueues: [ {
            isTransparent: !0,
            stages: [ "default" ],
            sortMode: RenderQueueSortMode.BACK_TO_FRONT
        } ],
        framebuffer: "window"
    };
    var UIFlow = function(_RenderFlow) {
        function UIFlow() {
            return _classCallCheck(this, UIFlow), _possibleConstructorReturn(this, _getPrototypeOf(UIFlow).call(this));
        }
        return _inherits(UIFlow, _RenderFlow), _createClass(UIFlow, [ {
            key: "initialize",
            value: function initialize(info) {
                _get(_getPrototypeOf(UIFlow.prototype), "initialize", this).call(this, info);
                var uiStage = new UIStage;
                return uiStage.initialize(UIStage.initInfo), this._stages.push(uiStage), !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.destroyStages();
            }
        }, {
            key: "rebuild",
            value: function rebuild() {}
        }, {
            key: "render",
            value: function render(view) {
                view.camera.update(), this.pipeline.sceneCulling(view), this.pipeline.updateUBOs(view);
                var isHDR = this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2];
                this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2] = 0, this.pipeline.globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this.pipeline.defaultGlobalUBOData.buffer), 
                _get(_getPrototypeOf(UIFlow.prototype), "render", this).call(this, view), this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2] = isHDR, 
                this.pipeline.globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this.pipeline.defaultGlobalUBOData.buffer);
            }
        } ]), UIFlow;
    }(RenderFlow);
    UIFlow.initInfo = {
        name: "UIFlow",
        priority: ForwardFlowPriority.UI,
        type: RenderFlowType.UI
    };
    var _class$G, _class2$A, _temp$B, _class$H, _class2$B, _temp$C, _class$I, _class2$C, _temp$D, _class$J, _class2$D, _temp$E, _class$K, _class2$E, _temp$F, RenderBatchedQueue = function() {
        function RenderBatchedQueue() {
            _classCallCheck(this, RenderBatchedQueue), this.queue = new Set;
        }
        return _createClass(RenderBatchedQueue, [ {
            key: "clear",
            value: function clear() {
                var _iterator = this.queue.values(), _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.clear();
                }
                this.queue.clear();
            }
        }, {
            key: "recordCommandBuffer",
            value: function recordCommandBuffer(cmdBuff) {
                var _iterator2 = this.queue.values(), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    for (var batchedBuffer = _ref2, boundPSO = !1, b = 0; b < batchedBuffer.batches.length; ++b) {
                        var batch = batchedBuffer.batches[b];
                        if (batch.mergeCount) {
                            for (var v = 0; v < batch.vbs.length; ++v) batch.vbs[v].update(batch.vbDatas[v]);
                            batch.vbIdx.update(batch.vbIdxData.buffer), batch.ubo.update(batch.uboData.view), 
                            boundPSO || (cmdBuff.bindPipelineState(batch.pso), boundPSO = !0), cmdBuff.bindBindingLayout(batch.pso.pipelineLayout.layouts[0]), 
                            cmdBuff.bindInputAssembler(batch.ia), cmdBuff.draw(batch.ia);
                        }
                    }
                }
            }
        } ]), RenderBatchedQueue;
    }(), colors$1 = [ {
        r: 0,
        g: 0,
        b: 0,
        a: 1
    } ], bufs$2 = [], ForwardStage = ccclass("ForwardStage")((_temp$B = _class2$A = function(_RenderStage) {
        function ForwardStage() {
            var _this;
            return _classCallCheck(this, ForwardStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ForwardStage).call(this)))._opaqueBatchedQueue = new RenderBatchedQueue, 
            _this;
        }
        return _inherits(ForwardStage, _RenderStage), _createClass(ForwardStage, [ {
            key: "activate",
            value: function activate(flow) {
                _get(_getPrototypeOf(ForwardStage.prototype), "activate", this).call(this, flow), 
                this.createCmdBuffer();
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
            }
        }, {
            key: "resize",
            value: function resize(width, height) {}
        }, {
            key: "rebuild",
            value: function rebuild() {}
        }, {
            key: "render",
            value: function render(view) {
                this._opaqueBatchedQueue.clear(), this._renderQueues.forEach(this.renderQueueClearFunc);
                for (var renderObjects = this._pipeline.renderObjects, i = 0; i < renderObjects.length; ++i) {
                    var ro = renderObjects[i];
                    if (ro.model.isDynamicBatching) for (var m = 0; m < ro.model.subModelNum; ++m) for (var subModel = ro.model.subModels[m], passes = subModel.passes, p = 0; p < passes.length; ++p) {
                        var pass = passes[p], pso = subModel.psos[p];
                        if (pass.batchedBuffer) pass.batchedBuffer.merge(subModel, ro, pso), this._opaqueBatchedQueue.queue.add(pass.batchedBuffer); else for (var k = 0; k < this._renderQueues.length; k++) this._renderQueues[k].insertRenderPass(ro, m, p);
                    } else for (var _m = 0; _m < ro.model.subModelNum; _m++) for (var _p = 0; _p < ro.model.getSubModel(_m).passes.length; _p++) for (var _k = 0; _k < this._renderQueues.length; _k++) this._renderQueues[_k].insertRenderPass(ro, _m, _p);
                }
                this._renderQueues.forEach(this.renderQueueSortFunc);
                var camera = view.camera, cmdBuff = this._cmdBuff, vp = camera.viewport;
                if (this._renderArea.x = vp.x * camera.width, this._renderArea.y = vp.y * camera.height, 
                this._renderArea.width = vp.width * camera.width * this.pipeline.shadingScale, this._renderArea.height = vp.height * camera.height * this.pipeline.shadingScale, 
                camera.clearFlag & exports.GFXClearFlag.COLOR) if (this._pipeline.isHDR) {
                    !function SRGBToLinear(out, gamma) {
                        out.r = gamma.r * gamma.r, out.g = gamma.g * gamma.g, out.b = gamma.b * gamma.b;
                    }(colors$1[0], camera.clearColor);
                    var scale = this._pipeline.fpScale / camera.exposure;
                    colors$1[0].r *= scale, colors$1[0].g *= scale, colors$1[0].b *= scale;
                } else colors$1[0].r = camera.clearColor.r, colors$1[0].g = camera.clearColor.g, 
                colors$1[0].b = camera.clearColor.b;
                colors$1[0].a = camera.clearColor.a, this._pipeline.usePostProcess ? this._pipeline.useMSAA ? this._framebuffer = this._pipeline.getFrameBuffer("msaa") : this._framebuffer = this._pipeline.getFrameBuffer(this._pipeline.currShading) : this._framebuffer = view.window.framebuffer;
                var planarShadow = camera.scene.planarShadows;
                cmdBuff.begin(), cmdBuff.beginRenderPass(this._framebuffer, this._renderArea, camera.clearFlag, colors$1, camera.clearDepth, camera.clearStencil), 
                cmdBuff.execute(this._renderQueues[0].cmdBuffs.array, this._renderQueues[0].cmdBuffCount), 
                this._opaqueBatchedQueue.recordCommandBuffer(cmdBuff), camera.visibility & Layers.BitMask.DEFAULT && cmdBuff.execute(planarShadow.cmdBuffs.array, planarShadow.cmdBuffCount), 
                cmdBuff.execute(this._renderQueues[1].cmdBuffs.array, this._renderQueues[1].cmdBuffCount), 
                cmdBuff.endRenderPass(), cmdBuff.end(), bufs$2[0] = cmdBuff, this._device.queue.submit(bufs$2), 
                this._pipeline.useMSAA && this._device.blitFramebuffer(this._framebuffer, this._pipeline.getFrameBuffer(this._pipeline.currShading), this._renderArea, this._renderArea, exports.GFXFilter.POINT);
            }
        } ]), ForwardStage;
    }(RenderStage), _class2$A.initInfo = {
        name: "ForwardStage",
        priority: ForwardStagePriority.FORWARD,
        renderQueues: [ {
            isTransparent: !1,
            sortMode: RenderQueueSortMode.FRONT_TO_BACK,
            stages: [ "default" ]
        }, {
            isTransparent: !0,
            sortMode: RenderQueueSortMode.BACK_TO_FRONT,
            stages: [ "default", "planarShadow" ]
        } ]
    }, _class$G = _temp$B)) || _class$G, ForwardFlow = ccclass("ForwardFlow")((_temp$C = _class2$B = function(_RenderFlow) {
        function ForwardFlow() {
            return _classCallCheck(this, ForwardFlow), _possibleConstructorReturn(this, _getPrototypeOf(ForwardFlow).call(this));
        }
        return _inherits(ForwardFlow, _RenderFlow), _createClass(ForwardFlow, [ {
            key: "initialize",
            value: function initialize(info) {
                _get(_getPrototypeOf(ForwardFlow.prototype), "initialize", this).call(this, info);
                var forwardStage = new ForwardStage;
                forwardStage.initialize(ForwardStage.initInfo), this._stages.push(forwardStage);
            }
        }, {
            key: "render",
            value: function render(view) {
                view.camera.update(), this.pipeline.sceneCulling(view), this.pipeline.updateUBOs(view), 
                _get(_getPrototypeOf(ForwardFlow.prototype), "render", this).call(this, view);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.destroyStages();
            }
        }, {
            key: "rebuild",
            value: function rebuild() {}
        } ]), ForwardFlow;
    }(RenderFlow), _class2$B.initInfo = {
        name: "ForwardFlow",
        priority: ForwardFlowPriority.FORWARD
    }, _class$H = _temp$C)) || _class$H, _vec4Array = new Float32Array(4), _sphere = sphere.create(0, 0, 0, 1), _tempLightIndex = [], _tempLightDist = [], _tempVec3 = new Vec3, ForwardPipeline = ccclass("ForwardPipeline")((_temp$D = _class2$C = function(_RenderPipeline) {
        function ForwardPipeline() {
            var _this;
            return _classCallCheck(this, ForwardPipeline), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ForwardPipeline).call(this)))._uboLights = new UBOForwardLight, 
            _this._lightsUBO = null, _this._validLights = [], _this._lightIndexOffset = [], 
            _this._lightIndices = [], _this;
        }
        return _inherits(ForwardPipeline, _RenderPipeline), _createClass(ForwardPipeline, [ {
            key: "lightsUBO",
            get: function get() {
                return this._lightsUBO;
            }
        } ]), _createClass(ForwardPipeline, [ {
            key: "initialize",
            value: function initialize(info) {
                _get(_getPrototypeOf(ForwardPipeline.prototype), "initialize", this).call(this, info);
                var forwardFlow = new ForwardFlow;
                forwardFlow.initialize(ForwardFlow.initInfo), this._flows.push(forwardFlow);
            }
        }, {
            key: "activate",
            value: function activate(root) {
                if (!_get(_getPrototypeOf(ForwardPipeline.prototype), "activate", this).call(this, root)) return !1;
                this._usePostProcess && (this._useSMAA, this.getFlow("ToneMapFlow").activate(this));
                var uiFlow = new UIFlow;
                return uiFlow.initialize(UIFlow.initInfo), this._flows.push(uiFlow), uiFlow.activate(this), 
                !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var lightsUBO = this._globalBindings.get(UBOForwardLight.BLOCK.name);
                lightsUBO && (lightsUBO.buffer.destroy(), this._globalBindings.delete(UBOForwardLight.BLOCK.name)), 
                this._destroy();
            }
        }, {
            key: "rebuild",
            value: function rebuild() {
                _get(_getPrototypeOf(ForwardPipeline.prototype), "rebuild", this).call(this);
                for (var i = 0; i < this._flows.length; i++) this._flows[i].rebuild();
            }
        }, {
            key: "updateUBOs",
            value: function updateUBOs(view) {
                _get(_getPrototypeOf(ForwardPipeline.prototype), "updateUBOs", this).call(this, view);
                for (var exposure = view.camera.exposure, i = 0; i < this._renderObjects.length; i++) {
                    this._uboLights.view.fill(0);
                    var nextLightIndex = i + 1 < this._renderObjects.length ? this._lightIndexOffset[i + 1] : this._lightIndices.length;
                    if (this._renderObjects[i].model.localBindings.get(UBOForwardLight.BLOCK.name)) {
                        for (var sphereNum = 0, spotNum = 0, l = this._lightIndexOffset[i]; l < nextLightIndex; l++) {
                            var light = this._validLights[this._lightIndices[l]];
                            if (light) switch (light.type) {
                              case LightType.SPHERE:
                                if (sphereNum >= UBOForwardLight.MAX_SPHERE_LIGHTS) continue;
                                var sphereLit = light;
                                if (Vec3.toArray(_vec4Array, sphereLit.position), this._uboLights.view.set(_vec4Array, UBOForwardLight.SPHERE_LIGHT_POS_OFFSET + 4 * sphereNum), 
                                _vec4Array[0] = sphereLit.size, _vec4Array[1] = sphereLit.range, _vec4Array[2] = 0, 
                                this._uboLights.view.set(_vec4Array, UBOForwardLight.SPHERE_LIGHT_SIZE_RANGE_OFFSET + 4 * sphereNum), 
                                Vec3.toArray(_vec4Array, light.color), light.useColorTemperature) {
                                    var tempRGB = light.colorTemperatureRGB;
                                    _vec4Array[0] *= tempRGB.x, _vec4Array[1] *= tempRGB.y, _vec4Array[2] *= tempRGB.z;
                                }
                                this._isHDR ? _vec4Array[3] = sphereLit.luminance * this._fpScale * this._lightMeterScale : _vec4Array[3] = sphereLit.luminance * exposure * this._lightMeterScale, 
                                this._uboLights.view.set(_vec4Array, UBOForwardLight.SPHERE_LIGHT_COLOR_OFFSET + 4 * sphereNum), 
                                sphereNum++;
                                break;

                              case LightType.SPOT:
                                if (spotNum >= UBOForwardLight.MAX_SPOT_LIGHTS) continue;
                                var spotLit = light;
                                if (Vec3.toArray(_vec4Array, spotLit.position), _vec4Array[3] = spotLit.size, this._uboLights.view.set(_vec4Array, UBOForwardLight.SPOT_LIGHT_POS_OFFSET + 4 * spotNum), 
                                _vec4Array[0] = spotLit.size, _vec4Array[1] = spotLit.range, _vec4Array[2] = spotLit.spotAngle, 
                                this._uboLights.view.set(_vec4Array, UBOForwardLight.SPOT_LIGHT_SIZE_RANGE_ANGLE_OFFSET + 4 * spotNum), 
                                Vec3.toArray(_vec4Array, spotLit.direction), this._uboLights.view.set(_vec4Array, UBOForwardLight.SPOT_LIGHT_DIR_OFFSET + 4 * spotNum), 
                                Vec3.toArray(_vec4Array, light.color), light.useColorTemperature) {
                                    var _tempRGB = light.colorTemperatureRGB;
                                    _vec4Array[0] *= _tempRGB.x, _vec4Array[1] *= _tempRGB.y, _vec4Array[2] *= _tempRGB.z;
                                }
                                this._isHDR ? _vec4Array[3] = spotLit.luminance * this._fpScale * this._lightMeterScale : _vec4Array[3] = spotLit.luminance * exposure * this._lightMeterScale, 
                                this._uboLights.view.set(_vec4Array, UBOForwardLight.SPOT_LIGHT_COLOR_OFFSET + 4 * spotNum), 
                                spotNum++;
                            }
                        }
                        this._renderObjects[i].model.localBindings.get(UBOForwardLight.BLOCK.name).buffer.update(this._uboLights.view);
                    }
                }
            }
        }, {
            key: "sceneCulling",
            value: function sceneCulling(view) {
                _get(_getPrototypeOf(ForwardPipeline.prototype), "sceneCulling", this).call(this, view), 
                this._validLights.length = 0;
                for (var sphereLights = view.camera.scene.sphereLights, i = 0; i < sphereLights.length; i++) {
                    var light = sphereLights[i];
                    light.update(), sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range), 
                    intersect.sphere_frustum(_sphere, view.camera.frustum) && this._validLights.push(light);
                }
                for (var spotLights = view.camera.scene.spotLights, _i = 0; _i < spotLights.length; _i++) {
                    var _light = spotLights[_i];
                    _light.update(), sphere.set(_sphere, _light.position.x, _light.position.y, _light.position.z, _light.range), 
                    intersect.sphere_frustum(_sphere, view.camera.frustum) && this._validLights.push(_light);
                }
                this._lightIndexOffset.length = 0, this._lightIndices.length = 0;
                for (var _i2 = 0; _i2 < this._renderObjects.length; _i2++) this._lightIndexOffset[_i2] = this._lightIndices.length, 
                this._renderObjects[_i2].model.localBindings.get(UBOForwardLight.BLOCK.name) && this.cullLightPerModel(this._renderObjects[_i2].model);
            }
        }, {
            key: "createUBOs",
            value: function createUBOs() {
                if (!this._globalBindings.get(UBOForwardLight.BLOCK.name)) {
                    var lightsUBO = this._root.device.createBuffer({
                        usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                        size: UBOForwardLight.SIZE
                    });
                    if (!lightsUBO) return !1;
                    this._globalBindings.set(UBOForwardLight.BLOCK.name, {
                        type: exports.GFXBindingType.UNIFORM_BUFFER,
                        blockInfo: UBOForwardLight.BLOCK,
                        buffer: lightsUBO
                    });
                }
                return _get(_getPrototypeOf(ForwardPipeline.prototype), "createUBOs", this).call(this);
            }
        }, {
            key: "cullLightPerModel",
            value: function cullLightPerModel(model) {
                _tempLightIndex.length = 0;
                for (var i = 0; i < this._validLights.length; i++) {
                    var isCulled = !1;
                    switch (this._validLights[i].type) {
                      case LightType.DIRECTIONAL:
                        this._validLights[i], isCulled = !1;
                        break;

                      case LightType.SPHERE:
                        isCulled = cullSphereLight(this._validLights[i], model);
                        break;

                      case LightType.SPOT:
                        isCulled = cullSpotLight(this._validLights[i], model);
                    }
                    isCulled || (_tempLightIndex.push(i), this._validLights[i].type === LightType.DIRECTIONAL ? _tempLightDist[i] = 0 : _tempLightDist[i] = Vec3.distance(this._validLights[i].position, model.node.getWorldPosition(_tempVec3)));
                }
                _tempLightIndex.sort(this.sortLight), Array.prototype.push.apply(this._lightIndices, _tempLightIndex);
            }
        }, {
            key: "sortLight",
            value: function sortLight(a, b) {
                return _tempLightDist[a] - _tempLightDist[b];
            }
        } ]), ForwardPipeline;
    }(RenderPipeline), _class2$C.initInfo = {}, _class$I = _temp$D)) || _class$I, bufs$3 = [], ToneMapStage = ccclass("ToneMapStage")((_temp$E = _class2$D = function(_RenderStage) {
        function ToneMapStage() {
            var _this;
            return _classCallCheck(this, ToneMapStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ToneMapStage).call(this)))._hTexSampler = 0, 
            _this._hBlendTexSampler = 0, _this._bindingLayout = null, _this;
        }
        return _inherits(ToneMapStage, _RenderStage), _createClass(ToneMapStage, [ {
            key: "activate",
            value: function activate(flow) {
                _get(_getPrototypeOf(ToneMapStage.prototype), "activate", this).call(this, flow), 
                this._createCmdBuffer(), this.rebuild();
            }
        }, {
            key: "_createCmdBuffer",
            value: function _createCmdBuffer() {
                this._cmdBuff = this._device.createCommandBuffer({
                    allocator: this._device.commandAllocator,
                    type: exports.GFXCommandBufferType.PRIMARY
                });
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
            }
        }, {
            key: "resize",
            value: function resize(width, height) {}
        }, {
            key: "rebuild",
            value: function rebuild() {
                this._pass = this._flow.material.passes[0], this._hTexSampler = this._pass.getBinding("u_texSampler");
                var globalUBO = this._pipeline.globalBindings.get(UBOGlobal.BLOCK.name);
                this._pso = this._pass.createPipelineState(), this._bindingLayout = this._pso.pipelineLayout.layouts[0], 
                this._pass.bindBuffer(UBOGlobal.BLOCK.binding, globalUBO.buffer), this._pass.bindTextureView(this._hTexSampler, this._pipeline.getTextureView(this._pipeline.currShading)), 
                this._pipeline.useSMAA && (this._hBlendTexSampler = this._pass.getBinding("u_blendTexSampler"), 
                this._pass.bindTextureView(this._hBlendTexSampler, this._pipeline.getTextureView("smaaBlend"))), 
                this._pass.update(), this._bindingLayout.update();
            }
        }, {
            key: "render",
            value: function render(view) {
                var camera = view.camera;
                if (this._cmdBuff) {
                    this._renderArea.width = camera.width, this._renderArea.height = camera.height;
                    var framebuffer = view.window.framebuffer;
                    this._cmdBuff.begin(), this._cmdBuff.beginRenderPass(framebuffer, this._renderArea, exports.GFXClearFlag.ALL, [ {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    } ], 1, 0), this._cmdBuff.bindPipelineState(this._pso), this._cmdBuff.bindBindingLayout(this._pso.pipelineLayout.layouts[0]), 
                    this._cmdBuff.bindInputAssembler(this._pipeline.quadIA), this._cmdBuff.draw(this._pipeline.quadIA), 
                    this._cmdBuff.endRenderPass(), this._cmdBuff.end();
                }
                bufs$3[0] = this._cmdBuff, this._device.queue.submit(bufs$3);
            }
        } ]), ToneMapStage;
    }(RenderStage), _class2$D.initInfo = {
        name: "ToneMapStage",
        priority: 0,
        framebuffer: "window"
    }, _class$J = _temp$E)) || _class$J;
    ccclass("ToneMapFlow")((_temp$F = _class2$E = function(_RenderFlow) {
        function ToneMapFlow() {
            return _classCallCheck(this, ToneMapFlow), _possibleConstructorReturn(this, _getPrototypeOf(ToneMapFlow).call(this));
        }
        return _inherits(ToneMapFlow, _RenderFlow), _createClass(ToneMapFlow, [ {
            key: "initialize",
            value: function initialize(info) {
                _get(_getPrototypeOf(ToneMapFlow.prototype), "initialize", this).call(this, info), 
                this._material.recompileShaders({
                    CC_USE_SMAA: this._pipeline.useSMAA
                });
                var toneStage = new ToneMapStage;
                return toneStage.initialize(ToneMapStage.initInfo), this._stages.push(toneStage), 
                !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._material && this._material.destroy(), this.destroyStages();
            }
        }, {
            key: "rebuild",
            value: function rebuild() {
                this._material && this._material.recompileShaders({
                    CC_USE_SMAA: this._pipeline.useSMAA
                });
                var _iterator = this._stages, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.rebuild();
                }
            }
        } ]), ToneMapFlow;
    }(RenderFlow), _class2$E.initInfo = {
        name: "ToneMapFlow",
        priority: ForwardFlowPriority.FORWARD + 1
    }, _class$K = _temp$F));
    cc.RenderPassStage = exports.RenderPassStage;
    var Game = function(_EventTarget) {
        function Game() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Game);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Game)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).frame = null, 
            _this.container = null, _this.canvas = null, _this.renderType = -1, _this.eventTargetOn = _get(_getPrototypeOf(Game.prototype), "on", _assertThisInitialized(_this)), 
            _this.eventTargetOnce = _get(_getPrototypeOf(Game.prototype), "once", _assertThisInitialized(_this)), 
            _this.config = {}, _this.onStart = null, _this._persistRootNodes = {}, _this._paused = !0, 
            _this._configLoaded = !1, _this._isCloning = !1, _this._prepared = !1, _this._rendererInitialized = !1, 
            _this._gfxDevice = null, _this._intervalId = null, _this._lastTime = null, _this._frameTime = null, 
            _this._sceneInfos = [], _this.collisionMatrix = [], _this.groupList = [], _this;
        }
        return _inherits(Game, _EventTarget), _createClass(Game, [ {
            key: "setFrameRate",
            value: function setFrameRate(frameRate) {
                var config = this.config;
                "number" != typeof frameRate && (frameRate = parseInt(frameRate), isNaN(frameRate) && (frameRate = 60)), 
                config.frameRate = frameRate, this._intervalId && window.cancelAnimationFrame(this._intervalId), 
                this._intervalId = 0, this._paused = !0, this._setAnimFrame(), this._runMainLoop();
            }
        }, {
            key: "getFrameRate",
            value: function getFrameRate() {
                return this.config.frameRate || 0;
            }
        }, {
            key: "step",
            value: function step() {
                cc.director.mainLoop();
            }
        }, {
            key: "pause",
            value: function pause() {
                if (!this._paused) {
                    this._paused = !0, this._intervalId && (window.cancelAnimationFrame(this._intervalId), 
                    this._intervalId = 0);
                    var swapbuffers = 3;
                    window.requestAnimationFrame((function cb() {
                        --swapbuffers > 1 && window.requestAnimationFrame(cb);
                        var root = cc.director.root;
                        root.frameMove(0), root.device.present();
                    }));
                }
            }
        }, {
            key: "resume",
            value: function resume() {
                this._paused && (this._paused = !1, this._runMainLoop());
            }
        }, {
            key: "isPaused",
            value: function isPaused() {
                return this._paused;
            }
        }, {
            key: "restart",
            value: function restart() {
                cc.director.once(cc.Director.EVENT_AFTER_DRAW, (function() {
                    for (var id in cc.game._persistRootNodes) cc.game.removePersistRootNode(cc.game._persistRootNodes[id]);
                    cc.director.getScene().destroy(), cc.Object._deferredDestroy(), cc.director.purgeDirector(), 
                    cc.director.reset(), cc.game.onStart();
                }));
            }
        }, {
            key: "end",
            value: function end() {
                this._gfxDevice && (this._gfxDevice.destroy(), this._gfxDevice = null), close();
            }
        }, {
            key: "on",
            value: function on(type, callback, target) {
                this._prepared && type === Game.EVENT_ENGINE_INITED ? callback.call(target) : this.eventTargetOn(type, callback, target);
            }
        }, {
            key: "once",
            value: function once(type, callback, target) {
                this._prepared && type === Game.EVENT_ENGINE_INITED ? callback.call(target) : this.eventTargetOnce(type, callback, target);
            }
        }, {
            key: "run",
            value: function run(config, onStart) {
                this._initConfig(config), this.onStart = onStart, this.prepare(cc.game.onStart && cc.game.onStart.bind(cc.game));
            }
        }, {
            key: "addPersistRootNode",
            value: function addPersistRootNode(node) {
                if (cc.Node.isNode(node) && node.uuid) {
                    var id = node.uuid;
                    if (!this._persistRootNodes[id]) {
                        var scene = cc.director._scene;
                        if (cc.isValid(scene)) if (node.parent) {
                            if (!(node.parent instanceof cc.Scene)) return void warnID(3801);
                            if (node.parent !== scene) return void warnID(3802);
                        } else node.parent = scene;
                        this._persistRootNodes[id] = node, node._persistNode = !0;
                    }
                } else warnID(3800);
            }
        }, {
            key: "removePersistRootNode",
            value: function removePersistRootNode(node) {
                var id = node.uuid || "";
                node === this._persistRootNodes[id] && (delete this._persistRootNodes[id], node._persistNode = !1);
            }
        }, {
            key: "isPersistRootNode",
            value: function isPersistRootNode(node) {
                return node._persistNode;
            }
        }, {
            key: "prepare",
            value: function prepare(cb) {
                var _this2 = this;
                if (this._prepared) cb && cb(); else {
                    this._initEngine((function start() {
                        _this2._setAnimFrame(), _this2._runMainLoop(), _this2.emit(Game.EVENT_GAME_INITED), 
                        cb && cb();
                    }));
                }
            }
        }, {
            key: "_initEngine",
            value: function _initEngine(cb) {
                var _this3 = this;
                this._initRenderer(), this._initEvents(), console.log("Cocos Creator 3D v" + cc.ENGINE_VERSION), 
                this.emit(Game.EVENT_ENGINE_INITED), this._prepared = !0;
                var config = this.config;
                cc.loader.load({
                    uuid: config.renderPipeline
                }, (function(err, asset) {
                    !err && asset instanceof cc.RenderPipeline ? _this3.setRenderPipeline(asset) : (console.error("Failed load renderpipeline: ".concat(config.renderPipeline, ", engine failed to initialize, all process stoped")), 
                    console.error(err), _this3.setRenderPipeline(null)), _this3._rendererInitialized = !0, 
                    _this3.emit(Game.EVENT_RENDERER_INITED), cc.internal.SplashScreenWebgl ? (cc.internal.SplashScreenWebgl.instance.setOnFinish(cb), 
                    cc.internal.SplashScreenWebgl.instance.loadFinish = !0) : cb && cb();
                }));
            }
        }, {
            key: "_setAnimFrame",
            value: function _setAnimFrame() {
                this._lastTime = new Date;
                var frameRate = cc.game.config.frameRate;
                this._frameTime = 1e3 / frameRate, jsb.setPreferredFramesPerSecond(frameRate);
            }
        }, {
            key: "_stTime",
            value: function _stTime(callback) {
                var currTime = (new Date).getTime(), timeToCall = Math.max(0, cc.game._frameTime - (currTime - cc.game._lastTime)), id = window.setTimeout(callback, timeToCall);
                return cc.game._lastTime = currTime + timeToCall, id;
            }
        }, {
            key: "_ctTime",
            value: function _ctTime(id) {
                window.clearTimeout(id);
            }
        }, {
            key: "_runMainLoop",
            value: function _runMainLoop() {
                var _callback, _this4 = this, config = this.config, director = cc.director;
                config.frameRate;
                setDisplayStats(!!config.showFPS), _callback = function callback(time) {
                    _this4._paused || (_this4._intervalId = window.requestAnimationFrame(_callback), 
                    director.mainLoop(time));
                }, this._intervalId = window.requestAnimationFrame(_callback), this._paused = !1;
            }
        }, {
            key: "_initConfig",
            value: function _initConfig(config) {
                "number" != typeof config.debugMode && (config.debugMode = 0), config.exposeClassName = !!config.exposeClassName, 
                "number" != typeof config.frameRate && (config.frameRate = 60);
                var renderMode = config.renderMode;
                ("number" != typeof renderMode || renderMode > 2 || renderMode < 0) && (config.renderMode = 0), 
                "boolean" != typeof config.registerSystemEvent && (config.registerSystemEvent = !0), 
                config.showFPS = !!config.showFPS, this._sceneInfos = config.scenes || [], this.collisionMatrix = config.collisionMatrix || [], 
                this.groupList = config.groupList || [], _resetDebugSetting(config.debugMode), this.config = config, 
                this._configLoaded = !0;
            }
        }, {
            key: "_determineRenderType",
            value: function _determineRenderType() {
                var config = this.config, userRenderMode = parseInt(config.renderMode);
                this.renderType = Game.RENDER_TYPE_CANVAS;
                var supportRender = !1;
                if (0 === userRenderMode ? cc.sys.capabilities.opengl ? (this.renderType = Game.RENDER_TYPE_WEBGL, 
                supportRender = !0) : cc.sys.capabilities.canvas && (this.renderType = Game.RENDER_TYPE_CANVAS, 
                supportRender = !0) : 1 === userRenderMode && cc.sys.capabilities.canvas ? (this.renderType = Game.RENDER_TYPE_CANVAS, 
                supportRender = !0) : 2 === userRenderMode && cc.sys.capabilities.opengl && (this.renderType = Game.RENDER_TYPE_WEBGL, 
                supportRender = !0), !supportRender) throw new Error(getError(3820, userRenderMode));
            }
        }, {
            key: "_initRenderer",
            value: function _initRenderer() {
                if (!this._rendererInitialized) {
                    var localCanvas;
                    if (this.canvas = this.config.adapter.canvas, this.frame = this.config.adapter.frame, 
                    this.container = this.config.adapter.container, localCanvas = this.canvas, this._determineRenderType(), 
                    this.renderType === Game.RENDER_TYPE_WEBGL) {
                        var useWebGL2 = !!window.WebGL2RenderingContext, userAgent = window.navigator.userAgent.toLowerCase();
                        (-1 !== userAgent.indexOf("safari") && -1 === userAgent.indexOf("chrome") || sys.browserType === sys.BROWSER_TYPE_UC) && (useWebGL2 = !1), 
                        useWebGL2 && cc.WebGL2GFXDevice ? this._gfxDevice = new cc.WebGL2GFXDevice : cc.WebGLGFXDevice && (this._gfxDevice = new cc.WebGLGFXDevice);
                        var opts = {
                            canvasElm: localCanvas,
                            debug: !0,
                            devicePixelRatio: window.devicePixelRatio,
                            nativeWidth: Math.floor(screen.width * cc.view._devicePixelRatio),
                            nativeHeight: Math.floor(screen.height * cc.view._devicePixelRatio)
                        };
                        !this._gfxDevice.initialize(opts) && useWebGL2 && (this._gfxDevice = new cc.WebGLGFXDevice, 
                        this._gfxDevice.initialize(opts));
                    }
                    if (!this._gfxDevice) return console.error("can not support canvas rendering in 3D"), 
                    void (this.renderType = Game.RENDER_TYPE_CANVAS);
                    this.canvas.oncontextmenu = function() {
                        if (!cc._isContextMenuEnable) return !1;
                    };
                }
            }
        }, {
            key: "_initEvents",
            value: function _initEvents() {
                var hiddenPropName, win = window;
                void 0 !== document.hidden ? hiddenPropName = "hidden" : void 0 !== document.mozHidden ? hiddenPropName = "mozHidden" : void 0 !== document.msHidden ? hiddenPropName = "msHidden" : void 0 !== document.webkitHidden && (hiddenPropName = "webkitHidden");
                var hidden = !1;
                function onHidden() {
                    hidden || (hidden = !0, cc.game.emit(Game.EVENT_HIDE));
                }
                function onShown() {
                    hidden && (hidden = !1, cc.game.emit(Game.EVENT_SHOW));
                }
                if (hiddenPropName) for (var changeList = [ "visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange" ], i = 0; i < changeList.length; i++) document.addEventListener(changeList[i], (function(event) {
                    var visible = document[hiddenPropName];
                    (visible = visible || event.hidden) ? onHidden() : onShown();
                })); else win.addEventListener("blur", onHidden), win.addEventListener("focus", onShown);
                navigator.userAgent.indexOf("MicroMessenger") > -1 && (win.onfocus = onShown), "onpageshow" in window && "onpagehide" in window && (win.addEventListener("pagehide", onHidden), 
                win.addEventListener("pageshow", onShown), document.addEventListener("pagehide", onHidden), 
                document.addEventListener("pageshow", onShown)), this.on(Game.EVENT_HIDE, (function() {
                    cc.game.pause();
                })), this.on(Game.EVENT_SHOW, (function() {
                    cc.game.resume();
                }));
            }
        }, {
            key: "setRenderPipeline",
            value: function setRenderPipeline(rppl) {
                rppl || (rppl = new ForwardPipeline).initialize(ForwardPipeline.initInfo), cc.director.root.setRenderPipeline(rppl) || this.setRenderPipeline(null);
            }
        } ]), Game;
    }(EventTarget);
    Game.EVENT_HIDE = "game_on_hide", Game.EVENT_SHOW = "game_on_show", Game.EVENT_GAME_INITED = "game_inited", 
    Game.EVENT_ENGINE_INITED = "engine_inited", Game.EVENT_RENDERER_INITED = "renderer_inited", 
    Game.RENDER_TYPE_CANVAS = 0, Game.RENDER_TYPE_WEBGL = 1, Game.RENDER_TYPE_OPENGL = 2, 
    cc.Game = Game;
    var game = cc.game = new Game, __BrowserGetter = new (function() {
        function BrowserGetter() {
            _classCallCheck(this, BrowserGetter), this.meta = {
                width: "device-width"
            }, this.adaptationType = cc.sys.browserType;
        }
        return _createClass(BrowserGetter, [ {
            key: "init",
            value: function init() {
                this.html = document.getElementsByTagName("html")[0];
            }
        }, {
            key: "availWidth",
            value: function availWidth(frame) {
                return cc.sys.isMobile || !frame || frame === this.html ? window.innerWidth : frame.clientWidth;
            }
        }, {
            key: "availHeight",
            value: function availHeight(frame) {
                return cc.sys.isMobile || !frame || frame === this.html ? window.innerHeight : frame.clientHeight;
            }
        } ]), BrowserGetter;
    }());
    switch (cc.sys.os === cc.sys.OS_IOS && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI), 
    __BrowserGetter.adaptationType) {
      case cc.sys.BROWSER_TYPE_SAFARI:
        __BrowserGetter.meta["minimal-ui"] = "true";

      case cc.sys.BROWSER_TYPE_SOUGOU:
      case cc.sys.BROWSER_TYPE_UC:
        __BrowserGetter.availWidth = function(frame) {
            return frame.clientWidth;
        }, __BrowserGetter.availHeight = function(frame) {
            return frame.clientHeight;
        };
        break;

      case cc.sys.BROWSER_TYPE_WECHAT_GAME:
        __BrowserGetter.availWidth = function() {
            return window.innerWidth;
        }, __BrowserGetter.availHeight = function() {
            return window.innerHeight;
        };
        break;

      case cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB:
        var sharedCanvas = window.sharedCanvas || wx.getSharedCanvas();
        __BrowserGetter.availWidth = function() {
            return sharedCanvas.width;
        }, __BrowserGetter.availHeight = function() {
            return sharedCanvas.height;
        };
    }
    var _scissorRect = null, View = function(_EventTarget) {
        function View() {
            var _this;
            _classCallCheck(this, View);
            _assertThisInitialized(_this = _possibleConstructorReturn(this, _getPrototypeOf(View).call(this)));
            var _strategyer = ContainerStrategy, _strategy = ContentStrategy;
            return _this._frameSize = new Size(0, 0), _this._designResolutionSize = new Size(0, 0), 
            _this._originalDesignResolutionSize = new Size(0, 0), _this._scaleX = 1, _this._scaleY = 1, 
            _this._viewportRect = new Rect(0, 0, 0, 0), _this._visibleRect = new Rect(0, 0, 0, 0), 
            _this._autoFullScreen = !1, _this._devicePixelRatio = 1, _this._retinaEnabled = !1, 
            _this._resizeCallback = null, _this._resizing = !1, _this._resizeWithBrowserSize = !1, 
            _this._orientationChanging = !0, _this._isRotated = !1, _this._orientation = cc.macro.ORIENTATION_AUTO, 
            _this._isAdjustViewport = !0, _this._antiAliasEnabled = !1, _this._resolutionPolicy = null, 
            _this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT), 
            _this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL), 
            _this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER), 
            _this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT), 
            _this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH), 
            cc.game.once(cc.Game.EVENT_ENGINE_INITED, _this.init, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(View, _EventTarget), _createClass(View, [ {
            key: "init",
            value: function init() {
                __BrowserGetter.init(), this._initFrameSize(), this.enableAntiAlias(!0);
                var w = cc.game.canvas.width, h = cc.game.canvas.height;
                this._designResolutionSize.width = w, this._designResolutionSize.height = h, this._originalDesignResolutionSize.width = w, 
                this._originalDesignResolutionSize.height = h, this._viewportRect.width = w, this._viewportRect.height = h, 
                this._visibleRect.width = w, this._visibleRect.height = h, cc.winSize.width = this._visibleRect.width, 
                cc.winSize.height = this._visibleRect.height, cc.visibleRect && cc.visibleRect.init(this._visibleRect);
            }
        }, {
            key: "resizeWithBrowserSize",
            value: function resizeWithBrowserSize(enabled) {
                enabled ? this._resizeWithBrowserSize || (this._resizeWithBrowserSize = !0, window.addEventListener("resize", this._resizeEvent), 
                window.addEventListener("orientationchange", this._orientationChange)) : this._resizeWithBrowserSize && (this._resizeWithBrowserSize = !1, 
                window.removeEventListener("resize", this._resizeEvent), window.removeEventListener("orientationchange", this._orientationChange));
            }
        }, {
            key: "setResizeCallback",
            value: function setResizeCallback(callback) {
                "function" != typeof callback && null != callback || (this._resizeCallback = callback);
            }
        }, {
            key: "setOrientation",
            value: function setOrientation(orientation) {
                (orientation &= cc.macro.ORIENTATION_AUTO) && this._orientation !== orientation && (this._orientation = orientation);
            }
        }, {
            key: "adjustViewportMeta",
            value: function adjustViewportMeta(enabled) {
                this._isAdjustViewport = enabled;
            }
        }, {
            key: "enableRetina",
            value: function enableRetina(enabled) {
                this._retinaEnabled = !!enabled;
            }
        }, {
            key: "isRetinaEnabled",
            value: function isRetinaEnabled() {
                return this._retinaEnabled;
            }
        }, {
            key: "enableAntiAlias",
            value: function enableAntiAlias(enabled) {
                if (this._antiAliasEnabled !== enabled) if (this._antiAliasEnabled = enabled, cc.game.renderType === cc.Game.RENDER_TYPE_WEBGL) {
                    var cache = cc.loader._cache;
                    for (var key in cache) {
                        var item = cache[key], tex = item && item.content instanceof cc.Texture2D ? item.content : null;
                        if (tex) {
                            var Filter = cc.Texture2D.Filter;
                            enabled ? tex.setFilters(Filter.LINEAR, Filter.LINEAR) : tex.setFilters(Filter.NEAREST, Filter.NEAREST);
                        }
                    }
                } else if (cc.game.renderType === cc.Game.RENDER_TYPE_CANVAS) {
                    var ctx = cc.game.canvas.getContext("2d");
                    ctx.imageSmoothingEnabled = enabled, ctx.mozImageSmoothingEnabled = enabled;
                }
            }
        }, {
            key: "isAntiAliasEnabled",
            value: function isAntiAliasEnabled() {
                return this._antiAliasEnabled;
            }
        }, {
            key: "enableAutoFullScreen",
            value: function enableAutoFullScreen(enabled) {
                enabled && enabled !== this._autoFullScreen && cc.sys.isMobile && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT ? (this._autoFullScreen = !0, 
                cc.screen.autoFullScreen(cc.game.frame)) : this._autoFullScreen = !1;
            }
        }, {
            key: "isAutoFullScreenEnabled",
            value: function isAutoFullScreenEnabled() {
                return this._autoFullScreen;
            }
        }, {
            key: "setCanvasSize",
            value: function setCanvasSize(width, height) {
                var canvas = cc.game.canvas, container = cc.game.container;
                canvas.width = width * this._devicePixelRatio, canvas.height = height * this._devicePixelRatio, 
                canvas.style.width = width + "px", canvas.style.height = height + "px", container.style.width = width + "px", 
                container.style.height = height + "px", this._resizeEvent();
            }
        }, {
            key: "getCanvasSize",
            value: function getCanvasSize() {
                return cc.size(cc.game.canvas.width, cc.game.canvas.height);
            }
        }, {
            key: "getFrameSize",
            value: function getFrameSize() {
                return cc.size(this._frameSize.width, this._frameSize.height);
            }
        }, {
            key: "setFrameSize",
            value: function setFrameSize(width, height) {
                this._frameSize.width = width, this._frameSize.height = height, cc.frame.style.width = width + "px", 
                cc.frame.style.height = height + "px", this._resizeEvent();
            }
        }, {
            key: "getVisibleSize",
            value: function getVisibleSize() {
                return cc.size(this._visibleRect.width, this._visibleRect.height);
            }
        }, {
            key: "getVisibleSizeInPixel",
            value: function getVisibleSizeInPixel() {
                return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
            }
        }, {
            key: "getVisibleOrigin",
            value: function getVisibleOrigin() {
                return cc.v2(this._visibleRect.x, this._visibleRect.y);
            }
        }, {
            key: "getVisibleOriginInPixel",
            value: function getVisibleOriginInPixel() {
                return cc.v2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
            }
        }, {
            key: "getResolutionPolicy",
            value: function getResolutionPolicy() {
                return this._resolutionPolicy;
            }
        }, {
            key: "setResolutionPolicy",
            value: function setResolutionPolicy(resolutionPolicy) {
                var _t = this;
                if (resolutionPolicy instanceof ResolutionPolicy) _t._resolutionPolicy = resolutionPolicy; else {
                    var _locPolicy = ResolutionPolicy;
                    resolutionPolicy === _locPolicy.EXACT_FIT && (_t._resolutionPolicy = _t._rpExactFit), 
                    resolutionPolicy === _locPolicy.SHOW_ALL && (_t._resolutionPolicy = _t._rpShowAll), 
                    resolutionPolicy === _locPolicy.NO_BORDER && (_t._resolutionPolicy = _t._rpNoBorder), 
                    resolutionPolicy === _locPolicy.FIXED_HEIGHT && (_t._resolutionPolicy = _t._rpFixedHeight), 
                    resolutionPolicy === _locPolicy.FIXED_WIDTH && (_t._resolutionPolicy = _t._rpFixedWidth);
                }
            }
        }, {
            key: "setDesignResolutionSize",
            value: function setDesignResolutionSize(width, height, resolutionPolicy) {
                if (width > 0 || height > 0) {
                    this.setResolutionPolicy(resolutionPolicy);
                    var policy = this._resolutionPolicy;
                    if (policy && policy.preApply(this), cc.sys.isMobile && this._adjustViewportMeta(), 
                    this._orientationChanging = !0, this._resizing || this._initFrameSize(), policy) {
                        this._originalDesignResolutionSize.width = this._designResolutionSize.width = width, 
                        this._originalDesignResolutionSize.height = this._designResolutionSize.height = height;
                        var result = policy.apply(this, this._designResolutionSize);
                        if (result.scale && 2 === result.scale.length && (this._scaleX = result.scale[0], 
                        this._scaleY = result.scale[1]), result.viewport) {
                            var vp = this._viewportRect, vb = this._visibleRect, rv = result.viewport;
                            vp.x = rv.x, vp.y = rv.y, vp.width = rv.width, vp.height = rv.height, vb.x = 0, 
                            vb.y = 0, vb.width = rv.width / this._scaleX, vb.height = rv.height / this._scaleY;
                        }
                        policy.postApply(this), cc.winSize.width = this._visibleRect.width, cc.winSize.height = this._visibleRect.height, 
                        visibleRect && visibleRect.init(this._visibleRect), this.emit("design-resolution-changed");
                    } else cc.logID(2201);
                } else cc.logID(2200);
            }
        }, {
            key: "getDesignResolutionSize",
            value: function getDesignResolutionSize() {
                return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
            }
        }, {
            key: "setRealPixelResolution",
            value: function setRealPixelResolution(width, height, resolutionPolicy) {
                this.setDesignResolutionSize(width, height, resolutionPolicy);
            }
        }, {
            key: "setViewportInPoints",
            value: function setViewportInPoints(x, y, w, h) {
                var locScaleX = this._scaleX, locScaleY = this._scaleY;
                cc.game._renderContext.viewport(x * locScaleX + this._viewportRect.x, y * locScaleY + this._viewportRect.y, w * locScaleX, h * locScaleY);
            }
        }, {
            key: "setScissorInPoints",
            value: function setScissorInPoints(x, y, w, h) {
                var scaleX = this._scaleX, scaleY = this._scaleY, sx = Math.ceil(x * scaleX + this._viewportRect.x), sy = Math.ceil(y * scaleY + this._viewportRect.y), sw = Math.ceil(w * scaleX), sh = Math.ceil(h * scaleY), gl = cc.game._renderContext;
                if (!_scissorRect) {
                    var boxArr = gl.getParameter(gl.SCISSOR_BOX);
                    _scissorRect = new Rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
                }
                _scissorRect.x === sx && _scissorRect.y === sy && _scissorRect.width === sw && _scissorRect.height === sh || (_scissorRect.x = sx, 
                _scissorRect.y = sy, _scissorRect.width = sw, _scissorRect.height = sh, gl.scissor(sx, sy, sw, sh));
            }
        }, {
            key: "isScissorEnabled",
            value: function isScissorEnabled() {
                var gl = cc.game._renderContext;
                return gl.isEnabled(gl.SCISSOR_TEST);
            }
        }, {
            key: "getScissorRect",
            value: function getScissorRect() {
                var gl = cc.game._renderContext;
                if (!_scissorRect) {
                    var boxArr = gl.getParameter(gl.SCISSOR_BOX);
                    _scissorRect = new Rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
                }
                var scaleXFactor = 1 / this._scaleX, scaleYFactor = 1 / this._scaleY;
                return new Rect((_scissorRect.x - this._viewportRect.x) * scaleXFactor, (_scissorRect.y - this._viewportRect.y) * scaleYFactor, _scissorRect.width * scaleXFactor, _scissorRect.height * scaleYFactor);
            }
        }, {
            key: "getViewportRect",
            value: function getViewportRect() {
                return this._viewportRect;
            }
        }, {
            key: "getScaleX",
            value: function getScaleX() {
                return this._scaleX;
            }
        }, {
            key: "getScaleY",
            value: function getScaleY() {
                return this._scaleY;
            }
        }, {
            key: "getDevicePixelRatio",
            value: function getDevicePixelRatio() {
                return this._devicePixelRatio;
            }
        }, {
            key: "convertToLocationInView",
            value: function convertToLocationInView(tx, ty, relatedPos, out) {
                var result = out || cc.v2(), x = this._devicePixelRatio * (tx - relatedPos.left), y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
                return this._isRotated ? (result.x = cc.game.canvas.width - y, result.y = x) : (result.x = x, 
                result.y = y), result;
            }
        }, {
            key: "_convertPointWithScale",
            value: function _convertPointWithScale(point) {
                var viewport = this._viewportRect;
                point.x = (point.x - viewport.x) / this._scaleX, point.y = (point.y - viewport.y) / this._scaleY;
            }
        }, {
            key: "_resizeEvent",
            value: function _resizeEvent() {
                var _view = cc.view, prevFrameW = _view._frameSize.width, prevFrameH = _view._frameSize.height, prevRotated = _view._isRotated;
                if (cc.sys.isMobile) {
                    var containerStyle = cc.game.container.style, margin = containerStyle.margin;
                    containerStyle.margin = "0", containerStyle.display = "none", _view._initFrameSize(), 
                    containerStyle.margin = margin, containerStyle.display = "block";
                } else _view._initFrameSize();
                if (_view._orientationChanging || _view._isRotated !== prevRotated || _view._frameSize.width !== prevFrameW || _view._frameSize.height !== prevFrameH) {
                    var width = _view._originalDesignResolutionSize.width, height = _view._originalDesignResolutionSize.height;
                    _view._resizing = !0, width > 0 && _view.setDesignResolutionSize(width, height, _view._resolutionPolicy), 
                    _view._resizing = !1, _view._resizeCallback && _view._resizeCallback.call();
                }
            }
        }, {
            key: "_orientationChange",
            value: function _orientationChange() {
                cc.view._orientationChanging = !0, cc.view._resizeEvent();
            }
        }, {
            key: "_initFrameSize",
            value: function _initFrameSize() {
                var locFrameSize = this._frameSize, w = __BrowserGetter.availWidth(cc.game.frame), h = __BrowserGetter.availHeight(cc.game.frame), isLandscape = w >= h;
                !cc.sys.isMobile || isLandscape && this._orientation & cc.macro.ORIENTATION_LANDSCAPE || !isLandscape && this._orientation & cc.macro.ORIENTATION_PORTRAIT ? (locFrameSize.width = w, 
                locFrameSize.height = h, cc.game.container.style["-webkit-transform"] = "rotate(0deg)", 
                cc.game.container.style.transform = "rotate(0deg)", this._isRotated = !1) : (locFrameSize.width = h, 
                locFrameSize.height = w, cc.game.container.style["-webkit-transform"] = "rotate(90deg)", 
                cc.game.container.style.transform = "rotate(90deg)", cc.game.container.style["-webkit-transform-origin"] = "0px 0px 0px", 
                cc.game.container.style.transformOrigin = "0px 0px 0px", this._isRotated = !0, cc.game.canvas.style["-webkit-transform"] = "translateZ(0px)", 
                cc.game.canvas.style.transform = "translateZ(0px)"), this._orientationChanging && setTimeout((function() {
                    cc.view._orientationChanging = !1;
                }), 1e3);
            }
        }, {
            key: "_adjustSizeKeepCanvasSize",
            value: function _adjustSizeKeepCanvasSize() {
                var designWidth = this._originalDesignResolutionSize.width, designHeight = this._originalDesignResolutionSize.height;
                designWidth > 0 && this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
            }
        }, {
            key: "_setViewportMeta",
            value: function _setViewportMeta(metas, overwrite) {
                var vp = document.getElementById("cocosMetaElement");
                vp && overwrite && document.head.removeChild(vp);
                var content, key, pattern, elems = document.getElementsByName("viewport"), currentVP = elems ? elems[0] : null;
                for (key in content = currentVP ? currentVP.content : "", (vp = vp || document.createElement("meta")).id = "cocosMetaElement", 
                vp.name = "viewport", vp.content = "", metas) -1 === content.indexOf(key) ? content += "," + key + "=" + metas[key] : overwrite && (pattern = new RegExp(key + "s*=s*[^,]+"), 
                content.replace(pattern, key + "=" + metas[key]));
                /^,/.test(content) && (content = content.substr(1)), vp.content = content, currentVP && (currentVP.content = content), 
                document.head.appendChild(vp);
            }
        }, {
            key: "_adjustViewportMeta",
            value: function _adjustViewportMeta() {
                this._isAdjustViewport, 0;
            }
        }, {
            key: "_convertMouseToLocation",
            value: function _convertMouseToLocation(in_out_point, relatedPos) {
                in_out_point.x = this._devicePixelRatio * (in_out_point.x - relatedPos.left), in_out_point.y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - in_out_point.y);
            }
        }, {
            key: "_convertTouchWidthScale",
            value: function _convertTouchWidthScale(selTouch) {
                var viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY;
                selTouch._point.x = (selTouch._point.x - viewport.x) / scaleX, selTouch._point.y = (selTouch._point.y - viewport.y) / scaleY, 
                selTouch._prevPoint.x = (selTouch._prevPoint.x - viewport.x) / scaleX, selTouch._prevPoint.y = (selTouch._prevPoint.y - viewport.y) / scaleY;
            }
        }, {
            key: "_convertTouchesWithScale",
            value: function _convertTouchesWithScale(touches) {
                for (var selPoint, selPrePoint, viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY, i = 0; i < touches.length; i++) {
                    var selTouch = touches[i];
                    selPoint = selTouch._point, selPrePoint = selTouch._prevPoint, selPoint.x = (selPoint.x - viewport.x) / scaleX, 
                    selPoint.y = (selPoint.y - viewport.y) / scaleY, selPrePoint.x = (selPrePoint.x - viewport.x) / scaleX, 
                    selPrePoint.y = (selPrePoint.y - viewport.y) / scaleY;
                }
            }
        } ]), View;
    }(EventTarget), ContainerStrategy = function() {
        function ContainerStrategy() {
            _classCallCheck(this, ContainerStrategy), this.name = "ContainerStrategy";
        }
        return _createClass(ContainerStrategy, [ {
            key: "preApply",
            value: function preApply(_view) {}
        }, {
            key: "apply",
            value: function apply(_view, designedResolution) {}
        }, {
            key: "postApply",
            value: function postApply(_view) {}
        }, {
            key: "_setupContainer",
            value: function _setupContainer(_view, w, h) {
                var locCanvas = cc.game.canvas, locContainer = cc.game.container;
                cc.sys.platform !== cc.sys.WECHAT_GAME && (cc.sys.os === cc.sys.OS_ANDROID && (document.body.style.width = (_view._isRotated ? h : w) + "px", 
                document.body.style.height = (_view._isRotated ? w : h) + "px"), locContainer.style.width = locCanvas.style.width = w + "px", 
                locContainer.style.height = locCanvas.style.height = h + "px");
                var devicePixelRatio = _view._devicePixelRatio = 1;
                _view.isRetinaEnabled() && (devicePixelRatio = _view._devicePixelRatio = Math.min(2, window.devicePixelRatio || 1)), 
                locCanvas.width = w * devicePixelRatio, locCanvas.height = h * devicePixelRatio;
            }
        }, {
            key: "_fixContainer",
            value: function _fixContainer() {
                document.body.insertBefore(cc.game.container, document.body.firstChild);
                var bs = document.body.style;
                bs.width = window.innerWidth + "px", bs.height = window.innerHeight + "px", bs.overflow = "hidden";
                var contStyle = cc.game.container.style;
                contStyle.position = "fixed", contStyle.left = contStyle.top = "0px", document.body.scrollTop = 0;
            }
        } ]), ContainerStrategy;
    }(), ContentStrategy = function() {
        function ContentStrategy() {
            _classCallCheck(this, ContentStrategy), this.name = "ContentStrategy", this._result = {
                scale: [ 1, 1 ],
                viewport: null
            };
        }
        return _createClass(ContentStrategy, [ {
            key: "preApply",
            value: function preApply(_view) {}
        }, {
            key: "apply",
            value: function apply(_view, designedResolution) {
                return {
                    scale: [ 1, 1 ]
                };
            }
        }, {
            key: "postApply",
            value: function postApply(_view) {}
        }, {
            key: "_buildResult",
            value: function _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
                Math.abs(containerW - contentW) < 2 && (contentW = containerW), Math.abs(containerH - contentH) < 2 && (contentH = containerH);
                var viewport = new Rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
                return this._result.scale = [ scaleX, scaleY ], this._result.viewport = viewport, 
                this._result;
            }
        } ]), ContentStrategy;
    }();
    !function() {
        var EqualToFrame = function(_ContainerStrategy) {
            function EqualToFrame() {
                var _getPrototypeOf2, _this2;
                _classCallCheck(this, EqualToFrame);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return (_this2 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EqualToFrame)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).name = "EqualToFrame", 
                _this2;
            }
            return _inherits(EqualToFrame, _ContainerStrategy), _createClass(EqualToFrame, [ {
                key: "apply",
                value: function apply(_view) {
                    var frameH = _view._frameSize.height, containerStyle = cc.game.container.style;
                    this._setupContainer(_view, _view._frameSize.width, _view._frameSize.height), _view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px", 
                    containerStyle.padding = "0px";
                }
            } ]), EqualToFrame;
        }(ContainerStrategy), ProportionalToFrame = function(_ContainerStrategy2) {
            function ProportionalToFrame() {
                var _getPrototypeOf3, _this3;
                _classCallCheck(this, ProportionalToFrame);
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                return (_this3 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(ProportionalToFrame)).call.apply(_getPrototypeOf3, [ this ].concat(args)))).name = "ProportionalToFrame", 
                _this3;
            }
            return _inherits(ProportionalToFrame, _ContainerStrategy2), _createClass(ProportionalToFrame, [ {
                key: "apply",
                value: function apply(_view, designedResolution) {
                    var containerW, containerH, frameW = _view._frameSize.width, frameH = _view._frameSize.height, containerStyle = cc.game.container.style, designW = designedResolution.width, designH = designedResolution.height, scaleX = frameW / designW, scaleY = frameH / designH;
                    scaleX < scaleY ? (containerW = frameW, containerH = designH * scaleX) : (containerW = designW * scaleY, 
                    containerH = frameH);
                    var offx = Math.round((frameW - containerW) / 2), offy = Math.round((frameH - containerH) / 2);
                    containerW = frameW - 2 * offx, containerH = frameH - 2 * offy, this._setupContainer(_view, containerW, containerH), 
                    _view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px", 
                    containerStyle.paddingLeft = offx + "px", containerStyle.paddingRight = offx + "px", 
                    containerStyle.paddingTop = offy + "px", containerStyle.paddingBottom = offy + "px";
                }
            } ]), ProportionalToFrame;
        }(ContainerStrategy), globalAdapter = ("undefined" == typeof window ? global : window).__globalAdapter;
        globalAdapter && (globalAdapter.adaptContainerStrategy && globalAdapter.adaptContainerStrategy(ContainerStrategy.prototype), 
        globalAdapter.adaptView && globalAdapter.adaptView(View.prototype)), ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame, 
        ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame;
        var ExactFit = function(_ContentStrategy) {
            function ExactFit() {
                var _getPrototypeOf4, _this4;
                _classCallCheck(this, ExactFit);
                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                return (_this4 = _possibleConstructorReturn(this, (_getPrototypeOf4 = _getPrototypeOf(ExactFit)).call.apply(_getPrototypeOf4, [ this ].concat(args)))).name = "ExactFit", 
                _this4;
            }
            return _inherits(ExactFit, _ContentStrategy), _createClass(ExactFit, [ {
                key: "apply",
                value: function apply(_view, designedResolution) {
                    var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
                    return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
                }
            } ]), ExactFit;
        }(ContentStrategy), ShowAll = function(_ContentStrategy2) {
            function ShowAll() {
                var _getPrototypeOf5, _this5;
                _classCallCheck(this, ShowAll);
                for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
                return (_this5 = _possibleConstructorReturn(this, (_getPrototypeOf5 = _getPrototypeOf(ShowAll)).call.apply(_getPrototypeOf5, [ this ].concat(args)))).name = "ShowAll", 
                _this5;
            }
            return _inherits(ShowAll, _ContentStrategy2), _createClass(ShowAll, [ {
                key: "apply",
                value: function apply(_view, designedResolution) {
                    var contentW, contentH, containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale = 0;
                    return scaleX < scaleY ? (contentW = containerW, contentH = designH * (scale = scaleX)) : (contentW = designW * (scale = scaleY), 
                    contentH = containerH), this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }
            } ]), ShowAll;
        }(ContentStrategy), NoBorder = function(_ContentStrategy3) {
            function NoBorder() {
                var _getPrototypeOf6, _this6;
                _classCallCheck(this, NoBorder);
                for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];
                return (_this6 = _possibleConstructorReturn(this, (_getPrototypeOf6 = _getPrototypeOf(NoBorder)).call.apply(_getPrototypeOf6, [ this ].concat(args)))).name = "NoBorder", 
                _this6;
            }
            return _inherits(NoBorder, _ContentStrategy3), _createClass(NoBorder, [ {
                key: "apply",
                value: function apply(_view, designedResolution) {
                    var scale, contentW, contentH, containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH;
                    return scaleX < scaleY ? (contentW = designW * (scale = scaleY), contentH = containerH) : (contentW = containerW, 
                    contentH = designH * (scale = scaleX)), this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }
            } ]), NoBorder;
        }(ContentStrategy), FixedHeight = function(_ContentStrategy4) {
            function FixedHeight() {
                var _getPrototypeOf7, _this7;
                _classCallCheck(this, FixedHeight);
                for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) args[_key6] = arguments[_key6];
                return (_this7 = _possibleConstructorReturn(this, (_getPrototypeOf7 = _getPrototypeOf(FixedHeight)).call.apply(_getPrototypeOf7, [ this ].concat(args)))).name = "FixedHeight", 
                _this7;
            }
            return _inherits(FixedHeight, _ContentStrategy4), _createClass(FixedHeight, [ {
                key: "apply",
                value: function apply(_view, designedResolution) {
                    var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scale = containerH / designedResolution.height, contentW = containerW, contentH = containerH;
                    return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }
            } ]), FixedHeight;
        }(ContentStrategy), FixedWidth = function(_ContentStrategy5) {
            function FixedWidth() {
                var _getPrototypeOf8, _this8;
                _classCallCheck(this, FixedWidth);
                for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) args[_key7] = arguments[_key7];
                return (_this8 = _possibleConstructorReturn(this, (_getPrototypeOf8 = _getPrototypeOf(FixedWidth)).call.apply(_getPrototypeOf8, [ this ].concat(args)))).name = "FixedWidth", 
                _this8;
            }
            return _inherits(FixedWidth, _ContentStrategy5), _createClass(FixedWidth, [ {
                key: "apply",
                value: function apply(_view, designedResolution) {
                    var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scale = containerW / designedResolution.width, contentW = containerW, contentH = containerH;
                    return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }
            } ]), FixedWidth;
        }(ContentStrategy);
        ContentStrategy.EXACT_FIT = new ExactFit, ContentStrategy.SHOW_ALL = new ShowAll, 
        ContentStrategy.NO_BORDER = new NoBorder, ContentStrategy.FIXED_HEIGHT = new FixedHeight, 
        ContentStrategy.FIXED_WIDTH = new FixedWidth;
    }();
    var ResolutionPolicy = function() {
        function ResolutionPolicy(containerStg, contentStg) {
            _classCallCheck(this, ResolutionPolicy), this.name = "ResolutionPolicy", this._containerStrategy = null, 
            this._contentStrategy = null, this.setContainerStrategy(containerStg), this.setContentStrategy(contentStg);
        }
        return _createClass(ResolutionPolicy, [ {
            key: "preApply",
            value: function preApply(_view) {
                this._containerStrategy.preApply(_view), this._contentStrategy.preApply(_view);
            }
        }, {
            key: "apply",
            value: function apply(_view, designedResolution) {
                return this._containerStrategy.apply(_view, designedResolution), this._contentStrategy.apply(_view, designedResolution);
            }
        }, {
            key: "postApply",
            value: function postApply(_view) {
                this._containerStrategy.postApply(_view), this._contentStrategy.postApply(_view);
            }
        }, {
            key: "setContainerStrategy",
            value: function setContainerStrategy(containerStg) {
                containerStg instanceof ContainerStrategy && (this._containerStrategy = containerStg);
            }
        }, {
            key: "setContentStrategy",
            value: function setContentStrategy(contentStg) {
                contentStg instanceof ContentStrategy && (this._contentStrategy = contentStg);
            }
        }, {
            key: "canvasSize",
            get: function get() {
                return cc.v2(cc.game.canvas.width, cc.game.canvas.height);
            }
        } ]), ResolutionPolicy;
    }();
    ResolutionPolicy.EXACT_FIT = 0, ResolutionPolicy.NO_BORDER = 1, ResolutionPolicy.SHOW_ALL = 2, 
    ResolutionPolicy.FIXED_HEIGHT = 3, ResolutionPolicy.FIXED_WIDTH = 4, ResolutionPolicy.UNKNOWN = 5, 
    ResolutionPolicy.ContainerStrategy = ContainerStrategy, ResolutionPolicy.ContentStrategy = ContentStrategy, 
    cc.ResolutionPolicy = ResolutionPolicy;
    var view = View.instance = cc.view = new View;
    cc.winSize = cc.v2();
    var _vec2 = new Vec2, Touch = function() {
        function Touch(x, y) {
            var id = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            _classCallCheck(this, Touch), this._point = new Vec2, this._prevPoint = new Vec2, 
            this._lastModified = 0, this._id = null, this._startPoint = new Vec2, this._startPointCaptured = !1, 
            this.setTouchInfo(id, x, y);
        }
        return _createClass(Touch, [ {
            key: "getLocation",
            value: function getLocation(out) {
                return out || (out = new Vec2), out.set(this._point.x, this._point.y), out;
            }
        }, {
            key: "getLocationX",
            value: function getLocationX() {
                return this._point.x;
            }
        }, {
            key: "getLocationY",
            value: function getLocationY() {
                return this._point.y;
            }
        }, {
            key: "getUILocation",
            value: function getUILocation(out) {
                return out || (out = new Vec2), out.set(this._point.x, this._point.y), cc.view._convertPointWithScale(out), 
                out;
            }
        }, {
            key: "getUILocationX",
            value: function getUILocationX() {
                var viewport = cc.view.getViewportRect();
                return (this._point.x - viewport.x) / cc.view.getScaleX();
            }
        }, {
            key: "getUILocationY",
            value: function getUILocationY() {
                var viewport = cc.view.getViewportRect();
                return (this._point.y - viewport.y) / cc.view.getScaleY();
            }
        }, {
            key: "getPreviousLocation",
            value: function getPreviousLocation(out) {
                return out || (out = new Vec2), out.set(this._prevPoint.x, this._prevPoint.y), out;
            }
        }, {
            key: "getUIPreviousLocation",
            value: function getUIPreviousLocation(out) {
                return out || (out = new Vec2), out.set(this._prevPoint.x, this._prevPoint.y), cc.view._convertPointWithScale(out), 
                out;
            }
        }, {
            key: "getStartLocation",
            value: function getStartLocation(out) {
                return out || (out = new Vec2), out.set(this._startPoint.x, this._startPoint.y), 
                out;
            }
        }, {
            key: "getUIStartLocation",
            value: function getUIStartLocation(out) {
                return out || (out = new Vec2), out.set(this._startPoint.x, this._startPoint.y), 
                cc.view._convertPointWithScale(out), out;
            }
        }, {
            key: "getDelta",
            value: function getDelta(out) {
                return out || (out = new Vec2), out.set(this._point), out.subtract(this._prevPoint), 
                out;
            }
        }, {
            key: "getUIDelta",
            value: function getUIDelta(out) {
                return out || (out = new Vec2), _vec2.set(this._point), _vec2.subtract(this._prevPoint), 
                out.set(cc.view.getScaleX(), cc.view.getScaleY()), Vec2.divide(out, _vec2, out), 
                out;
            }
        }, {
            key: "getLocationInView",
            value: function getLocationInView(out) {
                return out || (out = new Vec2), out.set(this._point.x, cc.view._designResolutionSize.height - this._point.y), 
                out;
            }
        }, {
            key: "getPreviousLocationInView",
            value: function getPreviousLocationInView(out) {
                return out || (out = new Vec2), out.set(this._prevPoint.x, cc.view._designResolutionSize.height - this._prevPoint.y), 
                out;
            }
        }, {
            key: "getStartLocationInView",
            value: function getStartLocationInView(out) {
                return out || (out = new Vec2), out.set(this._startPoint.x, cc.view._designResolutionSize.height - this._startPoint.y), 
                out;
            }
        }, {
            key: "getID",
            value: function getID() {
                return this._id;
            }
        }, {
            key: "setTouchInfo",
            value: function setTouchInfo() {
                var id = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, x = arguments.length > 1 ? arguments[1] : void 0, y = arguments.length > 2 ? arguments[2] : void 0;
                this._prevPoint = this._point, this._point = new Vec2(x || 0, y || 0), this._id = id, 
                this._startPointCaptured || (this._startPoint = new Vec2(this._point), this._startPointCaptured = !0);
            }
        }, {
            key: "_setPoint",
            value: function _setPoint(x, y) {
                "object" === _typeof(x) ? (this._point.x = x.x, this._point.y = x.y) : (this._point.x = x || 0, 
                this._point.y = y || 0);
            }
        }, {
            key: "_setPrevPoint",
            value: function _setPrevPoint(x, y) {
                "object" === _typeof(x) ? this._prevPoint = new Vec2(x.x, x.y) : this._prevPoint = new Vec2(x || 0, y || 0);
            }
        } ]), Touch;
    }();
    cc.Touch = Touch;
    var _didAccelerateFun, TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT, _vec2$1 = new Vec2, _preLocation = new Vec2, Acceleration$1 = function Acceleration() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, timestamp = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        _classCallCheck(this, Acceleration), this.x = x, this.y = y, this.z = z, this.timestamp = timestamp;
    }, inputManager = new (function() {
        function InputManager() {
            _classCallCheck(this, InputManager), this._mousePressed = !1, this._isRegisterEvent = !1, 
            this._preTouchPoint = new Vec2, this._prevMousePoint = new Vec2, this._preTouchPool = [], 
            this._preTouchPoolPointer = 0, this._touches = [], this._touchesIntegerDict = {}, 
            this._indexBitsUsed = 0, this._maxTouches = 8, this._accelEnabled = !1, this._accelInterval = .2, 
            this._accelMinus = 1, this._accelCurTime = 0, this._acceleration = null, this._accelDeviceEvent = null, 
            this._glView = null, this._minus = 0, this._pointLocked = !1;
        }
        return _createClass(InputManager, [ {
            key: "handleTouchesBegin",
            value: function handleTouchesBegin(touches) {
                for (var handleTouches = [], locTouchIntDict = this._touchesIntegerDict, now = sys.now(), i = 0; i < touches.length; ++i) {
                    var touch = touches[i], touchID = touch.getID();
                    if (null !== touchID) if (void 0 === locTouchIntDict[touchID]) {
                        var unusedIndex = this._getUnUsedIndex();
                        if (-1 === unusedIndex) {
                            cc.logID(2300, unusedIndex);
                            continue;
                        }
                        var curTouch = new Touch(touch._point.x, touch._point.y, touch.getID());
                        this._touches[unusedIndex] = curTouch, curTouch._lastModified = now, curTouch._setPrevPoint(touch._prevPoint), 
                        locTouchIntDict[touchID] = unusedIndex, handleTouches.push(curTouch);
                    }
                }
                if (handleTouches.length > 0) {
                    var touchEvent = new EventTouch(handleTouches);
                    touchEvent._eventCode = EventTouch.BEGAN, eventManager.dispatchEvent(touchEvent);
                }
            }
        }, {
            key: "handleTouchesMove",
            value: function handleTouchesMove(touches) {
                for (var handleTouches = [], locTouches = this._touches, now = sys.now(), i = 0; i < touches.length; ++i) {
                    var touch = touches[i], touchID = touch.getID();
                    if (null !== touchID) {
                        var _index2 = this._touchesIntegerDict[touchID];
                        void 0 !== _index2 && locTouches[_index2] && (locTouches[_index2]._setPoint(touch._point), 
                        locTouches[_index2]._setPrevPoint(touch._prevPoint), locTouches[_index2]._lastModified = now, 
                        handleTouches.push(locTouches[_index2]));
                    }
                }
                if (handleTouches.length > 0) {
                    var touchEvent = new EventTouch(handleTouches);
                    touchEvent._eventCode = EventTouch.MOVED, eventManager.dispatchEvent(touchEvent);
                }
            }
        }, {
            key: "handleTouchesEnd",
            value: function handleTouchesEnd(touches) {
                var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
                if (handleTouches.length > 0) {
                    var touchEvent = new EventTouch(handleTouches);
                    touchEvent._eventCode = EventTouch.ENDED, eventManager.dispatchEvent(touchEvent);
                }
                this._preTouchPool.length = 0;
            }
        }, {
            key: "handleTouchesCancel",
            value: function handleTouchesCancel(touches) {
                var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
                if (handleTouches.length > 0) {
                    var touchEvent = new EventTouch(handleTouches);
                    touchEvent._eventCode = EventTouch.CANCELLED, eventManager.dispatchEvent(touchEvent);
                }
                this._preTouchPool.length = 0;
            }
        }, {
            key: "getSetOfTouchesEndOrCancel",
            value: function getSetOfTouchesEndOrCancel(touches) {
                for (var handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict, i = 0; i < touches.length; ++i) {
                    var touch = touches[i], touchID = touch.getID();
                    if (null !== touchID) {
                        var _index3 = locTouchesIntDict[touchID];
                        void 0 !== _index3 && locTouches[_index3] && (locTouches[_index3]._setPoint(touch._point), 
                        locTouches[_index3]._setPrevPoint(touch._prevPoint), handleTouches.push(locTouches[_index3]), 
                        this._removeUsedIndexBit(_index3), delete locTouchesIntDict[touchID]);
                    }
                }
                return handleTouches;
            }
        }, {
            key: "getHTMLElementPosition",
            value: function getHTMLElementPosition(element) {
                if (sys.platform === sys.WECHAT_GAME) return {
                    left: 0,
                    top: 0,
                    width: window.innerWidth,
                    height: window.innerHeight
                };
                var docElem = document.documentElement, leftOffset = sys.os === sys.OS_IOS && sys.isBrowser ? window.screenLeft : window.pageXOffset;
                leftOffset -= docElem.clientLeft;
                var topOffset = sys.os === sys.OS_IOS && sys.isBrowser ? window.screenTop : window.pageYOffset;
                if (topOffset -= docElem.clientTop, element.getBoundingClientRect) {
                    var box = element.getBoundingClientRect();
                    return {
                        left: box.left + leftOffset,
                        top: box.top + topOffset,
                        width: box.width,
                        height: box.height
                    };
                }
                return element instanceof HTMLCanvasElement ? {
                    left: leftOffset,
                    top: topOffset,
                    width: element.width,
                    height: element.height
                } : {
                    left: leftOffset,
                    top: topOffset,
                    width: parseInt(element.style.width || "0", void 0),
                    height: parseInt(element.style.height || "0", void 0)
                };
            }
        }, {
            key: "getPreTouch",
            value: function getPreTouch(touch) {
                for (var preTouch = null, locPreTouchPool = this._preTouchPool, id = touch.getID(), i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
                    preTouch = locPreTouchPool[i];
                    break;
                }
                return preTouch || (preTouch = touch), preTouch;
            }
        }, {
            key: "setPreTouch",
            value: function setPreTouch(touch) {
                for (var find = !1, locPreTouchPool = this._preTouchPool, id = touch.getID(), i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
                    locPreTouchPool[i] = touch, find = !0;
                    break;
                }
                find || (locPreTouchPool.length <= 50 ? locPreTouchPool.push(touch) : (locPreTouchPool[this._preTouchPoolPointer] = touch, 
                this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50));
            }
        }, {
            key: "getTouchByXY",
            value: function getTouchByXY(event, tx, ty, pos) {
                var locPreTouch = this._preTouchPoint, location = this._glView.convertToLocationInView(tx, ty, pos);
                this._pointLocked && (location.x = locPreTouch.x + event.movementX, location.y = locPreTouch.y - event.movementY);
                var touch = new Touch(location.x, location.y, 0);
                return touch._setPrevPoint(locPreTouch.x, locPreTouch.y), locPreTouch.x = location.x, 
                locPreTouch.y = location.y, touch;
            }
        }, {
            key: "getMouseEvent",
            value: function getMouseEvent(location, pos, eventType) {
                var locPreMouse = this._prevMousePoint, mouseEvent = new EventMouse(eventType);
                return mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y), locPreMouse.x = location.x, 
                locPreMouse.y = location.y, this._glView._convertMouseToLocation(locPreMouse, pos), 
                mouseEvent.setLocation(locPreMouse.x, locPreMouse.y), mouseEvent;
            }
        }, {
            key: "getPointByEvent",
            value: function getPointByEvent(event, pos) {
                return null != event.pageX ? {
                    x: event.pageX,
                    y: event.pageY
                } : (sys.platform === sys.WECHAT_GAME ? (pos.left = 0, pos.top = 0) : (pos.left -= document.body.scrollLeft, 
                pos.top -= document.body.scrollTop), {
                    x: event.clientX,
                    y: event.clientY
                });
            }
        }, {
            key: "getTouchesByEvent",
            value: function getTouchesByEvent(event, position) {
                for (var touches = [], locView = this._glView, locPreTouch = this._preTouchPoint, length = event.changedTouches.length, i = 0; i < length; i++) {
                    var changedTouch = event.changedTouches[i];
                    if (changedTouch) {
                        var _location = void 0;
                        _location = sys.BROWSER_TYPE_FIREFOX === sys.browserType ? locView.convertToLocationInView(changedTouch.pageX, changedTouch.pageY, position, _vec2$1) : locView.convertToLocationInView(changedTouch.clientX, changedTouch.clientY, position, _vec2$1);
                        var touch = void 0;
                        null != changedTouch.identifier ? (touch = new Touch(_location.x, _location.y, changedTouch.identifier), 
                        this.getPreTouch(touch).getLocation(_preLocation), touch._setPrevPoint(_preLocation.x, _preLocation.y), 
                        this.setPreTouch(touch)) : (touch = new Touch(_location.x, _location.y))._setPrevPoint(locPreTouch.x, locPreTouch.y), 
                        locPreTouch.x = _location.x, locPreTouch.y = _location.y, touches.push(touch);
                    }
                }
                return touches;
            }
        }, {
            key: "registerSystemEvent",
            value: function registerSystemEvent(element) {
                if (!this._isRegisterEvent && element) {
                    this._glView = cc.view;
                    var prohibition = sys.isMobile, supportMouse = "mouse" in sys.capabilities, supportTouches = "touches" in sys.capabilities;
                    sys.platform === sys.WECHAT_GAME && (prohibition = !1, supportTouches = !0, supportMouse = !1), 
                    supportMouse && this._registerMouseEvents(element, prohibition), window.navigator.msPointerEnabled && this._registerMousePointerEvents(element), 
                    supportTouches && this._registerTouchEvents(element), cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB && this._registerKeyboardEvent(), 
                    this._isRegisterEvent = !0;
                }
            }
        }, {
            key: "setAccelerometerEnabled",
            value: function setAccelerometerEnabled(isEnable) {
                if (this._accelEnabled !== isEnable) {
                    this._accelEnabled = isEnable;
                    var scheduler = cc.director.getScheduler();
                    scheduler.enableForTarget(this), this._accelEnabled ? (this._registerAccelerometerEvent(), 
                    this._accelCurTime = 0, scheduler.scheduleUpdate(this)) : (this._unregisterAccelerometerEvent(), 
                    this._accelCurTime = 0, scheduler.unscheduleUpdate(this));
                }
            }
        }, {
            key: "didAccelerate",
            value: function didAccelerate(eventData) {
                if (this._accelEnabled) {
                    var mAcceleration = this._acceleration, x = 0, y = 0, z = 0;
                    if (this._accelDeviceEvent === window.DeviceMotionEvent) {
                        var eventAcceleration = eventData.accelerationIncludingGravity;
                        eventAcceleration && (x = this._accelMinus * (eventAcceleration.x || 0) * .1, y = this._accelMinus * (eventAcceleration.y || 0) * .1, 
                        z = .1 * (eventAcceleration.z || 0));
                    } else {
                        var deviceOrientationEvent = eventData;
                        x = (deviceOrientationEvent.gamma || 0) / 90 * .981, y = -(deviceOrientationEvent.beta || 0) / 90 * .981, 
                        z = (deviceOrientationEvent.alpha || 0) / 90 * .981;
                    }
                    if (cc.view._isRotated) {
                        var tmp = x;
                        x = -y, y = tmp;
                    }
                    mAcceleration.x = x, mAcceleration.y = y, mAcceleration.z = z, mAcceleration.timestamp = eventData.timeStamp || Date.now();
                    var tmpX = mAcceleration.x;
                    90 === window.orientation ? (mAcceleration.x = -mAcceleration.y, mAcceleration.y = tmpX) : -90 === window.orientation ? (mAcceleration.x = mAcceleration.y, 
                    mAcceleration.y = -tmpX) : 180 === window.orientation && (mAcceleration.x = -mAcceleration.x, 
                    mAcceleration.y = -mAcceleration.y), cc.sys.os === cc.sys.OS_ANDROID && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ && (mAcceleration.x = -mAcceleration.x, 
                    mAcceleration.y = -mAcceleration.y);
                }
            }
        }, {
            key: "update",
            value: function update(dt) {
                this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, 
                eventManager.dispatchEvent(new EventAcceleration(this._acceleration))), this._accelCurTime += dt;
            }
        }, {
            key: "setAccelerometerInterval",
            value: function setAccelerometerInterval(interval) {
                this._accelInterval !== interval && (this._accelInterval = interval);
            }
        }, {
            key: "_getUnUsedIndex",
            value: function _getUnUsedIndex() {
                for (var temp = this._indexBitsUsed, now = cc.sys.now(), i = 0; i < this._maxTouches; i++) {
                    if (!(1 & temp)) return this._indexBitsUsed |= 1 << i, i;
                    var touch = this._touches[i];
                    if (now - touch._lastModified > TOUCH_TIMEOUT) {
                        this._removeUsedIndexBit(i);
                        var touchID = touch.getID();
                        return null !== touchID && delete this._touchesIntegerDict[touchID], i;
                    }
                    temp >>= 1;
                }
                return -1;
            }
        }, {
            key: "_removeUsedIndexBit",
            value: function _removeUsedIndexBit(index) {
                if (!(index < 0 || index >= this._maxTouches)) {
                    var temp = 1 << index;
                    temp = ~temp, this._indexBitsUsed &= temp;
                }
            }
        }, {
            key: "_registerMouseEvents",
            value: function _registerMouseEvents(element, prohibition) {
                this._registerPointerLockEvent(), prohibition || this._registerWindowMouseEvents(element), 
                this._registerElementMouseEvents(element, prohibition);
            }
        }, {
            key: "_registerPointerLockEvent",
            value: function _registerPointerLockEvent() {
                var _this = this, lockChangeAlert = function lockChangeAlert() {
                    var canvas = cc.game.canvas;
                    document.pointerLockElement === canvas || document.mozPointerLockElement === canvas ? _this._pointLocked = !0 : _this._pointLocked = !1;
                };
                "onpointerlockchange" in document ? document.addEventListener("pointerlockchange", lockChangeAlert, !1) : "onmozpointerlockchange" in document && document.addEventListener("mozpointerlockchange", lockChangeAlert, !1);
            }
        }, {
            key: "_registerWindowMouseEvents",
            value: function _registerWindowMouseEvents(element) {
                var _this2 = this;
                window.addEventListener("mousedown", (function() {
                    _this2._mousePressed = !0;
                }), !1), window.addEventListener("mouseup", (function(event) {
                    if (_this2._mousePressed) {
                        _this2._mousePressed = !1;
                        var position = _this2.getHTMLElementPosition(element), location = _this2.getPointByEvent(event, position);
                        if (!rect(position.left, position.top, position.width, position.height).contains(new Vec2(location.x, location.y))) {
                            _this2.handleTouchesEnd([ _this2.getTouchByXY(event, location.x, location.y, position) ]);
                            var _mouseEvent = _this2.getMouseEvent(location, position, EventMouse.UP);
                            _mouseEvent.setButton(event.button), eventManager.dispatchEvent(_mouseEvent);
                        }
                    }
                }), !1);
            }
        }, {
            key: "_registerElementMouseEvents",
            value: function _registerElementMouseEvents(element, prohibition) {
                var _this3 = this, listenDOMMouseEvent = function listenDOMMouseEvent(eventName, type, handler) {
                    element.addEventListener(eventName, (function(event) {
                        var pos = _this3.getHTMLElementPosition(element), location = _this3.getPointByEvent(event, pos), mouseEvent = _this3.getMouseEvent(location, pos, type);
                        mouseEvent.setButton(event.button), handler(event, mouseEvent, location, pos), eventManager.dispatchEvent(mouseEvent), 
                        event.stopPropagation(), event.preventDefault();
                    }));
                };
                prohibition || (listenDOMMouseEvent("mousedown", EventMouse.DOWN, (function(event, mouseEvent, location, pos) {
                    _this3._mousePressed = !0, _this3.handleTouchesBegin([ _this3.getTouchByXY(event, location.x, location.y, pos) ]), 
                    element.focus();
                })), listenDOMMouseEvent("mouseup", EventMouse.UP, (function(event, mouseEvent, location, pos) {
                    _this3._mousePressed = !1, _this3.handleTouchesEnd([ _this3.getTouchByXY(event, location.x, location.y, pos) ]);
                })), listenDOMMouseEvent("mousemove", EventMouse.MOVE, (function(event, mouseEvent, location, pos) {
                    _this3.handleTouchesMove([ _this3.getTouchByXY(event, location.x, location.y, pos) ]), 
                    _this3._mousePressed || mouseEvent.setButton(null), void 0 !== event.movementX && void 0 !== event.movementY && (mouseEvent.movementX = event.movementX, 
                    mouseEvent.movementY = event.movementY);
                }))), listenDOMMouseEvent("mousewheel", EventMouse.SCROLL, (function(event, mouseEvent, location, pos) {
                    mouseEvent.setScrollData(0, event.wheelDelta);
                })), listenDOMMouseEvent("DOMMouseScroll", EventMouse.SCROLL, (function(event, mouseEvent, location, pos) {
                    mouseEvent.setScrollData(0, -120 * event.detail);
                }));
            }
        }, {
            key: "_registerMousePointerEvents",
            value: function _registerMousePointerEvents(element) {
                var _this4 = this, _pointerEventsMap = {
                    MSPointerDown: this.handleTouchesBegin,
                    MSPointerMove: this.handleTouchesMove,
                    MSPointerUp: this.handleTouchesEnd,
                    MSPointerCancel: this.handleTouchesCancel
                }, _loop = function _loop(eventName) {
                    var touchEvent = _pointerEventsMap[eventName];
                    element.addEventListener(eventName, (function(event) {
                        var pos = _this4.getHTMLElementPosition(element);
                        pos.left -= document.documentElement.scrollLeft, pos.top -= document.documentElement.scrollTop, 
                        touchEvent.call(_this4, [ _this4.getTouchByXY(event, event.clientX, event.clientY, pos) ]), 
                        event.stopPropagation();
                    }), !1);
                };
                for (var eventName in _pointerEventsMap) _loop(eventName);
            }
        }, {
            key: "_registerTouchEvents",
            value: function _registerTouchEvents(element) {
                cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? this._registerWXGameTouchEvents(element) : this._registerHTMLTouchEvents(element);
            }
        }, {
            key: "_registerWXGameTouchEvents",
            value: function _registerWXGameTouchEvents(element) {
                var _this5 = this, makeTouchListener = function makeTouchListener(touchesHandler) {
                    return function(event) {
                        var pos = _this5.getHTMLElementPosition(element), body = document.body;
                        pos.left -= body.scrollLeft || 0, pos.top -= body.scrollTop || 0, touchesHandler(_this5.getTouchesByEvent(event, pos));
                    };
                };
                wx.onTouchStart(makeTouchListener((function(touchesToHandle) {
                    _this5.handleTouchesBegin(touchesToHandle);
                }))), wx.onTouchEnd(makeTouchListener((function(touchesToHandle) {
                    _this5.handleTouchesEnd(touchesToHandle);
                }))), wx.onTouchMove(makeTouchListener((function(touchesToHandle) {
                    _this5.handleTouchesMove(touchesToHandle);
                }))), wx.onTouchCancel(makeTouchListener((function(touchesToHandle) {
                    _this5.handleTouchesCancel(touchesToHandle);
                })));
            }
        }, {
            key: "_registerHTMLTouchEvents",
            value: function _registerHTMLTouchEvents(element) {
                var _this6 = this, makeTouchListener = function makeTouchListener(touchesHandler) {
                    return function(event) {
                        if (event.changedTouches) {
                            var pos = _this6.getHTMLElementPosition(element), body = document.body;
                            pos.left -= body.scrollLeft || 0, pos.top -= body.scrollTop || 0, touchesHandler(_this6.getTouchesByEvent(event, pos)), 
                            event.stopPropagation(), event.preventDefault();
                        }
                    };
                };
                element.addEventListener("touchstart", makeTouchListener((function(touchesToHandle) {
                    _this6.handleTouchesBegin(touchesToHandle), sys.platform !== sys.WECHAT_GAME && element.focus();
                })), !1), element.addEventListener("touchmove", makeTouchListener((function(touchesToHandle) {
                    _this6.handleTouchesMove(touchesToHandle);
                })), !1), element.addEventListener("touchend", makeTouchListener((function(touchesToHandle) {
                    _this6.handleTouchesEnd(touchesToHandle);
                })), !1), element.addEventListener("touchcancel", makeTouchListener((function(touchesToHandle) {
                    _this6.handleTouchesCancel(touchesToHandle);
                })), !1);
            }
        }, {
            key: "_registerKeyboardEvent",
            value: function _registerKeyboardEvent() {
                var canvas = cc.game.canvas;
                canvas.addEventListener("keydown", (function(event) {
                    eventManager.dispatchEvent(new EventKeyboard(event, !0)), event.stopPropagation(), 
                    event.preventDefault();
                }), !1), canvas.addEventListener("keyup", (function(event) {
                    eventManager.dispatchEvent(new EventKeyboard(event, !1)), event.stopPropagation(), 
                    event.preventDefault();
                }), !1);
            }
        }, {
            key: "_registerAccelerometerEvent",
            value: function _registerAccelerometerEvent() {
                var _this7 = this;
                this._acceleration = new Acceleration$1, this._accelDeviceEvent = window.DeviceMotionEvent || window.DeviceOrientationEvent, 
                cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
                var _deviceEventType = this._accelDeviceEvent === window.DeviceMotionEvent ? "devicemotion" : "deviceorientation", ua = navigator.userAgent;
                (/Android/.test(ua) || /Adr/.test(ua) && cc.sys.browserType === cc.BROWSER_TYPE_UC) && (this._minus = -1), 
                _didAccelerateFun = function _didAccelerateFun() {
                    return _this7.didAccelerate.apply(_this7, arguments);
                }, window.addEventListener(_deviceEventType, _didAccelerateFun, !1);
            }
        }, {
            key: "_unregisterAccelerometerEvent",
            value: function _unregisterAccelerometerEvent() {
                var _deviceEventType = this._accelDeviceEvent === window.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
                _didAccelerateFun && window.removeEventListener(_deviceEventType, _didAccelerateFun, !1);
            }
        } ]), InputManager;
    }());
    game.once(Game.EVENT_ENGINE_INITED, (function() {
        game.config.registerSystemEvent && inputManager.registerSystemEvent(game.canvas);
    })), cc.internal.inputManager = inputManager;
    var keyboardListener = null, accelerationListener = null, touchListener = null, mouseListener = null, SystemEvent = function(_EventTarget) {
        function SystemEvent() {
            return _classCallCheck(this, SystemEvent), _possibleConstructorReturn(this, _getPrototypeOf(SystemEvent).call(this));
        }
        return _inherits(SystemEvent, _EventTarget), _createClass(SystemEvent, [ {
            key: "setAccelerometerEnabled",
            value: function setAccelerometerEnabled(isEnable) {
                inputManager.setAccelerometerEnabled(isEnable);
            }
        }, {
            key: "setAccelerometerInterval",
            value: function setAccelerometerInterval(interval) {
                inputManager.setAccelerometerInterval(interval);
            }
        }, {
            key: "on",
            value: function on(type, callback, target) {
                return _get(_getPrototypeOf(SystemEvent.prototype), "on", this).call(this, type, callback, target), 
                type !== exports.SystemEventType.KEY_DOWN && type !== exports.SystemEventType.KEY_UP || keyboardListener || (keyboardListener = EventListener.create({
                    event: EventListener.KEYBOARD,
                    onKeyPressed: function onKeyPressed(keyCode, event) {
                        event.type = exports.SystemEventType.KEY_DOWN, systemEvent.emit(event.type, event);
                    },
                    onKeyReleased: function onKeyReleased(keyCode, event) {
                        event.type = exports.SystemEventType.KEY_UP, systemEvent.emit(event.type, event);
                    }
                }), eventManager.addListener(keyboardListener, 256)), type === exports.SystemEventType.DEVICEMOTION && (accelerationListener || (accelerationListener = EventListener.create({
                    event: EventListener.ACCELERATION,
                    callback: function callback(acc, event) {
                        event.type = exports.SystemEventType.DEVICEMOTION, cc.systemEvent.emit(event.type, event);
                    }
                }), eventManager.addListener(accelerationListener, 256))), type !== exports.SystemEventType.TOUCH_START && type !== exports.SystemEventType.TOUCH_MOVE && type !== exports.SystemEventType.TOUCH_END && type !== exports.SystemEventType.TOUCH_CANCEL || touchListener || (touchListener = EventListener.create({
                    event: EventListener.TOUCH_ONE_BY_ONE,
                    onTouchBegan: function onTouchBegan(touch, event) {
                        return event.type = exports.SystemEventType.TOUCH_START, cc.systemEvent.emit(event.type, touch, event), 
                        !0;
                    },
                    onTouchMoved: function onTouchMoved(touch, event) {
                        event.type = exports.SystemEventType.TOUCH_MOVE, cc.systemEvent.emit(event.type, touch, event);
                    },
                    onTouchEnded: function onTouchEnded(touch, event) {
                        event.type = exports.SystemEventType.TOUCH_END, cc.systemEvent.emit(event.type, touch, event);
                    },
                    onTouchCancelled: function onTouchCancelled(touch, event) {
                        event.type = exports.SystemEventType.TOUCH_CANCEL, cc.systemEvent.emit(event.type, touch, event);
                    }
                }), eventManager.addListener(touchListener, 256)), type !== exports.SystemEventType.MOUSE_DOWN && type !== exports.SystemEventType.MOUSE_MOVE && type !== exports.SystemEventType.MOUSE_UP && type !== exports.SystemEventType.MOUSE_WHEEL || mouseListener || (mouseListener = EventListener.create({
                    event: EventListener.MOUSE,
                    onMouseDown: function onMouseDown(event) {
                        event.type = exports.SystemEventType.MOUSE_DOWN, cc.systemEvent.emit(event.type, event);
                    },
                    onMouseMove: function onMouseMove(event) {
                        event.type = exports.SystemEventType.MOUSE_MOVE, cc.systemEvent.emit(event.type, event);
                    },
                    onMouseUp: function onMouseUp(event) {
                        event.type = exports.SystemEventType.MOUSE_UP, cc.systemEvent.emit(event.type, event);
                    },
                    onMouseScroll: function onMouseScroll(event) {
                        event.type = exports.SystemEventType.MOUSE_WHEEL, cc.systemEvent.emit(event.type, event);
                    }
                }), eventManager.addListener(mouseListener, 256)), callback;
            }
        }, {
            key: "off",
            value: function off(type, callback, target) {
                if (_get(_getPrototypeOf(SystemEvent.prototype), "off", this).call(this, type, callback, target), 
                keyboardListener && (type === exports.SystemEventType.KEY_DOWN || type === exports.SystemEventType.KEY_UP)) {
                    var hasKeyDownEventListener = this.hasEventListener(exports.SystemEventType.KEY_DOWN), hasKeyUpEventListener = this.hasEventListener(exports.SystemEventType.KEY_UP);
                    hasKeyDownEventListener || hasKeyUpEventListener || (eventManager.removeListener(keyboardListener), 
                    keyboardListener = null);
                }
                if (accelerationListener && type === exports.SystemEventType.DEVICEMOTION && (eventManager.removeListener(accelerationListener), 
                accelerationListener = null), touchListener && (type === exports.SystemEventType.TOUCH_START || type === exports.SystemEventType.TOUCH_MOVE || type === exports.SystemEventType.TOUCH_END || type === exports.SystemEventType.TOUCH_CANCEL)) {
                    var hasTouchStart = this.hasEventListener(exports.SystemEventType.TOUCH_START), hasTouchMove = this.hasEventListener(exports.SystemEventType.TOUCH_MOVE), hasTouchEnd = this.hasEventListener(exports.SystemEventType.TOUCH_END), hasTouchCancel = this.hasEventListener(exports.SystemEventType.TOUCH_CANCEL);
                    hasTouchStart || hasTouchMove || hasTouchEnd || hasTouchCancel || (eventManager.removeListener(touchListener), 
                    touchListener = null);
                }
                if (mouseListener && (type === exports.SystemEventType.MOUSE_DOWN || type === exports.SystemEventType.MOUSE_MOVE || type === exports.SystemEventType.MOUSE_UP || type === exports.SystemEventType.MOUSE_WHEEL)) {
                    var hasMouseDown = this.hasEventListener(exports.SystemEventType.MOUSE_DOWN), hasMouseMove = this.hasEventListener(exports.SystemEventType.MOUSE_MOVE), hasMouseUp = this.hasEventListener(exports.SystemEventType.MOUSE_UP), hasMouseWheel = this.hasEventListener(exports.SystemEventType.MOUSE_WHEEL);
                    hasMouseDown || hasMouseMove || hasMouseUp || hasMouseWheel || (eventManager.removeListener(mouseListener), 
                    mouseListener = null);
                }
            }
        } ]), SystemEvent;
    }(EventTarget);
    SystemEvent.EventType = exports.SystemEventType, cc.SystemEvent = SystemEvent;
    var systemEvent = new SystemEvent;
    cc.systemEvent = systemEvent, exports.replaceProperty(exports.SystemEventType, "Node.EventType", [ {
        name: "POSITION_PART",
        newName: "TRANSFORM_CHANGED"
    }, {
        name: "ROTATION_PART",
        newName: "TRANSFORM_CHANGED"
    }, {
        name: "SCALE_PART",
        newName: "TRANSFORM_CHANGED"
    } ]);
    var screen$1 = {
        _supportsFullScreen: !1,
        _preOnFullScreenChange: null,
        _touchEvent: "",
        _fn: null,
        _fnMap: [ [ "requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement" ], [ "requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement" ], [ "webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement" ], [ "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement" ] ],
        init: function init() {
            this._fn = {};
            var i, l, val, valL, map = this._fnMap;
            for (i = 0, l = map.length; i < l; i++) if ((val = map[i]) && void 0 !== document[val[1]]) {
                for (i = 0, valL = val.length; i < valL; i++) this._fn[map[0][i]] = val[i];
                break;
            }
            this._supportsFullScreen = void 0 !== this._fn.requestFullscreen, this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown";
        },
        fullScreen: function fullScreen() {
            return !!this._supportsFullScreen && (void 0 !== document[this._fn.fullscreenElement] && null !== document[this._fn.fullscreenElement]);
        },
        requestFullScreen: function requestFullScreen(element, onFullScreenChange) {
            if (this._supportsFullScreen) {
                if (element = element || document.documentElement, onFullScreenChange) {
                    var eventName = this._fn.fullscreenchange;
                    this._preOnFullScreenChange && document.removeEventListener(eventName, this._preOnFullScreenChange), 
                    this._preOnFullScreenChange = onFullScreenChange, document.addEventListener(eventName, onFullScreenChange, !1);
                }
                return element[this._fn.requestFullscreen]();
            }
        },
        exitFullScreen: function exitFullScreen() {
            return !this._supportsFullScreen || document[this._fn.exitFullscreen]();
        },
        autoFullScreen: function autoFullScreen(element, onFullScreenChange) {
            element = element || document.body;
            var touchTarget = cc.game.canvas || element, theScreen = this;
            this.requestFullScreen(element, onFullScreenChange), touchTarget.addEventListener(this._touchEvent, (function callback() {
                touchTarget.removeEventListener(theScreen._touchEvent, callback), theScreen.requestFullScreen(element, onFullScreenChange);
            }));
        }
    };
    screen$1.init(), cc.screen = screen$1;
    var RenderQueue$1, PassStage, _stageOffset = 0, _name2stageID = {}, config_addStage = function addStage(name) {
        if (void 0 === _name2stageID[name]) {
            var stageID = 1 << _stageOffset;
            _name2stageID[name] = stageID, _stageOffset += 1;
        }
    };
    !function(RenderQueue) {
        RenderQueue[RenderQueue.OPAQUE = 0] = "OPAQUE", RenderQueue[RenderQueue.TRANSPARENT = 1] = "TRANSPARENT", 
        RenderQueue[RenderQueue.OVERLAY = 2] = "OVERLAY";
    }(RenderQueue$1 || (RenderQueue$1 = {})), function(PassStage) {
        PassStage[PassStage.DEFAULT = 1] = "DEFAULT", PassStage[PassStage.FORWARD = 2] = "FORWARD", 
        PassStage[PassStage.SHADOWCAST = 4] = "SHADOWCAST";
    }(PassStage || (PassStage = {}));
    var _keyMap, SkinningModel = function(_Model) {
        function SkinningModel() {
            var _this;
            _classCallCheck(this, SkinningModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SkinningModel).call(this))).uploadedAnim = void 0, 
            _this._skeleton = null, _this._staticModelBounds = null, _this._mesh = null, _this._type = "skinning", 
            _this._dataPoolManager = cc.director.root.dataPoolManager;
            var jointsTextureInfo = new Float32Array(4), texture = _this._dataPoolManager.jointsTexturePool.getDefaultJointsTexture(), animInfo = _this._dataPoolManager.jointsAnimationInfo.get();
            return _this._jointsMedium = {
                buffer: null,
                jointsTextureInfo: jointsTextureInfo,
                texture: texture,
                animInfo: animInfo,
                boundsInfo: null
            }, _this;
        }
        return _inherits(SkinningModel, _Model), _createClass(SkinningModel, [ {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(SkinningModel.prototype), "destroy", this).call(this), this._jointsMedium.buffer && (this._jointsMedium.buffer.destroy(), 
                this._jointsMedium.buffer = null, this.uploadedAnim = void 0);
            }
        }, {
            key: "bindSkeleton",
            value: function bindSkeleton(skeleton, skinningRoot, mesh) {
                this._skeleton = skeleton, this._mesh = mesh, skeleton && skinningRoot && mesh && (this._transform = skinningRoot, 
                this._jointsMedium.animInfo = this._dataPoolManager.jointsAnimationInfo.get(skinningRoot.uuid), 
                this._jointsMedium.buffer || (this._jointsMedium.buffer = this._device.createBuffer({
                    usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: UBOSkinningTexture.SIZE,
                    stride: UBOSkinningTexture.SIZE
                })));
            }
        }, {
            key: "updateTransform",
            value: function updateTransform() {
                if (_get(_getPrototypeOf(SkinningModel.prototype), "updateTransform", this).call(this), 
                this.uploadedAnim) {
                    var _this$_jointsMedium = this._jointsMedium, animInfo = _this$_jointsMedium.animInfo, skelBound = _this$_jointsMedium.boundsInfo[animInfo.data[1]], node = this._transform;
                    this._worldBounds && skelBound && skelBound.transform(node._mat, node._pos, node._rot, node._scale, this._worldBounds);
                }
            }
        }, {
            key: "updateUBOs",
            value: function updateUBOs() {
                if (!_get(_getPrototypeOf(SkinningModel.prototype), "updateUBOs", this).call(this)) return !1;
                var info = this._jointsMedium.animInfo;
                return info.dirty && (info.buffer.update(info.data), info.dirty = !1), !0;
            }
        }, {
            key: "createBoundingShape",
            value: function createBoundingShape(minPos, maxPos) {
                _get(_getPrototypeOf(SkinningModel.prototype), "createBoundingShape", this).call(this, minPos, maxPos), 
                this._staticModelBounds = this._modelBounds && aabb.clone(this._modelBounds);
            }
        }, {
            key: "uploadAnimation",
            value: function uploadAnimation(anim) {
                if (this._skeleton && this._mesh && this.uploadedAnim !== anim) {
                    this.uploadedAnim = anim;
                    var resMgr = this._dataPoolManager, texture = anim ? resMgr.jointsTexturePool.getJointsTextureWithAnimation(this._skeleton, anim) : resMgr.jointsTexturePool.getDefaultJointsTexture(this._skeleton);
                    resMgr.jointsAnimationInfo.switchClip(this._jointsMedium.animInfo, anim), this._applyJointsTexture(texture), 
                    this._jointsMedium.boundsInfo = anim ? resMgr.animatedBoundsInfo.get(this._mesh, this._skeleton, anim) : null, 
                    this._modelBounds = anim ? null : this._staticModelBounds;
                }
            }
        }, {
            key: "_applyJointsTexture",
            value: function _applyJointsTexture(texture) {
                if (texture) {
                    var oldTex = this._jointsMedium.texture;
                    oldTex && oldTex !== texture && this._dataPoolManager.jointsTexturePool.releaseHandle(oldTex), 
                    this._jointsMedium.texture = texture;
                    var _this$_jointsMedium2 = this._jointsMedium, buffer = _this$_jointsMedium2.buffer, jointsTextureInfo = _this$_jointsMedium2.jointsTextureInfo;
                    jointsTextureInfo[0] = texture.handle.texture.width, jointsTextureInfo[1] = 1 / jointsTextureInfo[0], 
                    jointsTextureInfo[2] = texture.pixelOffset + .1, buffer && buffer.update(jointsTextureInfo);
                    var sampler = samplerLib.getSampler(this._device, jointsTextureSamplerHash), _iterator = this._subModels, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var submodel = _ref;
                        if (submodel.psos) {
                            var _iterator3 = submodel.psos, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                var _ref3;
                                if (_isArray3) {
                                    if (_i3 >= _iterator3.length) break;
                                    _ref3 = _iterator3[_i3++];
                                } else {
                                    if ((_i3 = _iterator3.next()).done) break;
                                    _ref3 = _i3.value;
                                }
                                var bindingLayout = _ref3.pipelineLayout.layouts[0];
                                bindingLayout.bindTextureView(UniformJointsTexture.binding, texture.handle.texView), 
                                bindingLayout.bindSampler(UniformJointsTexture.binding, sampler);
                            }
                        }
                    }
                    var _iterator2 = this._implantPSOs, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var _bindingLayout = _ref2.pipelineLayout.layouts[0];
                        _bindingLayout.bindTextureView(UniformJointsTexture.binding, texture.handle.texView), 
                        _bindingLayout.bindSampler(UniformJointsTexture.binding, sampler), _bindingLayout.update();
                    }
                }
            }
        }, {
            key: "createPipelineState",
            value: function createPipelineState(pass) {
                var pso = _get(_getPrototypeOf(SkinningModel.prototype), "createPipelineState", this).call(this, pass), _this$_jointsMedium3 = this._jointsMedium, buffer = _this$_jointsMedium3.buffer, texture = _this$_jointsMedium3.texture, animInfo = _this$_jointsMedium3.animInfo, bindingLayout = pso.pipelineLayout.layouts[0];
                bindingLayout.bindBuffer(UBOSkinningTexture.BLOCK.binding, buffer), bindingLayout.bindBuffer(UBOSkinningAnimation.BLOCK.binding, animInfo.buffer);
                var sampler = samplerLib.getSampler(this._device, jointsTextureSamplerHash);
                return texture && (bindingLayout.bindTextureView(UniformJointsTexture.binding, texture.handle.texView), 
                bindingLayout.bindSampler(UniformJointsTexture.binding, sampler)), pso;
            }
        } ]), SkinningModel;
    }(Model), _forward = new Vec3(0, 0, -1), _v3$1 = new Vec3, _ab = new aabb, _qt$1 = new Quat, _info$1 = {
        allocator: null,
        type: exports.GFXCommandBufferType.SECONDARY
    }, PlanarShadows = function() {
        function PlanarShadows(scene) {
            _classCallCheck(this, PlanarShadows), this._enabled = !1, this._normal = new Vec3(0, 1, 0), 
            this._distance = 0, this._matLight = new Mat4, this._data = Float32Array.from([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, .3 ]), 
            this._cmdBuffCount = 0, this._psoRecord = new Map, this._cbRecord = new Map, this._scene = scene, 
            this._globalBindings = scene.root.pipeline.globalBindings.get(UBOShadow.BLOCK.name), 
            this._cmdBuffs = new CachedArray(64), this._matNormal = new Material, this._matNormal.initialize({
                effectName: "pipeline/planar-shadow"
            }), this._matSkinning = new Material, this._matSkinning.initialize({
                effectName: "pipeline/planar-shadow",
                defines: {
                    USE_SKINNING: !0
                }
            });
        }
        return _createClass(PlanarShadows, [ {
            key: "enabled",
            set: function set(enable) {
                this._enabled = enable, this._scene.mainLight && this.updateDirLight(this._scene.mainLight), 
                this._cmdBuffs.clear();
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "normal",
            set: function set(val) {
                Vec3.copy(this._normal, val), this._scene.mainLight && this.updateDirLight(this._scene.mainLight);
            },
            get: function get() {
                return this._normal;
            }
        }, {
            key: "distance",
            set: function set(val) {
                this._distance = val, this._scene.mainLight && this.updateDirLight(this._scene.mainLight);
            },
            get: function get() {
                return this._distance;
            }
        }, {
            key: "shadowColor",
            set: function set(color) {
                Color.toArray(this._data, color, UBOShadow.SHADOW_COLOR_OFFSET), this._globalBindings.buffer.update(this.data);
            }
        }, {
            key: "matLight",
            get: function get() {
                return this._matLight;
            }
        }, {
            key: "data",
            get: function get() {
                return this._data;
            }
        }, {
            key: "cmdBuffs",
            get: function get() {
                return this._cmdBuffs;
            }
        }, {
            key: "cmdBuffCount",
            get: function get() {
                return this._cmdBuffs.length;
            }
        } ]), _createClass(PlanarShadows, [ {
            key: "updateSphereLight",
            value: function updateSphereLight(light) {
                light.node.getWorldPosition(_v3$1);
                var n = this._normal, d = this._distance + .001, NdL = Vec3.dot(n, _v3$1), lx = _v3$1.x, ly = _v3$1.y, lz = _v3$1.z, nx = n.x, ny = n.y, nz = n.z, m = this._matLight;
                m.m00 = NdL - d - lx * nx, m.m01 = -ly * nx, m.m02 = -lz * nx, m.m03 = -nx, m.m04 = -lx * ny, 
                m.m05 = NdL - d - ly * ny, m.m06 = -lz * ny, m.m07 = -ny, m.m08 = -lx * nz, m.m09 = -ly * nz, 
                m.m10 = NdL - d - lz * nz, m.m11 = -nz, m.m12 = lx * d, m.m13 = ly * d, m.m14 = lz * d, 
                m.m15 = NdL, Mat4.toArray(this.data, this._matLight), this._globalBindings.buffer.update(this.data);
            }
        }, {
            key: "updateDirLight",
            value: function updateDirLight(light) {
                light.node.getWorldRotation(_qt$1), Vec3.transformQuat(_v3$1, _forward, _qt$1);
                var n = this._normal, d = this._distance + .001, scale = 1 / Vec3.dot(n, _v3$1), lx = _v3$1.x * scale, ly = _v3$1.y * scale, lz = _v3$1.z * scale, nx = n.x, ny = n.y, nz = n.z, m = this._matLight;
                m.m00 = 1 - nx * lx, m.m01 = -nx * ly, m.m02 = -nx * lz, m.m03 = 0, m.m04 = -ny * lx, 
                m.m05 = 1 - ny * ly, m.m06 = -ny * lz, m.m07 = 0, m.m08 = -nz * lx, m.m09 = -nz * ly, 
                m.m10 = 1 - nz * lz, m.m11 = 0, m.m12 = lx * d, m.m13 = ly * d, m.m14 = lz * d, 
                m.m15 = 1, Mat4.toArray(this.data, this._matLight, UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET), 
                this._globalBindings.buffer.update(this.data);
            }
        }, {
            key: "updateCommandBuffers",
            value: function updateCommandBuffers(frstm) {
                if (this._cmdBuffs.clear(), this._scene.mainLight) {
                    var _iterator = this._scene.models, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var model = _ref;
                        if (model.enabled && model.node && model.castShadow && (!model.worldBounds || (aabb.transform(_ab, model.worldBounds, this._matLight), 
                        intersect.aabb_frustum(_ab, frstm)))) {
                            var pso = this._psoRecord.get(model), newOne = !1;
                            pso || (pso = this._createPSO(model), this._psoRecord.set(model, pso), newOne = !0), 
                            model.UBOUpdated || model.updateUBOs();
                            for (var i = 0; i < model.subModelNum; i++) {
                                var ia = model.getSubModel(i).inputAssembler;
                                if (ia) {
                                    var cb = this._cbRecord.get(ia);
                                    !newOne && cb || ((cb = this._createOrReuseCommandBuffer(cb)).begin(), cb.bindPipelineState(pso), 
                                    cb.bindBindingLayout(pso.pipelineLayout.layouts[0]), cb.bindInputAssembler(ia), 
                                    cb.draw(ia), cb.end(), this._cbRecord.set(ia, cb)), this.cmdBuffs.push(cb);
                                }
                            }
                        }
                    }
                }
            }
        }, {
            key: "destroyShadowModel",
            value: function destroyShadowModel(model) {
                var pso = this._psoRecord.get(model);
                pso && (this._destroyPSO(model, pso), this._psoRecord.delete(model));
                for (var i = 0; i < model.subModelNum; i++) {
                    var ia = model.getSubModel(i).inputAssembler, cb = this._cbRecord.get(ia);
                    ia && cb && (cb.destroy(), this._cbRecord.delete(ia));
                }
            }
        }, {
            key: "onGlobalPipelineStateChanged",
            value: function onGlobalPipelineStateChanged() {
                for (var cbs = this._cbRecord.values(), cbRes = cbs.next(); !cbRes.done; ) cbRes.value.destroy(), 
                cbRes = cbs.next();
                this._cbRecord.clear();
                for (var models = this._psoRecord.keys(), modelRes = models.next(); !modelRes.done; ) this._destroyPSO(modelRes.value, this._psoRecord.get(modelRes.value)), 
                modelRes = models.next();
                this._psoRecord.clear();
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.onGlobalPipelineStateChanged(), this._matNormal.destroy(), this._matSkinning.destroy();
            }
        }, {
            key: "_createPSO",
            value: function _createPSO(model) {
                var mat = model instanceof SkinningModel ? this._matSkinning : this._matNormal, pso = model.createPipelineState(mat.passes[0]);
                return model.insertImplantPSO(pso), pso.pipelineLayout.layouts[0].update(), pso;
            }
        }, {
            key: "_destroyPSO",
            value: function _destroyPSO(model, pso) {
                var mat = model instanceof SkinningModel ? this._matSkinning : this._matNormal;
                model.removeImplantPSO(pso), mat.passes[0].destroyPipelineState(pso);
            }
        }, {
            key: "_createOrReuseCommandBuffer",
            value: function _createOrReuseCommandBuffer(cb) {
                var device = this._scene.root.device;
                return _info$1.allocator = device.commandAllocator, cb ? (cb.status === exports.GFXStatus.SUCCESS && cb.destroy(), 
                cb.initialize(_info$1)) : cb = device.createCommandBuffer(_info$1), cb;
            }
        } ]), PlanarShadows;
    }();
    !function(_keyMap) {
        _keyMap[_keyMap.positions = exports.GFXAttributeName.ATTR_POSITION] = "positions", 
        _keyMap[_keyMap.normals = exports.GFXAttributeName.ATTR_NORMAL] = "normals", _keyMap[_keyMap.uvs = exports.GFXAttributeName.ATTR_TEX_COORD] = "uvs", 
        _keyMap[_keyMap.colors = exports.GFXAttributeName.ATTR_COLOR] = "colors";
    }(_keyMap || (_keyMap = {}));
    var _defAttrs = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_NORMAL,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RG32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA32F
    } ], v3_1$6 = new Vec3;
    function createMesh(geometry, out, options) {
        options = options || {};
        var attr, attributes = [], stride = 0, channels = [], vertCount = 0;
        if (geometry.positions.length > 0) {
            if (attr = null, geometry.attributes) {
                var _iterator = geometry.attributes, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var att = _ref;
                    if (att.name === exports.GFXAttributeName.ATTR_POSITION) {
                        attr = att;
                        break;
                    }
                }
            }
            attr || (attr = _defAttrs[0]);
            var info = GFXFormatInfos[attr.format];
            attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.positions.length / info.count)), 
            channels.push({
                offset: stride,
                data: geometry.positions,
                attribute: attr
            }), stride += info.size;
        }
        if (geometry.normals && geometry.normals.length > 0) {
            if (attr = null, geometry.attributes) {
                var _iterator2 = geometry.attributes, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var _att = _ref2;
                    if (_att.name === exports.GFXAttributeName.ATTR_NORMAL) {
                        attr = _att;
                        break;
                    }
                }
            }
            attr || (attr = _defAttrs[1]);
            var _info = GFXFormatInfos[attr.format];
            attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.normals.length / _info.count)), 
            channels.push({
                offset: stride,
                data: geometry.normals,
                attribute: attr
            }), stride += _info.size;
        }
        if (geometry.uvs && geometry.uvs.length > 0) {
            if (attr = null, geometry.attributes) {
                var _iterator3 = geometry.attributes, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var _att2 = _ref3;
                    if (_att2.name === exports.GFXAttributeName.ATTR_TEX_COORD) {
                        attr = _att2;
                        break;
                    }
                }
            }
            attr || (attr = _defAttrs[2]);
            var _info2 = GFXFormatInfos[attr.format];
            attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.uvs.length / _info2.count)), 
            channels.push({
                offset: stride,
                data: geometry.uvs,
                attribute: attr
            }), stride += _info2.size;
        }
        if (geometry.colors && geometry.colors.length > 0) {
            if (attr = null, geometry.attributes) {
                var _iterator4 = geometry.attributes, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var _att3 = _ref4;
                    if (_att3.name === exports.GFXAttributeName.ATTR_COLOR) {
                        attr = _att3;
                        break;
                    }
                }
            }
            attr || (attr = _defAttrs[3]);
            var _info3 = GFXFormatInfos[attr.format];
            attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.colors.length / _info3.count)), 
            channels.push({
                offset: stride,
                data: geometry.colors,
                attribute: attr
            }), stride += _info3.size;
        }
        if (geometry.customAttributes) {
            var _iterator5 = geometry.customAttributes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                var _ref5;
                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    if ((_i5 = _iterator5.next()).done) break;
                    _ref5 = _i5.value;
                }
                var ca = _ref5, _info4 = GFXFormatInfos[ca.attr.format];
                attributes.push(ca.attr), vertCount = Math.max(vertCount, Math.floor(ca.values.length / _info4.count)), 
                channels.push({
                    offset: stride,
                    data: ca.values,
                    attribute: ca.attr
                }), stride += _info4.size;
            }
        }
        for (var bufferBlob = new BufferBlob, vertexBuffer = new ArrayBuffer(vertCount * stride), vertexBufferView = new DataView(vertexBuffer), _i6 = 0, _channels = channels; _i6 < _channels.length; _i6++) {
            var channel = _channels[_i6];
            writeBuffer(vertexBufferView, channel.data, channel.attribute.format, channel.offset, stride);
        }
        bufferBlob.setNextAlignment(0);
        var vertexBundle = {
            attributes: attributes,
            view: {
                offset: bufferBlob.getLength(),
                length: vertexBuffer.byteLength,
                count: vertCount,
                stride: stride
            }
        };
        bufferBlob.addBuffer(vertexBuffer);
        var indexBuffer = null, idxCount = 0;
        if (geometry.indices) {
            var indices = geometry.indices;
            idxCount = indices.length, indexBuffer = new ArrayBuffer(2 * idxCount), writeBuffer(new DataView(indexBuffer), indices, exports.GFXFormat.R16UI);
        }
        var primitive = {
            primitiveMode: geometry.primitiveMode || exports.GFXPrimitiveMode.TRIANGLE_LIST,
            vertexBundelIndices: [ 0 ]
        };
        if (primitive.primitiveMode >= exports.GFXPrimitiveMode.TRIANGLE_LIST) {
            var geomInfo = Float32Array.from(geometry.positions);
            bufferBlob.setNextAlignment(4), primitive.geometricInfo = {
                doubleSided: geometry.doubleSided,
                view: {
                    offset: bufferBlob.getLength(),
                    length: geomInfo.byteLength,
                    count: geometry.positions.length / 4,
                    stride: 4
                }
            }, bufferBlob.addBuffer(geomInfo.buffer);
        }
        indexBuffer && (bufferBlob.setNextAlignment(2), primitive.indexView = {
            offset: bufferBlob.getLength(),
            length: indexBuffer.byteLength,
            count: idxCount,
            stride: 2
        }, bufferBlob.addBuffer(indexBuffer));
        var minPosition = geometry.minPos;
        if (!minPosition && options.calculateBounds) {
            minPosition = Vec3.set(new Vec3, 1 / 0, 1 / 0, 1 / 0);
            for (var iVertex = 0; iVertex < vertCount; ++iVertex) Vec3.set(v3_1$6, geometry.positions[3 * iVertex + 0], geometry.positions[3 * iVertex + 1], geometry.positions[3 * iVertex + 2]), 
            Vec3.min(minPosition, minPosition, v3_1$6);
        }
        var maxPosition = geometry.maxPos;
        if (!maxPosition && options.calculateBounds) {
            maxPosition = Vec3.set(new Vec3, -1 / 0, -1 / 0, -1 / 0);
            for (var _iVertex = 0; _iVertex < vertCount; ++_iVertex) Vec3.set(v3_1$6, geometry.positions[3 * _iVertex + 0], geometry.positions[3 * _iVertex + 1], geometry.positions[3 * _iVertex + 2]), 
            Vec3.max(maxPosition, maxPosition, v3_1$6);
        }
        var meshStruct = {
            vertexBundles: [ vertexBundle ],
            primitives: [ primitive ]
        };
        return minPosition && (meshStruct.minPosition = new Vec3(minPosition.x, minPosition.y, minPosition.z)), 
        maxPosition && (meshStruct.maxPosition = new Vec3(maxPosition.x, maxPosition.y, maxPosition.z)), 
        out || (out = new Mesh), out.reset({
            struct: meshStruct,
            data: new Uint8Array(bufferBlob.getCombined())
        }), out;
    }
    var utils = Object.freeze({
        __proto__: null,
        find: find,
        toPPM: function toPPM(buffer, w, h) {
            return "P3 ".concat(w, " ").concat(h, " 255\n").concat(buffer.filter((function(e, i) {
                return i % 4 < 3;
            })).toString(), "\n");
        },
        readMesh: function readMesh(mesh) {
            var iPrimitive = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, out = {
                positions: []
            }, dataView = new DataView(mesh._nativeAsset), struct = mesh.struct, primitive = struct.primitives[iPrimitive], _iterator = primitive.vertexBundelIndices, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var idx = _ref, bundle = struct.vertexBundles[idx], offset = bundle.view.offset, _bundle$view = bundle.view, length = _bundle$view.length, stride = _bundle$view.stride, _iterator2 = bundle.attributes, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var attr = _ref2, name = _keyMap[attr.name];
                    name && (out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, offset, length, stride))), 
                    offset += GFXFormatInfos[attr.format].size;
                }
            }
            var view = primitive.indexView;
            return out.indices = readBuffer(dataView, exports.GFXFormat["R".concat(8 * view.stride, "UI")], view.offset, view.length), 
            out;
        },
        createMesh: createMesh,
        readBuffer: readBuffer,
        writeBuffer: writeBuffer,
        mapBuffer: mapBuffer
    });
    function applyDefaultGeometryOptions(options) {
        return void 0 === (options = options || {}).includeNormal && (options.includeNormal = !0), 
        void 0 === options.includeUV && (options.includeUV = !0), options;
    }
    function box(options) {
        var ws = (options = options || {}).widthSegments || 1, hs = options.heightSegments || 1, ls = options.lengthSegments || 1, hw = (options.width || 1) / 2, hh = (options.height || 1) / 2, hl = (options.length || 1) / 2, corners = [ Vec3.set(c0, -hw, -hh, hl), Vec3.set(c1, hw, -hh, hl), Vec3.set(c2, hw, hh, hl), Vec3.set(c3, -hw, hh, hl), Vec3.set(c4, hw, -hh, -hl), Vec3.set(c5, -hw, -hh, -hl), Vec3.set(c6, -hw, hh, -hl), Vec3.set(c7, hw, hh, -hl) ], faceAxes = [ [ 2, 3, 1 ], [ 4, 5, 7 ], [ 7, 6, 2 ], [ 1, 0, 4 ], [ 1, 4, 2 ], [ 5, 0, 6 ] ], faceNormals = [ [ 0, 0, 1 ], [ 0, 0, -1 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 1, 0, 0 ], [ -1, 0, 0 ] ], positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-hw, -hh, -hl), maxPos = new Vec3(hw, hh, hl), boundingRadius = Math.sqrt(hw * hw + hh * hh + hl * hl);
        function _buildPlane(side, uSegments, vSegments) {
            var u, v, ix, iy, offset = positions.length / 3, faceAxe = faceAxes[side], faceNormal = faceNormals[side];
            for (iy = 0; iy <= vSegments; iy++) for (ix = 0; ix <= uSegments; ix++) if (u = ix / uSegments, 
            v = iy / vSegments, Vec3.lerp(temp1, corners[faceAxe[0]], corners[faceAxe[1]], u), 
            Vec3.lerp(temp2, corners[faceAxe[0]], corners[faceAxe[2]], v), Vec3.subtract(temp3, temp2, corners[faceAxe[0]]), 
            Vec3.add(r, temp1, temp3), positions.push(r.x, r.y, r.z), normals.push(faceNormal[0], faceNormal[1], faceNormal[2]), 
            uvs.push(u, v), ix < uSegments && iy < vSegments) {
                var useg1 = uSegments + 1, a = ix + iy * useg1, b = ix + (iy + 1) * useg1, c = ix + 1 + (iy + 1) * useg1, d = ix + 1 + iy * useg1;
                indices.push(offset + a, offset + d, offset + b), indices.push(offset + b, offset + d, offset + c);
            }
        }
        return _buildPlane(0, ws, hs), _buildPlane(4, ls, hs), _buildPlane(1, ws, hs), _buildPlane(5, ls, hs), 
        _buildPlane(3, ws, ls), _buildPlane(2, ws, ls), {
            positions: positions,
            normals: normals,
            uvs: uvs,
            indices: indices,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
    }
    var temp1 = new Vec3, temp2 = new Vec3, temp3 = new Vec3, r = new Vec3, c0 = new Vec3, c1 = new Vec3, c2 = new Vec3, c3 = new Vec3, c4 = new Vec3, c5 = new Vec3, c6 = new Vec3, c7 = new Vec3, temp1$1 = new Vec3(0, 0, 0), temp2$1 = new Vec3(0, 0, 0);
    function cylinder() {
        var radiusTop = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, radiusBottom = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .5, height = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2, opts = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, halfHeight = .5 * height, radialSegments = opts.radialSegments || 32, heightSegments = opts.heightSegments || 1, capped = void 0 === opts.capped || opts.capped, arc = opts.arc || 2 * Math.PI, cntCap = 0;
        capped || (radiusTop > 0 && cntCap++, radiusBottom > 0 && cntCap++);
        var vertCount = (radialSegments + 1) * (heightSegments + 1);
        capped && (vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap);
        var indexCount = radialSegments * heightSegments * 2 * 3;
        capped && (indexCount += radialSegments * cntCap * 3);
        var indices = new Array(indexCount), positions = new Array(3 * vertCount), normals = new Array(3 * vertCount), uvs = new Array(2 * vertCount), maxRadius = Math.max(radiusTop, radiusBottom), minPos = new Vec3(-maxRadius, -halfHeight, -maxRadius), maxPos = new Vec3(maxRadius, halfHeight, maxRadius), boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight), index = 0, indexOffset = 0;
        return generateTorso(), capped && (radiusBottom > 0 && generateCap(!1), radiusTop > 0 && generateCap(!0)), 
        {
            positions: positions,
            normals: normals,
            uvs: uvs,
            indices: indices,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
        function generateTorso() {
            for (var indexArray = [], r = radiusTop - radiusBottom, slope = r * r / height * Math.sign(r), y = 0; y <= heightSegments; y++) {
                for (var indexRow = [], v = y / heightSegments, radius = v * r + radiusBottom, x = 0; x <= radialSegments; ++x) {
                    var u = x / radialSegments, theta = u * arc, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                    positions[3 * index] = radius * sinTheta, positions[3 * index + 1] = v * height - halfHeight, 
                    positions[3 * index + 2] = radius * cosTheta, Vec3.normalize(temp1$1, Vec3.set(temp2$1, sinTheta, -slope, cosTheta)), 
                    normals[3 * index] = temp1$1.x, normals[3 * index + 1] = temp1$1.y, normals[3 * index + 2] = temp1$1.z, 
                    uvs[2 * index] = 2 * (1 - u) % 1, uvs[2 * index + 1] = v, indexRow.push(index), 
                    ++index;
                }
                indexArray.push(indexRow);
            }
            for (var _y = 0; _y < heightSegments; ++_y) for (var _x = 0; _x < radialSegments; ++_x) {
                var i1 = indexArray[_y][_x], i2 = indexArray[_y + 1][_x], i3 = indexArray[_y + 1][_x + 1], i4 = indexArray[_y][_x + 1];
                indices[indexOffset] = i1, ++indexOffset, indices[indexOffset] = i4, ++indexOffset, 
                indices[indexOffset] = i2, ++indexOffset, indices[indexOffset] = i4, ++indexOffset, 
                indices[indexOffset] = i3, ++indexOffset, indices[indexOffset] = i2, ++indexOffset;
            }
        }
        function generateCap(top) {
            for (var radius = top ? radiusTop : radiusBottom, sign = top ? 1 : -1, centerIndexStart = index, x = 1; x <= radialSegments; ++x) positions[3 * index] = 0, 
            positions[3 * index + 1] = halfHeight * sign, positions[3 * index + 2] = 0, normals[3 * index] = 0, 
            normals[3 * index + 1] = sign, normals[3 * index + 2] = 0, uvs[2 * index] = .5, 
            uvs[2 * index + 1] = .5, ++index;
            for (var centerIndexEnd = index, _x2 = 0; _x2 <= radialSegments; ++_x2) {
                var theta = _x2 / radialSegments * arc, cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
                positions[3 * index] = radius * sinTheta, positions[3 * index + 1] = halfHeight * sign, 
                positions[3 * index + 2] = radius * cosTheta, normals[3 * index] = 0, normals[3 * index + 1] = sign, 
                normals[3 * index + 2] = 0, uvs[2 * index] = .5 - .5 * sinTheta * sign, uvs[2 * index + 1] = .5 + .5 * cosTheta, 
                ++index;
            }
            for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
                var c = centerIndexStart + _x3, i = centerIndexEnd + _x3;
                top ? (indices[indexOffset] = i + 1, ++indexOffset, indices[indexOffset] = c, ++indexOffset, 
                indices[indexOffset] = i, ++indexOffset) : (indices[indexOffset] = c, ++indexOffset, 
                indices[indexOffset] = i + 1, ++indexOffset, indices[indexOffset] = i, ++indexOffset);
            }
        }
    }
    var temp1$2 = new Vec3(0, 0, 0), temp2$2 = new Vec3(0, 0, 0), temp3$1 = new Vec3(0, 0, 0), r$1 = new Vec3(0, 0, 0), c00 = new Vec3(0, 0, 0), c10 = new Vec3(0, 0, 0), c01 = new Vec3(0, 0, 0);
    var temp1$3 = new Vec3(0, 0, 0), temp2$3 = new Vec3(0, 0, 0);
    var primitives = Object.freeze({
        __proto__: null,
        box: box,
        cone: function cone() {
            var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, height = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, opts = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return cylinder(0, radius, height, opts);
        },
        cylinder: cylinder,
        plane: function plane$1(options) {
            var normalizedOptions = function applyDefaultPlaneOptions(options) {
                return (options = applyDefaultGeometryOptions(options)).width = options.width || 10, 
                options.length = options.length || 10, options.widthSegments = options.widthSegments || 10, 
                options.lengthSegments = options.lengthSegments || 10, options;
            }(options), width = normalizedOptions.width, length = normalizedOptions.length, uSegments = normalizedOptions.widthSegments, vSegments = normalizedOptions.lengthSegments, hw = .5 * width, hl = .5 * length, positions = [], uvs = [], indices = [], minPos = new Vec3(-hw, 0, -hl), maxPos = new Vec3(hw, 0, hl), boundingRadius = Math.sqrt(width * width + length * length);
            Vec3.set(c00, -hw, 0, hl), Vec3.set(c10, hw, 0, hl), Vec3.set(c01, -hw, 0, -hl);
            for (var y = 0; y <= vSegments; y++) for (var x = 0; x <= uSegments; x++) {
                var u = x / uSegments, v = y / vSegments;
                if (Vec3.lerp(temp1$2, c00, c10, u), Vec3.lerp(temp2$2, c00, c01, v), Vec3.subtract(temp3$1, temp2$2, c00), 
                Vec3.add(r$1, temp1$2, temp3$1), positions.push(r$1.x, r$1.y, r$1.z), normalizedOptions.includeUV && uvs.push(u, v), 
                x < uSegments && y < vSegments) {
                    var useg1 = uSegments + 1, a = x + y * useg1, b = x + (y + 1) * useg1, c = x + 1 + (y + 1) * useg1, d = x + 1 + y * useg1;
                    indices.push(a, d, b), indices.push(d, c, b);
                }
            }
            var result = {
                positions: positions,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
            };
            if (normalizedOptions.includeNormal) {
                var nVertex = (vSegments + 1) * (uSegments + 1), normals = new Array(3 * nVertex);
                result.normals = normals;
                for (var i = 0; i < nVertex; ++i) normals[3 * i + 0] = 0, normals[3 * i + 1] = 1, 
                normals[3 * i + 2] = 0;
            }
            return normalizedOptions.includeUV && (result.uvs = uvs), result;
        },
        quad: function quad(options) {
            var normalizedOptions = applyDefaultGeometryOptions(options), result = {
                positions: [ -.5, -.5, 0, -.5, .5, 0, .5, .5, 0, .5, -.5, 0 ],
                indices: [ 0, 3, 1, 3, 2, 1 ],
                minPos: {
                    x: -.5,
                    y: -.5,
                    z: 0
                },
                maxPos: {
                    x: .5,
                    y: .5,
                    z: 0
                },
                boundingRadius: Math.sqrt(.5)
            };
            return !1 !== normalizedOptions.includeNormal && (result.normals = [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ]), 
            !1 !== normalizedOptions.includeUV && (result.uvs = [ 0, 0, 0, 1, 1, 1, 1, 0 ]), 
            result;
        },
        sphere: function sphere$1() {
            for (var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, segments = void 0 !== opts.segments ? opts.segments : 32, positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-radius, -radius, -radius), maxPos = new Vec3(radius, radius, radius), boundingRadius = radius, lat = 0; lat <= segments; ++lat) for (var theta = lat * Math.PI / segments, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= segments; ++lon) {
                var phi = 2 * lon * Math.PI / segments - Math.PI / 2, sinPhi = Math.sin(phi), cosPhi = Math.cos(phi), x = sinPhi * sinTheta, y = cosTheta, z = cosPhi * sinTheta, u = lon / segments, v = lat / segments;
                if (positions.push(x * radius, y * radius, z * radius), normals.push(x, y, z), uvs.push(u, v), 
                lat < segments && lon < segments) {
                    var seg1 = segments + 1, a = seg1 * lat + lon, b = seg1 * (lat + 1) + lon, c = seg1 * (lat + 1) + lon + 1, d = seg1 * lat + lon + 1;
                    indices.push(a, d, b), indices.push(d, c, b);
                }
            }
            return {
                positions: positions,
                indices: indices,
                normals: normals,
                uvs: uvs,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
            };
        },
        torus: function torus() {
            for (var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .4, tube = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .1, opts = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, radialSegments = opts.radialSegments || 32, tubularSegments = opts.tubularSegments || 32, arc = opts.arc || 2 * Math.PI, positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-radius - tube, -tube, -radius - tube), maxPos = new Vec3(radius + tube, tube, radius + tube), boundingRadius = radius + tube, j = 0; j <= radialSegments; j++) for (var i = 0; i <= tubularSegments; i++) {
                var u = i / tubularSegments, v = j / radialSegments, u1 = u * arc, v1 = v * Math.PI * 2, x = (radius + tube * Math.cos(v1)) * Math.sin(u1), y = tube * Math.sin(v1), z = (radius + tube * Math.cos(v1)) * Math.cos(u1), nx = Math.sin(u1) * Math.cos(v1), ny = Math.sin(v1), nz = Math.cos(u1) * Math.cos(v1);
                if (positions.push(x, y, z), normals.push(nx, ny, nz), uvs.push(u, v), i < tubularSegments && j < radialSegments) {
                    var seg1 = tubularSegments + 1, a = seg1 * j + i, b = seg1 * (j + 1) + i, c = seg1 * (j + 1) + i + 1, d = seg1 * j + i + 1;
                    indices.push(a, d, b), indices.push(d, c, b);
                }
            }
            return {
                positions: positions,
                normals: normals,
                uvs: uvs,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
            };
        },
        capsule: function capsule$1() {
            var radiusTop = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, radiusBottom = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .5, height = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2, opts = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, torsoHeight = height - radiusTop - radiusBottom, sides = opts.sides || 32, heightSegments = opts.heightSegments || 32, bottomProp = radiusBottom / height, torProp = torsoHeight / height, topProp = radiusTop / height, bottomSegments = Math.floor(heightSegments * bottomProp), topSegments = Math.floor(heightSegments * topProp), torSegments = Math.floor(heightSegments * torProp), topOffset = torsoHeight + radiusBottom - height / 2, torOffset = radiusBottom - height / 2, bottomOffset = radiusBottom - height / 2, arc = opts.arc || 2 * Math.PI, positions = [], normals = [], uvs = [], indices = [], maxRadius = Math.max(radiusTop, radiusBottom), minPos = new Vec3(-maxRadius, -height / 2, -maxRadius), maxPos = new Vec3(maxRadius, height / 2, maxRadius), boundingRadius = height / 2, index = 0, indexArray = [];
            return generateBottom(), generateTorso(), generateTop(), {
                positions: positions,
                normals: normals,
                uvs: uvs,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
            };
            function generateTorso() {
                for (var slope = (radiusTop - radiusBottom) / torsoHeight, y = 0; y <= torSegments; y++) {
                    for (var indexRow = [], lat = y / torSegments, radius = lat * (radiusTop - radiusBottom) + radiusBottom, x = 0; x <= sides; ++x) {
                        var u = x / sides, v = lat * torProp + bottomProp, theta = u * arc - arc / 4, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                        positions.push(radius * sinTheta), positions.push(lat * torsoHeight + torOffset), 
                        positions.push(radius * cosTheta), Vec3.normalize(temp1$3, Vec3.set(temp2$3, sinTheta, -slope, cosTheta)), 
                        normals.push(temp1$3.x), normals.push(temp1$3.y), normals.push(temp1$3.z), uvs.push(u, v), 
                        indexRow.push(index), ++index;
                    }
                    indexArray.push(indexRow);
                }
                for (var _y = 0; _y < torSegments; ++_y) for (var _x = 0; _x < sides; ++_x) {
                    var i1 = indexArray[_y][_x], i2 = indexArray[_y + 1][_x], i3 = indexArray[_y + 1][_x + 1], i4 = indexArray[_y][_x + 1];
                    indices.push(i1), indices.push(i4), indices.push(i2), indices.push(i4), indices.push(i3), 
                    indices.push(i2);
                }
            }
            function generateBottom() {
                for (var lat = 0; lat <= bottomSegments; ++lat) for (var theta = lat * Math.PI / bottomSegments / 2, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= sides; ++lon) {
                    var phi = 2 * lon * Math.PI / sides - Math.PI / 2, x = Math.sin(phi) * sinTheta, y = cosTheta, z = Math.cos(phi) * sinTheta, u = lon / sides, v = lat / heightSegments;
                    if (positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom), 
                    normals.push(x, y, z), uvs.push(u, v), lat < bottomSegments && lon < sides) {
                        var seg1 = sides + 1, a = seg1 * lat + lon, b = seg1 * (lat + 1) + lon, c = seg1 * (lat + 1) + lon + 1, d = seg1 * lat + lon + 1;
                        indices.push(a, d, b), indices.push(d, c, b);
                    }
                    ++index;
                }
            }
            function generateTop() {
                for (var lat = 0; lat <= topSegments; ++lat) for (var theta = lat * Math.PI / topSegments / 2 + Math.PI / 2, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= sides; ++lon) {
                    var phi = 2 * lon * Math.PI / sides - Math.PI / 2, x = Math.sin(phi) * sinTheta, y = cosTheta, z = Math.cos(phi) * sinTheta, u = lon / sides, v = lat / heightSegments + (1 - topProp);
                    if (positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop), normals.push(x, y, z), 
                    uvs.push(u, v), lat < topSegments && lon < sides) {
                        var seg1 = sides + 1, a = seg1 * lat + lon + indexArray[torSegments][sides] + 1, b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1, c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1, d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;
                        indices.push(a, d, b), indices.push(d, c, b);
                    }
                }
            }
        },
        circle: function circle(options) {
            var segments = function applyDefaultCircleOptions(options) {
                return (options = applyDefaultGeometryOptions(options)).segments = 64, options;
            }(options).segments, positions = new Array(3 * (segments + 1));
            positions[0] = 0, positions[1] = 0, positions[2] = 0;
            var indices = new Array(1 + 2 * segments);
            indices[0] = 0;
            for (var step = 2 * Math.PI / segments, iSegment = 0; iSegment < segments; ++iSegment) {
                var angle = step * iSegment, x = Math.cos(angle), y = Math.sin(angle), p = 3 * (iSegment + 1);
                positions[p + 0] = x, positions[p + 1] = y, positions[p + 2] = 0;
                var i = 2 * iSegment;
                indices[1 + i] = iSegment + 1, indices[1 + (i + 1)] = iSegment + 2;
            }
            return segments > 0 && (indices[indices.length - 1] = 1), {
                positions: positions,
                indices: indices,
                minPos: {
                    x: 1,
                    y: 1,
                    z: 0
                },
                maxPos: {
                    x: -1,
                    y: -1,
                    z: 0
                },
                boundingRadius: 1,
                primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_FAN
            };
        },
        translate: function translate(geometry, offset) {
            for (var x = offset.x || 0, y = offset.y || 0, z = offset.z || 0, nVertex = Math.floor(geometry.positions.length / 3), iVertex = 0; iVertex < nVertex; ++iVertex) {
                var iX = 3 * iVertex, iY = 3 * iVertex + 1, iZ = 3 * iVertex + 2;
                geometry.positions[iX] = geometry.positions[iX] + x, geometry.positions[iY] = geometry.positions[iY] + y, 
                geometry.positions[iZ] = geometry.positions[iZ] + z;
            }
            return geometry.minPos && (geometry.minPos.x += x, geometry.minPos.y += y, geometry.minPos.z += z), 
            geometry.maxPos && (geometry.maxPos.x += x, geometry.maxPos.y += y, geometry.maxPos.z += z), 
            geometry;
        },
        scale: function scale(geometry, value) {
            for (var x = value.x || 0, y = value.y || 0, z = value.z || 0, nVertex = Math.floor(geometry.positions.length / 3), iVertex = 0; iVertex < nVertex; ++iVertex) {
                var iX = 3 * iVertex, iY = 3 * iVertex + 1, iZ = 3 * iVertex + 2;
                geometry.positions[iX] *= x, geometry.positions[iY] *= y, geometry.positions[iZ] *= z;
            }
            return geometry.minPos && (geometry.minPos.x *= x, geometry.minPos.y *= y, geometry.minPos.z *= z), 
            geometry.maxPos && (geometry.maxPos.x *= x, geometry.maxPos.y *= y, geometry.maxPos.z *= z), 
            geometry.boundingRadius = Math.max(Math.max(x, y), z), geometry;
        },
        wireframed: function wireframed(geometry) {
            var indices = geometry.indices;
            if (!indices) return geometry;
            if (geometry.primitiveMode && geometry.primitiveMode !== exports.GFXPrimitiveMode.TRIANGLE_LIST) return geometry;
            for (var offsets = [ [ 0, 1 ], [ 1, 2 ], [ 2, 0 ] ], lines = [], lineIDs = {}, i = 0; i < indices.length; i += 3) for (var k = 0; k < 3; ++k) {
                var i1 = indices[i + offsets[k][0]], i2 = indices[i + offsets[k][1]], id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;
                void 0 === lineIDs[id] && (lineIDs[id] = 0, lines.push(i1, i2));
            }
            return geometry.indices = lines, geometry.primitiveMode = exports.GFXPrimitiveMode.LINE_LIST, 
            geometry;
        },
        wireframe: function wireframe(indices) {
            for (var offsets = [ [ 0, 1 ], [ 1, 2 ], [ 2, 0 ] ], lines = [], lineIDs = {}, i = 0; i < indices.length; i += 3) for (var k = 0; k < 3; ++k) {
                var i1 = indices[i + offsets[k][0]], i2 = indices[i + offsets[k][1]], id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;
                void 0 === lineIDs[id] && (lineIDs[id] = 0, lines.push(i1, i2));
            }
            return lines;
        },
        invWinding: function invWinding(indices) {
            for (var newIB = [], i = 0; i < indices.length; i += 3) newIB.push(indices[i], indices[i + 2], indices[i + 1]);
            return newIB;
        },
        toWavefrontOBJ: function toWavefrontOBJ(primitive) {
            var scale = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            if (!primitive.indices || !primitive.uvs || !primitive.normals || void 0 !== primitive.primitiveMode && primitive.primitiveMode !== exports.GFXPrimitiveMode.TRIANGLE_LIST) return "";
            for (var v = primitive.positions, t = primitive.uvs, n = primitive.normals, IB = primitive.indices, V = function V(i) {
                return "".concat(IB[i] + 1, "/").concat(IB[i] + 1, "/").concat(IB[i] + 1);
            }, content = "", i = 0; i < v.length; i += 3) content += "v ".concat(v[i] * scale, " ").concat(v[i + 1] * scale, " ").concat(v[i + 2] * scale, "\n");
            for (var _i = 0; _i < t.length; _i += 2) content += "vt ".concat(t[_i], " ").concat(t[_i + 1], "\n");
            for (var _i2 = 0; _i2 < n.length; _i2 += 3) content += "vn ".concat(n[_i2], " ").concat(n[_i2 + 1], " ").concat(n[_i2 + 2], "\n");
            for (var _i3 = 0; _i3 < IB.length; _i3 += 3) content += "f ".concat(V(_i3), " ").concat(V(_i3 + 1), " ").concat(V(_i3 + 2), "\n");
            return content;
        },
        normals: function normals(positions, nms) {
            for (var length = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, verts = new Array(2 * positions.length), i = 0; i < positions.length / 3; ++i) {
                var i3 = 3 * i, i6 = 6 * i;
                verts[i6 + 0] = positions[i3 + 0], verts[i6 + 1] = positions[i3 + 1], verts[i6 + 2] = positions[i3 + 2], 
                verts[i6 + 3] = positions[i3 + 0] + nms[i3 + 0] * length, verts[i6 + 4] = positions[i3 + 1] + nms[i3 + 1] * length, 
                verts[i6 + 5] = positions[i3 + 2] + nms[i3 + 2] * length;
            }
            return verts;
        },
        applyDefaultGeometryOptions: applyDefaultGeometryOptions
    }), skybox_mesh = null, skybox_material = null, Skybox = function(_Model) {
        function Skybox(scene) {
            var _this;
            if (_classCallCheck(this, Skybox), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Skybox).call(this)))._default = builtinResMgr.get("default-cube-texture"), 
            _this._envmap = _this._default, _this._isRGBE = !1, _this._useIBL = !1, _this._scene = scene, 
            _this._globalBinding = _this._scene.root.pipeline.globalBindings.get(UNIFORM_ENVIRONMENT.name), 
            !skybox_material) {
                var mat = new Material;
                mat.initialize({
                    effectName: "pipeline/skybox",
                    defines: {
                        USE_RGBE_CUBEMAP: _this._isRGBE
                    }
                }), skybox_material = new MaterialInstance({
                    parent: mat
                });
            }
            return skybox_mesh || (skybox_mesh = createMesh(box({
                width: 2,
                height: 2,
                length: 2
            }))), _this.initSubModel(0, skybox_mesh.renderingMesh.getSubmesh(0), skybox_material), 
            _this;
        }
        return _inherits(Skybox, _Model), _createClass(Skybox, [ {
            key: "useIBL",
            set: function set(val) {
                this._useIBL = val, this._updatePipeline();
            },
            get: function get() {
                return this._useIBL;
            }
        }, {
            key: "isRGBE",
            set: function set(val) {
                this._isRGBE = val, skybox_material.recompileShaders({
                    USE_RGBE_CUBEMAP: this._isRGBE
                }), this.setSubModelMaterial(0, skybox_material), this._updateGlobalBinding(), this._updatePipeline();
            },
            get: function get() {
                return this._isRGBE;
            }
        }, {
            key: "envmap",
            set: function set(val) {
                var newEnvmap = val || this._default;
                this._envmap = newEnvmap, this._scene.ambient.groundAlbedo[3] = this._envmap.mipmapLevel, 
                this._updateGlobalBinding();
            },
            get: function get() {
                return this._envmap;
            }
        } ]), _createClass(Skybox, [ {
            key: "_updatePipeline",
            value: function _updatePipeline() {
                var value = this._useIBL ? this._isRGBE ? 2 : 1 : 0, pipeline = this._scene.root.pipeline;
                pipeline.macros.CC_USE_IBL !== value && (pipeline.macros.CC_USE_IBL = value, this._scene.onGlobalPipelineStateChanged());
            }
        }, {
            key: "_updateGlobalBinding",
            value: function _updateGlobalBinding() {
                var textureView = this._envmap.getGFXTextureView(), sampler = samplerLib.getSampler(this._device, this._envmap.getSamplerHash());
                this._globalBinding.sampler = sampler, this._globalBinding.textureView = textureView;
                var mat = skybox_material;
                mat.passes[0].bindSampler(UNIFORM_ENVIRONMENT.binding, sampler), mat.passes[0].bindTextureView(UNIFORM_ENVIRONMENT.binding, textureView);
                var _iterator = this._matPSORecord.get(mat), _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.pipelineLayout.layouts[0].update();
                }
            }
        } ]), Skybox;
    }(Model), RenderScene = function() {
        function RenderScene(root) {
            _classCallCheck(this, RenderScene), this._name = "", this._cameras = [], this._models = [], 
            this._sphereLights = [], this._spotLights = [], this._mainLight = null, this._modelId = 0, 
            this._root = root, this._ambient = new Ambient(this), this._skybox = new Skybox(this), 
            this._planarShadows = new PlanarShadows(this);
        }
        return _createClass(RenderScene, [ {
            key: "root",
            get: function get() {
                return this._root;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "cameras",
            get: function get() {
                return this._cameras;
            }
        }, {
            key: "ambient",
            get: function get() {
                return this._ambient;
            }
        }, {
            key: "skybox",
            get: function get() {
                return this._skybox;
            }
        }, {
            key: "planarShadows",
            get: function get() {
                return this._planarShadows;
            }
        }, {
            key: "mainLight",
            get: function get() {
                return this._mainLight;
            }
        }, {
            key: "sphereLights",
            get: function get() {
                return this._sphereLights;
            }
        }, {
            key: "spotLights",
            get: function get() {
                return this._spotLights;
            }
        }, {
            key: "models",
            get: function get() {
                return this._models;
            }
        }, {
            key: "rayResultCanvas",
            get: function get() {
                return resultCanvas;
            }
        }, {
            key: "rayResultModels",
            get: function get() {
                return resultModels;
            }
        }, {
            key: "rayResultAll",
            get: function get() {
                return resultAll;
            }
        }, {
            key: "rayResultSingleModel",
            get: function get() {
                return resultSingleModel;
            }
        } ], [ {
            key: "registerCreateFunc",
            value: function registerCreateFunc(root) {
                root._createSceneFun = function(_root) {
                    return new RenderScene(_root);
                };
            }
        } ]), _createClass(RenderScene, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._name = info.name, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.removeCameras(), this.removeSphereLights(), this.removeSpotLights(), this.removeModels(), 
                this._skybox.destroy(), this._planarShadows.destroy();
            }
        }, {
            key: "addCamera",
            value: function addCamera(cam) {
                cam.attachToScene(this), this._cameras.push(cam);
            }
        }, {
            key: "removeCamera",
            value: function removeCamera(camera) {
                for (var i = 0; i < this._cameras.length; ++i) if (this._cameras[i] === camera) return this._cameras.splice(i, 1), 
                void camera.detachFromScene();
            }
        }, {
            key: "removeCameras",
            value: function removeCameras() {
                var _iterator = this._cameras, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.detachFromScene();
                }
                this._cameras.splice(0);
            }
        }, {
            key: "setMainLight",
            value: function setMainLight(dl) {
                dl.attachToScene(this), this._mainLight = dl;
            }
        }, {
            key: "unsetMainLight",
            value: function unsetMainLight(dl) {
                dl.detachFromScene(), this._mainLight = null;
            }
        }, {
            key: "addSphereLight",
            value: function addSphereLight(pl) {
                pl.attachToScene(this), this._sphereLights.push(pl);
            }
        }, {
            key: "removeSphereLight",
            value: function removeSphereLight(pl) {
                for (var i = 0; i < this._sphereLights.length; ++i) if (this._sphereLights[i] === pl) return pl.detachFromScene(), 
                void this._sphereLights.splice(i, 1);
            }
        }, {
            key: "addSpotLight",
            value: function addSpotLight(sl) {
                sl.attachToScene(this), this._spotLights.push(sl);
            }
        }, {
            key: "removeSpotLight",
            value: function removeSpotLight(sl) {
                for (var i = 0; i < this._spotLights.length; ++i) if (this._spotLights[i] === sl) return sl.detachFromScene(), 
                void this._spotLights.splice(i, 1);
            }
        }, {
            key: "removeSphereLights",
            value: function removeSphereLights() {
                for (var i = 0; i < this._sphereLights.length; ++i) this._sphereLights[i].detachFromScene();
                this._sphereLights.length = 0;
            }
        }, {
            key: "removeSpotLights",
            value: function removeSpotLights() {
                for (var i = 0; i < this._spotLights.length; ++i) this._spotLights[i].detachFromScene();
                this._spotLights = [];
            }
        }, {
            key: "addModel",
            value: function addModel(m) {
                m.attachToScene(this), this._models.push(m);
            }
        }, {
            key: "removeModel",
            value: function removeModel(model) {
                for (var i = 0; i < this._models.length; ++i) if (this._models[i] === model) return this._planarShadows.destroyShadowModel(model), 
                model.detachFromScene(), void this._models.splice(i, 1);
            }
        }, {
            key: "removeModels",
            value: function removeModels() {
                var _iterator2 = this._models, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var m = _ref2;
                    this._planarShadows.destroyShadowModel(m), m.detachFromScene();
                }
                this._models.length = 0;
            }
        }, {
            key: "onGlobalPipelineStateChanged",
            value: function onGlobalPipelineStateChanged() {
                var _iterator3 = this._models, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    _ref3.onGlobalPipelineStateChanged();
                }
                this._skybox.onGlobalPipelineStateChanged(), this._planarShadows.onGlobalPipelineStateChanged();
            }
        }, {
            key: "generateModelId",
            value: function generateModelId() {
                return this._modelId++;
            }
        }, {
            key: "raycastAll",
            value: function raycastAll(worldRay) {
                var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Layers.Enum.DEFAULT | Layers.Enum.UI_2D, distance = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1 / 0, r_3d = this.raycastAllModels(worldRay, mask, distance), r_ui2d = this.raycastAllCanvas(worldRay, mask, distance), isHit = r_3d || r_ui2d;
                return resultAll.length = 0, isHit && (Array.prototype.push.apply(resultAll, resultModels), 
                Array.prototype.push.apply(resultAll, resultCanvas)), isHit;
            }
        }, {
            key: "raycastAllModels",
            value: function raycastAllModels(worldRay) {
                var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Layers.Enum.DEFAULT, distance = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1 / 0;
                pool.reset();
                var _iterator4 = this._models, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var m = _ref4, transform = m.transform;
                    if (transform && m.enabled && m.node.layer & mask & ~Layers.Enum.IGNORE_RAYCAST && m.worldBounds) {
                        var d = intersect.ray_aabb(worldRay, m.worldBounds);
                        if (!(d <= 0 || d >= distance)) {
                            if (!(m instanceof SkinningModel && m.uploadedAnim)) {
                                Mat4.invert(m4, transform.getWorldMatrix(m4)), Vec3.transformMat4(modelRay.o, worldRay.o, m4), 
                                Vec3.normalize(modelRay.d, Vec3.transformMat4Normal(modelRay.d, worldRay.d, m4)), 
                                d = 1 / 0;
                                for (var i = 0; i < m.subModelNum; ++i) {
                                    var subModel = m.getSubModel(i).subMeshData;
                                    if (subModel && subModel.geometricInfo) {
                                        var _subModel$geometricIn = subModel.geometricInfo, vb = _subModel$geometricIn.positions, ib = _subModel$geometricIn.indices, sides = _subModel$geometricIn.doubleSided;
                                        narrowphase(vb, ib, subModel.primitiveMode, sides, distance), d = Math.min(d, narrowDis * Vec3.multiply(v3$1, modelRay.d, transform.worldScale).length());
                                    }
                                }
                            }
                            if (d < distance) {
                                var r = pool.add();
                                r.node = m.node, r.distance = d, resultModels[pool.length - 1] = r;
                            }
                        }
                    }
                }
                return resultModels.length = pool.length, resultModels.length > 0;
            }
        }, {
            key: "raycastSingleModel",
            value: function raycastSingleModel(worldRay, model) {
                var mask = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Layers.Enum.DEFAULT, distance = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
                pool.reset();
                var m = model, transform = m.transform;
                if (!(transform && m.enabled && m.node.layer & mask & ~Layers.Enum.IGNORE_RAYCAST && m.worldBounds)) return !1;
                var d = intersect.ray_aabb(worldRay, m.worldBounds);
                if (d <= 0 || d >= distance) return !1;
                if (!(m instanceof SkinningModel && m.uploadedAnim)) {
                    Mat4.invert(m4, transform.getWorldMatrix(m4)), Vec3.transformMat4(modelRay.o, worldRay.o, m4), 
                    Vec3.normalize(modelRay.d, Vec3.transformMat4Normal(modelRay.d, worldRay.d, m4)), 
                    d = 1 / 0;
                    for (var i = 0; i < m.subModelNum; ++i) {
                        var subModel = m.getSubModel(i).subMeshData;
                        if (subModel && subModel.geometricInfo) {
                            var _subModel$geometricIn2 = subModel.geometricInfo, vb = _subModel$geometricIn2.positions, ib = _subModel$geometricIn2.indices, sides = _subModel$geometricIn2.doubleSided;
                            narrowphase(vb, ib, subModel.primitiveMode, sides, distance), d = Math.min(d, narrowDis * Vec3.multiply(v3$1, modelRay.d, transform.worldScale).length());
                        }
                    }
                }
                if (d < distance) {
                    var r = pool.add();
                    r.node = m.node, r.distance = d, resultSingleModel[pool.length - 1] = r;
                }
                return resultSingleModel.length = pool.length, resultSingleModel.length > 0;
            }
        }, {
            key: "raycastAllCanvas",
            value: function raycastAllCanvas(worldRay) {
                var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Layers.Enum.UI_2D, distance = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1 / 0;
                poolUI.reset();
                var canvasComs = cc.director.getScene().getComponentsInChildren(cc.CanvasComponent);
                if (null != canvasComs && canvasComs.length > 0) for (var i = 0; i < canvasComs.length; i++) {
                    var canvasNode = canvasComs[i].node;
                    null != canvasNode && canvasNode.active && this._raycastUI2DNodeRecursiveChildren(worldRay, canvasNode, mask, distance);
                }
                return resultCanvas.length = poolUI.length, resultCanvas.length > 0;
            }
        }, {
            key: "_raycastUI2DNode",
            value: function _raycastUI2DNode(worldRay, ui2dNode) {
                var mask = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Layers.Enum.UI_2D, distance = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
                var uiTransfrom = ui2dNode._uiProps.uiTransformComp;
                if (!(null == uiTransfrom || ui2dNode.layer & Layers.Enum.IGNORE_RAYCAST) && ui2dNode.layer & mask) {
                    uiTransfrom.getComputeAABB(aabbUI);
                    var d = intersect.ray_aabb(worldRay, aabbUI);
                    if (!(d <= 0) && d < distance) {
                        var r = poolUI.add();
                        return r.node = ui2dNode, r.distance = d, r;
                    }
                }
            }
        }, {
            key: "_raycastUI2DNodeRecursiveChildren",
            value: function _raycastUI2DNodeRecursiveChildren(worldRay, parent) {
                var mask = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Layers.Enum.UI_2D, distance = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0, result = this._raycastUI2DNode(worldRay, parent, mask, distance);
                null != result && (resultCanvas[poolUI.length - 1] = result);
                var _iterator5 = parent.children, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    var node = _ref5;
                    null != node && node.active && this._raycastUI2DNodeRecursiveChildren(worldRay, node, mask, distance);
                }
            }
        } ]), RenderScene;
    }(), modelRay = ray.create(), v3$1 = new Vec3, m4 = new Mat4, narrowDis = 1 / 0, tri = triangle.create(), pool = new RecyclePool((function() {
        return {
            node: null,
            distance: 1 / 0
        };
    }), 8), resultModels = [], aabbUI = new aabb, poolUI = new RecyclePool((function() {
        return {
            node: null,
            distance: 1 / 0
        };
    }), 8), resultCanvas = [], resultAll = [], resultSingleModel = [], narrowphase = function narrowphase(vb, ib, pm, sides) {
        var distance = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1 / 0;
        if (narrowDis = distance, pm === exports.GFXPrimitiveMode.TRIANGLE_LIST) for (var cnt = ib.length, j = 0; j < cnt; j += 3) {
            var i0 = 3 * ib[j], i1 = 3 * ib[j + 1], i2 = 3 * ib[j + 2];
            Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]), Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]), 
            Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
            var dist = intersect.ray_triangle(modelRay, tri, sides);
            dist <= 0 || dist >= narrowDis || (narrowDis = dist);
        } else if (pm === exports.GFXPrimitiveMode.TRIANGLE_STRIP) for (var _cnt = ib.length - 2, rev = 0, _j = 0; _j < _cnt; _j += 1) {
            var _i6 = 3 * ib[_j - rev], _i7 = 3 * ib[_j + rev + 1], _i8 = 3 * ib[_j + 2];
            Vec3.set(tri.a, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]), Vec3.set(tri.b, vb[_i7], vb[_i7 + 1], vb[_i7 + 2]), 
            Vec3.set(tri.c, vb[_i8], vb[_i8 + 1], vb[_i8 + 2]), rev = ~rev;
            var _dist = intersect.ray_triangle(modelRay, tri, sides);
            _dist <= 0 || _dist >= narrowDis || (narrowDis = _dist);
        } else if (pm === exports.GFXPrimitiveMode.TRIANGLE_FAN) {
            var _cnt2 = ib.length - 1, _i9 = 3 * ib[0];
            Vec3.set(tri.a, vb[_i9], vb[_i9 + 1], vb[_i9 + 2]);
            for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
                var _i10 = 3 * ib[_j2], _i11 = 3 * ib[_j2 + 1];
                Vec3.set(tri.b, vb[_i10], vb[_i10 + 1], vb[_i10 + 2]), Vec3.set(tri.c, vb[_i11], vb[_i11 + 1], vb[_i11 + 2]);
                var _dist2 = intersect.ray_triangle(modelRay, tri, sides);
                _dist2 <= 0 || _dist2 >= narrowDis || (narrowDis = _dist2);
            }
        }
    };
    exports.replaceProperty(RenderScene.prototype, "RenderScene.prototype", [ {
        name: "raycastUI",
        newName: "raycastAllCanvas"
    }, {
        name: "raycastUI2D",
        newName: "raycastAllCanvas"
    }, {
        name: "raycast",
        newName: "raycastAllModels"
    }, {
        name: "raycastModels",
        newName: "raycastAllModels"
    }, {
        name: "raycastModel",
        newName: "raycastSingleModel"
    } ]), exports.removeProperty(RenderScene.prototype, "RenderScene.prototype", [ {
        name: "raycastUI2DNode"
    }, {
        name: "raycastUINode"
    } ]);
    var CameraVisFlags = {};
    exports.removeProperty(CameraVisFlags, "CameraVisFlags", [ {
        name: "GENERAL"
    } ]), exports.replaceProperty(CameraVisFlags, "CameraVisFlags", [ {
        name: "PROFILER",
        newName: "PROFILER",
        target: Layers.BitMask,
        targetName: "PROFILER"
    }, {
        name: "GIZMOS",
        newName: "GIZMOS",
        target: Layers.BitMask,
        targetName: "GIZMOS"
    }, {
        name: "EDITOR",
        newName: "EDITOR",
        target: Layers.BitMask,
        targetName: "EDITOR"
    }, {
        name: "UI",
        newName: "UI",
        target: Layers.BitMask,
        targetName: "UI_3D"
    }, {
        name: "UI2D",
        newName: "UI2D",
        target: Layers.BitMask,
        targetName: "UI_2D"
    } ]), cc.CameraVisFlags = CameraVisFlags;
    var VisibilityFlags = {};
    exports.removeProperty(VisibilityFlags, "VisibilityFlags", [ {
        name: "GENERAL"
    } ]), exports.replaceProperty(VisibilityFlags, "VisibilityFlags", [ {
        name: "ALWALS",
        newName: "ALWALS",
        target: Layers.Enum,
        targetName: "ALWALS"
    }, {
        name: "PROFILER",
        newName: "PROFILER",
        target: Layers.Enum,
        targetName: "PROFILER"
    }, {
        name: "GIZMOS",
        newName: "GIZMOS",
        target: Layers.Enum,
        targetName: "GIZMOS"
    }, {
        name: "EDITOR",
        newName: "EDITOR",
        target: Layers.Enum,
        targetName: "EDITOR"
    }, {
        name: "UI",
        newName: "UI",
        target: Layers.Enum,
        targetName: "UI_3D"
    }, {
        name: "UI2D",
        newName: "UI2D",
        target: Layers.Enum,
        targetName: "UI_2D"
    } ]), cc.VisibilityFlags = VisibilityFlags;
    var _class$L, _dec$M, _dec2$o, _dec3$d, _dec4$a, _dec5$9, _class$M, _class2$F, _descriptor$y, _descriptor2$p, _descriptor3$i, _descriptor4$c, _class3$f, _temp$H, InstanceMaterialType, _forward$1 = new Vec3(0, 0, -1), _v3$2 = new Vec3, _qt$2 = new Quat, DirectionalLight = function(_Light) {
        function DirectionalLight() {
            var _this;
            return _classCallCheck(this, DirectionalLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(DirectionalLight).call(this)))._dir = new Vec3(1, -1, -1), 
            _this._illum = Ambient.SUN_ILLUM, _this._type = LightType.DIRECTIONAL, _this;
        }
        return _inherits(DirectionalLight, _Light), _createClass(DirectionalLight, [ {
            key: "direction",
            set: function set(dir) {
                this._dir = dir, Vec3.normalize(this._dir, this._dir);
            },
            get: function get() {
                return this._dir;
            }
        }, {
            key: "illuminance",
            set: function set(illum) {
                this._illum = illum;
            },
            get: function get() {
                return this._illum;
            }
        } ]), _createClass(DirectionalLight, [ {
            key: "update",
            value: function update() {
                this._node && this._node.hasChangedFlags && (this._dir = Vec3.transformQuat(_v3$2, _forward$1, this._node.getWorldRotation(_qt$2)), 
                Vec3.normalize(this._dir, this._dir));
            }
        } ]), DirectionalLight;
    }(Light), SphereLight = function(_Light) {
        function SphereLight() {
            var _this;
            return _classCallCheck(this, SphereLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereLight).call(this)))._needUpdate = !1, 
            _this._size = .15, _this._range = 1, _this._luminance = 1700 / nt2lm(_this._size), 
            _this._type = LightType.SPHERE, _this._aabb = aabb.create(), _this._pos = new Vec3, 
            _this;
        }
        return _inherits(SphereLight, _Light), _createClass(SphereLight, [ {
            key: "position",
            get: function get() {
                return this._pos;
            }
        }, {
            key: "size",
            set: function set(size) {
                this._size = size;
            },
            get: function get() {
                return this._size;
            }
        }, {
            key: "range",
            set: function set(range) {
                this._range = range, this._needUpdate = !0;
            },
            get: function get() {
                return this._range;
            }
        }, {
            key: "luminance",
            set: function set(lum) {
                this._luminance = lum;
            },
            get: function get() {
                return this._luminance;
            }
        }, {
            key: "aabb",
            get: function get() {
                return this._aabb;
            }
        } ]), _createClass(SphereLight, [ {
            key: "update",
            value: function update() {
                this._node && (this._node.hasChangedFlags || this._needUpdate) && (this._node.getWorldPosition(this._pos), 
                aabb.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range), 
                this._needUpdate = !1);
            }
        } ]), SphereLight;
    }(Light), _forward$2 = new Vec3(0, 0, -1), _qt$3 = (new Vec3, new Quat), _matView = new Mat4, _matProj = new Mat4, _matViewProj = new Mat4, _matViewProjInv = new Mat4, SpotLight = function(_Light) {
        function SpotLight() {
            var _this;
            return _classCallCheck(this, SpotLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SpotLight).call(this)))._dir = new Vec3(1, -1, -1), 
            _this._size = .15, _this._range = 5, _this._luminance = 1700 / nt2lm(_this._size), 
            _this._spotAngle = Math.cos(Math.PI / 6), _this._angle = 0, _this._needUpdate = !1, 
            _this._type = LightType.SPOT, _this._aabb = aabb.create(), _this._frustum = frustum.create(), 
            _this._pos = new Vec3, _this;
        }
        return _inherits(SpotLight, _Light), _createClass(SpotLight, [ {
            key: "position",
            get: function get() {
                return this._pos;
            }
        }, {
            key: "size",
            set: function set(size) {
                this._size = size;
            },
            get: function get() {
                return this._size;
            }
        }, {
            key: "range",
            set: function set(range) {
                this._range = range, this._needUpdate = !0;
            },
            get: function get() {
                return this._range;
            }
        }, {
            key: "luminance",
            set: function set(lum) {
                this._luminance = lum;
            },
            get: function get() {
                return this._luminance;
            }
        }, {
            key: "direction",
            get: function get() {
                return this._dir;
            }
        }, {
            key: "spotAngle",
            get: function get() {
                return this._spotAngle;
            },
            set: function set(val) {
                this._angle = .5 * val, this._spotAngle = Math.cos(.5 * val), this._needUpdate = !0;
            }
        }, {
            key: "aabb",
            get: function get() {
                return this._aabb;
            }
        }, {
            key: "frustum",
            get: function get() {
                return this._frustum;
            }
        } ]), _createClass(SpotLight, [ {
            key: "update",
            value: function update() {
                this._node && (this._node.hasChangedFlags || this._needUpdate) && (this._node.getWorldPosition(this._pos), 
                Vec3.transformQuat(this._dir, _forward$2, this._node.getWorldRotation(_qt$3)), Vec3.normalize(this._dir, this._dir), 
                aabb.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range), 
                this._node.getWorldRT(_matView), Mat4.invert(_matView, _matView), Mat4.perspective(_matProj, this._angle, 1, .001, this._range), 
                Mat4.multiply(_matViewProj, _matProj, _matView), this._frustum.update(_matViewProj, _matViewProjInv), 
                this._needUpdate = !1);
            }
        } ]), SpotLight;
    }(Light), BaseRenderData = function BaseRenderData() {
        _classCallCheck(this, BaseRenderData), this.material = null, this.vertexCount = 0, 
        this.indiceCount = 0;
    }, RenderData = function(_BaseRenderData) {
        function RenderData() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, RenderData);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderData)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).vData = null, 
            _this.uvDirty = !0, _this.vertDirty = !0, _this._datas = [], _this._indices = [], 
            _this._pivotX = 0, _this._pivotY = 0, _this._width = 0, _this._height = 0, _this;
        }
        return _inherits(RenderData, _BaseRenderData), _createClass(RenderData, [ {
            key: "updateSizeNPivot",
            value: function updateSizeNPivot(width, height, pivotX, pivotY) {
                width === this._width && height === this._height && pivotX === this._pivotX && pivotY === this._pivotY || (this._width = width, 
                this._height = height, this._pivotX = pivotX, this._pivotY = pivotY, this.vertDirty = !0);
            }
        }, {
            key: "clear",
            value: function clear() {
                this._datas.length = 0, this._indices.length = 0, this._pivotX = 0, this._pivotY = 0, 
                this._width = 0, this._height = 0, this.uvDirty = !0, this.vertDirty = !0, this.material = null, 
                this.vertexCount = 0, this.indiceCount = 0;
            }
        }, {
            key: "dataLength",
            get: function get() {
                return this._datas.length;
            },
            set: function set(length) {
                var data = this._datas;
                if (data.length !== length) {
                    var value = data.length, i = 0;
                    for (i = length; i < value; i++) _dataPool.free(data[i]);
                    for (i = value; i < length; i++) data[i] = _dataPool.alloc();
                    data.length = length;
                }
            }
        }, {
            key: "datas",
            get: function get() {
                return this._datas;
            }
        } ], [ {
            key: "add",
            value: function add() {
                return _pool$1.add();
            }
        }, {
            key: "remove",
            value: function remove(data) {
                var idx = _pool$1.data.indexOf(data);
                -1 !== idx && (_pool$1.data[idx].clear(), _pool$1.removeAt(idx));
            }
        } ]), RenderData;
    }(BaseRenderData), MeshRenderData = function(_BaseRenderData2) {
        function MeshRenderData() {
            var _getPrototypeOf3, _this2;
            _classCallCheck(this, MeshRenderData);
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
            return (_this2 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(MeshRenderData)).call.apply(_getPrototypeOf3, [ this ].concat(args)))).vData = new Float32Array(2304 * Float32Array.BYTES_PER_ELEMENT), 
            _this2.iData = new Uint16Array(1536), _this2.vertexStart = 0, _this2.indiceStart = 0, 
            _this2.byteStart = 0, _this2.byteCount = 0, _this2._formatByte = 9 * Float32Array.BYTES_PER_ELEMENT, 
            _this2;
        }
        return _inherits(MeshRenderData, _BaseRenderData2), _createClass(MeshRenderData, [ {
            key: "request",
            value: function request(vertexCount, indiceCount) {
                var byteOffset = this.byteCount + vertexCount * this._formatByte, indiceOffset = this.indiceCount + indiceCount;
                if (vertexCount + this.vertexCount > 65535) return !1;
                var byteLength = this.vData.byteLength, indiceLength = this.iData.length, vCount = this.vData.length, iCount = this.iData.length;
                if (byteOffset > byteLength || indiceOffset > indiceLength) {
                    for (;byteLength < byteOffset || indiceLength < indiceOffset; ) byteLength = 4 * (vCount *= 2), 
                    indiceLength = iCount *= 2;
                    var oldvData = new Float32Array(this.vData.buffer);
                    this.vData = new Float32Array(vCount), this.vData.set(oldvData, 0);
                    var oldiData = new Uint16Array(this.iData.buffer);
                    this.iData = new Uint16Array(iCount), this.iData.set(oldiData, 0);
                }
                return this.vertexCount += vertexCount, this.indiceCount += indiceCount, this.byteCount = byteOffset, 
                !0;
            }
        }, {
            key: "reset",
            value: function reset() {
                this.vertexCount = 0, this.indiceCount = 0, this.byteCount = 0, this.vertexStart = 0, 
                this.indiceStart = 0, this.byteStart = 0;
            }
        } ]), MeshRenderData;
    }(BaseRenderData), _dataPool = new Pool$1((function() {
        return {
            x: 0,
            y: 0,
            z: 0,
            u: 0,
            v: 0,
            color: Color.WHITE.clone()
        };
    }), 128), _pool$1 = new RecyclePool((function() {
        return new RenderData;
    }), 32), addStage = config_addStage, renderer = Object.freeze({
        __proto__: null,
        addStage: addStage,
        createIA: function createIA(device, data) {
            if (!data.positions) return console.error("The data must have positions field"), 
            null;
            for (var verts = [], vcount = data.positions.length / 3, i = 0; i < vcount; ++i) verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]), 
            data.normals && verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]), 
            data.uvs && verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]), data.colors && verts.push(data.colors[3 * i], data.uvs[3 * i + 1], data.colors[3 * i + 2]);
            var vfmt = [];
            vfmt.push({
                name: exports.GFXAttributeName.ATTR_POSITION,
                format: exports.GFXFormat.RGB32F
            }), data.normals && vfmt.push({
                name: exports.GFXAttributeName.ATTR_NORMAL,
                format: exports.GFXFormat.RGB32F
            }), data.uvs && vfmt.push({
                name: exports.GFXAttributeName.ATTR_TEX_COORD,
                format: exports.GFXFormat.RG32F
            }), data.colors && vfmt.push({
                name: exports.GFXAttributeName.ATTR_COLOR,
                format: exports.GFXFormat.RGB32F
            });
            var vb = device.createBuffer({
                usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: 4 * verts.length,
                stride: 4 * verts.length / vcount
            });
            vb.update(new Float32Array(verts));
            var ib = device.createBuffer({
                usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: 2 * data.indices.length,
                stride: 2
            });
            return ib.update(new Uint16Array(data.indices)), device.createInputAssembler({
                attributes: vfmt,
                vertexBuffers: [ vb ],
                indexBuffer: ib
            });
        },
        get RenderQueue() {
            return RenderQueue$1;
        },
        get PassStage() {
            return PassStage;
        },
        genHandle: genHandle,
        getBindingTypeFromHandle: getBindingTypeFromHandle,
        getTypeFromHandle: getTypeFromHandle,
        getBindingFromHandle: getBindingFromHandle,
        getOffsetFromHandle: getOffsetFromHandle,
        customizeType: customizeType,
        type2reader: type2reader,
        type2writer: type2writer,
        type2default: type2default,
        assignDefines: assignDefines,
        Pass: Pass,
        programLib: programLib,
        get SamplerInfoIndex() {
            return SamplerInfoIndex;
        },
        genSamplerHash: genSamplerHash,
        samplerLib: samplerLib,
        nearestPOT: nearestPOT,
        TextureBufferPool: TextureBufferPool,
        MaterialInstance: MaterialInstance,
        PassInstance: PassInstance,
        get JointsMediumType() {
            return JointsMediumType;
        },
        selectJointsMediumType: selectJointsMediumType,
        jointsTextureSamplerHash: jointsTextureSamplerHash,
        JointsTexturePool: JointsTexturePool,
        JointsAnimationInfo: JointsAnimationInfo,
        AnimatedBoundsInfo: AnimatedBoundsInfo,
        SkinningModel: SkinningModel,
        Ambient: Ambient,
        get CameraProjection() {
            return CameraProjection;
        },
        get CameraAperture() {
            return CameraAperture;
        },
        get CameraISO() {
            return CameraISO;
        },
        get CameraShutter() {
            return CameraShutter;
        },
        SKYBOX_FLAG: SKYBOX_FLAG,
        Camera: Camera,
        customizationManager: customizationManager,
        CameraVisFlags: CameraVisFlags,
        VisibilityFlags: VisibilityFlags,
        DirectionalLight: DirectionalLight,
        ColorTemperatureToRGB: ColorTemperatureToRGB,
        get LightType() {
            return LightType;
        },
        nt2lm: nt2lm,
        Light: Light,
        Model: Model,
        PlanarShadows: PlanarShadows,
        RenderScene: RenderScene,
        Skybox: Skybox,
        SphereLight: SphereLight,
        SpotLight: SpotLight,
        SubModel: SubModel
    }), UIComponent = ccclass("cc.UIComponent")(_class$L = requireComponent(UITransformComponent)(_class$L = executionOrder(110)(_class$L = disallowMultiple(_class$L = executeInEditMode(_class$L = function(_Component) {
        function UIComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, UIComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._lastParent = null, 
            _this;
        }
        return _inherits(UIComponent, _Component), _createClass(UIComponent, [ {
            key: "__preload",
            value: function __preload() {
                this.node._uiProps.uiComp = this;
            }
        }, {
            key: "onEnable",
            value: function onEnable() {}
        }, {
            key: "onDisable",
            value: function onDisable() {}
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this.node._uiProps.uiComp === this && (this.node._uiProps.uiComp = null);
            }
        }, {
            key: "updateAssembler",
            value: function updateAssembler(render) {}
        }, {
            key: "postUpdateAssembler",
            value: function postUpdateAssembler(render) {}
        } ]), UIComponent;
    }(Component)) || _class$L) || _class$L) || _class$L) || _class$L) || _class$L;
    ccenum(exports.GFXBlendFactor), (InstanceMaterialType = exports.InstanceMaterialType || (exports.InstanceMaterialType = {}))[InstanceMaterialType.ADDCOLOR = 0] = "ADDCOLOR", 
    InstanceMaterialType[InstanceMaterialType.ADDCOLORANDTEXTURE = 1] = "ADDCOLORANDTEXTURE", 
    InstanceMaterialType[InstanceMaterialType.GRAYSCALE = 2] = "GRAYSCALE";
    var _dec$N, _dec2$p, _dec3$e, _dec4$b, _dec5$a, _dec6$7, _dec7$4, _dec8$3, _dec9$2, _dec10$2, _dec11$2, _dec12$2, _class$N, _class2$G, _descriptor$z, _descriptor2$q, _descriptor3$j, _descriptor4$d, _descriptor5$9, _descriptor6$4, _descriptor7$4, _descriptor8$3, _descriptor9$3, _descriptor10$3, _class3$g, _temp$I, SpriteType, FillType, SizeMode, EventType, _matInsInfo$1 = {
        parent: null,
        owner: null,
        subModelIdx: 0
    }, UIRenderComponent = (_dec$M = ccclass("cc.UIRenderComponent"), _dec2$o = property({
        type: exports.GFXBlendFactor,
        displayOrder: 0,
        tooltip: "原图混合模式"
    }), _dec3$d = property({
        type: exports.GFXBlendFactor,
        displayOrder: 1,
        tooltip: "目标混合模式"
    }), _dec4$a = property({
        displayOrder: 2,
        tooltip: "渲染颜色"
    }), _dec5$9 = property({
        type: Material,
        displayOrder: 3,
        tooltip: "源材质",
        visible: !1
    }), _dec$M((_temp$H = _class3$f = function(_UIComponent) {
        function UIRenderComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, UIRenderComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIRenderComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_srcBlendFactor", _descriptor$y, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_dstBlendFactor", _descriptor2$p, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_color", _descriptor3$i, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_sharedMaterial", _descriptor4$c, _assertThisInitialized(_this)), 
            _this._assembler = null, _this._postAssembler = null, _this._renderData = null, 
            _this._renderDataFlag = !0, _this._renderFlag = !0, _this._delegateSrc = null, _this._material = null, 
            _this._instanceMaterialType = exports.InstanceMaterialType.ADDCOLORANDTEXTURE, _this._blendTemplate = {
                blendState: {
                    targets: [ {
                        blendSrc: exports.GFXBlendFactor.SRC_ALPHA,
                        blendDst: exports.GFXBlendFactor.ONE_MINUS_SRC_ALPHA
                    } ]
                },
                depthStencilState: {},
                rasterizerState: {}
            }, _this;
        }
        return _inherits(UIRenderComponent, _UIComponent), _createClass(UIRenderComponent, [ {
            key: "__preload",
            value: function __preload() {
                _get(_getPrototypeOf(UIRenderComponent.prototype), "__preload", this).call(this), 
                this._instanceMaterial(), this._flushAssembler && this._flushAssembler();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(UIRenderComponent.prototype), "onEnable", this).call(this), 
                this.node.on(exports.SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this), 
                this.node.on(exports.SystemEventType.SIZE_CHANGED, this._nodeStateChange, this), 
                this._renderFlag = this._canRender();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(UIRenderComponent.prototype), "onDisable", this).call(this), 
                this.node.off(exports.SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this), 
                this.node.off(exports.SystemEventType.SIZE_CHANGED, this._nodeStateChange, this), 
                this._renderFlag = !1;
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(UIRenderComponent.prototype), "onDestroy", this).call(this), 
                this.destroyRenderData(), this._material && this._material.destroy(), this._updateMaterial(null), 
                this._renderData = null;
            }
        }, {
            key: "markForUpdateRenderData",
            value: function markForUpdateRenderData() {
                var enable = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                if (this._renderFlag = this._canRender(), enable && this._renderFlag) {
                    var renderData = this._renderData;
                    renderData && (renderData.vertDirty = !0), this._renderDataFlag = enable;
                } else enable || (this._renderDataFlag = enable);
            }
        }, {
            key: "requestRenderData",
            value: function requestRenderData() {
                var data = RenderData.add();
                return this._renderData = data, data;
            }
        }, {
            key: "destroyRenderData",
            value: function destroyRenderData() {
                this._renderData && (RenderData.remove(this._renderData), this._renderData = null);
            }
        }, {
            key: "updateAssembler",
            value: function updateAssembler(render) {
                _get(_getPrototypeOf(UIRenderComponent.prototype), "updateAssembler", this).call(this, render), 
                this._renderFlag && (this._checkAndUpdateRenderData(), this._render(render));
            }
        }, {
            key: "postUpdateAssembler",
            value: function postUpdateAssembler(render) {
                _get(_getPrototypeOf(UIRenderComponent.prototype), "postUpdateAssembler", this).call(this, render), 
                this._renderFlag && this._postRender(render);
            }
        }, {
            key: "_render",
            value: function _render(render) {}
        }, {
            key: "_postRender",
            value: function _postRender(render) {}
        }, {
            key: "_checkAndUpdateRenderData",
            value: function _checkAndUpdateRenderData() {
                this._renderDataFlag && (this._assembler.updateRenderData(this), this._renderDataFlag = !1);
            }
        }, {
            key: "_canRender",
            value: function _canRender() {
                return null !== this.material && this.enabled && (this._delegateSrc ? this._delegateSrc.activeInHierarchy : this.enabledInHierarchy);
            }
        }, {
            key: "_postCanRender",
            value: function _postCanRender() {}
        }, {
            key: "_updateColor",
            value: function _updateColor() {
                this._assembler && this._assembler.updateColor && this._assembler.updateColor(this);
            }
        }, {
            key: "_updateMaterial",
            value: function _updateMaterial(material) {
                this._material = material, this._updateBlendFunc();
            }
        }, {
            key: "_updateBlendFunc",
            value: function _updateBlendFunc() {
                if (this._material) {
                    var target = this._blendTemplate.blendState.targets[0];
                    target.blendDst === this._dstBlendFactor && target.blendSrc === this._srcBlendFactor || (target.blendDst = this._dstBlendFactor, 
                    target.blendSrc = this._srcBlendFactor, this._blendTemplate.depthStencilState = this._material.passes[0].depthStencilState, 
                    this._blendTemplate.rasterizerState = this._material.passes[0].rasterizerState, 
                    this._material.overridePipelineStates(this._blendTemplate, 0));
                }
            }
        }, {
            key: "_nodeStateChange",
            value: function _nodeStateChange(type) {
                this._renderData && this.markForUpdateRenderData();
                var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var renderComp = _ref.getComponent(UIRenderComponent);
                    renderComp && renderComp.markForUpdateRenderData();
                }
            }
        }, {
            key: "_instanceMaterial",
            value: function _instanceMaterial() {
                var mat = null;
                if (_matInsInfo$1.owner = new RenderableComponent, this._sharedMaterial) _matInsInfo$1.parent = this._sharedMaterial, 
                mat = new MaterialInstance(_matInsInfo$1); else switch (this._instanceMaterialType) {
                  case exports.InstanceMaterialType.ADDCOLOR:
                    _matInsInfo$1.parent = builtinResMgr.get("ui-base-material"), mat = new MaterialInstance(_matInsInfo$1);
                    break;

                  case exports.InstanceMaterialType.ADDCOLORANDTEXTURE:
                    _matInsInfo$1.parent = builtinResMgr.get("ui-sprite-material"), mat = new MaterialInstance(_matInsInfo$1);
                    break;

                  case exports.InstanceMaterialType.GRAYSCALE:
                    _matInsInfo$1.parent = builtinResMgr.get("ui-sprite-gray-material"), mat = new MaterialInstance(_matInsInfo$1);
                }
                this._updateMaterial(mat);
            }
        }, {
            key: "srcBlendFactor",
            get: function get() {
                return this._srcBlendFactor;
            },
            set: function set(value) {
                this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
            }
        }, {
            key: "dstBlendFactor",
            get: function get() {
                return this._dstBlendFactor;
            },
            set: function set(value) {
                this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(value) {
                this._color !== value && (this._color.set(value), this._updateColor(), this.markForUpdateRenderData());
            }
        }, {
            key: "sharedMaterial",
            get: function get() {
                return this._sharedMaterial;
            },
            set: function set(value) {
                this._sharedMaterial !== value && (this._sharedMaterial = value, this._instanceMaterial && this._instanceMaterial());
            }
        }, {
            key: "material",
            get: function get() {
                return this._material || this._instanceMaterial && this._instanceMaterial(), this._material;
            }
        }, {
            key: "renderData",
            get: function get() {
                return this._renderData;
            }
        }, {
            key: "delegateSrc",
            set: function set(value) {
                this._delegateSrc = value;
            }
        } ]), UIRenderComponent;
    }(UIComponent), _class3$f.BlendState = exports.GFXBlendFactor, _class3$f.Assembler = null, 
    _class3$f.PostAssembler = null, _applyDecoratedDescriptor((_class2$F = _temp$H).prototype, "srcBlendFactor", [ _dec2$o ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "srcBlendFactor"), _class2$F.prototype), 
    _applyDecoratedDescriptor(_class2$F.prototype, "dstBlendFactor", [ _dec3$d ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "dstBlendFactor"), _class2$F.prototype), 
    _applyDecoratedDescriptor(_class2$F.prototype, "color", [ _dec4$a ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "color"), _class2$F.prototype), 
    _applyDecoratedDescriptor(_class2$F.prototype, "sharedMaterial", [ _dec5$9 ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "sharedMaterial"), _class2$F.prototype), 
    _descriptor$y = _applyDecoratedDescriptor(_class2$F.prototype, "_srcBlendFactor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXBlendFactor.SRC_ALPHA;
        }
    }), _descriptor2$p = _applyDecoratedDescriptor(_class2$F.prototype, "_dstBlendFactor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.GFXBlendFactor.ONE_MINUS_SRC_ALPHA;
        }
    }), _descriptor3$i = _applyDecoratedDescriptor(_class2$F.prototype, "_color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE.clone();
        }
    }), _descriptor4$c = _applyDecoratedDescriptor(_class2$F.prototype, "_sharedMaterial", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$M = _class2$F)) || _class$M);
    cc.UIRenderComponent = UIRenderComponent, function(SpriteType) {
        SpriteType[SpriteType.SIMPLE = 0] = "SIMPLE", SpriteType[SpriteType.SLICED = 1] = "SLICED", 
        SpriteType[SpriteType.TILED = 2] = "TILED", SpriteType[SpriteType.FILLED = 3] = "FILLED";
    }(SpriteType || (SpriteType = {})), ccenum(SpriteType), function(FillType) {
        FillType[FillType.HORIZONTAL = 0] = "HORIZONTAL", FillType[FillType.VERTICAL = 1] = "VERTICAL", 
        FillType[FillType.RADIAL = 2] = "RADIAL";
    }(FillType || (FillType = {})), ccenum(FillType), function(SizeMode) {
        SizeMode[SizeMode.CUSTOM = 0] = "CUSTOM", SizeMode[SizeMode.TRIMMED = 1] = "TRIMMED", 
        SizeMode[SizeMode.RAW = 2] = "RAW";
    }(SizeMode || (SizeMode = {})), ccenum(SizeMode), function(EventType) {
        EventType.SPRITE_FRAME_CHANGED = "spriteframe-changed";
    }(EventType || (EventType = {}));
    var _dec$O, _dec2$q, _dec3$f, _dec4$c, _dec5$b, _class$O, _class2$H, _descriptor$A, SpriteComponent = (_dec$N = ccclass("cc.SpriteComponent"), 
    _dec2$p = executionOrder(110), _dec3$e = menu("UI/Render/Sprite"), _dec4$b = property({
        type: SpriteAtlas,
        displayOrder: 4,
        tooltip: "图片资源所属的 Atlas 图集资源"
    }), _dec5$a = property({
        type: SpriteFrame,
        displayOrder: 5,
        tooltip: "渲染 Sprite 使用的 SpriteFrame 图片资源"
    }), _dec6$7 = property({
        type: SpriteType,
        displayOrder: 6,
        tooltip: "渲染模式：\n- 普通（Simple）：修改尺寸会整体拉伸图像，适用于序列帧动画和普通图像 \n- 九宫格（Sliced）：修改尺寸时四个角的区域不会拉伸，适用于 UI 按钮和面板背景 \n- 填充（Filled）：设置一定的填充起始位置和方向，能够以一定比率剪裁显示图片"
    }), _dec7$4 = property({
        type: FillType,
        tooltip: "填充方向，可以选择横向（Horizontal），纵向（Vertical）和扇形（Radial）三种方向"
    }), _dec8$3 = property({
        tooltip: "扇形填充时，指定扇形的中心点，取值范围 0 ~ 1"
    }), _dec9$2 = property({
        range: [ 0, 1, .1 ],
        tooltip: "填充起始位置，输入一个 0 ~ 1 之间的小数表示起始位置的百分比"
    }), _dec10$2 = property({
        range: [ 0, 1, .1 ],
        tooltip: "填充总量，取值范围 0 ~ 1 指定显示图像范围的百分比"
    }), _dec11$2 = property({
        displayOrder: 8,
        tooltip: "节点约束框内是否包括透明像素区域，勾选此项会去除节点约束框内的透明区域"
    }), _dec12$2 = property({
        type: SizeMode,
        displayOrder: 7,
        tooltip: "指定 Sprite 所在节点的尺寸，CUSTOM 表示自定义尺寸，TRIMMED 表示取原始图片剪裁透明像素后的尺寸，RAW 表示取原始图片未剪裁的尺寸"
    }), _dec$N(_class$N = _dec2$p(_class$N = _dec3$e((_temp$I = _class3$g = function(_UIRenderComponent) {
        function SpriteComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SpriteComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_spriteFrame", _descriptor$z, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_type", _descriptor2$q, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_fillType", _descriptor3$j, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_sizeMode", _descriptor4$d, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_fillCenter", _descriptor5$9, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_fillStart", _descriptor6$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_fillRange", _descriptor7$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isTrimmedMode", _descriptor8$3, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_useGrayscale", _descriptor9$3, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_atlas", _descriptor10$3, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(SpriteComponent, _UIRenderComponent), _createClass(SpriteComponent, [ {
            key: "__preload",
            value: function __preload() {
                this._useGrayscale && (this._instanceMaterialType = exports.InstanceMaterialType.GRAYSCALE), 
                _get(_getPrototypeOf(SpriteComponent.prototype), "__preload", this) && _get(_getPrototypeOf(SpriteComponent.prototype), "__preload", this).call(this), 
                this._spriteFrame && (this._spriteFrame.on("load", this._markForUpdateUvDirty, this), 
                this._markForUpdateUvDirty());
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(SpriteComponent.prototype), "onEnable", this).call(this), this._activateMaterial();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(SpriteComponent.prototype), "onDestroy", this).call(this), 
                this.destroyRenderData(), this._spriteFrame && this._spriteFrame.off("load");
            }
        }, {
            key: "changeSpriteFrameFromAtlas",
            value: function changeSpriteFrameFromAtlas(name) {
                if (this._atlas) {
                    var sprite = this._atlas.getSpriteFrame(name);
                    this.spriteFrame = sprite;
                } else console.warn("SpriteAtlas is null.");
            }
        }, {
            key: "_render",
            value: function _render(render) {
                render.commitComp(this, this._spriteFrame.getGFXTextureView(), this._assembler);
            }
        }, {
            key: "_canRender",
            value: function _canRender() {
                if (!_get(_getPrototypeOf(SpriteComponent.prototype), "_canRender", this).call(this)) return !1;
                var spriteFrame = this._spriteFrame;
                return !(!spriteFrame || !spriteFrame.textureLoaded());
            }
        }, {
            key: "_flushAssembler",
            value: function _flushAssembler() {
                var assembler = SpriteComponent.Assembler.getAssembler(this);
                this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
                this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
                this._renderData.material = this._material, this.markForUpdateRenderData(), this._updateColor());
            }
        }, {
            key: "_applySpriteSize",
            value: function _applySpriteSize() {
                if (this._spriteFrame) {
                    if (SizeMode.RAW === this._sizeMode) {
                        var size = this._spriteFrame.originalSize;
                        this.node.setContentSize(size);
                    } else if (SizeMode.TRIMMED === this._sizeMode) {
                        var rect = this._spriteFrame.getRect();
                        this.node.setContentSize(rect.width, rect.height);
                    }
                    this._activateMaterial();
                }
            }
        }, {
            key: "_resized",
            value: function _resized() {
            }
        }, {
            key: "_activateMaterial",
            value: function _activateMaterial() {
                var spriteFrame = this._spriteFrame, material = this._material;
                cc.game.renderType !== cc.game.RENDER_TYPE_CANVAS ? (spriteFrame && material && (material.setProperty("mainTexture", spriteFrame), 
                this.markForUpdateRenderData()), this._renderData && (this._renderData.material = material)) : this.markForUpdateRenderData();
            }
        }, {
            key: "_onTextureLoaded",
            value: function _onTextureLoaded() {
                this.isValid && this._applySpriteSize();
            }
        }, {
            key: "_applySpriteFrame",
            value: function _applySpriteFrame(oldFrame) {
                var spriteFrame = this._spriteFrame;
                this._renderData && (oldFrame && oldFrame.off("load", this._markForUpdateUvDirty), 
                spriteFrame && spriteFrame.on("load", this._markForUpdateUvDirty, this), this._renderData.uvDirty || (this._renderData.uvDirty = !oldFrame || !spriteFrame || oldFrame.uvHash !== spriteFrame.uvHash), 
                this._renderDataFlag = this._renderData.uvDirty), spriteFrame && (oldFrame && spriteFrame === oldFrame || (spriteFrame.loaded ? this._onTextureLoaded() : spriteFrame.once("load", this._onTextureLoaded, this)));
            }
        }, {
            key: "_markForUpdateUvDirty",
            value: function _markForUpdateUvDirty() {
                this._renderData && (this._renderData.uvDirty = !0, this._renderDataFlag = !0);
            }
        }, {
            key: "spriteAtlas",
            get: function get() {
                return this._atlas;
            },
            set: function set(value) {
                this._atlas !== value && (this._atlas = value);
            }
        }, {
            key: "spriteFrame",
            get: function get() {
                return this._spriteFrame;
            },
            set: function set(value) {
                if (this._spriteFrame !== value) {
                    var lastSprite = this._spriteFrame;
                    this._spriteFrame = value, this.markForUpdateRenderData(!1), this._applySpriteFrame(lastSprite);
                }
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            },
            set: function set(value) {
                this._type !== value && (this._type = value, this._flushAssembler());
            }
        }, {
            key: "fillType",
            get: function get() {
                return this._fillType;
            },
            set: function set(value) {
                this._fillType !== value && (value === FillType.RADIAL || this._fillType === FillType.RADIAL ? (this.destroyRenderData(), 
                this._renderData = null) : this._renderData && this.markForUpdateRenderData(!0)), 
                this._fillType = value, this._flushAssembler();
            }
        }, {
            key: "fillCenter",
            get: function get() {
                return this._fillCenter;
            },
            set: function set(value) {
                this._fillCenter.x = value.x, this._fillCenter.y = value.y, this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData();
            }
        }, {
            key: "fillStart",
            get: function get() {
                return this._fillStart;
            },
            set: function set(value) {
                this._fillStart = clamp(value, -1, 1), this._type === SpriteType.FILLED && this._renderData && (this.markForUpdateRenderData(), 
                this._renderData.uvDirty = !0);
            }
        }, {
            key: "fillRange",
            get: function get() {
                return this._fillRange;
            },
            set: function set(value) {
                this._fillRange = clamp(value, 0, 1), this._type === SpriteType.FILLED && this._renderData && (this.markForUpdateRenderData(), 
                this._renderData.uvDirty = !0);
            }
        }, {
            key: "trim",
            get: function get() {
                return this._isTrimmedMode;
            },
            set: function set(value) {
                this._isTrimmedMode !== value && (this._isTrimmedMode = value, this._type === SpriteType.SIMPLE && this._renderData && this.markForUpdateRenderData(!0));
            }
        }, {
            key: "grayscale",
            get: function get() {
                return this._useGrayscale;
            },
            set: function set(value) {
                this._useGrayscale !== value && (this._useGrayscale = value, this._instanceMaterialType = !0 === value ? exports.InstanceMaterialType.GRAYSCALE : exports.InstanceMaterialType.ADDCOLORANDTEXTURE, 
                this._instanceMaterial());
            }
        }, {
            key: "sizeMode",
            get: function get() {
                return this._sizeMode;
            },
            set: function set(value) {
                this._sizeMode !== value && (this._sizeMode = value, value !== SizeMode.CUSTOM && this._applySpriteSize());
            }
        } ]), SpriteComponent;
    }(UIRenderComponent), _class3$g.FillType = FillType, _class3$g.Type = SpriteType, 
    _class3$g.SizeMode = SizeMode, _class3$g.EventType = EventType, _applyDecoratedDescriptor((_class2$G = _temp$I).prototype, "spriteAtlas", [ _dec4$b ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "spriteAtlas"), _class2$G.prototype), 
    _applyDecoratedDescriptor(_class2$G.prototype, "spriteFrame", [ _dec5$a ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "spriteFrame"), _class2$G.prototype), 
    _applyDecoratedDescriptor(_class2$G.prototype, "type", [ _dec6$7 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "type"), _class2$G.prototype), 
    _applyDecoratedDescriptor(_class2$G.prototype, "fillType", [ _dec7$4 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "fillType"), _class2$G.prototype), 
    _applyDecoratedDescriptor(_class2$G.prototype, "fillCenter", [ _dec8$3 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "fillCenter"), _class2$G.prototype), 
    _applyDecoratedDescriptor(_class2$G.prototype, "fillStart", [ _dec9$2 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "fillStart"), _class2$G.prototype), 
    _applyDecoratedDescriptor(_class2$G.prototype, "fillRange", [ _dec10$2 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "fillRange"), _class2$G.prototype), 
    _applyDecoratedDescriptor(_class2$G.prototype, "trim", [ _dec11$2 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "trim"), _class2$G.prototype), 
    _applyDecoratedDescriptor(_class2$G.prototype, "grayscale", [ property ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "grayscale"), _class2$G.prototype), 
    _applyDecoratedDescriptor(_class2$G.prototype, "sizeMode", [ _dec12$2 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "sizeMode"), _class2$G.prototype), 
    _descriptor$z = _applyDecoratedDescriptor(_class2$G.prototype, "_spriteFrame", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$q = _applyDecoratedDescriptor(_class2$G.prototype, "_type", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return SpriteType.SIMPLE;
        }
    }), _descriptor3$j = _applyDecoratedDescriptor(_class2$G.prototype, "_fillType", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return FillType.HORIZONTAL;
        }
    }), _descriptor4$d = _applyDecoratedDescriptor(_class2$G.prototype, "_sizeMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return SizeMode.TRIMMED;
        }
    }), _descriptor5$9 = _applyDecoratedDescriptor(_class2$G.prototype, "_fillCenter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(0, 0);
        }
    }), _descriptor6$4 = _applyDecoratedDescriptor(_class2$G.prototype, "_fillStart", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor7$4 = _applyDecoratedDescriptor(_class2$G.prototype, "_fillRange", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor8$3 = _applyDecoratedDescriptor(_class2$G.prototype, "_isTrimmedMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor9$3 = _applyDecoratedDescriptor(_class2$G.prototype, "_useGrayscale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor10$3 = _applyDecoratedDescriptor(_class2$G.prototype, "_atlas", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$N = _class2$G)) || _class$N) || _class$N) || _class$N);
    cc.SpriteComponent = SpriteComponent;
    var SubContextView = (_dec$O = ccclass("cc.SubContextView"), _dec2$q = executionOrder(110), 
    _dec3$f = requireComponent(UITransformComponent), _dec4$c = menu("Components/SubContextView"), 
    _dec5$b = property({
        tooltip: "帧数"
    }), _dec$O(_class$O = _dec2$q(_class$O = _dec3$f(_class$O = _dec4$c((_applyDecoratedDescriptor((_class2$H = function(_Component) {
        function SubContextView() {
            var _this;
            return _classCallCheck(this, SubContextView), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(SubContextView).call(this)), "_fps", _descriptor$A, _assertThisInitialized(_this)), 
            _this._updatedTime = 0, _this._updateInterval = 0, _this._sprite = null, _this._imageAsset = new ImageAsset, 
            _this._context = null, _this._updatedTime = performance.now(), _this;
        }
        return _inherits(SubContextView, _Component), _createClass(SubContextView, [ {
            key: "fps",
            get: function get() {
                return this._fps;
            },
            set: function set(value) {
                this._fps !== value && (this._fps = value, this._updateInterval = 1 / value, this._updateSubContextFrameRate());
            }
        } ]), _createClass(SubContextView, [ {
            key: "onLoad",
            value: function onLoad() {
                if (wx && wx.getOpenDataContext) {
                    this._updateInterval = 1e3 / this._fps, this._context = wx.getOpenDataContext(), 
                    this.reset();
                    var image = this._imageAsset, sharedCanvas = this._context.canvas;
                    if (image.reset(sharedCanvas), image._texture.create(sharedCanvas.width, sharedCanvas.height), 
                    this._sprite = this.node.getComponent(SpriteComponent), this._sprite || (this._sprite = this.node.addComponent(SpriteComponent)), 
                    this._sprite.spriteFrame) this._sprite.spriteFrame.texture = this._imageAsset._texture; else {
                        var sp = new SpriteFrame;
                        sp.texture = this._imageAsset._texture, this._sprite.spriteFrame = sp;
                    }
                } else this.enabled = !1;
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._runSubContextMainLoop(), this._registerNodeEvent(), this._updateSubContextFrameRate(), 
                this.updateSubContextViewport();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._unregisterNodeEvent(), this._stopSubContextMainLoop();
            }
        }, {
            key: "update",
            value: function update(dt) {
                if (void 0 === dt) return this._context && this._context.postMessage({
                    fromEngine: !0,
                    event: "step"
                }), void this._updateSubContextTexture();
                performance.now() - this._updatedTime >= this._updateInterval && (this._updatedTime += this._updateInterval, 
                this._updateSubContextTexture());
            }
        }, {
            key: "reset",
            value: function reset() {
                if (this._context) {
                    this.updateSubContextViewport();
                    var sharedCanvas = this._context.canvas, transformComp = this.node.getComponent(UITransformComponent);
                    sharedCanvas && (sharedCanvas.width = transformComp.width, sharedCanvas.height = transformComp.height);
                }
            }
        }, {
            key: "updateSubContextViewport",
            value: function updateSubContextViewport() {
                if (this._context) {
                    var box = this.node.getComponent(UITransformComponent).getBoundingBoxToWorld(), sx = view.getScaleX(), sy = view.getScaleY(), rect = view.getViewportRect();
                    this._context.postMessage({
                        fromEngine: !0,
                        event: "viewport",
                        x: box.x * sx + rect.x,
                        y: box.y * sy + rect.y,
                        width: box.width * sx,
                        height: box.height * sy
                    });
                }
            }
        }, {
            key: "_updateSubContextTexture",
            value: function _updateSubContextTexture() {
                var img = this._imageAsset;
                if (img && this._context && !(img.width <= 0 || img.height <= 0)) {
                    var canvas = this._context.canvas;
                    img.reset(canvas), (canvas.width > img.width || canvas.height > img.height) && this._imageAsset._texture.create(canvas.width, canvas.height), 
                    this._imageAsset._texture.uploadData(canvas);
                }
            }
        }, {
            key: "_registerNodeEvent",
            value: function _registerNodeEvent() {
                this.node.on(Node$1.EventType.TRANSFORM_CHANGED, this.updateSubContextViewport, this), 
                this.node.on(Node$1.EventType.SIZE_CHANGED, this.updateSubContextViewport, this);
            }
        }, {
            key: "_unregisterNodeEvent",
            value: function _unregisterNodeEvent() {
                this.node.off(Node$1.EventType.TRANSFORM_CHANGED, this.updateSubContextViewport, this), 
                this.node.off(Node$1.EventType.SIZE_CHANGED, this.updateSubContextViewport, this);
            }
        }, {
            key: "_runSubContextMainLoop",
            value: function _runSubContextMainLoop() {
                this._context && this._context.postMessage({
                    fromEngine: !0,
                    event: "mainLoop",
                    value: !0
                });
            }
        }, {
            key: "_stopSubContextMainLoop",
            value: function _stopSubContextMainLoop() {
                this._context && this._context.postMessage({
                    fromEngine: !0,
                    event: "mainLoop",
                    value: !1
                });
            }
        }, {
            key: "_updateSubContextFrameRate",
            value: function _updateSubContextFrameRate() {
                this._context && this._context.postMessage({
                    fromEngine: !0,
                    event: "frameRate",
                    value: this._fps
                });
            }
        } ]), SubContextView;
    }(Component)).prototype, "fps", [ _dec5$b ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "fps"), _class2$H.prototype), 
    _descriptor$A = _applyDecoratedDescriptor(_class2$H.prototype, "_fps", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 60;
        }
    }), _class$O = _class2$H)) || _class$O) || _class$O) || _class$O) || _class$O);
    cc.SubContextView = SubContextView;
    var System = function() {
        function System() {
            _classCallCheck(this, System), this._id = "", this._priority = 0, this._executeInEditMode = !1;
        }
        return _createClass(System, [ {
            key: "init",
            value: function init() {}
        }, {
            key: "update",
            value: function update(dt) {}
        }, {
            key: "postUpdate",
            value: function postUpdate(dt) {}
        }, {
            key: "priority",
            set: function set(value) {
                this._priority = value;
            },
            get: function get() {
                return this._priority;
            }
        }, {
            key: "id",
            set: function set(id) {
                this._id = id;
            },
            get: function get() {
                return this._id;
            }
        } ], [ {
            key: "sortByPriority",
            value: function sortByPriority(a, b) {
                return a._priority < b._priority ? 1 : a._priority > b.priority ? -1 : 0;
            }
        } ]), System;
    }(), idGenerator$3 = new IDGenerator("Scheduler"), ListEntry = function ListEntry(target, priority, paused, markedForDeletion) {
        _classCallCheck(this, ListEntry), this.target = target, this.priority = priority, 
        this.paused = paused, this.markedForDeletion = markedForDeletion;
    };
    ListEntry.get = function(target, priority, paused, markedForDeletion) {
        var result = ListEntry._listEntries.pop();
        return result ? (result.target = target, result.priority = priority, result.paused = paused, 
        result.markedForDeletion = markedForDeletion) : result = new ListEntry(target, priority, paused, markedForDeletion), 
        result;
    }, ListEntry.put = function(entry) {
        ListEntry._listEntries.length < 20 && (entry.target = null, ListEntry._listEntries.push(entry));
    }, ListEntry._listEntries = [];
    var HashUpdateEntry = function HashUpdateEntry(list, entry, target, callback) {
        _classCallCheck(this, HashUpdateEntry), this.list = list, this.entry = entry, this.target = target, 
        this.callback = callback;
    };
    HashUpdateEntry.get = function(list, entry, target, callback) {
        var result = HashUpdateEntry._hashUpdateEntries.pop();
        return result ? (result.list = list, result.entry = entry, result.target = target, 
        result.callback = callback) : result = new HashUpdateEntry(list, entry, target, callback), 
        result;
    }, HashUpdateEntry.put = function(entry) {
        HashUpdateEntry._hashUpdateEntries.length < 20 && (entry.list = entry.entry = entry.target = entry.callback = null, 
        HashUpdateEntry._hashUpdateEntries.push(entry));
    }, HashUpdateEntry._hashUpdateEntries = [];
    var HashTimerEntry = function HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
        _classCallCheck(this, HashTimerEntry), this.timers = timers, this.target = target, 
        this.timerIndex = timerIndex, this.currentTimer = currentTimer, this.currentTimerSalvaged = currentTimerSalvaged, 
        this.paused = paused;
    };
    HashTimerEntry.get = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
        var result = HashTimerEntry._hashTimerEntries.pop();
        return result ? (result.timers = timers, result.target = target, result.timerIndex = timerIndex, 
        result.currentTimer = currentTimer, result.currentTimerSalvaged = currentTimerSalvaged, 
        result.paused = paused) : result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused), 
        result;
    }, HashTimerEntry.put = function(entry) {
        HashTimerEntry._hashTimerEntries.length < 20 && (entry.timers = entry.target = entry.currentTimer = null, 
        HashTimerEntry._hashTimerEntries.push(entry));
    }, HashTimerEntry._hashTimerEntries = [];
    var CallbackTimer = function() {
        function CallbackTimer() {
            _classCallCheck(this, CallbackTimer), this._lock = !1, this._scheduler = null, this._elapsed = -1, 
            this._runForever = !1, this._useDelay = !1, this._timesExecuted = 0, this._repeat = 0, 
            this._delay = 0, this._interval = 0, this._target = null, this._callback = null;
        }
        return _createClass(CallbackTimer, [ {
            key: "initWithCallback",
            value: function initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
                return this._lock = !1, this._scheduler = scheduler, this._target = target, this._callback = callback, 
                this._elapsed = -1, this._interval = seconds, this._delay = delay, this._useDelay = this._delay > 0, 
                this._repeat = repeat, this._runForever = this._repeat === cc.macro.REPEAT_FOREVER, 
                !0;
            }
        }, {
            key: "getInterval",
            value: function getInterval() {
                return this._interval;
            }
        }, {
            key: "setInterval",
            value: function setInterval(interval) {
                this._interval = interval;
            }
        }, {
            key: "update",
            value: function update(dt) {
                -1 === this._elapsed ? (this._elapsed = 0, this._timesExecuted = 0) : (this._elapsed += dt, 
                this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), 
                this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), 
                this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), 
                this._elapsed = 0, this._timesExecuted += 1), this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel()));
            }
        }, {
            key: "getCallback",
            value: function getCallback() {
                return this._callback;
            }
        }, {
            key: "trigger",
            value: function trigger() {
                this._target && this._callback && (this._lock = !0, this._callback.call(this._target, this._elapsed), 
                this._lock = !1);
            }
        }, {
            key: "cancel",
            value: function cancel() {
                this._scheduler.unschedule(this._callback, this._target);
            }
        } ]), CallbackTimer;
    }();
    CallbackTimer._timers = [], CallbackTimer.get = function() {
        return CallbackTimer._timers.pop() || new CallbackTimer;
    }, CallbackTimer.put = function(timer) {
        CallbackTimer._timers.length < 20 && !timer._lock && (timer._scheduler = timer._target = timer._callback = null, 
        CallbackTimer._timers.push(timer));
    };
    var Scheduler = function(_System) {
        function Scheduler() {
            var _this;
            return _classCallCheck(this, Scheduler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Scheduler).call(this)))._timeScale = 1, 
            _this._updatesNegList = [], _this._updates0List = [], _this._updatesPosList = [], 
            _this._hashForUpdates = createMap(!0), _this._hashForTimers = createMap(!0), _this._currentTarget = null, 
            _this._currentTargetSalvaged = !1, _this._updateHashLocked = !1, _this._arrayForTimers = [], 
            _this;
        }
        return _inherits(Scheduler, _System), _createClass(Scheduler, null, [ {
            key: "enableForTarget",
            value: function enableForTarget(target) {
                var found = !1;
                target.uuid ? found = !0 : target.id && (found = !0), found || (target.__instanceId ? cc.warnID(1513) : target.id = idGenerator$3.getNewId());
            }
        } ]), _createClass(Scheduler, [ {
            key: "setTimeScale",
            value: function setTimeScale(timeScale) {
                this._timeScale = timeScale;
            }
        }, {
            key: "getTimeScale",
            value: function getTimeScale() {
                return this._timeScale;
            }
        }, {
            key: "update",
            value: function update(dt) {
                var i, list, len, entry, elt;
                for (this._updateHashLocked = !0, 1 !== this._timeScale && (dt *= this._timeScale), 
                i = 0, len = (list = this._updatesNegList).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
                for (i = 0, len = (list = this._updates0List).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
                for (i = 0, len = (list = this._updatesPosList).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
                var arr = this._arrayForTimers;
                for (i = 0; i < arr.length; i++) {
                    if (elt = arr[i], this._currentTarget = elt, this._currentTargetSalvaged = !1, !elt.paused) for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) elt.currentTimer = elt.timers[elt.timerIndex], 
                    elt.currentTimerSalvaged = !1, elt.currentTimer.update(dt), elt.currentTimer = null;
                    this._currentTargetSalvaged && 0 === this._currentTarget.timers.length && (this._removeHashElement(this._currentTarget), 
                    --i);
                }
                for (i = 0, list = this._updatesNegList; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                for (i = 0, list = this._updates0List; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                for (i = 0, list = this._updatesPosList; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                this._updateHashLocked = !1, this._currentTarget = null;
            }
        }, {
            key: "schedule",
            value: function schedule(callback, target, interval, repeat, delay, paused) {
                if ("function" != typeof callback) {
                    var tmp = callback;
                    callback = target, target = tmp;
                }
                3 !== arguments.length && 4 !== arguments.length && 5 !== arguments.length || (paused = !!repeat, 
                repeat = cc.macro.REPEAT_FOREVER, delay = 0), cc.assertID(target, 1502);
                var targetId = target.uuid || target.id;
                if (targetId) {
                    var timer, i, element = this._hashForTimers[targetId];
                    if (element ? element.paused !== paused && cc.warnID(1511) : (element = HashTimerEntry.get(null, target, 0, null, null, paused), 
                    this._arrayForTimers.push(element), this._hashForTimers[targetId] = element), null == element.timers) element.timers = []; else for (i = 0; i < element.timers.length; ++i) if ((timer = element.timers[i]) && callback === timer._callback) return cc.logID(1507, timer.getInterval(), interval), 
                    void (timer._interval = interval);
                    (timer = CallbackTimer.get()).initWithCallback(this, callback, target, interval, repeat, delay), 
                    element.timers.push(timer), this._currentTarget === element && this._currentTargetSalvaged && (this._currentTargetSalvaged = !1);
                } else cc.errorID(1510);
            }
        }, {
            key: "scheduleUpdate",
            value: function scheduleUpdate(target, priority, paused) {
                var targetId = target.uuid || target.id;
                if (targetId) {
                    var hashElement = this._hashForUpdates[targetId];
                    if (hashElement && hashElement.entry) {
                        if (hashElement.entry.priority === priority) return hashElement.entry.markedForDeletion = !1, 
                        void (hashElement.entry.paused = paused);
                        if (this._updateHashLocked) return cc.logID(1506), hashElement.entry.markedForDeletion = !1, 
                        void (hashElement.entry.paused = paused);
                        this.unscheduleUpdate(target);
                    }
                    var ppList, listElement = ListEntry.get(target, priority, paused, !1);
                    0 === priority ? (ppList = this._updates0List, this._appendIn(ppList, listElement)) : (ppList = priority < 0 ? this._updatesNegList : this._updatesPosList, 
                    this._priorityIn(ppList, listElement, priority)), this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
                } else cc.errorID(1510);
            }
        }, {
            key: "unschedule",
            value: function unschedule(callback, target) {
                if (target && callback) {
                    var targetId = target.uuid || target.id;
                    if (targetId) {
                        var element = this._hashForTimers[targetId];
                        if (element) for (var timers = element.timers, i = 0, li = timers.length; i < li; i++) {
                            var timer = timers[i];
                            if (callback === timer._callback) return timer !== element.currentTimer || element.currentTimerSalvaged || (element.currentTimerSalvaged = !0), 
                            timers.splice(i, 1), CallbackTimer.put(timer), element.timerIndex >= i && element.timerIndex--, 
                            void (0 === timers.length && (this._currentTarget === element ? this._currentTargetSalvaged = !0 : this._removeHashElement(element)));
                        }
                    } else cc.errorID(1510);
                }
            }
        }, {
            key: "unscheduleUpdate",
            value: function unscheduleUpdate(target) {
                if (target) {
                    var targetId = target.uuid || target.id;
                    if (targetId) {
                        var element = this._hashForUpdates[targetId];
                        element && (this._updateHashLocked ? element.entry.markedForDeletion = !0 : this._removeUpdateFromHash(element.entry));
                    } else cc.errorID(1510);
                }
            }
        }, {
            key: "unscheduleAllForTarget",
            value: function unscheduleAllForTarget(target) {
                if (target) {
                    var targetId = target.uuid || target.id;
                    if (targetId) {
                        var element = this._hashForTimers[targetId];
                        if (element) {
                            var timers = element.timers;
                            timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged && (element.currentTimerSalvaged = !0);
                            for (var i = 0, l = timers.length; i < l; i++) CallbackTimer.put(timers[i]);
                            timers.length = 0, this._currentTarget === element ? this._currentTargetSalvaged = !0 : this._removeHashElement(element);
                        }
                        this.unscheduleUpdate(target);
                    } else cc.errorID(1510);
                }
            }
        }, {
            key: "unscheduleAll",
            value: function unscheduleAll() {
                this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
            }
        }, {
            key: "unscheduleAllWithMinPriority",
            value: function unscheduleAllWithMinPriority(minPriority) {
                var i, element, entry, arr = this._arrayForTimers;
                for (i = arr.length - 1; i >= 0; i--) element = arr[i], this.unscheduleAllForTarget(element.target);
                var temp_length = 0;
                if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; ) temp_length = this._updatesNegList.length, 
                (entry = this._updatesNegList[i]) && entry.priority >= minPriority && this.unscheduleUpdate(entry.target), 
                temp_length === this._updatesNegList.length && i++;
                if (minPriority <= 0) for (i = 0; i < this._updates0List.length; ) temp_length = this._updates0List.length, 
                (entry = this._updates0List[i]) && this.unscheduleUpdate(entry.target), temp_length === this._updates0List.length && i++;
                for (i = 0; i < this._updatesPosList.length; ) temp_length = this._updatesPosList.length, 
                (entry = this._updatesPosList[i]) && entry.priority >= minPriority && this.unscheduleUpdate(entry.target), 
                temp_length === this._updatesPosList.length && i++;
            }
        }, {
            key: "isScheduled",
            value: function isScheduled(callback, target) {
                cc.assertID(callback, 1508), cc.assertID(target, 1509);
                var targetId = target.uuid || target.id;
                if (targetId) {
                    var element = this._hashForTimers[targetId];
                    if (!element) return !1;
                    if (null == element.timers) return !1;
                    for (var timers = element.timers, i = 0; i < timers.length; ++i) {
                        if (callback === timers[i]._callback) return !0;
                    }
                    return !1;
                }
                cc.errorID(1510);
            }
        }, {
            key: "pauseAllTargets",
            value: function pauseAllTargets() {
                return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
            }
        }, {
            key: "pauseAllTargetsWithMinPriority",
            value: function pauseAllTargetsWithMinPriority(minPriority) {
                var element, i, li, entry, idsWithSelectors = [], locArrayForTimers = this._arrayForTimers;
                for (i = 0, li = locArrayForTimers.length; i < li; i++) (element = locArrayForTimers[i]) && (element.paused = !0, 
                idsWithSelectors.push(element.target));
                if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; i++) (entry = this._updatesNegList[i]) && entry.priority >= minPriority && (entry.paused = !0, 
                idsWithSelectors.push(entry.target));
                if (minPriority <= 0) for (i = 0; i < this._updates0List.length; i++) (entry = this._updates0List[i]) && (entry.paused = !0, 
                idsWithSelectors.push(entry.target));
                for (i = 0; i < this._updatesPosList.length; i++) (entry = this._updatesPosList[i]) && entry.priority >= minPriority && (entry.paused = !0, 
                idsWithSelectors.push(entry.target));
                return idsWithSelectors;
            }
        }, {
            key: "resumeTargets",
            value: function resumeTargets(targetsToResume) {
                if (targetsToResume) for (var i = 0; i < targetsToResume.length; i++) this.resumeTarget(targetsToResume[i]);
            }
        }, {
            key: "pauseTarget",
            value: function pauseTarget(target) {
                cc.assertID(target, 1503);
                var targetId = target.uuid || target.id;
                if (targetId) {
                    var element = this._hashForTimers[targetId];
                    element && (element.paused = !0);
                    var elementUpdate = this._hashForUpdates[targetId];
                    elementUpdate && (elementUpdate.entry.paused = !0);
                } else cc.errorID(1510);
            }
        }, {
            key: "resumeTarget",
            value: function resumeTarget(target) {
                cc.assertID(target, 1504);
                var targetId = target.uuid || target.id;
                if (targetId) {
                    var element = this._hashForTimers[targetId];
                    element && (element.paused = !1);
                    var elementUpdate = this._hashForUpdates[targetId];
                    elementUpdate && (elementUpdate.entry.paused = !1);
                } else cc.errorID(1510);
            }
        }, {
            key: "isTargetPaused",
            value: function isTargetPaused(target) {
                cc.assertID(target, 1505);
                var targetId = target.uuid || target.id;
                if (!targetId) return cc.errorID(1510), !1;
                var element = this._hashForTimers[targetId];
                if (element) return element.paused;
                var elementUpdate = this._hashForUpdates[targetId];
                return !!elementUpdate && elementUpdate.entry.paused;
            }
        }, {
            key: "_removeHashElement",
            value: function _removeHashElement(element) {
                var targetId = element.target.uuid || element.target.id;
                delete this._hashForTimers[targetId];
                for (var arr = this._arrayForTimers, i = 0, l = arr.length; i < l; i++) if (arr[i] === element) {
                    arr.splice(i, 1);
                    break;
                }
                HashTimerEntry.put(element);
            }
        }, {
            key: "_removeUpdateFromHash",
            value: function _removeUpdateFromHash(entry) {
                var targetId = entry.target.uuid || entry.target.id, element = this._hashForUpdates[targetId];
                if (element) {
                    for (var list = element.list, listEntry = element.entry, i = 0, l = list.length; i < l; i++) if (list[i] === listEntry) {
                        list.splice(i, 1);
                        break;
                    }
                    delete this._hashForUpdates[targetId], ListEntry.put(listEntry), HashUpdateEntry.put(element);
                }
            }
        }, {
            key: "_priorityIn",
            value: function _priorityIn(ppList, listElement, priority) {
                for (var i = 0; i < ppList.length; i++) if (priority < ppList[i].priority) return void ppList.splice(i, 0, listElement);
                ppList.push(listElement);
            }
        }, {
            key: "_appendIn",
            value: function _appendIn(ppList, listElement) {
                ppList.push(listElement);
            }
        } ]), Scheduler;
    }(System);
    Scheduler.PRIORITY_SYSTEM = 1 << 31, Scheduler.PRIORITY_NON_SYSTEM = Scheduler.PRIORITY_SYSTEM + 1, 
    Scheduler.ID = "scheduler", cc.Scheduler = Scheduler;
    var Stage, DataPoolManager = function() {
        function DataPoolManager(device) {
            _classCallCheck(this, DataPoolManager), this.jointsTexturePool = new JointsTexturePool(device), 
            this.jointsAnimationInfo = new JointsAnimationInfo(device), this.animatedBoundsInfo = new AnimatedBoundsInfo;
        }
        return _createClass(DataPoolManager, [ {
            key: "releaseMesh",
            value: function releaseMesh(mesh) {
                this.animatedBoundsInfo.releaseMesh(mesh);
            }
        }, {
            key: "releaseSkeleton",
            value: function releaseSkeleton(skeleton) {
                this.jointsTexturePool.releaseSkeleton(skeleton), this.animatedBoundsInfo.releaseSkeleton(skeleton);
            }
        }, {
            key: "releaseAnimationClip",
            value: function releaseAnimationClip(clip) {
                this.jointsTexturePool.releaseAnimationClip(clip), this.animatedBoundsInfo.releaseAnimationClip(clip);
            }
        }, {
            key: "clear",
            value: function clear() {
                this.jointsTexturePool.clear(), this.jointsAnimationInfo.clear(), this.animatedBoundsInfo.clear();
            }
        } ]), DataPoolManager;
    }(), MeshBuffer = function() {
        function MeshBuffer(batcher) {
            _classCallCheck(this, MeshBuffer), this.vData = null, this.iData = null, this.vb = null, 
            this.ib = null, this.ia = null, this.byteStart = 0, this.byteOffset = 0, this.indiceStart = 0, 
            this.indiceOffset = 0, this.vertexStart = 0, this.vertexOffset = 0, this.lastByteOffset = 1, 
            this.dirty = !1, this._vertexFormatBytes = 9 * Float32Array.BYTES_PER_ELEMENT, this._initVDataCount = 256 * this._vertexFormatBytes, 
            this._initIDataCount = 1536, this._outofCallback = null, this.batcher = batcher;
        }
        return _createClass(MeshBuffer, [ {
            key: "initialize",
            value: function initialize(attrs, outofCallback) {
                this._outofCallback = outofCallback;
                var vbStride = 9 * Float32Array.BYTES_PER_ELEMENT;
                this.vb = this.vb || this.batcher.device.createBuffer({
                    usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: 0,
                    stride: vbStride
                });
                var ibStride = Uint16Array.BYTES_PER_ELEMENT;
                this.ib = this.ib || this.batcher.device.createBuffer({
                    usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: 0,
                    stride: ibStride
                }), this.ia = this.ia || this.batcher.device.createInputAssembler({
                    attributes: attrs,
                    vertexBuffers: [ this.vb ],
                    indexBuffer: this.ib
                }), this._reallocBuffer();
            }
        }, {
            key: "request",
            value: function request() {
                var vertexCount = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 4, indiceCount = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 6;
                this.lastByteOffset = this.byteOffset;
                var byteOffset = this.byteOffset + vertexCount * this._vertexFormatBytes, indiceOffset = this.indiceOffset + indiceCount;
                if (vertexCount + this.vertexOffset > 65535) return this.batcher.autoMergeBatches(), 
                this._outofCallback && this._outofCallback.call(this.batcher, vertexCount, indiceCount), 
                !1;
                var byteLength = this.vData.byteLength, indiceLength = this.iData.length;
                if (byteOffset > byteLength || indiceOffset > indiceLength) {
                    for (;byteLength < byteOffset || indiceLength < indiceOffset; ) this._initVDataCount *= 2, 
                    this._initIDataCount *= 2, byteLength = 4 * this._initVDataCount, indiceLength = this._initIDataCount;
                    this._reallocBuffer();
                }
                return this.vertexOffset += vertexCount, this.indiceOffset += indiceCount, this.byteOffset = byteOffset, 
                this.dirty = !0, !0;
            }
        }, {
            key: "reset",
            value: function reset() {
                this.byteStart = 0, this.byteOffset = 0, this.indiceStart = 0, this.indiceOffset = 0, 
                this.vertexStart = 0, this.vertexOffset = 0, this.lastByteOffset = 0, this.dirty = !1;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.ib.destroy(), this.vb.destroy(), this.ia.destroy(), this.ib = null, this.vb = null, 
                this.ia = null;
            }
        }, {
            key: "uploadData",
            value: function uploadData() {
                if (0 !== this.byteOffset && this.dirty) {
                    var verticesData = new Float32Array(this.vData.buffer, 0, this.byteOffset >> 2), indicesData = new Uint16Array(this.iData.buffer, 0, this.indiceOffset);
                    this.byteOffset > this.vb.size && this.vb.resize(this.byteOffset), this.vb.update(verticesData), 
                    2 * this.indiceOffset > this.ib.size && this.ib.resize(2 * this.indiceOffset), this.ib.update(indicesData);
                }
            }
        }, {
            key: "_reallocBuffer",
            value: function _reallocBuffer() {
                this._reallocVData(!0), this._reallocIData(!0);
            }
        }, {
            key: "_reallocVData",
            value: function _reallocVData(copyOldData) {
                var oldVData;
                if (this.vData && (oldVData = new Uint8Array(this.vData.buffer)), this.vData = new Float32Array(this._initVDataCount), 
                oldVData && copyOldData) for (var newData = new Uint8Array(this.vData.buffer), i = 0, l = oldVData.length; i < l; i++) newData[i] = oldVData[i];
            }
        }, {
            key: "_reallocIData",
            value: function _reallocIData(copyOldData) {
                var oldIData = this.iData;
                if (this.iData = new Uint16Array(this._initIDataCount), oldIData && copyOldData) for (var iData = this.iData, i = 0, l = oldIData.length; i < l; i++) iData[i] = oldIData[i];
            }
        } ]), MeshBuffer;
    }();
    MeshBuffer.OPACITY_OFFSET = 8, function(Stage) {
        Stage[Stage.DISABLED = 0] = "DISABLED", Stage[Stage.CLEAR = 1] = "CLEAR", Stage[Stage.ENTER_LEVEL = 2] = "ENTER_LEVEL", 
        Stage[Stage.ENABLED = 3] = "ENABLED", Stage[Stage.EXIT_LEVEL = 4] = "EXIT_LEVEL";
    }(Stage || (Stage = {}));
    var StencilManager = function() {
        function StencilManager() {
            _classCallCheck(this, StencilManager), this.stage = Stage.DISABLED, this._maskStack = [], 
            this._stencilPattern = {
                stencilTest: !0,
                func: exports.GFXComparisonFunc.ALWAYS,
                stencilMask: 65535,
                writeMask: 65535,
                failOp: exports.GFXStencilOp.KEEP,
                zFailOp: exports.GFXStencilOp.KEEP,
                passOp: exports.GFXStencilOp.KEEP,
                ref: 1
            }, this._defaultPipelineState = {
                depthStencilState: {},
                rasterizerState: {},
                blendState: {}
            };
        }
        return _createClass(StencilManager, [ {
            key: "pushMask",
            value: function pushMask(mask) {
                this._maskStack.push(mask);
            }
        }, {
            key: "clear",
            value: function clear() {
                this.stage = Stage.CLEAR;
            }
        }, {
            key: "enterLevel",
            value: function enterLevel() {
                this.stage = Stage.ENTER_LEVEL;
            }
        }, {
            key: "enableMask",
            value: function enableMask() {
                this.stage = Stage.ENABLED;
            }
        }, {
            key: "exitMask",
            value: function exitMask() {
                0 !== this._maskStack.length && (this._maskStack.pop(), 0 === this._maskStack.length ? this.stage = Stage.DISABLED : this.stage = Stage.ENABLED);
            }
        }, {
            key: "handleMaterial",
            value: function handleMaterial(mat) {
                var pattern = this._stencilPattern;
                if (this.stage === Stage.DISABLED) pattern.stencilTest = !1, pattern.func = exports.GFXComparisonFunc.ALWAYS, 
                pattern.failOp = exports.GFXStencilOp.KEEP, pattern.stencilMask = pattern.writeMask = 65535, 
                pattern.ref = 1; else if (pattern.stencilTest = !0, this.stage === Stage.ENABLED) pattern.func = exports.GFXComparisonFunc.EQUAL, 
                pattern.failOp = exports.GFXStencilOp.KEEP, pattern.stencilMask = pattern.ref = this.getStencilRef(), 
                pattern.writeMask = this.getWriteMask(); else if (this.stage === Stage.CLEAR) {
                    var mask = this._maskStack[this._maskStack.length - 1];
                    pattern.func = exports.GFXComparisonFunc.NEVER, pattern.failOp = mask.inverted ? exports.GFXStencilOp.REPLACE : exports.GFXStencilOp.ZERO, 
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                } else if (this.stage === Stage.ENTER_LEVEL) {
                    var _mask = this._maskStack[this._maskStack.length - 1];
                    pattern.func = exports.GFXComparisonFunc.NEVER, pattern.failOp = _mask.inverted ? exports.GFXStencilOp.ZERO : exports.GFXStencilOp.REPLACE, 
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                }
                var pass = mat.passes[0];
                if (this._changed(pass)) {
                    var state = this._stencilPattern;
                    return this._defaultPipelineState.depthStencilState = {
                        stencilTestFront: state.stencilTest,
                        stencilFuncFront: state.func,
                        stencilReadMaskFront: state.stencilMask,
                        stencilWriteMaskFront: state.writeMask,
                        stencilFailOpFront: state.failOp,
                        stencilZFailOpFront: state.zFailOp,
                        stencilPassOpFront: state.passOp,
                        stencilRefFront: state.ref,
                        stencilTestBack: state.stencilTest,
                        stencilFuncBack: state.func,
                        stencilReadMaskBack: state.stencilMask,
                        stencilWriteMaskBack: state.writeMask,
                        stencilFailOpBack: state.failOp,
                        stencilZFailOpBack: state.zFailOp,
                        stencilPassOpBack: state.passOp,
                        stencilRefBack: state.ref
                    }, this._defaultPipelineState.blendState = pass.blendState, this._defaultPipelineState.rasterizerState = pass.rasterizerState, 
                    mat.overridePipelineStates(this._defaultPipelineState), !0;
                }
                return !1;
            }
        }, {
            key: "getWriteMask",
            value: function getWriteMask() {
                return 1 << this._maskStack.length - 1;
            }
        }, {
            key: "getExitWriteMask",
            value: function getExitWriteMask() {
                return 1 << this._maskStack.length;
            }
        }, {
            key: "getStencilRef",
            value: function getStencilRef() {
                for (var result = 0, i = 0; i < this._maskStack.length; ++i) result += 1 << i;
                return result;
            }
        }, {
            key: "reset",
            value: function reset() {
                this._maskStack.length = 0, this.stage = Stage.DISABLED;
            }
        }, {
            key: "_changed",
            value: function _changed(pass) {
                var stencilState = pass.depthStencilState, pattern = this._stencilPattern;
                return pattern.stencilTest !== stencilState.stencilTestFront || pattern.func !== stencilState.stencilFuncFront || pattern.failOp !== stencilState.stencilFailOpFront || pattern.zFailOp !== stencilState.stencilZFailOpFront || pattern.passOp !== stencilState.stencilPassOpFront || pattern.stencilMask !== stencilState.stencilReadMaskFront || pattern.writeMask !== stencilState.stencilWriteMaskFront || pattern.ref !== stencilState.stencilRefFront;
            }
        } ]), StencilManager;
    }();
    StencilManager.sharedManager = null, StencilManager.sharedManager = new StencilManager;
    var UIBatchModel = function(_Model) {
        function UIBatchModel() {
            var _this;
            return _classCallCheck(this, UIBatchModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(UIBatchModel).call(this)))._subModel = new UISubModel, 
            _this;
        }
        return _inherits(UIBatchModel, _Model), _createClass(UIBatchModel, [ {
            key: "updateTransform",
            value: function updateTransform() {}
        }, {
            key: "updateUBOs",
            value: function updateUBOs() {
                return !1;
            }
        }, {
            key: "directInitialize",
            value: function directInitialize(ia, batch) {
                this._subModel.directInitialize(ia, batch.material, batch.pipelineState), this._subModels[0] = this._subModel;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._subModel.destroy();
            }
        } ]), UIBatchModel;
    }(Model), UISubModel = function(_SubModel) {
        function UISubModel() {
            var _this2;
            return _classCallCheck(this, UISubModel), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(UISubModel).call(this))).psos = [], 
            _this2;
        }
        return _inherits(UISubModel, _SubModel), _createClass(UISubModel, [ {
            key: "directInitialize",
            value: function directInitialize(ia, mat, pso) {
                this._inputAssembler = ia, this.psos[0] = pso, this.material = mat;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.commandBuffers.length > 0 && this.commandBuffers[0].destroy();
            }
        } ]), UISubModel;
    }(SubModel), UIDrawBatch = function() {
        function UIDrawBatch() {
            _classCallCheck(this, UIDrawBatch), this.camera = null, this.bufferBatch = null, 
            this.model = null, this.material = null, this.texView = null, this.firstIdx = 0, 
            this.idxCount = 0, this.pipelineState = null, this.bindingLayout = null, this.useLocalData = null, 
            this.isStatic = !1;
        }
        return _createClass(UIDrawBatch, [ {
            key: "destroy",
            value: function destroy(ui) {
                this.pipelineState && (ui._getUIMaterial(this.material).revertPipelineState(this.pipelineState), 
                this.pipelineState = null), this.bindingLayout && (this.bindingLayout = null);
            }
        }, {
            key: "clear",
            value: function clear(ui) {
                this.pipelineState && (ui._getUIMaterial(this.material).revertPipelineState(this.pipelineState), 
                this.pipelineState = null), this.camera = null, this.bufferBatch = null, this.material = null, 
                this.texView = null, this.firstIdx = 0, this.idxCount = 0, this.model = null, this.isStatic = !1;
            }
        } ]), UIDrawBatch;
    }(), UIMaterial = function() {
        function UIMaterial() {
            _classCallCheck(this, UIMaterial), this._material = null, this._pass = null, this._refCount = 0, 
            this._psos = null;
        }
        return _createClass(UIMaterial, [ {
            key: "material",
            get: function get() {
                return this._material;
            }
        }, {
            key: "pass",
            get: function get() {
                return this._pass;
            }
        } ]), _createClass(UIMaterial, [ {
            key: "initialize",
            value: function initialize(info) {
                var _this = this;
                return !!info.material && (this._material = new Material, this._material.copy(info.material), 
                this._pass = this._material.passes[0], this._pass.update(), this._psos = new Pool$1((function() {
                    return _this._pass.createPipelineState();
                }), 1), !0);
            }
        }, {
            key: "increase",
            value: function increase() {
                return this._refCount++, this._refCount;
            }
        }, {
            key: "decrease",
            value: function decrease() {
                return this._refCount--, 0 === this._refCount && this.destroy(), this._refCount;
            }
        }, {
            key: "getPipelineState",
            value: function getPipelineState() {
                return this._psos.alloc();
            }
        }, {
            key: "revertPipelineState",
            value: function revertPipelineState(pso) {
                this._psos.free(pso);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var _this2 = this;
                this._psos && this._psos.clear((function(obj) {
                    _this2._pass.destroyPipelineState(obj);
                })), this._material && (this._material.destroy(), this._material = null), this._refCount = 0;
            }
        } ]), UIMaterial;
    }(), vfmt = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RG32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA32F
    } ], UIVertexFormat = Object.freeze({
        __proto__: null,
        vfmt: vfmt
    }), UI = function() {
        function UI(_root) {
            var _this = this;
            _classCallCheck(this, UI), this._screens = [], this._bufferBatchPool = new RecyclePool((function() {
                return new MeshBuffer(_this);
            }), 128), this._drawBatchPool = new Pool$1((function() {
                return new UIDrawBatch;
            }), 128), this._cmdBuff = null, this._attributes = [], this._meshBuffers = [], this._meshBufferUseCount = 0, 
            this._uiMaterials = new Map, this._canvasMaterials = new Map, this._uiModelPool = null, 
            this._emptyMaterial = new Material, this._currMaterial = this._emptyMaterial, this._currTexView = null, 
            this._currCanvas = null, this._currMeshBuffer = null, this._currStaticRoot = null, 
            this._parentOpacity = 1, this._root = _root, this.device = _root.device, this._scene = this._root.createScene({
                name: "GUIScene"
            }), this._uiModelPool = new Pool$1((function() {
                var model = cc.director.root.createModel(UIBatchModel);
                return model.enabled = !0, model.visFlags |= Layers.Enum.UI_3D, model;
            }), 2), this._modelInUse = new CachedArray(10), this._batches = new CachedArray(64), 
            cc.director.on(cc.Director.EVENT_BEFORE_DRAW, this.update, this);
        }
        return _createClass(UI, [ {
            key: "renderScene",
            get: function get() {
                return this._scene;
            }
        }, {
            key: "currBufferBatch",
            get: function get() {
                return this._currMeshBuffer;
            },
            set: function set(value) {
                value && (this._currMeshBuffer = value);
            }
        }, {
            key: "currStaticRoot",
            set: function set(value) {
                this._currStaticRoot = value;
            }
        } ]), _createClass(UI, [ {
            key: "initialize",
            value: function initialize() {
                return this._attributes = vfmt, this._requireBufferBatch(), this._cmdBuff = this.device.createCommandBuffer({
                    allocator: this.device.commandAllocator,
                    type: exports.GFXCommandBufferType.PRIMARY
                }), !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var _iterator = this._batches.array, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.destroy(this);
                }
                var _iterator2 = this._meshBuffers, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2.destroy();
                }
                this._meshBuffers.splice(0), this._destroyUIMaterials(), this._cmdBuff && (this._cmdBuff.destroy(), 
                this._cmdBuff = null);
            }
        }, {
            key: "getRenderSceneGetter",
            value: function getRenderSceneGetter() {
                return Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), "renderScene").get.bind(this);
            }
        }, {
            key: "_getUIMaterial",
            value: function _getUIMaterial(mat) {
                if (this._uiMaterials.has(mat.hash)) return this._uiMaterials.get(mat.hash);
                var uiMat = new UIMaterial;
                return uiMat.initialize({
                    material: mat
                }), this._uiMaterials.set(mat.hash, uiMat), uiMat;
            }
        }, {
            key: "_removeUIMaterial",
            value: function _removeUIMaterial(hash) {
                this._uiMaterials.has(hash) && 0 === this._uiMaterials.get(hash).decrease() && this._uiMaterials.delete(hash);
            }
        }, {
            key: "addScreen",
            value: function addScreen(comp) {
                for (var screens = this._screens, i = 0; i < screens.length; i++) {
                    var screen = screens[i];
                    if (screen.camera) {
                        var visibility = screen.camera.view.visibility, matRecord = this._canvasMaterials.get(visibility);
                        if (matRecord) {
                            for (var matHashInter = matRecord.keys(), matHash = matHashInter.next(); !matHash.done; ) this._removeUIMaterial(matHash.value), 
                            matHash = matHashInter.next();
                            matRecord.clear();
                        }
                    }
                }
                this._screens.push(comp), this._screens.sort(this._screenSort);
                for (var _i3 = 0; _i3 < screens.length; _i3++) {
                    var element = screens[_i3];
                    element.camera && (element.camera.view.visibility = Layers.BitMask.UI_2D | _i3 + 1, 
                    this._canvasMaterials.has(element.camera.view.visibility) || this._canvasMaterials.set(element.camera.view.visibility, new Map));
                }
            }
        }, {
            key: "getScreen",
            value: function getScreen(visibility) {
                for (var screens = this._screens, i = 0; i < screens.length; ++i) {
                    var screen = screens[i];
                    if (screen.camera && screen.camera.view.visibility === visibility) return screen;
                }
                return null;
            }
        }, {
            key: "removeScreen",
            value: function removeScreen(comp) {
                var _this2 = this, idx = this._screens.indexOf(comp);
                if (-1 !== idx) {
                    if (this._screens.splice(idx, 1), comp.camera) {
                        for (var matRecord = this._canvasMaterials.get(comp.camera.view.visibility), matHashInter = matRecord.keys(), matHash = matHashInter.next(); !matHash.done; ) this._removeUIMaterial(matHash.value), 
                        matHash = matHashInter.next();
                        matRecord.clear();
                    }
                    for (var camera, i = idx; i < this._screens.length; i++) (camera = this._screens[i].camera) && function() {
                        var matRecord = _this2._canvasMaterials.get(camera.view.visibility);
                        camera.view.visibility = Layers.BitMask.UI_2D | i + 1;
                        var newMatRecord = _this2._canvasMaterials.get(camera.view.visibility);
                        matRecord.forEach((function(value, key) {
                            newMatRecord.set(key, value);
                        })), matRecord.clear();
                    }();
                }
            }
        }, {
            key: "update",
            value: function update(dt) {
                if (this._renderScreens(), this._batches.length > 0) for (var buffers = this._meshBuffers, i = 0; i < buffers.length; ++i) {
                    var bufferBatch = buffers[i];
                    bufferBatch.uploadData(), bufferBatch.reset();
                }
                this.render(), this._reset();
            }
        }, {
            key: "sortScreens",
            value: function sortScreens() {
                this._screens.sort(this._screenSort);
            }
        }, {
            key: "render",
            value: function render() {
                for (var batchPriority = 0, i = 0; i < this._modelInUse.length; i++) this._scene.removeModel(this._modelInUse.get(i)), 
                this._uiModelPool.free(this._modelInUse.get(i));
                if (this._modelInUse.clear(), this._batches.length) for (var _i4 = 0; _i4 < this._batches.length; ++_i4) {
                    var batch = this._batches.array[_i4];
                    if (batch.model) {
                        if (batch.camera) {
                            var visFlags = batch.camera.view.visibility;
                            batch.model.visFlags = visFlags, batch.model.node.layer = visFlags;
                        }
                        for (var j = 0; j < batch.model.subModelNum; j++) batch.model.getSubModel(j).priority = batchPriority++;
                    } else {
                        var bindingLayout = batch.bindingLayout;
                        bindingLayout.bindTextureView(UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT, batch.texView), 
                        bindingLayout.update();
                        var ia = batch.bufferBatch.ia;
                        ia.firstIndex = batch.firstIdx, ia.indexCount = batch.idxCount;
                        var uiModel = this._uiModelPool.alloc();
                        uiModel.directInitialize(ia, batch), this._scene.addModel(uiModel), uiModel.getSubModel(0).priority = batchPriority++, 
                        batch.camera && (uiModel.visFlags = batch.camera.view.visibility, null == this._canvasMaterials.get(batch.camera.view.visibility).get(batch.material.hash) && (this._uiMaterials.get(batch.material.hash).increase(), 
                        this._canvasMaterials.get(batch.camera.view.visibility).set(batch.material.hash, 1))), 
                        this._modelInUse.push(uiModel);
                    }
                }
            }
        }, {
            key: "commitComp",
            value: function commitComp(comp) {
                var frame = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, assembler = arguments.length > 2 ? arguments[2] : void 0, renderComp = comp, texView = frame;
                this._currMaterial.hash === renderComp.material.hash && this._currTexView === texView || (this.autoMergeBatches(), 
                this._currMaterial = renderComp.material, this._currTexView = texView), assembler && (assembler.fillBuffers(renderComp, this), 
                this._applyOpacity(renderComp));
            }
        }, {
            key: "commitModel",
            value: function commitModel(comp, model, mat) {
                if ((this._currMaterial !== this._emptyMaterial && this.autoMergeBatches(), mat) && (StencilManager.sharedManager.handleMaterial(mat) && model)) for (var i = 0; i < model.subModelNum; i++) model.setSubModelMaterial(i, mat);
                var uiCanvas = this._currCanvas, curDrawBatch = this._drawBatchPool.alloc();
                curDrawBatch.camera = uiCanvas && uiCanvas.camera, curDrawBatch.model = model, curDrawBatch.bufferBatch = null, 
                curDrawBatch.material = mat, curDrawBatch.texView = null, curDrawBatch.firstIdx = 0, 
                curDrawBatch.idxCount = 0, curDrawBatch.pipelineState = null, curDrawBatch.bindingLayout = null, 
                this._currMaterial = this._emptyMaterial, this._currTexView = null, this._batches.push(curDrawBatch);
            }
        }, {
            key: "commitStaticBatch",
            value: function commitStaticBatch(comp) {
                this._batches.concat(comp.drawBatchList), this.finishMergeBatches();
            }
        }, {
            key: "autoMergeBatches",
            value: function autoMergeBatches() {
                var mat = this._currMaterial, buffer = this._currMeshBuffer, indicsStart = buffer.indiceStart, vCount = buffer.indiceOffset - indicsStart;
                if (vCount && mat) {
                    var uiCanvas = this._currCanvas;
                    StencilManager.sharedManager.handleMaterial(mat);
                    var curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
                    curDrawBatch.camera = uiCanvas && uiCanvas.camera, curDrawBatch.bufferBatch = buffer, 
                    curDrawBatch.material = mat, curDrawBatch.texView = this._currTexView, curDrawBatch.firstIdx = indicsStart, 
                    curDrawBatch.idxCount = vCount, curDrawBatch.pipelineState = this._getUIMaterial(mat).getPipelineState(), 
                    curDrawBatch.bindingLayout = curDrawBatch.pipelineState.pipelineLayout.layouts[0], 
                    this._batches.push(curDrawBatch), buffer.vertexStart = buffer.vertexOffset, buffer.indiceStart = buffer.indiceOffset, 
                    buffer.byteStart = buffer.byteOffset;
                }
            }
        }, {
            key: "forceMergeBatches",
            value: function forceMergeBatches(material, sprite) {
                this._currMaterial = material, this._currTexView = sprite, this.autoMergeBatches();
            }
        }, {
            key: "finishMergeBatches",
            value: function finishMergeBatches() {
                this.autoMergeBatches(), this._currMaterial = this._emptyMaterial, this._currTexView = null;
            }
        }, {
            key: "_destroyUIMaterials",
            value: function _destroyUIMaterials() {
                for (var matIter = this._uiMaterials.values(), result = matIter.next(); !result.done; ) {
                    result.value.destroy(), result = matIter.next();
                }
                this._uiMaterials.clear();
            }
        }, {
            key: "_walk",
            value: function _walk(node) {
                var level = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, len = node.children.length, parentOpacity = this._parentOpacity;
                if (this._parentOpacity *= node._uiProps.opacity, this._preprocess(node), len > 0 && !node._static) for (var children = node.children, i = 0; i < children.length; ++i) {
                    var child = children[i];
                    this._walk(child, level);
                }
                this._postprocess(node), this._parentOpacity = parentOpacity, level += 1;
            }
        }, {
            key: "_renderScreens",
            value: function _renderScreens() {
                for (var screens = this._screens, i = 0; i < screens.length; ++i) {
                    var screen = screens[i];
                    screen.enabledInHierarchy && (this._currCanvas = screen, this._recursiveScreenNode(screen.node));
                }
            }
        }, {
            key: "_preprocess",
            value: function _preprocess(c) {
                if (c._uiProps.uiTransformComp) {
                    c._uiProps.uiTransformComp._canvas = this._currCanvas;
                    var render = c._uiProps.uiComp;
                    render && render.enabledInHierarchy && render.updateAssembler(this);
                }
            }
        }, {
            key: "_postprocess",
            value: function _postprocess(c) {
                var render = c._uiProps.uiComp;
                render && render.enabledInHierarchy && render.postUpdateAssembler(this);
            }
        }, {
            key: "_recursiveScreenNode",
            value: function _recursiveScreenNode(screen) {
                this._walk(screen), this.autoMergeBatches();
            }
        }, {
            key: "_reset",
            value: function _reset() {
                for (var i = 0; i < this._batches.length; ++i) {
                    var batch = this._batches.array[i];
                    batch.isStatic || (batch.clear(this), this._drawBatchPool.free(batch));
                }
                this._parentOpacity = 1, this._batches.clear(), this._currMaterial = this._emptyMaterial, 
                this._currCanvas = null, this._currTexView = null, this._meshBufferUseCount = 0, 
                this._requireBufferBatch(), StencilManager.sharedManager.reset();
            }
        }, {
            key: "_createMeshBuffer",
            value: function _createMeshBuffer() {
                var batch = this._bufferBatchPool.add();
                return batch.initialize(this._attributes, this._requireBufferBatch.bind(this)), 
                this._meshBuffers.push(batch), batch;
            }
        }, {
            key: "_requireBufferBatch",
            value: function _requireBufferBatch() {
                this._meshBufferUseCount >= this._meshBuffers.length ? this._currMeshBuffer = this._createMeshBuffer() : this._currMeshBuffer = this._meshBuffers[this._meshBufferUseCount], 
                this._meshBufferUseCount++, 2 === arguments.length && this._currMeshBuffer.request(arguments[0], arguments[1]);
            }
        }, {
            key: "_screenSort",
            value: function _screenSort(a, b) {
                var delta = a.priority - b.priority;
                return 0 === delta ? a.node.getSiblingIndex() - b.node.getSiblingIndex() : delta;
            }
        }, {
            key: "_applyOpacity",
            value: function _applyOpacity(comp) {
                for (var color = comp.color.a / 255, opacity = this._parentOpacity = this._parentOpacity * color, byteOffset = this._currMeshBuffer.byteOffset >> 2, vbuf = this._currMeshBuffer.vData, i = this._currMeshBuffer.lastByteOffset >> 2; i < byteOffset; i += 9) vbuf[i + MeshBuffer.OPACITY_OFFSET] = opacity;
                this._currMeshBuffer.lastByteOffset = this._currMeshBuffer.byteOffset;
            }
        } ]), UI;
    }(), Root = function() {
        function Root(device) {
            _classCallCheck(this, Root), this._windows = [], this._mainWindow = null, this._curWindow = null, 
            this._tempWindow = null, this._pipeline = null, this._ui = null, this._scenes = [], 
            this._views = [], this._modelPools = new Map, this._cameraPool = null, this._lightPools = new Map, 
            this._directLightPool = null, this._sphereLightPool = null, this._spotLightPool = null, 
            this._time = 0, this._frameTime = 0, this._fpsTime = 0, this._frameCount = 0, this._fps = 0, 
            this._fixedFPS = 0, this._fixedFPSFrameTime = 0, this._device = device, this._dataPoolMgr = new DataPoolManager(device), 
            RenderScene.registerCreateFunc(this), RenderView.registerCreateFunc(this), this._cameraPool = new Pool$1((function() {
                return new Camera;
            }), 4);
        }
        return _createClass(Root, [ {
            key: "device",
            get: function get() {
                return this._device;
            }
        }, {
            key: "mainWindow",
            get: function get() {
                return this._mainWindow;
            }
        }, {
            key: "curWindow",
            set: function set(window) {
                this._curWindow = window;
            },
            get: function get() {
                return this._curWindow;
            }
        }, {
            key: "tempWindow",
            set: function set(window) {
                this._tempWindow = window;
            },
            get: function get() {
                return this._tempWindow;
            }
        }, {
            key: "windows",
            get: function get() {
                return this._windows;
            }
        }, {
            key: "pipeline",
            get: function get() {
                return this._pipeline;
            }
        }, {
            key: "ui",
            get: function get() {
                return this._ui;
            }
        }, {
            key: "scenes",
            get: function get() {
                return this._scenes;
            }
        }, {
            key: "views",
            get: function get() {
                return this._views;
            }
        }, {
            key: "cumulativeTime",
            get: function get() {
                return this._time;
            }
        }, {
            key: "frameTime",
            get: function get() {
                return this._frameTime;
            }
        }, {
            key: "frameCount",
            get: function get() {
                return this._frameCount;
            }
        }, {
            key: "fps",
            get: function get() {
                return this._fps;
            }
        }, {
            key: "fixedFPS",
            set: function set(fps) {
                fps > 0 ? (this._fixedFPS = fps, this._fixedFPSFrameTime = 1e3 / fps) : this._fixedFPSFrameTime = 0;
            },
            get: function get() {
                return this._fixedFPS;
            }
        }, {
            key: "dataPoolManager",
            get: function get() {
                return this._dataPoolMgr;
            }
        } ]), _createClass(Root, [ {
            key: "initialize",
            value: function initialize(info) {
                var _this = this;
                return !!this._device.mainWindow && (this._mainWindow = this._device.mainWindow, 
                this._curWindow = this._mainWindow, builtinResMgr.initBuiltinRes(this._device), 
                cc.view.on("design-resolution-changed", (function() {
                    var width = cc.game.canvas.width, height = cc.game.canvas.height;
                    _this.resize(width, height);
                }), this), !0);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.destroyViews(), this.destroyScenes(), this._pipeline && (this._pipeline.destroy(), 
                this._pipeline = null), this._ui && (this._ui.destroy(), this._ui = null), this._curWindow = null, 
                this._mainWindow = null, this.dataPoolManager.clear();
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._device.resize(width, height), this._mainWindow.resize(width, height);
                var _iterator = this._windows, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var window = _ref;
                    window.isOffscreen || window.resize(width, height);
                }
                this._pipeline && this._pipeline.resize(width, height);
                var _iterator2 = this._views, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var view = _ref2;
                    view.camera.isWindowSize && view.camera.resize(width, height);
                }
            }
        }, {
            key: "setRenderPipeline",
            value: function setRenderPipeline(rppl) {
                return this._pipeline = rppl, !!this._pipeline.activate(this) && (this._ui = new UI(this), 
                !!this._ui.initialize() || (this.destroy(), !1));
            }
        }, {
            key: "activeWindow",
            value: function activeWindow(window) {
                this._curWindow = window;
            }
        }, {
            key: "resetCumulativeTime",
            value: function resetCumulativeTime() {
                this._time = 0;
            }
        }, {
            key: "frameMove",
            value: function frameMove(deltaTime) {
                this._frameTime = deltaTime, ++this._frameCount, this._time += this._frameTime, 
                this._fpsTime += this._frameTime, this._fpsTime > 1 && (this._fps = this._frameCount, 
                this._frameCount = 0, this._fpsTime = 0);
                for (var views = this._views, i = 0; i < views.length; i++) {
                    var view = views[i];
                    view.isEnable && view.window && (view.window.isOffscreen || !view.window.isOffscreen && view.window === this._curWindow) && this._pipeline && this._pipeline.render(view);
                }
            }
        }, {
            key: "createWindow",
            value: function createWindow(info) {
                if (this._device) {
                    var window = this._device.createWindow(info);
                    if (window) return this._windows.push(window), window;
                }
                return null;
            }
        }, {
            key: "destroyWindow",
            value: function destroyWindow(window) {
                for (var i = 0; i < this._windows.length; ++i) if (this._windows[i] === window) return window.destroy(), 
                void this._windows.splice(i, 1);
            }
        }, {
            key: "destroyWindows",
            value: function destroyWindows() {
                var _iterator3 = this._windows, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    _ref3.destroy();
                }
                this._windows = [];
            }
        }, {
            key: "createScene",
            value: function createScene(info) {
                var scene = this._createSceneFun(this);
                return scene.initialize(info), this._scenes.push(scene), scene;
            }
        }, {
            key: "destroyScene",
            value: function destroyScene(scene) {
                for (var i = 0; i < this._scenes.length; ++i) if (this._scenes[i] === scene) return scene.destroy(), 
                void this._scenes.splice(i, 1);
            }
        }, {
            key: "destroyScenes",
            value: function destroyScenes() {
                var _iterator4 = this._scenes, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    _ref4.destroy();
                }
                this._scenes = [];
            }
        }, {
            key: "createView",
            value: function createView(info) {
                var view = this._createViewFun(this, info.camera);
                return view.initialize(info), this._views.push(view), this.sortViews(), view;
            }
        }, {
            key: "destroyView",
            value: function destroyView(view) {
                for (var i = 0; i < this._views.length; ++i) if (this._views[i] === view) return this._views.splice(i, 1), 
                void view.destroy();
            }
        }, {
            key: "destroyViews",
            value: function destroyViews() {
                var _iterator5 = this._views, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    _ref5.destroy();
                }
                this._views = [];
            }
        }, {
            key: "createModel",
            value: function createModel(mClass) {
                var p = this._modelPools.get(mClass);
                return p || (this._modelPools.set(mClass, new Pool$1((function() {
                    return new mClass;
                }), 10)), p = this._modelPools.get(mClass)), p.alloc();
            }
        }, {
            key: "destroyModel",
            value: function destroyModel(m) {
                var p = this._modelPools.get(m.constructor);
                p && (p.free(m), m.destroy(), m.scene && m.scene.removeModel(m));
            }
        }, {
            key: "createCamera",
            value: function createCamera() {
                return this._cameraPool.alloc();
            }
        }, {
            key: "destroyCamera",
            value: function destroyCamera(c) {
                this._cameraPool.free(c), c.destroy(), c.scene && c.scene.removeCamera(c);
            }
        }, {
            key: "createLight",
            value: function createLight(lClass) {
                var l = this._lightPools.get(lClass);
                return l || (this._lightPools.set(lClass, new Pool$1((function() {
                    return new lClass;
                }), 4)), l = this._lightPools.get(lClass)), l.alloc();
            }
        }, {
            key: "destroyLight",
            value: function destroyLight(l) {
                var p = this._lightPools.get(l.constructor);
                if (l.destroy(), p && (p.free(l), l.scene)) switch (l.type) {
                  case LightType.SPHERE:
                    l.scene.removeSphereLight(l);
                    break;

                  case LightType.SPOT:
                    l.scene.removeSpotLight(l);
                }
            }
        }, {
            key: "sortViews",
            value: function sortViews() {
                this._views.sort((function(a, b) {
                    return a.priority - b.priority;
                }));
            }
        } ]), Root;
    }(), Director = function(_EventTarget) {
        function Director() {
            var _this;
            return _classCallCheck(this, Director), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Director).call(this)))._invalid = !1, 
            _this._paused = !1, _this._purgeDirectorInNextLoop = !1, _this._root = null, _this._loadingScene = "", 
            _this._scene = null, _this._totalFrames = 0, _this._lastUpdate = 0, _this._deltaTime = 0, 
            _this._scheduler = new Scheduler, _this._compScheduler = new ComponentScheduler, 
            _this._nodeActivator = new NodeActivator, _this._systems = [], cc.game.on(Game.EVENT_SHOW, (function() {
                _this._lastUpdate = performance.now();
            })), cc.game.once(Game.EVENT_RENDERER_INITED, _this._initOnRendererInitialized, _assertThisInitialized(_this)), 
            cc.game.once(Game.EVENT_ENGINE_INITED, _this._initOnEngineInitialized, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(Director, _EventTarget), _createClass(Director, [ {
            key: "calculateDeltaTime",
            value: function calculateDeltaTime() {
                var now = performance.now();
                this._deltaTime = (now - this._lastUpdate) / 1e3, this._deltaTime > 1 && (this._deltaTime = 1 / 60), 
                this._lastUpdate = now;
            }
        }, {
            key: "convertToGL",
            value: function convertToGL(uiPoint) {
                var container = cc.game.container, view = cc.view, box = container.getBoundingClientRect(), left = box.left + window.pageXOffset - container.clientLeft, top = box.top + window.pageYOffset - container.clientTop, x = view._devicePixelRatio * (uiPoint.x - left), y = view._devicePixelRatio * (top + box.height - uiPoint.y);
                return view._isRotated ? v2(view._viewportRect.width - y, x) : v2(x, y);
            }
        }, {
            key: "convertToUI",
            value: function convertToUI(glPoint) {
                var container = cc.game.container, view = cc.view, box = container.getBoundingClientRect(), left = box.left + window.pageXOffset - container.clientLeft, top = box.top + window.pageYOffset - container.clientTop, uiPoint = v2(0, 0);
                return view._isRotated ? (uiPoint.x = left + glPoint.y / view._devicePixelRatio, 
                uiPoint.y = top + box.height - (view._viewportRect.width - glPoint.x) / view._devicePixelRatio) : (uiPoint.x = left + glPoint.x * view._devicePixelRatio, 
                uiPoint.y = top + box.height - glPoint.y * view._devicePixelRatio), uiPoint;
            }
        }, {
            key: "end",
            value: function end() {
                this._purgeDirectorInNextLoop = !0;
            }
        }, {
            key: "getWinSize",
            value: function getWinSize() {
                return size(cc.winSize);
            }
        }, {
            key: "getWinSizeInPixels",
            value: function getWinSizeInPixels() {
                return size(cc.winSize);
            }
        }, {
            key: "pause",
            value: function pause() {
                this._paused || (this._paused = !0);
            }
        }, {
            key: "purgeCachedData",
            value: function purgeCachedData() {
                cc.loader.releaseAll();
            }
        }, {
            key: "purgeDirector",
            value: function purgeDirector() {
                this._scheduler.unscheduleAll(), this._compScheduler.unscheduleAll(), this._nodeActivator.reset(), 
                eventManager && eventManager.setEnabled(!1), cc.isValid(this._scene) && this._scene.destroy(), 
                this._scene = null, this.stopAnimation(), null != this._root && this._root.destroy(), 
                this._root = null, cc.loader.releaseAll();
            }
        }, {
            key: "reset",
            value: function reset() {
                this.purgeDirector(), this.emit(Director.EVENT_RESET), eventManager && eventManager.setEnabled(!0), 
                this.startAnimation();
            }
        }, {
            key: "runSceneImmediate",
            value: function runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
                cc.assertID(scene instanceof cc.Scene, 1216);
                var uuid = cc.loader._getReferenceKey(scene.uuid);
                cc.loader.removeItem(uuid), console.time("InitScene"), scene._load(), console.timeEnd("InitScene"), 
                console.time("AttachPersist");
                for (var persistNodeList = Object.keys(cc.game._persistRootNodes).map((function(x) {
                    return cc.game._persistRootNodes[x];
                })), i = 0; i < persistNodeList.length; i++) {
                    var node = persistNodeList[i];
                    node.emit(cc.Node.SCENE_CHANGED_FOR_PERSISTS, scene.renderScene);
                    var existNode = scene.getChildByUuid(node.uuid);
                    if (existNode) {
                        var index = existNode.getSiblingIndex();
                        existNode._destroyImmediate(), scene.insertChild(node, index);
                    } else node.parent = scene;
                }
                console.timeEnd("AttachPersist");
                var oldScene = this._scene;
                console.time("AutoRelease"), function autoRelease(oldSceneAssets, nextSceneAssets, persistNodes) {
                    var releaseSettings = cc.loader._autoReleaseSetting, excludeMap = createMap();
                    if (nextSceneAssets) for (var i = 0; i < nextSceneAssets.length; i++) excludeMap[nextSceneAssets[i]] = !0;
                    for (var _i2 = 0; _i2 < persistNodes.length; _i2++) visitNode(persistNodes[_i2], excludeMap);
                    if (oldSceneAssets) for (var _i3 = 0; _i3 < oldSceneAssets.length; _i3++) {
                        var key = oldSceneAssets[_i3];
                        !1 === releaseSettings[key] || excludeMap[key] || cc.loader.release(key);
                    }
                    for (var keys = Object.keys(releaseSettings), _i4 = 0; _i4 < keys.length; _i4++) {
                        var _key = keys[_i4];
                        !0 !== releaseSettings[_key] || excludeMap[_key] || cc.loader.release(_key);
                    }
                }(oldScene && oldScene.autoReleaseAssets && oldScene.dependAssets, scene.dependAssets, persistNodeList), 
                console.timeEnd("AutoRelease"), console.time("Destroy"), cc.isValid(oldScene) && oldScene.destroy(), 
                this._scene = null, CCObject._deferredDestroy(), console.timeEnd("Destroy"), onBeforeLoadScene && onBeforeLoadScene(), 
                this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene), this._scene = scene, console.time("Activate"), 
                scene._activate(), console.timeEnd("Activate"), this._root && this._root.resetCumulativeTime(), 
                this.startAnimation(), onLaunched && onLaunched(null, scene), this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
            }
        }, {
            key: "runScene",
            value: function runScene(scene, onBeforeLoadScene, onLaunched) {
                var _this2 = this;
                cc.assertID(scene, 1205), cc.assertID(scene instanceof cc.Scene, 1216), scene._load(), 
                this.once(cc.Director.EVENT_AFTER_UPDATE, (function() {
                    _this2.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
                }));
            }
        }, {
            key: "_getSceneUuid",
            value: function _getSceneUuid(key) {
                var scenes = cc.game._sceneInfos;
                if ("string" == typeof key) {
                    key.endsWith(".scene") || (key += ".scene"), "/" === key[0] || key.startsWith("db://") || (key = "/" + key);
                    for (var i = 0; i < scenes.length; i++) {
                        var info = scenes[i];
                        if (info.url.endsWith(key)) return info;
                    }
                } else if ("number" == typeof key) {
                    if (0 <= key && key < scenes.length) return scenes[key];
                    cc.errorID(1206, key);
                } else cc.errorID(1207, key);
                return null;
            }
        }, {
            key: "loadScene",
            value: function loadScene(sceneName, onLaunched, onUnloaded) {
                if (this._loadingScene) return cc.errorID(1208, sceneName, this._loadingScene), 
                !1;
                var info = this._getSceneUuid(sceneName);
                if (info) {
                    var _uuid = info.uuid;
                    return this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName), this._loadingScene = sceneName, 
                    this._loadSceneByUuid(_uuid, onLaunched, onUnloaded), !0;
                }
                return cc.errorID(1209, sceneName), !1;
            }
        }, {
            key: "preloadScene",
            value: function preloadScene(sceneName, arg1, arg2) {
                var onProgress, onLoaded;
                void 0 === arg2 ? (onLoaded = arg1, onProgress = void 0) : (onLoaded = arg2, onProgress = arg1);
                var info = this._getSceneUuid(sceneName);
                if (info) this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName), cc.loader.load({
                    uuid: info.uuid,
                    type: "uuid"
                }, onProgress, (function(error, asset) {
                    error && cc.errorID(1210, sceneName, error.message), onLoaded && onLoaded(error, asset);
                })); else {
                    var _error = 'Can not preload the scene "' + sceneName + '" because it is not in the build settings.';
                    onLoaded && onLoaded(new Error(_error)), cc.error("preloadScene: " + _error);
                }
            }
        }, {
            key: "_loadSceneByUuid",
            value: function _loadSceneByUuid(uuid, arg1, arg2, arg3) {
                var onLaunched, onUnloaded;
                onLaunched = arg1, onUnloaded = arg2, console.time("LoadScene " + uuid), cc.AssetLibrary.loadAsset(uuid, (function(error, sceneAsset) {
                    console.timeEnd("LoadScene " + uuid);
                    var self = director;
                    if (self._loadingScene = "", error) error = "Failed to load scene: " + error, cc.error(error); else {
                        if (sceneAsset instanceof cc.SceneAsset) {
                            var _scene = sceneAsset.scene;
                            return _scene._id = sceneAsset._uuid, _scene._name = sceneAsset._name, void self.runSceneImmediate(_scene, onUnloaded, onLaunched);
                        }
                        error = "The asset " + uuid + " is not a scene", cc.error(error);
                    }
                    onLaunched && onLaunched(error);
                }));
            }
        }, {
            key: "resume",
            value: function resume() {
                this._paused && (this._lastUpdate = performance.now(), this._lastUpdate || cc.logID(1200), 
                this._paused = !1, this._deltaTime = 0);
            }
        }, {
            key: "setDepthTest",
            value: function setDepthTest(value) {
                cc.Camera.main && (cc.Camera.main.depth = !!value);
            }
        }, {
            key: "setClearColor",
            value: function setClearColor(clearColor) {
                cc.Camera.main && (cc.Camera.main.backgroundColor = clearColor);
            }
        }, {
            key: "getRunningScene",
            value: function getRunningScene() {
                return this._scene;
            }
        }, {
            key: "getScene",
            value: function getScene() {
                return this._scene;
            }
        }, {
            key: "getAnimationInterval",
            value: function getAnimationInterval() {
                return 1e3 / cc.game.getFrameRate();
            }
        }, {
            key: "setAnimationInterval",
            value: function setAnimationInterval(value) {
                cc.game.setFrameRate(Math.round(1e3 / value));
            }
        }, {
            key: "getDeltaTime",
            value: function getDeltaTime() {
                return this._deltaTime;
            }
        }, {
            key: "getCurrentTime",
            value: function getCurrentTime() {
                return this._lastUpdate;
            }
        }, {
            key: "getTotalFrames",
            value: function getTotalFrames() {
                return this._totalFrames;
            }
        }, {
            key: "isPaused",
            value: function isPaused() {
                return this._paused;
            }
        }, {
            key: "getScheduler",
            value: function getScheduler() {
                return this._scheduler;
            }
        }, {
            key: "setScheduler",
            value: function setScheduler(scheduler) {
                this._scheduler !== scheduler && (this.unregisterSystem(this._scheduler), this._scheduler = scheduler, 
                this.registerSystem(Scheduler.ID, scheduler, 200));
            }
        }, {
            key: "registerSystem",
            value: function registerSystem(name, sys, priority) {
                sys.id = name, sys.priority = priority, sys.init(), this._systems.push(sys), this._systems.sort(System.sortByPriority);
            }
        }, {
            key: "unregisterSystem",
            value: function unregisterSystem(sys) {
                array.fastRemove(this._systems, sys), this._systems.sort(System.sortByPriority);
            }
        }, {
            key: "getSystem",
            value: function getSystem(name) {
                return this._systems.find((function(sys) {
                    return sys.id === name;
                }));
            }
        }, {
            key: "getAnimationManager",
            value: function getAnimationManager() {
                return this.getSystem(cc.AnimationManager.ID);
            }
        }, {
            key: "startAnimation",
            value: function startAnimation() {
                this._invalid = !1, this._lastUpdate = performance.now();
            }
        }, {
            key: "stopAnimation",
            value: function stopAnimation() {
                this._invalid = !0;
            }
        }, {
            key: "mainLoop",
            value: function mainLoop(time) {
                if (this._purgeDirectorInNextLoop) this._purgeDirectorInNextLoop = !1, this.purgeDirector(); else if (!this._invalid) {
                    this.calculateDeltaTime();
                    var dt = this._deltaTime;
                    if (!this._paused) {
                        this.emit(Director.EVENT_BEFORE_UPDATE), this._compScheduler.startPhase(), this._compScheduler.updatePhase(dt);
                        for (var i = 0; i < this._systems.length; ++i) this._systems[i].update(dt);
                        this._compScheduler.lateUpdatePhase(dt), this.emit(Director.EVENT_AFTER_UPDATE), 
                        CCObject._deferredDestroy();
                        for (var _i = 0; _i < this._systems.length; ++_i) this._systems[_i].postUpdate(dt);
                    }
                    this.emit(Director.EVENT_BEFORE_DRAW), this._root.frameMove(this._deltaTime), this._root.device.present(), 
                    this.emit(Director.EVENT_AFTER_DRAW), eventManager.frameUpdateListeners(), Node$1.bookOfChange.clear(), 
                    this._totalFrames++;
                }
            }
        }, {
            key: "_initOnRendererInitialized",
            value: function _initOnRendererInitialized() {
                this._totalFrames = 0, this._lastUpdate = performance.now(), this._paused = !1, 
                this._purgeDirectorInNextLoop = !1, eventManager && eventManager.setEnabled(!0), 
                this.registerSystem(Scheduler.ID, this._scheduler, 200), this.emit(Director.EVENT_INIT);
            }
        }, {
            key: "_initOnEngineInitialized",
            value: function _initOnEngineInitialized() {
                cc.loader.init(this), this._root = new Root(cc.game._gfxDevice);
                return !!this._root.initialize({});
            }
        }, {
            key: "root",
            get: function get() {
                return this._root;
            }
        } ]), Director;
    }(EventTarget);
    Director.EVENT_INIT = "director_init", Director.EVENT_RESET = "director_reset", 
    Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading", Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch", 
    Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch", Director.EVENT_BEFORE_UPDATE = "director_before_update", 
    Director.EVENT_AFTER_UPDATE = "director_after_update", Director.EVENT_BEFORE_DRAW = "director_before_draw", 
    Director.EVENT_AFTER_DRAW = "director_after_draw", Director.EVENT_BEFORE_PHYSICS = "director_before_physics", 
    Director.EVENT_AFTER_PHYSICS = "director_after_physics", cc.Director = Director;
    var _dec$P, _dec2$r, _class$P, _class2$I, _descriptor$B, _descriptor2$r, _descriptor3$k, _descriptor4$e, _descriptor5$a, _class$Q, director = Director.instance = cc.director = new Director, EventHandler = (_dec$P = ccclass("cc.ClickEvent"), 
    _dec2$r = property(cc.Node), _dec$P((_applyDecoratedDescriptor((_class2$I = function() {
        function EventHandler() {
            _classCallCheck(this, EventHandler), _initializerDefineProperty(this, "target", _descriptor$B, this), 
            _initializerDefineProperty(this, "component", _descriptor2$r, this), _initializerDefineProperty(this, "_componentId", _descriptor3$k, this), 
            _initializerDefineProperty(this, "handler", _descriptor4$e, this), _initializerDefineProperty(this, "customEventData", _descriptor5$a, this);
        }
        return _createClass(EventHandler, [ {
            key: "emit",
            value: function emit(params) {
                var target = this.target;
                if (cc.isValid(target)) {
                    this._genCompIdIfNeeded();
                    var compType = cc.js._getClassById(this._componentId), comp = target.getComponent(compType);
                    if (cc.isValid(comp)) {
                        var handler = comp[this.handler];
                        "function" == typeof handler && (null != this.customEventData && "" !== this.customEventData && (params = params.slice()).push(this.customEventData), 
                        handler.apply(comp, params));
                    }
                }
            }
        }, {
            key: "_compName2Id",
            value: function _compName2Id(compName) {
                var comp = cc.js.getClassByName(compName);
                return cc.js._getClassId(comp);
            }
        }, {
            key: "_compId2Name",
            value: function _compId2Name(compId) {
                var comp = cc.js._getClassById(compId);
                return cc.js.getClassName(comp);
            }
        }, {
            key: "_genCompIdIfNeeded",
            value: function _genCompIdIfNeeded() {
                this._componentId || (this._componentName = this.component, this.component = "");
            }
        }, {
            key: "_componentName",
            get: function get() {
                return this._genCompIdIfNeeded(), this._compId2Name(this._componentId);
            },
            set: function set(value) {
                this._componentId = this._compName2Id(value);
            }
        } ], [ {
            key: "emitEvents",
            value: function emitEvents(events) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                for (var i = 0, l = events.length; i < l; i++) {
                    var event = events[i];
                    event instanceof EventHandler && event.emit(args);
                }
            }
        } ]), EventHandler;
    }()).prototype, "_componentName", [ property ], Object.getOwnPropertyDescriptor(_class2$I.prototype, "_componentName"), _class2$I.prototype), 
    _descriptor$B = _applyDecoratedDescriptor(_class2$I.prototype, "target", [ _dec2$r ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$r = _applyDecoratedDescriptor(_class2$I.prototype, "component", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor3$k = _applyDecoratedDescriptor(_class2$I.prototype, "_componentId", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor4$e = _applyDecoratedDescriptor(_class2$I.prototype, "handler", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor5$a = _applyDecoratedDescriptor(_class2$I.prototype, "customEventData", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _class$P = _class2$I)) || _class$P);
    cc.Component.EventHandler = EventHandler;
    var BlockEvents = [ exports.SystemEventType.TOUCH_START, exports.SystemEventType.TOUCH_END, exports.SystemEventType.TOUCH_MOVE, exports.SystemEventType.MOUSE_DOWN, exports.SystemEventType.MOUSE_MOVE, exports.SystemEventType.MOUSE_UP, exports.SystemEventType.MOUSE_ENTER, exports.SystemEventType.MOUSE_LEAVE, exports.SystemEventType.MOUSE_WHEEL ];
    function stopPropagation(event) {
        event.propagationStopped = !0;
    }
    var _dec$R, _dec2$t, _dec3$g, _dec4$d, _dec5$c, _dec6$8, _dec7$5, _dec8$4, _dec9$3, _dec10$3, _dec11$3, _dec12$3, _dec13$2, _dec14$2, _dec15$2, _dec16$2, _class$R, _class2$J, _descriptor$C, _descriptor2$s, _descriptor3$l, _descriptor4$f, _descriptor5$b, _descriptor6$5, _descriptor7$5, _descriptor8$4, _descriptor9$4, _descriptor10$4, _descriptor11$2, _descriptor12$2, _descriptor13$2, _descriptor14$2, _class3$h, _temp$L, BlockInputEventsComponent = ccclass("cc.BlockInputEventsComponent")(_class$Q = menu("Components/BlockInputEvents")(_class$Q = function(_Component) {
        function BlockInputEventsComponent() {
            return _classCallCheck(this, BlockInputEventsComponent), _possibleConstructorReturn(this, _getPrototypeOf(BlockInputEventsComponent).apply(this, arguments));
        }
        return _inherits(BlockInputEventsComponent, _Component), _createClass(BlockInputEventsComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                for (var i = 0; i < BlockEvents.length; i++) this.node.on(BlockEvents[i], stopPropagation, this);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                for (var i = 0; i < BlockEvents.length; i++) this.node.off(BlockEvents[i], stopPropagation, this);
            }
        } ]), BlockInputEventsComponent;
    }(Component)) || _class$Q) || _class$Q;
    cc.BlockInputEventsComponent = BlockInputEventsComponent;
    var _dec$S, _dec2$u, _dec3$h, _dec4$e, _dec5$d, _dec6$9, _dec7$6, _dec8$5, _dec9$4, _dec10$4, _dec11$4, _class$S, _class2$K, _descriptor$D, _descriptor2$t, _descriptor3$m, _descriptor4$g, _descriptor5$c, _dec$T, _dec2$v, _dec3$i, _dec4$f, _dec5$e, _dec6$a, _dec7$7, _class$T, _class2$L, _descriptor$E, _descriptor2$u, _temp_vec3_1 = new Vec3, ProjectionType = Enum({
        ORTHO: 0,
        PERSPECTIVE: 1
    }), CameraClearFlag = Enum({
        SKYBOX: SKYBOX_FLAG | exports.GFXClearFlag.DEPTH_STENCIL,
        SOLID_COLOR: exports.GFXClearFlag.ALL,
        DEPTH_ONLY: exports.GFXClearFlag.DEPTH_STENCIL,
        DONT_CLEAR: exports.GFXClearFlag.NONE
    }), CameraComponent = (_dec$R = ccclass("cc.CameraComponent"), _dec2$t = menu("Components/Camera"), 
    _dec3$g = property({
        type: ProjectionType,
        tooltip: "相机的投影类型"
    }), _dec4$d = property({
        tooltip: "相机的优先级顺序，只能在编辑器中设置，动态设置无效"
    }), _dec5$c = property({
        tooltip: "相机的视角大小"
    }), _dec6$8 = property({
        tooltip: "正交模式下的相机视角大小"
    }), _dec7$5 = property({
        tooltip: "相机的近平面"
    }), _dec8$4 = property({
        tooltip: "相机的远平面"
    }), _dec9$3 = property({
        tooltip: "相机的颜色缓冲默认值"
    }), _dec10$3 = property({
        tooltip: "相机的深度缓冲默认值"
    }), _dec11$3 = property({
        tooltip: "相机的模板缓冲默认值"
    }), _dec12$3 = property({
        type: CameraClearFlag,
        tooltip: "相机的缓冲清除标志位"
    }), _dec13$2 = property({
        tooltip: "相机相对屏幕的 viewport"
    }), _dec14$2 = property({
        visible: !1
    }), _dec15$2 = property({
        type: Layers.BitMask,
        tooltip: "设置摄像机可见掩码，与 Component 中的 visibility 同时使用，用于过滤摄像机不需要渲染的物体"
    }), _dec16$2 = property({
        type: RenderTexture,
        tooltip: "设置摄像机 RenderTexture"
    }), _dec$R(_class$R = _dec2$t(_class$R = executeInEditMode((_temp$L = _class3$h = function(_Component) {
        function CameraComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, CameraComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CameraComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_projection", _descriptor$C, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_priority", _descriptor2$s, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_fov", _descriptor3$l, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_orthoHeight", _descriptor4$f, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_near", _descriptor5$b, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_far", _descriptor6$5, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_color", _descriptor7$5, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_depth", _descriptor8$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_stencil", _descriptor9$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_clearFlags", _descriptor10$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_rect", _descriptor11$2, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_screenScale", _descriptor12$2, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_visibility", _descriptor13$2, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_targetTexture", _descriptor14$2, _assertThisInitialized(_this)), 
            _this._camera = null, _this._inEditorMode = !1, _this._flows = void 0, _this;
        }
        return _inherits(CameraComponent, _Component), _createClass(CameraComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                cc.director.on(cc.Director.EVENT_AFTER_SCENE_LAUNCH, this.onSceneChanged, this), 
                this._createCamera();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._camera && this._attachToScene();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._camera && this._detachFromScene();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._camera && (cc.director.root.destroyCamera(this._camera), this._camera = null), 
                this._targetTexture && this._targetTexture.off("resize");
            }
        }, {
            key: "screenPointToRay",
            value: function screenPointToRay(x, y, out) {
                return out || (out = ray.create()), this._camera && this._camera.screenPointToRay(out, x, y), 
                out;
            }
        }, {
            key: "worldToScreen",
            value: function worldToScreen(worldPos, out) {
                return out || (out = new Vec3), this._camera && this._camera.worldToScreen(out, worldPos), 
                out;
            }
        }, {
            key: "screenToWorld",
            value: function screenToWorld(screenPos, out) {
                return out || (out = this.node.getWorldPosition()), this._camera && this._camera.screenToWorld(out, screenPos), 
                out;
            }
        }, {
            key: "convertToUINode",
            value: function convertToUINode(wpos, uiNode, out) {
                if (out || (out = new Vec3), !this._camera) return out;
                this.worldToScreen(wpos, _temp_vec3_1);
                var cmp = uiNode.getComponent("cc.UITransformComponent"), designSize = view.getVisibleSize(), xoffset = _temp_vec3_1.x - .5 * this._camera.width, yoffset = _temp_vec3_1.y - .5 * this._camera.height;
                return _temp_vec3_1.x = xoffset / cc.view.getScaleX() + .5 * designSize.width, _temp_vec3_1.y = yoffset / cc.view.getScaleY() + .5 * designSize.height, 
                cmp && cmp.convertToNodeSpaceAR(_temp_vec3_1, out), out;
            }
        }, {
            key: "_createCamera",
            value: function _createCamera() {
                if (this._camera = cc.director.root.createCamera(), this._camera.initialize({
                    name: this.node.name,
                    node: this.node,
                    projection: this._projection,
                    window: this._inEditorMode ? cc.director.root && cc.director.root.mainWindow : cc.director.root && cc.director.root.tempWindow,
                    priority: this._priority,
                    flows: this._flows
                }), this._camera) {
                    this._camera.viewport = this._rect, this._camera.fov = toRadian(this._fov), this._camera.orthoHeight = this._orthoHeight, 
                    this._camera.nearClip = this._near, this._camera.farClip = this._far;
                    var r = this._color.x, g = this._color.y, b = this._color.z, a = this._color.w;
                    this._camera.clearColor = {
                        r: r,
                        g: g,
                        b: b,
                        a: a
                    }, this._camera.clearDepth = this._depth, this._camera.clearStencil = this._stencil, 
                    this._camera.clearFlag = this._clearFlags, this._camera.visibility = this._visibility;
                }
                this._updateTargetTexture();
            }
        }, {
            key: "_attachToScene",
            value: function _attachToScene() {
                this.node.scene && this._camera && (this._camera && this._camera.scene && this._camera.scene.removeCamera(this._camera), 
                this._getRenderScene().addCamera(this._camera));
            }
        }, {
            key: "_detachFromScene",
            value: function _detachFromScene() {
                this._camera && this._camera.scene && this._camera.scene.removeCamera(this._camera);
            }
        }, {
            key: "onSceneChanged",
            value: function onSceneChanged(scene) {
                this._camera && null == this._camera.scene && this._attachToScene();
            }
        }, {
            key: "_chechTargetTextureEvent",
            value: function _chechTargetTextureEvent(old) {
                var _this2 = this;
                old && old.off("resize"), this._targetTexture && this._targetTexture.on("resize", (function resizeFunc(window) {
                    _this2._camera && _this2._camera.setFixedSize(window.width, window.height);
                }), this);
            }
        }, {
            key: "_updateTargetTexture",
            value: function _updateTargetTexture() {
                if (this._camera && this._targetTexture) {
                    var window = this._targetTexture.getGFXWindow();
                    this._camera.changeTargetWindow(window), this._camera.setFixedSize(window.width, window.height);
                }
            }
        }, {
            key: "camera",
            get: function get() {
                return this._camera;
            }
        }, {
            key: "projection",
            get: function get() {
                return this._projection;
            },
            set: function set(val) {
                this._projection = val, this._camera && (this._camera.projectionType = val);
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            },
            set: function set(val) {
                this._priority = val, this._camera && (this._camera.priority = val);
            }
        }, {
            key: "fov",
            get: function get() {
                return this._fov;
            },
            set: function set(val) {
                this._fov = val, this._camera && (this._camera.fov = toRadian(val));
            }
        }, {
            key: "orthoHeight",
            get: function get() {
                return this._orthoHeight;
            },
            set: function set(val) {
                this._orthoHeight = val, this._camera && (this._camera.orthoHeight = val);
            }
        }, {
            key: "near",
            get: function get() {
                return this._near;
            },
            set: function set(val) {
                this._near = val, this._camera && (this._camera.nearClip = val);
            }
        }, {
            key: "far",
            get: function get() {
                return this._far;
            },
            set: function set(val) {
                this._far = val, this._camera && (this._camera.farClip = val);
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(val) {
                this._color.set(val), this._camera && (this._camera.clearColor.r = val.x, this._camera.clearColor.g = val.y, 
                this._camera.clearColor.b = val.z, this._camera.clearColor.a = val.w);
            }
        }, {
            key: "depth",
            get: function get() {
                return this._depth;
            },
            set: function set(val) {
                this._depth = val, this._camera && (this._camera.clearDepth = val);
            }
        }, {
            key: "stencil",
            get: function get() {
                return this._stencil;
            },
            set: function set(val) {
                this._stencil = val, this._camera && (this._camera.clearStencil = val);
            }
        }, {
            key: "clearFlags",
            get: function get() {
                return this._clearFlags;
            },
            set: function set(val) {
                this._clearFlags = val, this._camera && (this._camera.clearFlag = val);
            }
        }, {
            key: "rect",
            get: function get() {
                return this._rect;
            },
            set: function set(val) {
                this._rect = val, this._camera && (this._camera.viewport = val);
            }
        }, {
            key: "screenScale",
            get: function get() {
                return this._screenScale;
            },
            set: function set(val) {
                this._screenScale = val, this._camera && (this._camera.screenScale = val);
            }
        }, {
            key: "visibility",
            get: function get() {
                return this._visibility;
            },
            set: function set(val) {
                this._visibility = val, this._camera && (this._camera.visibility = val);
            }
        }, {
            key: "targetTexture",
            get: function get() {
                return this._targetTexture;
            },
            set: function set(value) {
                if (this._targetTexture !== value) {
                    var old = this._targetTexture;
                    this._targetTexture = value, this._chechTargetTextureEvent(old), this._updateTargetTexture(), 
                    !value && this._camera && (this._camera.changeTargetWindow(null), this._camera.isWindowSize = !0);
                }
            }
        }, {
            key: "inEditorMode",
            get: function get() {
                return this._inEditorMode;
            },
            set: function set(value) {
                this._inEditorMode = value, this._camera && this._camera.changeTargetWindow(value ? cc.director.root && cc.director.root.mainWindow : cc.director.root && cc.director.root.tempWindow);
            }
        }, {
            key: "flows",
            set: function set(val) {
                this._camera && (this._camera.flows = val), this._flows = val;
            }
        } ]), CameraComponent;
    }(Component), _class3$h.ProjectionType = ProjectionType, _class3$h.CameraClearFlag = CameraClearFlag, 
    _descriptor$C = _applyDecoratedDescriptor((_class2$J = _temp$L).prototype, "_projection", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return ProjectionType.PERSPECTIVE;
        }
    }), _descriptor2$s = _applyDecoratedDescriptor(_class2$J.prototype, "_priority", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor3$l = _applyDecoratedDescriptor(_class2$J.prototype, "_fov", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 45;
        }
    }), _descriptor4$f = _applyDecoratedDescriptor(_class2$J.prototype, "_orthoHeight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 10;
        }
    }), _descriptor5$b = _applyDecoratedDescriptor(_class2$J.prototype, "_near", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor6$5 = _applyDecoratedDescriptor(_class2$J.prototype, "_far", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1e3;
        }
    }), _descriptor7$5 = _applyDecoratedDescriptor(_class2$J.prototype, "_color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color("#334C78");
        }
    }), _descriptor8$4 = _applyDecoratedDescriptor(_class2$J.prototype, "_depth", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor9$4 = _applyDecoratedDescriptor(_class2$J.prototype, "_stencil", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor10$4 = _applyDecoratedDescriptor(_class2$J.prototype, "_clearFlags", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return CameraClearFlag.SOLID_COLOR;
        }
    }), _descriptor11$2 = _applyDecoratedDescriptor(_class2$J.prototype, "_rect", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Rect(0, 0, 1, 1);
        }
    }), _descriptor12$2 = _applyDecoratedDescriptor(_class2$J.prototype, "_screenScale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor13$2 = _applyDecoratedDescriptor(_class2$J.prototype, "_visibility", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return CameraDefaultMask;
        }
    }), _descriptor14$2 = _applyDecoratedDescriptor(_class2$J.prototype, "_targetTexture", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _applyDecoratedDescriptor(_class2$J.prototype, "projection", [ _dec3$g ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "projection"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "priority", [ _dec4$d ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "priority"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "fov", [ _dec5$c ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "fov"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "orthoHeight", [ _dec6$8 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "orthoHeight"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "near", [ _dec7$5 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "near"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "far", [ _dec8$4 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "far"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "color", [ _dec9$3 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "color"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "depth", [ _dec10$3 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "depth"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "stencil", [ _dec11$3 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "stencil"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "clearFlags", [ _dec12$3 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "clearFlags"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "rect", [ _dec13$2 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "rect"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "screenScale", [ _dec14$2 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "screenScale"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "visibility", [ _dec15$2 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "visibility"), _class2$J.prototype), 
    _applyDecoratedDescriptor(_class2$J.prototype, "targetTexture", [ _dec16$2 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "targetTexture"), _class2$J.prototype), 
    _class$R = _class2$J)) || _class$R) || _class$R) || _class$R), _worldPos = new Vec3, CanvasClearFlag = Enum({
        SOLID_COLOR: exports.GFXClearFlag.ALL,
        DEPTH_STENCIL: exports.GFXClearFlag.DEPTH_STENCIL,
        NONE: exports.GFXClearFlag.NONE
    }), RenderMode = Enum({
        OVERLAY: 0,
        INTERSPERSE: 1
    }), CanvasComponent = (_dec$S = ccclass("cc.CanvasComponent"), _dec2$u = executionOrder(100), 
    _dec3$h = requireComponent(UITransformComponent), _dec4$e = menu("UI/Canvas"), _dec5$d = property({
        type: CanvasClearFlag,
        tooltip: "清理屏幕缓冲标记"
    }), _dec6$9 = property({
        tooltip: "清理颜色缓冲区后的颜色"
    }), _dec7$6 = property({
        type: RenderMode,
        tooltip: "Canvas 渲染模式，intersperse 下可以指定 Canvas 与场景中的相机的渲染顺序，overlay 下 Canvas 会在所有场景相机渲染完成后渲染。\n注意：启用 intersperse 模式，如果 3D 场景的相机内容显示上要在 Canvas 前面，相机的 clearFlags 也要为 none"
    }), _dec8$5 = property({
        tooltip: "相机排序优先级。当 RenderMode 为 intersperse 时，指定与其它相机的渲染顺序，当 RenderMode 为 overlay 时，指定跟其余 Canvas 做排序使用。需要对多 Canvas 设定 priority 以免出现不同平台下的闪屏问题。"
    }), _dec9$4 = property({
        type: RenderTexture,
        tooltip: "目标渲染纹理"
    }), _dec10$4 = property({
        type: CanvasClearFlag
    }), _dec11$4 = property({
        type: RenderMode
    }), _dec$S(_class$S = _dec2$u(_class$S = _dec3$h(_class$S = _dec4$e(_class$S = executeInEditMode(_class$S = disallowMultiple((_applyDecoratedDescriptor((_class2$K = function(_Component) {
        function CanvasComponent() {
            var _this;
            return _classCallCheck(this, CanvasComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasComponent).call(this)), "_priority", _descriptor$D, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_targetTexture", _descriptor2$t, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_clearFlag", _descriptor3$m, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_color", _descriptor4$g, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_renderMode", _descriptor5$c, _assertThisInitialized(_this)), 
            _this._camera = null, _this._pos = new Vec3, _this._thisOnResized = _this.alignWithScreen.bind(_assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(CanvasComponent, _Component), _createClass(CanvasComponent, [ {
            key: "clearFlag",
            get: function get() {
                return this._clearFlag;
            },
            set: function set(val) {
                this._clearFlag = val, this._camera && (this._camera.clearFlag = this._clearFlag);
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(val) {
                Color.copy(this._color, val), this._camera && (this._camera.clearColor.r = val.r / 255, 
                this._camera.clearColor.g = val.g / 255, this._camera.clearColor.b = val.b / 255, 
                this._camera.clearColor.a = val.a / 255);
            }
        }, {
            key: "renderMode",
            get: function get() {
                return this._renderMode;
            },
            set: function set(val) {
                this._renderMode = val, this._camera && (this._camera.priority = this._getViewPriority());
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            },
            set: function set(val) {
                this._priority = val, this._camera && (this._camera.priority = this._getViewPriority()), 
                director.root && director.root.ui && director.root.ui.sortScreens();
            }
        }, {
            key: "targetTexture",
            get: function get() {
                return this._targetTexture;
            },
            set: function set(value) {
                if (this._targetTexture !== value) {
                    var old = this._targetTexture;
                    this._targetTexture = value, this._checkTargetTextureEvent(old), this._updateTargetTexture();
                }
            }
        }, {
            key: "visibility",
            get: function get() {
                return this._camera ? this._camera.view.visibility : -1;
            }
        }, {
            key: "camera",
            get: function get() {
                return this._camera;
            }
        } ]), _createClass(CanvasComponent, [ {
            key: "__preload",
            value: function __preload() {
                var cameraNode = new Node$1("UICamera_" + this.node.name);
                if (cameraNode.setPosition(0, 0, 1e3), this._camera = director.root.createCamera(), 
                this._camera.initialize({
                    name: "ui_" + this.node.name,
                    node: cameraNode,
                    projection: CameraComponent.ProjectionType.ORTHO,
                    priority: this._getViewPriority(),
                    flows: [ "UIFlow" ]
                }), this._camera.fov = 45, this._camera.clearFlag = this.clearFlag, this._camera.farClip = 2e3, 
                this._camera.viewport = new Rect(0, 0, 1, 1), this.color = this._color, this._targetTexture) {
                    var win = this._targetTexture.getGFXWindow();
                    this._camera.changeTargetWindow(win);
                }
                view.on("design-resolution-changed", this._thisOnResized), this.alignWithScreen(), 
                director.root.ui.addScreen(this);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._camera && director.root.ui.renderScene.addCamera(this._camera);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._camera && director.root.ui.renderScene.removeCamera(this._camera);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                director.root.ui.removeScreen(this), this._camera && director.root.destroyCamera(this._camera), 
                this._targetTexture && this._targetTexture.off("resize"), view.off("design-resolution-changed", this._thisOnResized);
            }
        }, {
            key: "alignWithScreen",
            value: function alignWithScreen() {
                var nodeSize, designSize;
                this.node.getPosition(this._pos);
                var visibleSize = visibleRect;
                nodeSize = visibleSize, designSize = view.getDesignResolutionSize();
                var offsetX = 0, offsetY = 0;
                view.getResolutionPolicy() === ResolutionPolicy.NO_BORDER && (offsetX = .5 * (designSize.width - visibleSize.width), 
                offsetY = .5 * (designSize.height - visibleSize.height)), Vec3.set(_worldPos, .5 * visibleSize.width + offsetX, .5 * visibleSize.height + offsetY, 0), 
                this._pos.equals(_worldPos) || this.node.setPosition(_worldPos), this.node.width !== nodeSize.width && (this.node.width = nodeSize.width), 
                this.node.height !== nodeSize.height && (this.node.height = nodeSize.height), this.node.getWorldPosition(_worldPos);
                var camera = this._camera;
                if (camera) {
                    if (this._targetTexture) camera.setFixedSize(visibleSize.width, visibleSize.height), 
                    camera.orthoHeight = visibleSize.height / 2; else {
                        var size = game.canvas;
                        camera.resize(size.width, size.height), camera.orthoHeight = game.canvas.height / view.getScaleY() / 2;
                    }
                    camera.node.setPosition(_worldPos.x, _worldPos.y, 1e3), camera.update();
                }
            }
        }, {
            key: "_checkTargetTextureEvent",
            value: function _checkTargetTextureEvent(old) {
                var _this2 = this;
                old && old.off("resize"), this._targetTexture && this._targetTexture.on("resize", (function resizeFunc(win) {
                    _this2._camera && _this2._camera.setFixedSize(win.width, win.height);
                }), this);
            }
        }, {
            key: "_updateTargetTexture",
            value: function _updateTargetTexture() {
                if (this._camera) {
                    var camera = this._camera;
                    if (this._targetTexture) {
                        var win = this._targetTexture.getGFXWindow();
                        camera.changeTargetWindow(win), camera.orthoHeight = visibleRect.height / 2, camera.isWindowSize = !1;
                    } else camera.changeTargetWindow(), camera.orthoHeight = game.canvas.height / view.getScaleY() / 2, 
                    camera.isWindowSize = !0;
                }
            }
        }, {
            key: "_getViewPriority",
            value: function _getViewPriority() {
                return this._renderMode === RenderMode.OVERLAY ? this._priority | 1 << 30 : this._priority;
            }
        } ]), CanvasComponent;
    }(Component)).prototype, "clearFlag", [ _dec5$d ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "clearFlag"), _class2$K.prototype), 
    _applyDecoratedDescriptor(_class2$K.prototype, "color", [ _dec6$9 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "color"), _class2$K.prototype), 
    _applyDecoratedDescriptor(_class2$K.prototype, "renderMode", [ _dec7$6 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "renderMode"), _class2$K.prototype), 
    _applyDecoratedDescriptor(_class2$K.prototype, "priority", [ _dec8$5 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "priority"), _class2$K.prototype), 
    _applyDecoratedDescriptor(_class2$K.prototype, "targetTexture", [ _dec9$4 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "targetTexture"), _class2$K.prototype), 
    _descriptor$D = _applyDecoratedDescriptor(_class2$K.prototype, "_priority", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor2$t = _applyDecoratedDescriptor(_class2$K.prototype, "_targetTexture", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$m = _applyDecoratedDescriptor(_class2$K.prototype, "_clearFlag", [ _dec10$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return CanvasClearFlag.NONE;
        }
    }), _descriptor4$g = _applyDecoratedDescriptor(_class2$K.prototype, "_color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(0, 0, 0, 0);
        }
    }), _descriptor5$c = _applyDecoratedDescriptor(_class2$K.prototype, "_renderMode", [ _dec11$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return RenderMode.OVERLAY;
        }
    }), _class$S = _class2$K)) || _class$S) || _class$S) || _class$S) || _class$S) || _class$S) || _class$S);
    cc.CanvasComponent = CanvasComponent, exports.removeProperty(UIComponent.prototype, "UIComponent", [ {
        name: "_visibility"
    }, {
        name: "setVisibility"
    } ]);
    var _dec$U, _dec2$w, _dec3$j, _dec4$g, _dec5$f, _class$U, _class2$M, _descriptor$F, _descriptor2$v, _descriptor3$n, _descriptor4$h, _descriptor5$d, _dec6$b, _dec7$8, _dec8$6, _dec9$5, _dec10$5, _dec11$5, _dec12$4, _dec13$3, _class4$5, _class5$5, _descriptor6$6, _descriptor7$6, _descriptor8$5, _dec$V, _dec2$x, _dec3$k, _dec4$h, _class$V, _class2$N, _descriptor$G, _descriptor2$w, _descriptor3$o, _class3$i, _temp$P, _dec$W, _dec2$y, _dec3$l, _class$W, _class2$O, _descriptor$H, _class$X, _dec$Y, _dec2$z, _dec3$m, _dec4$i, _dec5$g, _dec6$c, _dec7$9, _class$Y, _class2$P, _descriptor$I, _descriptor2$x, _descriptor3$p, _descriptor4$i, _dec$Z, _dec2$A, _dec3$n, _dec4$j, _dec5$h, _dec6$d, _dec7$a, _dec8$7, _class$Z, _class2$Q, _descriptor$J, _descriptor2$y, _descriptor3$q, _descriptor4$j, _descriptor5$e, _dec$_, _dec2$B, _dec3$o, _dec4$k, _dec5$i, _dec6$e, _dec7$b, _dec8$8, _class$_, _class2$R, _descriptor$K, _descriptor2$z, _descriptor3$r, _descriptor4$k, _descriptor5$f, SkinningModelComponent = (_dec$T = ccclass("cc.SkinningModelComponent"), 
    _dec2$v = executionOrder(100), _dec3$i = menu("Components/SkinningModel"), _dec4$f = property(Skeleton), 
    _dec5$e = property(Node$1), _dec6$a = property({
        type: Skeleton
    }), _dec7$7 = property({
        type: Node$1
    }), _dec$T(_class$T = _dec2$v(_class$T = executeInEditMode(_class$T = _dec3$i((_descriptor$E = _applyDecoratedDescriptor((_class2$L = function(_ModelComponent) {
        function SkinningModelComponent() {
            var _this;
            return _classCallCheck(this, SkinningModelComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(SkinningModelComponent).call(this)), "_skeleton", _descriptor$E, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_skinningRoot", _descriptor2$u, _assertThisInitialized(_this)), 
            _this._clip = null, _this._modelType = SkinningModel, _this;
        }
        return _inherits(SkinningModelComponent, _ModelComponent), _createClass(SkinningModelComponent, [ {
            key: "skeleton",
            get: function get() {
                return this._skeleton;
            },
            set: function set(val) {
                this._skeleton = val, this._update();
            }
        }, {
            key: "skinningRoot",
            get: function get() {
                return this._skinningRoot;
            },
            set: function set(value) {
                this._skinningRoot = value, this._update();
            }
        }, {
            key: "model",
            get: function get() {
                return this._model;
            }
        } ]), _createClass(SkinningModelComponent, [ {
            key: "uploadAnimation",
            value: function uploadAnimation(clip) {
                this._clip = clip, this._model && this._model.uploadAnimation(clip);
            }
        }, {
            key: "_updateModelParams",
            value: function _updateModelParams() {
                this._update(), _get(_getPrototypeOf(SkinningModelComponent.prototype), "_updateModelParams", this).call(this);
            }
        }, {
            key: "_getBuiltinMaterial",
            value: function _getBuiltinMaterial() {
                return builtinResMgr.get("missing-skinning-material");
            }
        }, {
            key: "_update",
            value: function _update() {
                if (this._model) {
                    var model = this._model;
                    model.bindSkeleton(this._skeleton, this._skinningRoot, this._mesh), model.uploadAnimation(this._clip);
                }
            }
        } ]), SkinningModelComponent;
    }(ModelComponent)).prototype, "_skeleton", [ _dec4$f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$u = _applyDecoratedDescriptor(_class2$L.prototype, "_skinningRoot", [ _dec5$e ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _applyDecoratedDescriptor(_class2$L.prototype, "skeleton", [ _dec6$a ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "skeleton"), _class2$L.prototype), 
    _applyDecoratedDescriptor(_class2$L.prototype, "skinningRoot", [ _dec7$7 ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "skinningRoot"), _class2$L.prototype), 
    _class$T = _class2$L)) || _class$T) || _class$T) || _class$T) || _class$T), batch_id = {
        name: exports.GFXAttributeName.ATTR_BATCH_ID,
        format: exports.GFXFormat.R32F,
        isNormalized: !1
    }, batch_uv = {
        name: exports.GFXAttributeName.ATTR_BATCH_UV,
        format: exports.GFXFormat.RG32F,
        isNormalized: !1
    }, batch_extras_size = GFXFormatInfos[batch_id.format].size + GFXFormatInfos[batch_uv.format].size, SkinningModelUnit = (_dec$U = ccclass("cc.SkinningModelUnit"), 
    _dec2$w = property(Mesh), _dec3$j = property(Skeleton), _dec4$g = property(Material), 
    _dec5$f = property({
        type: SkinningModelComponent
    }), _dec$U((_descriptor$F = _applyDecoratedDescriptor((_class2$M = function() {
        function SkinningModelUnit() {
            _classCallCheck(this, SkinningModelUnit), _initializerDefineProperty(this, "mesh", _descriptor$F, this), 
            _initializerDefineProperty(this, "skeleton", _descriptor2$v, this), _initializerDefineProperty(this, "material", _descriptor3$n, this), 
            _initializerDefineProperty(this, "_offset", _descriptor4$h, this), _initializerDefineProperty(this, "_size", _descriptor5$d, this);
        }
        return _createClass(SkinningModelUnit, [ {
            key: "offset",
            set: function set(offset) {
                Vec2.copy(this._offset, offset);
            },
            get: function get() {
                return this._offset;
            }
        }, {
            key: "size",
            set: function set(size) {
                Vec2.copy(this._size, size);
            },
            get: function get() {
                return this._size;
            }
        }, {
            key: "copyFrom",
            set: function set(comp) {
                comp && (this.mesh = comp.mesh, this.skeleton = comp.skeleton, this.material = comp.getMaterial(0));
            },
            get: function get() {
                return null;
            }
        } ]), SkinningModelUnit;
    }()).prototype, "mesh", [ _dec2$w ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$v = _applyDecoratedDescriptor(_class2$M.prototype, "skeleton", [ _dec3$j ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$n = _applyDecoratedDescriptor(_class2$M.prototype, "material", [ _dec4$g ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor4$h = _applyDecoratedDescriptor(_class2$M.prototype, "_offset", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(0, 0);
        }
    }), _descriptor5$d = _applyDecoratedDescriptor(_class2$M.prototype, "_size", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(1, 1);
        }
    }), _applyDecoratedDescriptor(_class2$M.prototype, "offset", [ property ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "offset"), _class2$M.prototype), 
    _applyDecoratedDescriptor(_class2$M.prototype, "size", [ property ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "size"), _class2$M.prototype), 
    _applyDecoratedDescriptor(_class2$M.prototype, "copyFrom", [ _dec5$f ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "copyFrom"), _class2$M.prototype), 
    _class$U = _class2$M)) || _class$U), BatchedSkinningModelComponent = (_dec6$b = ccclass("cc.BatchedSkinningModelComponent"), 
    _dec7$8 = executionOrder(100), _dec8$6 = menu("Components/BatchedSkinningModel"), 
    _dec9$5 = property({
        tooltip: "合图生成的最终图集的边长"
    }), _dec10$5 = property({
        type: [ CCString ],
        tooltip: "材质中真正参与合图的贴图属性，不参与的属性统一使用第一个 unit 的贴图"
    }), _dec11$5 = property({
        type: [ SkinningModelUnit ],
        tooltip: "合批前的子蒙皮模型数组，最主要的数据来源"
    }), _dec12$4 = property({
        override: !0,
        visible: !1
    }), _dec13$3 = property({
        override: !0,
        visible: !1
    }), _dec6$b(_class4$5 = _dec7$8(_class4$5 = executeInEditMode(_class4$5 = _dec8$6((_descriptor6$6 = _applyDecoratedDescriptor((_class5$5 = function(_SkinningModelCompone) {
        function BatchedSkinningModelComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, BatchedSkinningModelComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BatchedSkinningModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "atlasSize", _descriptor6$6, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "batchableTextureNames", _descriptor7$6, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "units", _descriptor8$5, _assertThisInitialized(_this)), 
            _this._textures = {}, _this._batchMaterial = null, _this;
        }
        return _inherits(BatchedSkinningModelComponent, _SkinningModelCompone), _createClass(BatchedSkinningModelComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onLoad", this).call(this), 
                this.cook();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                for (var _i = 0, _Object$keys = Object.keys(this._textures); _i < _Object$keys.length; _i++) {
                    var tex = _Object$keys[_i];
                    this._textures[tex].destroy();
                }
                this._textures = {}, this._mesh && (this._mesh.destroy(), this._mesh = null), _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onDestroy", this).call(this);
            }
        }, {
            key: "_onMaterialModified",
            value: function _onMaterialModified(idx, material) {
                this.cookMaterials(), _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "_onMaterialModified", this).call(this, idx, this.getMaterial(idx));
            }
        }, {
            key: "cook",
            value: function cook() {
                this.cookMaterials(), this.cookSkeletons(), this.cookMeshes();
            }
        }, {
            key: "cookMaterials",
            value: function cookMaterials() {
                var _this2 = this;
                this._batchMaterial || (this._batchMaterial = this.getMaterial(0));
                var mat = this.getMaterial(0);
                if (mat && this._batchMaterial && this._batchMaterial.effectAsset) {
                    mat.copy(this._batchMaterial), this.resizeAtlases();
                    for (var tech = mat.effectAsset.techniques[mat.technique], _loop = function _loop(i) {
                        var pass = tech.passes[i];
                        if (!pass.properties) return "continue";
                        for (var _loop2 = function _loop2() {
                            var prop = _Object$keys2[_i2];
                            if (pass.properties[prop].type >= exports.GFXType.SAMPLER1D) {
                                var tex = null;
                                _this2.batchableTextureNames.find((function(n) {
                                    return n === prop;
                                })) ? ((tex = _this2._textures[prop]) || (tex = _this2.createTexture(prop)), _this2.cookTextures(tex, prop, i)) : _this2.units.some((function(u) {
                                    return tex = u.material && u.material.getProperty(prop, i);
                                })), tex && mat.setProperty(prop, tex, i);
                            } else {
                                var value = [], _iterator = _this2.units, _isArray = Array.isArray(_iterator), _i3 = 0;
                                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                    var _ref;
                                    if (_isArray) {
                                        if (_i3 >= _iterator.length) break;
                                        _ref = _iterator[_i3++];
                                    } else {
                                        if ((_i3 = _iterator.next()).done) break;
                                        _ref = _i3.value;
                                    }
                                    var unit = _ref;
                                    unit.material && value.push(unit.material.getProperty(prop.slice(0, -3), i));
                                }
                                mat.setProperty(prop, value, i);
                            }
                        }, _i2 = 0, _Object$keys2 = Object.keys(pass.properties); _i2 < _Object$keys2.length; _i2++) _loop2();
                    }, i = 0; i < tech.passes.length; i++) _loop(i);
                } else console.warn("incomplete batch material!");
            }
        }, {
            key: "cookSkeletons",
            value: function cookSkeletons() {
                if (this._skinningRoot) {
                    var skeleton = new Skeleton, bindposes = [], _iterator2 = this.units, _isArray2 = Array.isArray(_iterator2), _i4 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i4 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i4++];
                        } else {
                            if ((_i4 = _iterator2.next()).done) break;
                            _ref2 = _i4.value;
                        }
                        var unit = _ref2;
                        if (unit && unit.skeleton) for (var partial = unit.skeleton, _loop3 = function _loop3(i) {
                            var path = partial.joints[i];
                            if (skeleton.joints.findIndex((function(p) {
                                return p === path;
                            })) >= 0) return "continue";
                            skeleton.joints.push(path), bindposes.push(partial.bindposes[i] || new Mat4);
                        }, i = 0; i < partial.joints.length; i++) _loop3(i);
                    }
                    var idxMap = Array.from(Array(skeleton.joints.length).keys()).sort((function(a, b) {
                        return skeleton.joints[a] > skeleton.joints[b] ? 1 : skeleton.joints[a] < skeleton.joints[b] ? -1 : 0;
                    }));
                    skeleton.joints = skeleton.joints.map((function(_, idx, arr) {
                        return arr[idxMap[idx]];
                    })), skeleton.bindposes = bindposes.map((function(_, idx, arr) {
                        return arr[idxMap[idx]];
                    })), this._skeleton && this._skeleton.destroy(), this.skeleton = skeleton;
                } else console.warn("no skinning root specified!");
            }
        }, {
            key: "cookMeshes",
            value: function cookMeshes() {
                var _this3 = this, isValid = !1, _iterator3 = this.units, _isArray3 = Array.isArray(_iterator3), _i5 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i5 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i5++];
                    } else {
                        if ((_i5 = _iterator3.next()).done) break;
                        _ref3 = _i5.value;
                    }
                    if (_ref3.mesh) {
                        isValid = !0;
                        break;
                    }
                }
                if (this._mesh ? this._mesh.destroyRenderingMesh() : this._mesh = new Mesh, isValid && this._skinningRoot) {
                    for (var dataView, uvOffset = 0, uvFormat = exports.GFXFormat.UNKNOWN, jointOffset = 0, jointFormat = exports.GFXFormat.UNKNOWN, jointIndexMap = new Array(this.units.length), unitLen = this.units.length, i = 0; i < unitLen; i++) {
                        var unit = this.units[i];
                        unit && unit.skeleton && (jointIndexMap[i] = unit.skeleton.joints.map((function(j) {
                            return _this3._skeleton.joints.findIndex((function(ref) {
                                return j === ref;
                            }));
                        })));
                    }
                    for (var _loop4 = function _loop4(_i6) {
                        var unit = _this3.units[_i6];
                        if (!unit || !unit.mesh || !unit.mesh.data) return "continue";
                        var newMeshStruct = JSON.parse(JSON.stringify(unit.mesh.struct)), newOffset = 0, _iterator4 = newMeshStruct.vertexBundles, _isArray4 = Array.isArray(_iterator4), _i7 = 0;
                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                            var _ref4;
                            if (_isArray4) {
                                if (_i7 >= _iterator4.length) break;
                                _ref4 = _iterator4[_i7++];
                            } else {
                                if ((_i7 = _iterator4.next()).done) break;
                                _ref4 = _i7.value;
                            }
                            var vb = _ref4;
                            vb.attributes.push(batch_id), vb.attributes.push(batch_uv), vb.view.offset = newOffset, 
                            vb.view.length += vb.view.count * batch_extras_size, vb.view.stride += batch_extras_size, 
                            newOffset += vb.view.length;
                        }
                        var _iterator5 = newMeshStruct.primitives, _isArray5 = Array.isArray(_iterator5), _i8 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i8 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i8++];
                            } else {
                                if ((_i8 = _iterator5.next()).done) break;
                                _ref5 = _i8.value;
                            }
                            var pm = _ref5;
                            pm.indexView && (pm.indexView.offset = newOffset, newOffset += pm.indexView.length), 
                            pm.geometricInfo && (newOffset = 4 * Math.ceil(newOffset / 4), pm.geometricInfo.view.offset = newOffset, 
                            newOffset += pm.geometricInfo.view.length);
                        }
                        var src = unit.mesh.data, oldOffset = 0, newMeshData = new Uint8Array(newOffset);
                        dataView = new DataView(newMeshData.buffer);
                        for (var k = 0; k < newMeshStruct.vertexBundles.length; k++) {
                            var uvs = unit.mesh.readAttribute(k, exports.GFXAttributeName.ATTR_TEX_COORD), oldView = unit.mesh.struct.vertexBundles[k].view, newView = newMeshStruct.vertexBundles[k].view, oldStride = oldView.stride, newStride = newView.stride;
                            oldOffset = oldView.offset, newOffset = newView.offset;
                            for (var j = 0; j < newView.count; j++) {
                                var srcVertex = src.subarray(oldOffset, oldOffset + oldStride);
                                newMeshData.set(srcVertex, newOffset), dataView.setFloat32(newOffset + oldStride, _i6, cc.sys.isLittleEndian), 
                                dataView.setFloat32(newOffset + oldStride + 4, uvs[2 * j], cc.sys.isLittleEndian), 
                                dataView.setFloat32(newOffset + oldStride + 8, uvs[2 * j + 1], cc.sys.isLittleEndian), 
                                newOffset += newStride, oldOffset += oldStride;
                            }
                        }
                        for (var _k = 0; _k < newMeshStruct.primitives.length; _k++) {
                            var oldPrimitive = unit.mesh.struct.primitives[_k], newPrimitive = newMeshStruct.primitives[_k];
                            if (oldPrimitive.indexView && newPrimitive.indexView) {
                                var _oldStride = oldPrimitive.indexView.stride, _newStride = newPrimitive.indexView.stride;
                                oldOffset = oldPrimitive.indexView.offset, newOffset = newPrimitive.indexView.offset;
                                for (var _j = 0; _j < newPrimitive.indexView.count; _j++) {
                                    var srcIndices = src.subarray(oldOffset, oldOffset + _oldStride);
                                    newMeshData.set(srcIndices, newOffset), newOffset += _newStride, oldOffset += _oldStride;
                                }
                            }
                            if (oldPrimitive.geometricInfo && newPrimitive.geometricInfo) {
                                var _oldStride2 = oldPrimitive.geometricInfo.view.stride, _newStride2 = newPrimitive.geometricInfo.view.stride;
                                oldOffset = oldPrimitive.geometricInfo.view.offset, newOffset = newPrimitive.geometricInfo.view.offset;
                                for (var _j2 = 0; _j2 < newPrimitive.geometricInfo.view.count; _j2++) {
                                    var srcPositions = src.subarray(oldOffset, oldOffset + _oldStride2);
                                    newMeshData.set(srcPositions, newOffset), newOffset += _newStride2, oldOffset += _oldStride2;
                                }
                            }
                        }
                        var newMesh = new Mesh;
                        newMesh.reset({
                            struct: newMeshStruct,
                            data: newMeshData
                        });
                        var offset = unit.offset, size = unit.size, _loop6 = function _loop6() {
                            if (_isArray6) {
                                if (_i9 >= _iterator6.length) return "break";
                                _ref6 = _iterator6[_i9++];
                            } else {
                                if ((_i9 = _iterator6.next()).done) return "break";
                                _ref6 = _i9.value;
                            }
                            var bundle = _ref6;
                            uvOffset = bundle.view.offset, uvFormat = exports.GFXFormat.UNKNOWN;
                            var _iterator7 = bundle.attributes, _isArray7 = Array.isArray(_iterator7), _i10 = 0;
                            for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                                var _ref7;
                                if (_isArray7) {
                                    if (_i10 >= _iterator7.length) break;
                                    _ref7 = _iterator7[_i10++];
                                } else {
                                    if ((_i10 = _iterator7.next()).done) break;
                                    _ref7 = _i10.value;
                                }
                                var attr = _ref7;
                                if (attr.name === exports.GFXAttributeName.ATTR_BATCH_UV) {
                                    uvFormat = attr.format;
                                    break;
                                }
                                uvOffset += GFXFormatInfos[attr.format].size;
                            }
                            uvFormat && mapBuffer(dataView, (function(cur, idx) {
                                var comp = 0 === idx ? "x" : "y";
                                return (cur = function repeat(n) {
                                    return n - Math.floor(n);
                                }(cur)) * size[comp] + offset[comp];
                            }), uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
                            var idxMap = jointIndexMap[_i6];
                            if (!idxMap) return "continue";
                            jointOffset = bundle.view.offset, jointFormat = exports.GFXFormat.UNKNOWN;
                            var _iterator8 = bundle.attributes, _isArray8 = Array.isArray(_iterator8), _i11 = 0;
                            for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                                var _ref8;
                                if (_isArray8) {
                                    if (_i11 >= _iterator8.length) break;
                                    _ref8 = _iterator8[_i11++];
                                } else {
                                    if ((_i11 = _iterator8.next()).done) break;
                                    _ref8 = _i11.value;
                                }
                                var _attr = _ref8;
                                if (_attr.name === exports.GFXAttributeName.ATTR_JOINTS) {
                                    jointFormat = _attr.format;
                                    break;
                                }
                                jointOffset += GFXFormatInfos[_attr.format].size;
                            }
                            jointFormat && mapBuffer(dataView, (function(cur) {
                                return idxMap[cur];
                            }), jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                        };
                        var _iterator6 = newMeshStruct.vertexBundles, _isArray6 = Array.isArray(_iterator6), _i9 = 0;
                        _loop5: for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            switch (_loop6()) {
                              case "break":
                                break _loop5;

                              case "continue":
                                continue;
                            }
                        }
                        _this3._mesh.merge(newMesh);
                    }, _i6 = 0; _i6 < unitLen; _i6++) _loop4(_i6);
                    this._onMeshChanged(this._mesh), this._updateModels();
                }
            }
        }, {
            key: "cookTextures",
            value: function cookTextures(target, prop, passIdx) {
                var texImages = [], texImageRegions = [], texBuffers = [], texBufferRegions = [], _iterator9 = this.units, _isArray9 = Array.isArray(_iterator9), _i12 = 0;
                for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                    var _ref9;
                    if (_isArray9) {
                        if (_i12 >= _iterator9.length) break;
                        _ref9 = _iterator9[_i12++];
                    } else {
                        if ((_i12 = _iterator9.next()).done) break;
                        _ref9 = _i12.value;
                    }
                    var unit = _ref9;
                    if (unit.material) {
                        var partial = unit.material.getProperty(prop, passIdx);
                        if (partial && partial.image && partial.image.data) {
                            var region = new GFXBufferTextureCopy;
                            region.texOffset.x = unit.offset.x * this.atlasSize, region.texOffset.y = unit.offset.y * this.atlasSize, 
                            region.texExtent.width = unit.size.x * this.atlasSize, region.texExtent.height = unit.size.y * this.atlasSize;
                            var data = partial.image.data;
                            data instanceof HTMLCanvasElement || data instanceof HTMLImageElement ? (texImages.push(data), 
                            texImageRegions.push(region)) : (texBuffers.push(data), texBufferRegions.push(region));
                        }
                    }
                }
                var gfxTex = target.getGFXTexture(), device = cc.director.root.device;
                texBuffers.length > 0 && device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions), 
                texImages.length > 0 && device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
            }
        }, {
            key: "createTexture",
            value: function createTexture(prop) {
                var tex = new Texture2D;
                return tex.setFilters(Filter.LINEAR, Filter.LINEAR), tex.reset({
                    width: this.atlasSize,
                    height: this.atlasSize,
                    format: PixelFormat.RGBA8888
                }), tex.loaded = !0, this._textures[prop] = tex, tex;
            }
        }, {
            key: "resizeAtlases",
            value: function resizeAtlases() {
                for (var _i13 = 0, _Object$keys3 = Object.keys(this._textures); _i13 < _Object$keys3.length; _i13++) {
                    var prop = _Object$keys3[_i13];
                    this._textures[prop].reset({
                        width: this.atlasSize,
                        height: this.atlasSize,
                        format: PixelFormat.RGBA8888
                    });
                }
            }
        }, {
            key: "mesh",
            get: function get() {
                return this._mesh;
            },
            set: function set(val) {
                _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "mesh", val, this, !0);
            }
        }, {
            key: "skeleton",
            get: function get() {
                return this._skeleton;
            },
            set: function set(val) {
                _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "skeleton", val, this, !0);
            }
        } ]), BatchedSkinningModelComponent;
    }(SkinningModelComponent)).prototype, "atlasSize", [ _dec9$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1024;
        }
    }), _descriptor7$6 = _applyDecoratedDescriptor(_class5$5.prototype, "batchableTextureNames", [ _dec10$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor8$5 = _applyDecoratedDescriptor(_class5$5.prototype, "units", [ _dec11$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _applyDecoratedDescriptor(_class5$5.prototype, "mesh", [ _dec12$4 ], Object.getOwnPropertyDescriptor(_class5$5.prototype, "mesh"), _class5$5.prototype), 
    _applyDecoratedDescriptor(_class5$5.prototype, "skeleton", [ _dec13$3 ], Object.getOwnPropertyDescriptor(_class5$5.prototype, "skeleton"), _class5$5.prototype), 
    _class4$5 = _class5$5)) || _class4$5) || _class4$5) || _class4$5) || _class4$5), PhotometricTerm = Enum({
        LUMINOUS_POWER: 0,
        LUMINANCE: 1
    }), LightComponent = (_dec$V = ccclass("cc.LightComponent"), _dec2$x = property({
        tooltip: "光源颜色"
    }), _dec3$k = property({
        tooltip: "是否启用光源色温"
    }), _dec4$h = property({
        slide: !0,
        range: [ 1e3, 15e3, 1 ],
        tooltip: "光源色温"
    }), _dec$V((_temp$P = _class3$i = function(_Component) {
        function LightComponent() {
            var _this;
            return _classCallCheck(this, LightComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LightComponent).call(this)), "_color", _descriptor$G, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_useColorTemperature", _descriptor2$w, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_colorTemperature", _descriptor3$o, _assertThisInitialized(_this)), 
            _this._type = LightType.UNKNOWN, _this._light = null, _this._lightType = Light, 
            _this;
        }
        return _inherits(LightComponent, _Component), _createClass(LightComponent, [ {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(val) {
                this._color = val, this._light && (this._light.color.x = val.r / 255, this._light.color.y = val.g / 255, 
                this._light.color.z = val.b / 255);
            }
        }, {
            key: "useColorTemperature",
            get: function get() {
                return this._useColorTemperature;
            },
            set: function set(enable) {
                this._useColorTemperature = enable, this._light && (this._light.useColorTemperature = enable);
            }
        }, {
            key: "colorTemperature",
            get: function get() {
                return this._colorTemperature;
            },
            set: function set(val) {
                this._colorTemperature = val, this._light && (this._light.colorTemperature = val);
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        } ]), _createClass(LightComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this._createLight();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._attachToScene();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._detachFromScene();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._destroyLight();
            }
        }, {
            key: "_createLight",
            value: function _createLight() {
                this._light || (this._light = cc.director.root.createLight(this._lightType)), this.color = this._color, 
                this.useColorTemperature = this._useColorTemperature, this.colorTemperature = this._colorTemperature, 
                this._light.node = this.node;
            }
        }, {
            key: "_destroyLight",
            value: function _destroyLight() {
                this._light && (cc.director.root.destroyLight(this), this._light = null);
            }
        }, {
            key: "_attachToScene",
            value: function _attachToScene() {
                if (this._detachFromScene(), this._light && !this._light.scene && this.node.scene) switch (this._type) {
                  case LightType.DIRECTIONAL:
                    this._getRenderScene().setMainLight(this._light);
                    break;

                  case LightType.SPHERE:
                    this._getRenderScene().addSphereLight(this._light);
                    break;

                  case LightType.SPOT:
                    this._getRenderScene().addSpotLight(this._light);
                }
            }
        }, {
            key: "_detachFromScene",
            value: function _detachFromScene() {
                if (this._light && this._light.scene) switch (this._type) {
                  case LightType.DIRECTIONAL:
                    this._light.scene.unsetMainLight(this._light);
                    break;

                  case LightType.SPHERE:
                    this._light.scene.removeSphereLight(this._light);
                    break;

                  case LightType.SPOT:
                    this._light.scene.removeSpotLight(this._light);
                }
            }
        } ]), LightComponent;
    }(Component), _class3$i.Type = LightType, _class3$i.PhotometricTerm = PhotometricTerm, 
    _descriptor$G = _applyDecoratedDescriptor((_class2$N = _temp$P).prototype, "_color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE.clone();
        }
    }), _descriptor2$w = _applyDecoratedDescriptor(_class2$N.prototype, "_useColorTemperature", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$o = _applyDecoratedDescriptor(_class2$N.prototype, "_colorTemperature", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 6550;
        }
    }), _applyDecoratedDescriptor(_class2$N.prototype, "color", [ _dec2$x ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "color"), _class2$N.prototype), 
    _applyDecoratedDescriptor(_class2$N.prototype, "useColorTemperature", [ _dec3$k ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "useColorTemperature"), _class2$N.prototype), 
    _applyDecoratedDescriptor(_class2$N.prototype, "colorTemperature", [ _dec4$h ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "colorTemperature"), _class2$N.prototype), 
    _class$V = _class2$N)) || _class$V), DirectionalLightComponent = (_dec$W = ccclass("cc.DirectionalLightComponent"), 
    _dec2$y = menu("Light/DirectionalLight"), _dec3$l = property({
        unit: "lx",
        tooltip: "光源强度"
    }), _dec$W(_class$W = _dec2$y(_class$W = executeInEditMode((_descriptor$H = _applyDecoratedDescriptor((_class2$O = function(_LightComponent) {
        function DirectionalLightComponent() {
            var _this;
            return _classCallCheck(this, DirectionalLightComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(DirectionalLightComponent).call(this)), "_illuminance", _descriptor$H, _assertThisInitialized(_this)), 
            _this._type = LightType.DIRECTIONAL, _this._light = null, _this._lightType = DirectionalLight, 
            _this;
        }
        return _inherits(DirectionalLightComponent, _LightComponent), _createClass(DirectionalLightComponent, [ {
            key: "illuminance",
            get: function get() {
                return this._illuminance;
            },
            set: function set(val) {
                this._illuminance = val, this._light && (this._light.illuminance = this._illuminance);
            }
        } ]), _createClass(DirectionalLightComponent, [ {
            key: "_createLight",
            value: function _createLight() {
                _get(_getPrototypeOf(DirectionalLightComponent.prototype), "_createLight", this).call(this), 
                this._light && (this.illuminance = this._illuminance);
            }
        } ]), DirectionalLightComponent;
    }(LightComponent)).prototype, "_illuminance", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 65e3;
        }
    }), _applyDecoratedDescriptor(_class2$O.prototype, "illuminance", [ _dec3$l ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "illuminance"), _class2$O.prototype), 
    _class$W = _class2$O)) || _class$W) || _class$W) || _class$W), EditorCameraComponent = ccclass("cc.EditorCameraComponent")(_class$X = function(_CameraComponent) {
        function EditorCameraComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, EditorCameraComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditorCameraComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._uiEditorCamera = null, 
            _this;
        }
        return _inherits(EditorCameraComponent, _CameraComponent), _createClass(EditorCameraComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                _get(_getPrototypeOf(EditorCameraComponent.prototype), "onLoad", this).call(this), 
                this._inEditorMode = !0;
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(EditorCameraComponent.prototype), "onEnable", this).call(this), 
                this._uiEditorCamera && (cc.director.root.ui.renderScene.addCamera(this._uiEditorCamera), 
                this._uiEditorCamera.enabled = !0);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(EditorCameraComponent.prototype), "onDisable", this).call(this), 
                this._uiEditorCamera && cc.director.root.ui.renderScene.removeCamera(this._uiEditorCamera);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(EditorCameraComponent.prototype), "onDestroy", this).call(this), 
                this._uiEditorCamera && (cc.director.root.destroyCamera(this._uiEditorCamera), this._uiEditorCamera = null);
            }
        }, {
            key: "_createCamera",
            value: function _createCamera() {
                var priorCamera = this._camera;
                _get(_getPrototypeOf(EditorCameraComponent.prototype), "_createCamera", this).call(this), 
                this._camera !== priorCamera && this._camera && (this._uiEditorCamera && (cc.director.root.destroyCamera(this._uiEditorCamera), 
                this._uiEditorCamera = null), this._uiEditorCamera = cc.director.root.createCamera(), 
                this._uiEditorCamera.initialize({
                    name: "Editor UICamera",
                    node: this._camera.node,
                    projection: this._projection,
                    window: cc.director.root.mainWindow,
                    priority: this._priority + 1,
                    flows: [ "UIFlow" ]
                }), this._uiEditorCamera.enabled = !0, this._uiEditorCamera.visibility = CameraEditorMask, 
                this._uiEditorCamera.viewport = this._camera.viewport, this._uiEditorCamera.fov = this._camera.fov, 
                this._uiEditorCamera.nearClip = this._camera.nearClip, this._uiEditorCamera.farClip = this._camera.farClip, 
                this._uiEditorCamera.clearColor = this._camera.clearColor, this._uiEditorCamera.clearDepth = this._camera.clearDepth, 
                this._uiEditorCamera.clearStencil = this._camera.clearStencil, this._uiEditorCamera.clearFlag = exports.GFXClearFlag.DEPTH_STENCIL);
            }
        }, {
            key: "projection",
            set: function set(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "projection", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.projectionType = val);
            }
        }, {
            key: "fov",
            set: function set(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "fov", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.fov = toRadian(val));
            }
        }, {
            key: "orthoHeight",
            set: function set(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "orthoHeight", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.orthoHeight = val);
            }
        }, {
            key: "near",
            set: function set(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "near", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.nearClip = val);
            }
        }, {
            key: "far",
            set: function set(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "far", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.farClip = val);
            }
        }, {
            key: "color",
            set: function set(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "color", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.clearColor = val);
            }
        }, {
            key: "depth",
            set: function set(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "depth", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.clearDepth = val);
            }
        }, {
            key: "stencil",
            set: function set(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "stencil", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.clearStencil = val);
            }
        }, {
            key: "clearFlags",
            set: function set(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "clearFlags", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.clearFlag = val);
            }
        }, {
            key: "rect",
            set: function set(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "rect", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.viewport = val);
            }
        }, {
            key: "screenScale",
            set: function set(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "screenScale", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.screenScale = val);
            }
        } ]), EditorCameraComponent;
    }(CameraComponent)) || _class$X, SphereLightComponent = (_dec$Y = ccclass("cc.SphereLightComponent"), 
    _dec2$z = menu("Light/SphereLight"), _dec3$m = property({
        unit: "lm",
        tooltip: "光通量"
    }), _dec4$i = property({
        unit: "cd/m²",
        tooltip: "亮度"
    }), _dec5$g = property({
        type: PhotometricTerm,
        tooltip: "指定光通量或亮度"
    }), _dec6$c = property({
        tooltip: "针对聚光灯和点光源设置光源大小"
    }), _dec7$9 = property({
        tooltip: "针对聚光灯和点光源设置光源范围"
    }), _dec$Y(_class$Y = _dec2$z(_class$Y = executeInEditMode((_descriptor$I = _applyDecoratedDescriptor((_class2$P = function(_LightComponent) {
        function SphereLightComponent() {
            var _this;
            return _classCallCheck(this, SphereLightComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereLightComponent).call(this)), "_size", _descriptor$I, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_luminance", _descriptor2$x, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_term", _descriptor3$p, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_range", _descriptor4$i, _assertThisInitialized(_this)), 
            _this._type = LightType.SPHERE, _this._light = null, _this._lightType = SphereLight, 
            _this;
        }
        return _inherits(SphereLightComponent, _LightComponent), _createClass(SphereLightComponent, [ {
            key: "luminousPower",
            get: function get() {
                return this._luminance * nt2lm(this._size);
            },
            set: function set(val) {
                this._luminance = val / nt2lm(this._size), this._light && (this._light.luminance = this._luminance);
            }
        }, {
            key: "luminance",
            get: function get() {
                return this._luminance;
            },
            set: function set(val) {
                this._luminance = val, this._light && (this._light.luminance = val);
            }
        }, {
            key: "term",
            get: function get() {
                return this._term;
            },
            set: function set(val) {
                this._term = val;
            }
        }, {
            key: "size",
            get: function get() {
                return this._size;
            },
            set: function set(val) {
                this._size = val, this._light && (this._light.size = val);
            }
        }, {
            key: "range",
            get: function get() {
                return this._range;
            },
            set: function set(val) {
                this._range = val, this._light && (this._light.range = val);
            }
        } ]), _createClass(SphereLightComponent, [ {
            key: "_createLight",
            value: function _createLight() {
                _get(_getPrototypeOf(SphereLightComponent.prototype), "_createLight", this).call(this), 
                this._light && (this.luminance = this._luminance, this.size = this._size, this.range = this._range);
            }
        } ]), SphereLightComponent;
    }(LightComponent)).prototype, "_size", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .15;
        }
    }), _descriptor2$x = _applyDecoratedDescriptor(_class2$P.prototype, "_luminance", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1700 / nt2lm(.15);
        }
    }), _descriptor3$p = _applyDecoratedDescriptor(_class2$P.prototype, "_term", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return PhotometricTerm.LUMINOUS_POWER;
        }
    }), _descriptor4$i = _applyDecoratedDescriptor(_class2$P.prototype, "_range", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _applyDecoratedDescriptor(_class2$P.prototype, "luminousPower", [ _dec3$m ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "luminousPower"), _class2$P.prototype), 
    _applyDecoratedDescriptor(_class2$P.prototype, "luminance", [ _dec4$i ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "luminance"), _class2$P.prototype), 
    _applyDecoratedDescriptor(_class2$P.prototype, "term", [ _dec5$g ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "term"), _class2$P.prototype), 
    _applyDecoratedDescriptor(_class2$P.prototype, "size", [ _dec6$c ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "size"), _class2$P.prototype), 
    _applyDecoratedDescriptor(_class2$P.prototype, "range", [ _dec7$9 ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "range"), _class2$P.prototype), 
    _class$Y = _class2$P)) || _class$Y) || _class$Y) || _class$Y), SpotLightComponent = (_dec$Z = ccclass("cc.SpotLightComponent"), 
    _dec2$A = menu("Light/SpotLight"), _dec3$n = property({
        unit: "lm",
        tooltip: "光通量"
    }), _dec4$j = property({
        unit: "cd/m²",
        tooltip: "亮度"
    }), _dec5$h = property({
        type: PhotometricTerm,
        tooltip: "指定光通量或亮度"
    }), _dec6$d = property({
        tooltip: "针对聚光灯和点光源设置光源大小"
    }), _dec7$a = property({
        tooltip: "针对聚光灯和点光源设置光源范围"
    }), _dec8$7 = property({
        slide: !0,
        range: [ 2, 180, 1 ],
        tooltip: "聚光灯锥角"
    }), _dec$Z(_class$Z = _dec2$A(_class$Z = executeInEditMode((_descriptor$J = _applyDecoratedDescriptor((_class2$Q = function(_LightComponent) {
        function SpotLightComponent() {
            var _this;
            return _classCallCheck(this, SpotLightComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(SpotLightComponent).call(this)), "_size", _descriptor$J, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_luminance", _descriptor2$y, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_term", _descriptor3$q, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_range", _descriptor4$j, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_spotAngle", _descriptor5$e, _assertThisInitialized(_this)), 
            _this._type = LightType.SPOT, _this._light = null, _this._lightType = SpotLight, 
            _this;
        }
        return _inherits(SpotLightComponent, _LightComponent), _createClass(SpotLightComponent, [ {
            key: "luminousPower",
            get: function get() {
                return this._luminance * nt2lm(this._size);
            },
            set: function set(val) {
                this._luminance = val / nt2lm(this._size), this._light && (this._light.luminance = this._luminance);
            }
        }, {
            key: "luminance",
            get: function get() {
                return this._luminance;
            },
            set: function set(val) {
                this._luminance = val, this._light && (this._light.luminance = val);
            }
        }, {
            key: "term",
            get: function get() {
                return this._term;
            },
            set: function set(val) {
                this._term = val;
            }
        }, {
            key: "size",
            get: function get() {
                return this._size;
            },
            set: function set(val) {
                this._size = val, this._light && (this._light.size = val);
            }
        }, {
            key: "range",
            get: function get() {
                return this._range;
            },
            set: function set(val) {
                this._range = val, this._light && (this._light.range = val);
            }
        }, {
            key: "spotAngle",
            get: function get() {
                return this._spotAngle;
            },
            set: function set(val) {
                this._spotAngle = val, this._light && (this._light.spotAngle = toRadian(val));
            }
        } ]), _createClass(SpotLightComponent, [ {
            key: "_createLight",
            value: function _createLight() {
                _get(_getPrototypeOf(SpotLightComponent.prototype), "_createLight", this).call(this), 
                this._light && (this.luminance = this._luminance, this.size = this._size, this.range = this._range, 
                this.spotAngle = this._spotAngle);
            }
        } ]), SpotLightComponent;
    }(LightComponent)).prototype, "_size", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .15;
        }
    }), _descriptor2$y = _applyDecoratedDescriptor(_class2$Q.prototype, "_luminance", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1700 / nt2lm(.15);
        }
    }), _descriptor3$q = _applyDecoratedDescriptor(_class2$Q.prototype, "_term", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return PhotometricTerm.LUMINOUS_POWER;
        }
    }), _descriptor4$j = _applyDecoratedDescriptor(_class2$Q.prototype, "_range", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor5$e = _applyDecoratedDescriptor(_class2$Q.prototype, "_spotAngle", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 60;
        }
    }), _applyDecoratedDescriptor(_class2$Q.prototype, "luminousPower", [ _dec3$n ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "luminousPower"), _class2$Q.prototype), 
    _applyDecoratedDescriptor(_class2$Q.prototype, "luminance", [ _dec4$j ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "luminance"), _class2$Q.prototype), 
    _applyDecoratedDescriptor(_class2$Q.prototype, "term", [ _dec5$h ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "term"), _class2$Q.prototype), 
    _applyDecoratedDescriptor(_class2$Q.prototype, "size", [ _dec6$d ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "size"), _class2$Q.prototype), 
    _applyDecoratedDescriptor(_class2$Q.prototype, "range", [ _dec7$a ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "range"), _class2$Q.prototype), 
    _applyDecoratedDescriptor(_class2$Q.prototype, "spotAngle", [ _dec8$7 ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "spotAngle"), _class2$Q.prototype), 
    _class$Z = _class2$Q)) || _class$Z) || _class$Z) || _class$Z);
    exports.removeProperty(ModelComponent.prototype, "ModelComponent.prototype", [ {
        name: "enableDynamicBatching"
    }, {
        name: "receiveShadows"
    } ]), cc.CameraComponent = CameraComponent, cc.EditorComponent = EditorCameraComponent, 
    cc.RenderableComponent = RenderableComponent, cc.ModelComponent = ModelComponent, 
    cc.SkinningModelComponent = SkinningModelComponent, cc.BatchedSkinningModelComponent = BatchedSkinningModelComponent, 
    cc.SkinningModelUnit = SkinningModelUnit, cc.LightComponent = LightComponent, cc.DirectionalLightComponent = DirectionalLightComponent, 
    cc.SphereLightComponent = SphereLightComponent, cc.SpotLightComponent = SpotLightComponent, 
    cc.utils = utils;
    var _class$$, _class2$S, _descriptor$L, _descriptor2$A, _descriptor3$s, _class4$6, _class5$6, _descriptor4$l, _descriptor5$g, _descriptor6$7, UICoordinateTrackerComponent = (_dec$_ = ccclass("cc.UICoordinateTrackerComponent"), 
    _dec2$B = menu("Components/UICoordinateTracker"), _dec3$o = executionOrder(110), 
    _dec4$k = property({
        type: Node$1,
        tooltip: "目标对象"
    }), _dec5$i = property({
        type: CameraComponent,
        tooltip: "照射相机"
    }), _dec6$e = property({
        tooltip: "是否是缩放映射"
    }), _dec7$b = property({
        tooltip: "距相机多少距离为正常显示计算大小"
    }), _dec8$8 = property({
        type: [ EventHandler ],
        tooltip: "映射数据事件。回调的第一个参数是映射后的本地坐标，第二个是距相机距离比"
    }), _dec$_(_class$_ = _dec2$B(_class$_ = _dec3$o((_applyDecoratedDescriptor((_class2$R = function(_Component) {
        function UICoordinateTrackerComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, UICoordinateTrackerComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UICoordinateTrackerComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "syncEvents", _descriptor$K, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_target", _descriptor2$z, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_camera", _descriptor3$r, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_useScale", _descriptor4$k, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_distance", _descriptor5$f, _assertThisInitialized(_this)), 
            _this._transformPos = new Vec3, _this._viewPos = new Vec3, _this._canMove = !0, 
            _this._lastWpos = new Vec3, _this._lastCameraPos = new Vec3, _this;
        }
        return _inherits(UICoordinateTrackerComponent, _Component), _createClass(UICoordinateTrackerComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                this._checkCanMove();
            }
        }, {
            key: "update",
            value: function update() {
                var wpos = this.node.worldPosition, camera = this._camera;
                if (this._canMove && camera._camera && (!this._lastWpos.equals(wpos) || !this._lastCameraPos.equals(camera.node.worldPosition)) && (this._lastWpos.set(wpos), 
                this._lastCameraPos.set(camera.node.worldPosition), camera._camera.update(), convertUtils.WorldNode3DToLocalNodeUI(camera, wpos, this._target, this._transformPos), 
                this._useScale && Vec3.transformMat4(this._viewPos, this.node.worldPosition, camera._camera.matView), 
                this.syncEvents.length > 0)) {
                    var data = this._distance / Math.abs(this._viewPos.z);
                    EventHandler.emitEvents(this.syncEvents, this._transformPos, data);
                }
            }
        }, {
            key: "_checkCanMove",
            value: function _checkCanMove() {
                this._canMove = !(!this._camera || !this._target);
            }
        }, {
            key: "target",
            get: function get() {
                return this._target;
            },
            set: function set(value) {
                this._target !== value && (this._target = value, this._checkCanMove());
            }
        }, {
            key: "camera",
            get: function get() {
                return this._camera;
            },
            set: function set(value) {
                this._camera !== value && (this._camera = value, this._checkCanMove());
            }
        }, {
            key: "useScale",
            get: function get() {
                return this._useScale;
            },
            set: function set(value) {
                this._useScale !== value && (this._useScale = value);
            }
        }, {
            key: "distance",
            get: function get() {
                return this._distance;
            },
            set: function set(value) {
                this._distance !== value && (this._distance = value);
            }
        } ]), UICoordinateTrackerComponent;
    }(Component)).prototype, "target", [ _dec4$k ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "target"), _class2$R.prototype), 
    _applyDecoratedDescriptor(_class2$R.prototype, "camera", [ _dec5$i ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "camera"), _class2$R.prototype), 
    _applyDecoratedDescriptor(_class2$R.prototype, "useScale", [ _dec6$e ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "useScale"), _class2$R.prototype), 
    _applyDecoratedDescriptor(_class2$R.prototype, "distance", [ _dec7$b ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "distance"), _class2$R.prototype), 
    _descriptor$K = _applyDecoratedDescriptor(_class2$R.prototype, "syncEvents", [ _dec8$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$z = _applyDecoratedDescriptor(_class2$R.prototype, "_target", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$r = _applyDecoratedDescriptor(_class2$R.prototype, "_camera", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor4$k = _applyDecoratedDescriptor(_class2$R.prototype, "_useScale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor5$f = _applyDecoratedDescriptor(_class2$R.prototype, "_distance", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _class$_ = _class2$R)) || _class$_) || _class$_) || _class$_), UniformProxyFactory = ccclass("cc.animation.UniformProxyFactory")((_descriptor$L = _applyDecoratedDescriptor((_class2$S = function() {
        function UniformProxyFactory(uniformName, passIndex) {
            _classCallCheck(this, UniformProxyFactory), _initializerDefineProperty(this, "passIndex", _descriptor$L, this), 
            _initializerDefineProperty(this, "uniformName", _descriptor2$A, this), _initializerDefineProperty(this, "channelIndex", _descriptor3$s, this), 
            this.passIndex = passIndex || 0, this.uniformName = uniformName || "";
        }
        return _createClass(UniformProxyFactory, [ {
            key: "forTarget",
            value: function forTarget(target) {
                var pass = target.passes[this.passIndex], handle = pass.getHandle(this.uniformName);
                if (void 0 === handle) throw new Error('Material "'.concat(target.name, '" has no uniform "').concat(this.uniformName, '"'));
                var bindingType = Pass.getBindingTypeFromHandle(handle);
                if (bindingType === exports.GFXBindingType.UNIFORM_BUFFER) {
                    var realHandle = void 0 === this.channelIndex ? handle : pass.getHandle(this.uniformName, this.channelIndex, exports.GFXType.FLOAT);
                    if (void 0 === realHandle) throw new Error('Uniform "'.concat(this.uniformName, " (in material ").concat(target.name, ") has no channel ").concat(this.channelIndex, '"'));
                    return function isUniformArray(pass, name) {
                        var _iterator = pass.shaderInfo.blocks, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var _iterator2 = _ref.members, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref2;
                                if (_isArray2) {
                                    if (_i2 >= _iterator2.length) break;
                                    _ref2 = _iterator2[_i2++];
                                } else {
                                    if ((_i2 = _iterator2.next()).done) break;
                                    _ref2 = _i2.value;
                                }
                                var uniform = _ref2;
                                if (uniform.name === name) return uniform.count > 1;
                            }
                        }
                        return !1;
                    }(pass, this.uniformName) ? {
                        set: function set(value) {
                            pass.setUniformArray(realHandle, value);
                        }
                    } : {
                        set: function set(value) {
                            pass.setUniform(realHandle, value);
                        }
                    };
                }
                if (bindingType === exports.GFXBindingType.SAMPLER) {
                    var binding = Pass.getBindingFromHandle(handle), prop = pass.properties[this.uniformName], texName = prop && prop.value ? prop.value + "-texture" : type2default[prop.type], dftTex = builtinResMgr.get(texName);
                    return dftTex || (console.warn("illegal texture default value: " + texName), dftTex = builtinResMgr.get("default-texture")), 
                    {
                        set: function set(value) {
                            value || (value = dftTex);
                            var tv = value.getGFXTextureView();
                            tv && tv.texture.width && tv.texture.height && (pass.bindTextureView(binding, tv), 
                            value instanceof TextureBase && pass.bindSampler(binding, samplerLib.getSampler(cc.game._gfxDevice, value.getSamplerHash())));
                        }
                    };
                }
                throw new Error("Animations are not available for uniforms with binding type ".concat(bindingType, "."));
            }
        } ]), UniformProxyFactory;
    }()).prototype, "passIndex", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor2$A = _applyDecoratedDescriptor(_class2$S.prototype, "uniformName", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor3$s = _applyDecoratedDescriptor(_class2$S.prototype, "channelIndex", [ _float ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {}
    }), _class$$ = _class2$S)) || _class$$;
    function makeCubicSplineValueConstructor(name, constructorX, scaleFx, scaleAndAdd) {
        var _class, _class2, _descriptor, _descriptor2, _descriptor3, tempValue = new constructorX, m0 = new constructorX, m1 = new constructorX, CubicSplineValueClass = ccclass(name)((_descriptor = _applyDecoratedDescriptor((_class2 = function() {
            function CubicSplineValueClass(dataPoint, inTangent, outTangent) {
                _classCallCheck(this, CubicSplineValueClass), _initializerDefineProperty(this, "dataPoint", _descriptor, this), 
                _initializerDefineProperty(this, "inTangent", _descriptor2, this), _initializerDefineProperty(this, "outTangent", _descriptor3, this), 
                this.dataPoint = dataPoint || new constructorX, this.inTangent = inTangent || new constructorX, 
                this.outTangent = outTangent || new constructorX;
            }
            return _createClass(CubicSplineValueClass, [ {
                key: "lerp",
                value: function lerp(to, t, dt) {
                    var p0 = this.dataPoint, p1 = to.dataPoint;
                    m0 = scaleFx(m0, this.inTangent, dt), m1 = scaleFx(m1, to.outTangent, dt);
                    var t_3 = t * t * t, t_2 = t * t, f_1 = t_3 - 2 * t_2 + t, f_2 = -2 * t_3 + 3 * t_2, f_3 = t_3 - t_2;
                    return tempValue = scaleFx(tempValue, p0, 2 * t_3 - 3 * t_2 + 1), tempValue = scaleAndAdd(tempValue, tempValue, m0, f_1), 
                    tempValue = scaleAndAdd(tempValue, tempValue, p1, f_2), tempValue = scaleAndAdd(tempValue, tempValue, m1, f_3);
                }
            }, {
                key: "getNoLerp",
                value: function getNoLerp() {
                    return this.dataPoint;
                }
            } ]), CubicSplineValueClass;
        }()).prototype, "dataPoint", [ property ], {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: function initializer() {
                return new constructorX;
            }
        }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "inTangent", [ property ], {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: function initializer() {
                return new constructorX;
            }
        }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "outTangent", [ property ], {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: function initializer() {
                return new constructorX;
            }
        }), _class = _class2)) || _class;
        if (constructorX === Quat) {
            var _lerp = CubicSplineValueClass.prototype.lerp;
            CubicSplineValueClass.prototype.lerp = function(to, t, dt) {
                var result = _lerp.call(this, to, t, dt);
                return Quat.normalize(result, result), result;
            };
        }
        return CubicSplineValueClass;
    }
    var CubicSplineVec2Value = makeCubicSplineValueConstructor("cc.CubicSplineVec2Value", Vec2, Vec2.multiplyScalar, Vec2.scaleAndAdd);
    cc.CubicSplineVec2Value = CubicSplineVec2Value;
    var CubicSplineVec3Value = makeCubicSplineValueConstructor("cc.CubicSplineVec3Value", Vec3, Vec3.multiplyScalar, Vec3.scaleAndAdd);
    cc.CubicSplineVec3Value = CubicSplineVec3Value;
    var CubicSplineVec4Value = makeCubicSplineValueConstructor("cc.CubicSplineVec4Value", Vec4, Vec4.multiplyScalar, Vec4.scaleAndAdd);
    cc.CubicSplineVec4Value = CubicSplineVec4Value;
    var CubicSplineQuatValue = makeCubicSplineValueConstructor("cc.CubicSplineQuatValue", Quat, Quat.multiplyScalar, Quat.scaleAndAdd);
    cc.CubicSplineQuatValue = CubicSplineQuatValue;
    var CubicSplineNumberValue = ccclass("cc.CubicSplineNumberValue")((_descriptor4$l = _applyDecoratedDescriptor((_class5$6 = function() {
        function CubicSplineNumberValue(dataPoint, inTangent, outTangent) {
            _classCallCheck(this, CubicSplineNumberValue), _initializerDefineProperty(this, "dataPoint", _descriptor4$l, this), 
            _initializerDefineProperty(this, "inTangent", _descriptor5$g, this), _initializerDefineProperty(this, "outTangent", _descriptor6$7, this), 
            this.dataPoint = dataPoint, this.inTangent = inTangent, this.outTangent = outTangent;
        }
        return _createClass(CubicSplineNumberValue, [ {
            key: "lerp",
            value: function lerp(to, t, dt) {
                var p0 = this.dataPoint, p1 = to.dataPoint, t_3 = t * t * t, t_2 = t * t;
                return p0 * (2 * t_3 - 3 * t_2 + 1) + this.outTangent * dt * (t_3 - 2 * t_2 + t) + p1 * (-2 * t_3 + 3 * t_2) + to.inTangent * dt * (t_3 - t_2);
            }
        }, {
            key: "getNoLerp",
            value: function getNoLerp() {
                return this.dataPoint;
            }
        } ]), CubicSplineNumberValue;
    }()).prototype, "dataPoint", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor5$g = _applyDecoratedDescriptor(_class5$6.prototype, "inTangent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$7 = _applyDecoratedDescriptor(_class5$6.prototype, "outTangent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class4$6 = _class5$6)) || _class4$6;
    cc.CubicSplineNumberValue = CubicSplineNumberValue;
    var animation = Object.freeze({
        __proto__: null,
        UniformProxyFactory: UniformProxyFactory,
        isPropertyPath: isPropertyPath,
        isCustomPath: isCustomPath,
        HierarchyPath: HierarchyPath,
        ComponentPath: ComponentPath,
        CubicSplineVec2Value: CubicSplineVec2Value,
        CubicSplineVec3Value: CubicSplineVec3Value,
        CubicSplineVec4Value: CubicSplineVec4Value,
        CubicSplineQuatValue: CubicSplineQuatValue,
        CubicSplineNumberValue: CubicSplineNumberValue
    });
    function quadIn(k) {
        return k * k;
    }
    function quadOut(k) {
        return k * (2 - k);
    }
    function cubicIn(k) {
        return k * k * k;
    }
    function cubicOut(k) {
        return --k * k * k + 1;
    }
    function quartIn(k) {
        return k * k * k * k;
    }
    function quartOut(k) {
        return 1 - --k * k * k * k;
    }
    function quintIn(k) {
        return k * k * k * k * k;
    }
    function quintOut(k) {
        return --k * k * k * k * k + 1;
    }
    function sineIn(k) {
        return 1 - Math.cos(k * Math.PI / 2);
    }
    function sineOut(k) {
        return Math.sin(k * Math.PI / 2);
    }
    function expoIn(k) {
        return 0 === k ? 0 : Math.pow(1024, k - 1);
    }
    function expoOut(k) {
        return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
    }
    function circIn(k) {
        return 1 - Math.sqrt(1 - k * k);
    }
    function circOut(k) {
        return Math.sqrt(1 - --k * k);
    }
    function elasticIn(k) {
        var s, a = .1;
        return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
        -a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4));
    }
    function elasticOut(k) {
        var s, a = .1;
        return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
        a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / .4) + 1);
    }
    function backIn(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
    }
    function backOut(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
    }
    function bounceIn(k) {
        return 1 - bounceOut(1 - k);
    }
    function bounceOut(k) {
        return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
    }
    var quadOutIn = _makeOutIn(quadIn, quadOut), cubicOutIn = _makeOutIn(cubicIn, cubicOut), quartOutIn = _makeOutIn(quartIn, quartOut), quintOutIn = _makeOutIn(quintIn, quintOut), sineOutIn = _makeOutIn(sineIn, sineOut), expoOutIn = _makeOutIn(expoIn, expoOut), circOutIn = _makeOutIn(circIn, circOut), elasticOutIn = _makeOutIn(elasticIn, elasticOut), backOutIn = _makeOutIn(backIn, backOut), bounceOutIn = _makeOutIn(bounceIn, bounceOut);
    function _makeOutIn(fnIn, fnOut) {
        return function(k) {
            return k < .5 ? fnOut(2 * k) / 2 : fnIn(2 * k - 1) / 2 + .5;
        };
    }
    var easing = Object.freeze({
        __proto__: null,
        constant: function constant() {
            return 0;
        },
        linear: function linear(k) {
            return k;
        },
        quadIn: quadIn,
        quadOut: quadOut,
        quadInOut: function quadInOut(k) {
            return (k *= 2) < 1 ? .5 * k * k : -.5 * (--k * (k - 2) - 1);
        },
        cubicIn: cubicIn,
        cubicOut: cubicOut,
        cubicInOut: function cubicInOut(k) {
            return (k *= 2) < 1 ? .5 * k * k * k : .5 * ((k -= 2) * k * k + 2);
        },
        quartIn: quartIn,
        quartOut: quartOut,
        quartInOut: function quartInOut(k) {
            return (k *= 2) < 1 ? .5 * k * k * k * k : -.5 * ((k -= 2) * k * k * k - 2);
        },
        quintIn: quintIn,
        quintOut: quintOut,
        quintInOut: function quintInOut(k) {
            return (k *= 2) < 1 ? .5 * k * k * k * k * k : .5 * ((k -= 2) * k * k * k * k + 2);
        },
        sineIn: sineIn,
        sineOut: sineOut,
        sineInOut: function sineInOut(k) {
            return .5 * (1 - Math.cos(Math.PI * k));
        },
        expoIn: expoIn,
        expoOut: expoOut,
        expoInOut: function expoInOut(k) {
            return 0 === k ? 0 : 1 === k ? 1 : (k *= 2) < 1 ? .5 * Math.pow(1024, k - 1) : .5 * (2 - Math.pow(2, -10 * (k - 1)));
        },
        circIn: circIn,
        circOut: circOut,
        circInOut: function circInOut(k) {
            return (k *= 2) < 1 ? -.5 * (Math.sqrt(1 - k * k) - 1) : .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        },
        elasticIn: elasticIn,
        elasticOut: elasticOut,
        elasticInOut: function elasticInOut(k) {
            var s, a = .1;
            return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
            (k *= 2) < 1 ? a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * -.5 : a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * .5 + 1);
        },
        backIn: backIn,
        backOut: backOut,
        backInOut: function backInOut(k) {
            var s = 2.5949095;
            return (k *= 2) < 1 ? k * k * ((s + 1) * k - s) * .5 : .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        },
        bounceIn: bounceIn,
        bounceOut: bounceOut,
        bounceInOut: function bounceInOut(k) {
            return k < .5 ? .5 * bounceIn(2 * k) : .5 * bounceOut(2 * k - 1) + .5;
        },
        smooth: function smooth(k) {
            return k <= 0 ? 0 : k >= 1 ? 1 : k * k * (3 - 2 * k);
        },
        fade: function fade(k) {
            return k <= 0 ? 0 : k >= 1 ? 1 : k * k * k * (k * (6 * k - 15) + 10);
        },
        quadOutIn: quadOutIn,
        cubicOutIn: cubicOutIn,
        quartOutIn: quartOutIn,
        quintOutIn: quintOutIn,
        sineOutIn: sineOutIn,
        expoOutIn: expoOutIn,
        circOutIn: circOutIn,
        elasticOutIn: elasticOutIn,
        backOutIn: backOutIn,
        bounceOutIn: bounceOutIn
    });
    function binarySearchEpsilon$1(array, value) {
        for (var low = 0, high = array.length - 1, middle = high >>> 1; low <= high; middle = low + high >>> 1) {
            var middleValue = array[middle];
            if (middleValue > value + 1e-6) high = middle - 1; else {
                if (!(middleValue < value - 1e-6)) return middle;
                low = middle + 1;
            }
        }
        return ~low;
    }
    function bezier(C1, C2, C3, C4, t) {
        var t1 = 1 - t;
        return C1 * t1 * t1 * t1 + 3 * C2 * t1 * t1 * t + 3 * C3 * t1 * t * t + C4 * t * t * t;
    }
    cc.bezier = bezier;
    var WrapModeMask, WrapMode$2, cos = Math.cos, acos = Math.acos, max$2 = Math.max, tau = 2 * Math.PI, sqrt = Math.sqrt;
    function crt(v) {
        return v < 0 ? -Math.pow(-v, 1 / 3) : Math.pow(v, 1 / 3);
    }
    function bezierByTime(controlPoints, x) {
        var percent = function cardano(curve, x) {
            var u1, x1, x2, x3, pa = x - 0, pb = x - curve[0], pa3 = 3 * pa, pb3 = 3 * pb, pc3 = 3 * (x - curve[2]), rd = 1 / (-pa + pb3 - pc3 + (x - 1)), a = (pa3 - 6 * pb + pc3) * rd, a3 = a * (1 / 3), b = (-pa3 + pb3) * rd, p = 1 / 3 * (3 * b - a * a), p3 = p * (1 / 3), q = (2 * a * a * a - 9 * a * b + 27 * (pa * rd)) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
            if (discriminant < 0) {
                var mp3 = 1 / 3 * -p, r = sqrt(mp3 * mp3 * mp3), t = -q / (2 * r), phi = acos(t < -1 ? -1 : t > 1 ? 1 : t), t1 = 2 * crt(r);
                return x1 = t1 * cos(phi * (1 / 3)) - a3, x2 = t1 * cos((phi + tau) * (1 / 3)) - a3, 
                x3 = t1 * cos((phi + 2 * tau) * (1 / 3)) - a3, 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max$2(x1, x2, x3) : max$2(x1, x2) : 0 <= x3 && x3 <= 1 ? max$2(x1, x3) : x1 : 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max$2(x2, x3) : x2 : x3;
            }
            if (0 === discriminant) return x2 = -(u1 = q2 < 0 ? crt(-q2) : -crt(q2)) - a3, 0 <= (x1 = 2 * u1 - a3) && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? max$2(x1, x2) : x1 : x2;
            var sd = sqrt(discriminant);
            return x1 = (u1 = crt(-q2 + sd)) - crt(q2 + sd) - a3;
        }(controlPoints, x), t1 = 1 - percent;
        return 0 * t1 * t1 * t1 + 3 * controlPoints[1] * percent * t1 * t1 + 3 * controlPoints[3] * percent * percent * t1 + 1 * percent * percent * percent;
    }
    cc.bezierByTime = bezierByTime, function(WrapModeMask) {
        WrapModeMask[WrapModeMask.Loop = 2] = "Loop", WrapModeMask[WrapModeMask.ShouldWrap = 4] = "ShouldWrap", 
        WrapModeMask[WrapModeMask.PingPong = 22] = "PingPong", WrapModeMask[WrapModeMask.Reverse = 36] = "Reverse";
    }(WrapModeMask || (WrapModeMask = {})), function(WrapMode) {
        WrapMode[WrapMode.Default = 0] = "Default", WrapMode[WrapMode.Normal = 1] = "Normal", 
        WrapMode[WrapMode.Reverse = WrapModeMask.Reverse] = "Reverse", WrapMode[WrapMode.Loop = WrapModeMask.Loop] = "Loop", 
        WrapMode[WrapMode.LoopReverse = WrapModeMask.Loop | WrapModeMask.Reverse] = "LoopReverse", 
        WrapMode[WrapMode.PingPong = WrapModeMask.PingPong] = "PingPong", WrapMode[WrapMode.PingPongReverse = WrapModeMask.PingPong | WrapModeMask.Reverse] = "PingPongReverse";
    }(WrapMode$2 || (WrapMode$2 = {})), ccenum(WrapMode$2);
    var WrappedInfo = function() {
        function WrappedInfo(info) {
            _classCallCheck(this, WrappedInfo), this.ratio = 0, this.time = 0, this.direction = 1, 
            this.stopped = !0, this.iterations = 0, this.frameIndex = void 0, info && this.set(info);
        }
        return _createClass(WrappedInfo, [ {
            key: "set",
            value: function set(info) {
                this.ratio = info.ratio, this.time = info.time, this.direction = info.direction, 
                this.stopped = info.stopped, this.iterations = info.iterations, this.frameIndex = info.frameIndex;
            }
        } ]), WrappedInfo;
    }();
    var RatioSampler = function() {
        function RatioSampler(ratios) {
            var currRatioDif, lastRatioDif;
            _classCallCheck(this, RatioSampler), this.ratios = ratios;
            for (var canOptimize = !0, i = 1, l = ratios.length; i < l; i++) if (currRatioDif = ratios[i] - ratios[i - 1], 
            1 === i) lastRatioDif = currRatioDif; else if (Math.abs(currRatioDif - lastRatioDif) > 1e-6) {
                canOptimize = !1;
                break;
            }
            this._findRatio = canOptimize ? quickFindIndex : binarySearchEpsilon$1;
        }
        return _createClass(RatioSampler, [ {
            key: "sample",
            value: function sample(ratio) {
                return this._findRatio(this.ratios, ratio);
            }
        } ]), RatioSampler;
    }();
    cc.RatioSampler = RatioSampler;
    var AnimCurve = function() {
        function AnimCurve(propertyCurveData, duration) {
            _classCallCheck(this, AnimCurve), this.types = void 0, this.type = null, this._values = [], 
            this._lerp = void 0, this._duration = duration, this._values = propertyCurveData.values;
            var getCurveType = function getCurveType(easingMethod) {
                return "string" == typeof easingMethod ? easingMethod : Array.isArray(easingMethod) ? easingMethod[0] === easingMethod[1] && easingMethod[2] === easingMethod[3] ? AnimCurve.Linear : AnimCurve.Bezier(easingMethod) : AnimCurve.Linear;
            };
            if (void 0 !== propertyCurveData.easingMethod) this.type = getCurveType(propertyCurveData.easingMethod); else if (Array.isArray(propertyCurveData.easingMethods)) this.types = propertyCurveData.easingMethods.map(getCurveType); else if (void 0 !== propertyCurveData.easingMethods) {
                this.types = new Array(this._values.length).fill(null);
                for (var _i = 0, _Object$keys = Object.keys(propertyCurveData.easingMethods); _i < _Object$keys.length; _i++) {
                    var index = _Object$keys[_i];
                    this.types[index] = getCurveType(propertyCurveData.easingMethods[index]);
                }
            } else this.type = null;
            var firstValue = propertyCurveData.values[0];
            (void 0 === propertyCurveData.interpolate || propertyCurveData.interpolate) && (this._lerp = selectLerpFx(firstValue));
        }
        return _createClass(AnimCurve, null, [ {
            key: "Bezier",
            value: function Bezier(controlPoints) {
                return controlPoints;
            }
        } ]), _createClass(AnimCurve, [ {
            key: "hasLerp",
            value: function hasLerp() {
                return !!this._lerp;
            }
        }, {
            key: "valueAt",
            value: function valueAt(index) {
                var value = this._values[index];
                return value && value.getNoLerp ? value.getNoLerp() : value;
            }
        }, {
            key: "valueBetween",
            value: function valueBetween(ratio, from, fromRatio, to, toRatio) {
                if (this._lerp) {
                    var type = this.types ? this.types[from] : this.type, dRatio = toRatio - fromRatio, ratioBetweenFrames = (ratio - fromRatio) / dRatio;
                    type && (ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type));
                    var fromVal = this._values[from], toVal = this._values[to];
                    return this._lerp(fromVal, toVal, ratioBetweenFrames, dRatio * this._duration);
                }
                return this.valueAt(from);
            }
        }, {
            key: "empty",
            value: function empty() {
                return 0 === this._values.length;
            }
        } ]), AnimCurve;
    }();
    AnimCurve.Linear = null, cc.AnimCurve = AnimCurve;
    var EventInfo = function() {
        function EventInfo() {
            _classCallCheck(this, EventInfo), this.events = [];
        }
        return _createClass(EventInfo, [ {
            key: "add",
            value: function add(func, params) {
                this.events.push({
                    func: func || "",
                    params: params || []
                });
            }
        } ]), EventInfo;
    }();
    function sampleAnimationCurve(curve, sampler, ratio) {
        var index = sampler.sample(ratio);
        if (index < 0) if ((index = ~index) <= 0) index = 0; else {
            if (!(index >= sampler.ratios.length)) return curve.valueBetween(ratio, index - 1, sampler.ratios[index - 1], index, sampler.ratios[index]);
            index = sampler.ratios.length - 1;
        }
        return curve.valueAt(index);
    }
    function computeRatioByType(ratio, type) {
        if ("string" == typeof type) {
            var func = easing[type];
            func ? ratio = func(ratio) : errorID(3906, type);
        } else Array.isArray(type) && (ratio = bezierByTime(type, ratio));
        return ratio;
    }
    function quickFindIndex(ratios, ratio) {
        var length = ratios.length - 1;
        if (0 === length) return 0;
        var start = ratios[0];
        if (ratio < start) return 0;
        var end = ratios[length];
        if (ratio > end) return length;
        var index = (ratio = (ratio - start) / (end - start)) / (1 / length), floorIndex = 0 | index;
        return index - floorIndex < 1e-6 ? floorIndex : floorIndex + 1 - index < 1e-6 ? floorIndex + 1 : ~(floorIndex + 1);
    }
    cc.sampleAnimationCurve = sampleAnimationCurve;
    var _dec$10, _dec2$D, _class$10, _class2$T, _descriptor$M, _descriptor2$B, _descriptor3$t, _descriptor4$m, _descriptor5$h, _descriptor6$8, _descriptor7$7, _descriptor8$6, _descriptor9$5, _descriptor10$5, _descriptor11$3, _class3$j, _temp$W, selectLerpFx = function() {
        function callLerpable(from, to, t, dt) {
            return from.lerp(to, t, dt);
        }
        return function(value) {
            if (null !== value) {
                if ("number" == typeof value) return lerp;
                if ("object" === _typeof(value) && value.constructor) {
                    if (value instanceof Quat) return function makeQuatSlerpFx() {
                        var tempValue = new Quat;
                        return function(from, to, t, dt) {
                            return Quat.slerp(tempValue, from, to, t);
                        };
                    }();
                    if (value instanceof ValueType) return function makeValueTypeLerpFx(constructor) {
                        var tempValue = new constructor;
                        return function(from, to, ratio) {
                            return constructor.lerp(tempValue, from, to, ratio), tempValue;
                        };
                    }(value.constructor);
                    if (value.constructor === Number) return lerp;
                    if (function isLerpable(object) {
                        return "function" == typeof object.lerp;
                    }(value)) return callLerpable;
                }
            }
        };
    }(), AnimationClip = (_dec$10 = ccclass("cc.AnimationClip"), _dec2$D = property({
        visible: !1
    }), _dec$10((_temp$W = _class3$j = function(_Asset) {
        function AnimationClip() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, AnimationClip);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationClip)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "sample", _descriptor$M, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "speed", _descriptor2$B, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "wrapMode", _descriptor3$t, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "events", _descriptor4$m, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_duration", _descriptor5$h, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_keys", _descriptor6$8, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_stepness", _descriptor7$7, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "curveDatas", _descriptor8$6, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_curves", _descriptor9$5, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_commonTargets", _descriptor10$5, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_hash", _descriptor11$3, _assertThisInitialized(_this)), 
            _this.frameRate = 0, _this._ratioSamplers = [], _this._data = null, _this;
        }
        return _inherits(AnimationClip, _Asset), _createClass(AnimationClip, [ {
            key: "onLoaded",
            value: function onLoaded() {
                this.frameRate = this.sample, this._migrateCurveDatas(), this._decodeCVTAs();
            }
        }, {
            key: "getPropertyCurves",
            value: function getPropertyCurves() {
                return this._runtimeCurves || this._createPropertyCurves(), this._runtimeCurves;
            }
        }, {
            key: "updateCurveDatas",
            value: function updateCurveDatas() {
                this._migrateCurveDatas(), delete this._runtimeCurves;
            }
        }, {
            key: "updateEventDatas",
            value: function updateEventDatas() {
                delete this._runtimeEvents;
            }
        }, {
            key: "getEventGroupIndexAtRatio",
            value: function getEventGroupIndexAtRatio(ratio) {
                return this._runtimeEvents || this._createRuntimeEvents(), function binarySearchEpsilon(array, value) {
                    for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                        var test = array[m];
                        if (test > value + 1e-6) h = m - 1; else {
                            if (!(test < value - 1e-6)) return m;
                            l = m + 1;
                        }
                    }
                    return ~l;
                }(this._runtimeEvents.ratios, ratio);
            }
        }, {
            key: "hasEvents",
            value: function hasEvents() {
                return 0 !== this.events.length;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return cc.director.root.dataPoolManager.releaseAnimationClip(this), SkelAnimDataHub.destroy(this), 
                _get(_getPrototypeOf(AnimationClip.prototype), "destroy", this).call(this);
            }
        }, {
            key: "_createPropertyCurves",
            value: function _createPropertyCurves() {
                var _this2 = this;
                this._ratioSamplers = this._keys.map((function(keys) {
                    return new RatioSampler(keys.map((function(key) {
                        return key / _this2._duration;
                    })));
                })), this._runtimeCurves = this._curves.map((function(targetCurve) {
                    return {
                        curve: new AnimCurve(targetCurve.data, _this2._duration),
                        modifiers: targetCurve.modifiers,
                        valueAdapter: targetCurve.valueAdapter,
                        sampler: _this2._ratioSamplers[targetCurve.data.keys],
                        commonTarget: targetCurve.commonTarget
                    };
                })), this._applyStepness();
            }
        }, {
            key: "_createRuntimeEvents",
            value: function _createRuntimeEvents() {
                var _this3 = this;
                var ratios = [], eventGroups = [], _loop = function _loop() {
                    if (_isArray) {
                        if (_i >= _iterator.length) return "break";
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) return "break";
                        _ref = _i.value;
                    }
                    var eventData = _ref, ratio = eventData.frame / _this3._duration, i = ratios.findIndex((function(r) {
                        return r === ratio;
                    }));
                    i < 0 && (i = ratios.length, ratios.push(ratio), eventGroups.push({
                        events: []
                    })), eventGroups[i].events.push({
                        functionName: eventData.func,
                        parameters: eventData.params
                    });
                }, _iterator = this.events.sort((function(a, b) {
                    return a.frame - b.frame;
                })), _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if ("break" === _loop()) break;
                }
                this._runtimeEvents = {
                    ratios: ratios,
                    eventGroups: eventGroups
                };
            }
        }, {
            key: "_applyStepness",
            value: function _applyStepness() {
                this._runtimeCurves;
            }
        }, {
            key: "_migrateCurveDatas",
            value: function _migrateCurveDatas() {
                if (this.curveDatas) {
                    for (var _i2 = 0, _Object$keys = Object.keys(this.curveDatas); _i2 < _Object$keys.length; _i2++) {
                        var curveTargetPath = _Object$keys[_i2], hierarchyPath = new HierarchyPath;
                        hierarchyPath.path = curveTargetPath;
                        var nodeData = this.curveDatas[curveTargetPath];
                        if (nodeData.props) for (var _i3 = 0, _Object$keys2 = Object.keys(nodeData.props); _i3 < _Object$keys2.length; _i3++) {
                            var nodePropertyName = _Object$keys2[_i3], propertyCurveData = nodeData.props[nodePropertyName];
                            this._curves.push({
                                modifiers: [ hierarchyPath, nodePropertyName ],
                                data: propertyCurveData
                            });
                        }
                        if (nodeData.comps) for (var _i4 = 0, _Object$keys3 = Object.keys(nodeData.comps); _i4 < _Object$keys3.length; _i4++) {
                            var _componentName = _Object$keys3[_i4], componentPath = new ComponentPath;
                            componentPath.component = _componentName;
                            for (var componentData = nodeData.comps[_componentName], _i5 = 0, _Object$keys4 = Object.keys(componentData); _i5 < _Object$keys4.length; _i5++) {
                                var componentPropertyName = _Object$keys4[_i5], _propertyCurveData = componentData[componentPropertyName];
                                this._curves.push({
                                    modifiers: [ hierarchyPath, componentPath, componentPropertyName ],
                                    data: _propertyCurveData
                                });
                            }
                        }
                    }
                    delete this.curveDatas;
                }
            }
        }, {
            key: "_decodeCVTAs",
            value: function _decodeCVTAs() {
                var binaryBuffer = ArrayBuffer.isView(this._nativeAsset) ? this._nativeAsset.buffer : this._nativeAsset;
                if (binaryBuffer) {
                    for (var maybeCompressedKeys = this._keys, iKey = 0; iKey < maybeCompressedKeys.length; ++iKey) {
                        var keys = maybeCompressedKeys[iKey];
                        keys instanceof CompactValueTypeArray && (maybeCompressedKeys[iKey] = keys.decompress(binaryBuffer));
                    }
                    for (var iCurve = 0; iCurve < this._curves.length; ++iCurve) {
                        var curve = this._curves[iCurve];
                        curve.data.values instanceof CompactValueTypeArray && (curve.data.values = curve.data.values.decompress(binaryBuffer));
                    }
                }
            }
        }, {
            key: "duration",
            get: function get() {
                return this._duration;
            },
            set: function set(value) {
                this._duration = value;
            }
        }, {
            key: "keys",
            get: function get() {
                return this._keys;
            },
            set: function set(value) {
                this._keys = value;
            }
        }, {
            key: "eventGroups",
            get: function get() {
                return this._runtimeEvents || this._createRuntimeEvents(), this._runtimeEvents.eventGroups;
            }
        }, {
            key: "stepness",
            get: function get() {
                return this._stepness;
            },
            set: function set(value) {
                this._stepness = value, this._applyStepness();
            }
        }, {
            key: "hash",
            get: function get() {
                return this._hash || (this._hash = murmurhash2_32_gc(JSON.stringify(SkelAnimDataHub.getOrExtract(this).data), 666)), 
                this._hash;
            }
        }, {
            key: "curves",
            get: function get() {
                return this._curves;
            },
            set: function set(value) {
                this._curves = value, delete this._runtimeCurves;
            }
        }, {
            key: "data",
            get: function get() {
                return this._data;
            }
        }, {
            key: "commonTargets",
            get: function get() {
                return this._commonTargets;
            },
            set: function set(value) {
                this._commonTargets = value;
            }
        } ], [ {
            key: "createWithSpriteFrames",
            value: function createWithSpriteFrames(spriteFrames, sample) {
                if (!Array.isArray(spriteFrames)) return errorID(3905), null;
                var clip = new AnimationClip;
                clip.sample = sample || clip.sample, clip.duration = spriteFrames.length / clip.sample;
                for (var step = 1 / clip.sample, keys = new Array(spriteFrames.length), values = new Array(keys.length), i = 0; i < spriteFrames.length; i++) keys[i] = i * step, 
                values[i] = spriteFrames[i];
                return clip.keys = [ keys ], clip.curves = [ {
                    modifiers: [ new ComponentPath("cc.SpriteComponent"), "spriteFrame" ],
                    data: {
                        keys: 0,
                        values: values
                    }
                } ], clip;
            }
        } ]), AnimationClip;
    }(Asset), _class3$j.preventDeferredLoadDependents = !0, _class3$j.WrapMode = WrapMode$2, 
    _descriptor$M = _applyDecoratedDescriptor((_class2$T = _temp$W).prototype, "sample", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 60;
        }
    }), _descriptor2$B = _applyDecoratedDescriptor(_class2$T.prototype, "speed", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor3$t = _applyDecoratedDescriptor(_class2$T.prototype, "wrapMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return WrapMode$2.Normal;
        }
    }), _descriptor4$m = _applyDecoratedDescriptor(_class2$T.prototype, "events", [ _dec2$D ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor5$h = _applyDecoratedDescriptor(_class2$T.prototype, "_duration", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$8 = _applyDecoratedDescriptor(_class2$T.prototype, "_keys", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor7$7 = _applyDecoratedDescriptor(_class2$T.prototype, "_stepness", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor8$6 = _applyDecoratedDescriptor(_class2$T.prototype, "curveDatas", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return {};
        }
    }), _descriptor9$5 = _applyDecoratedDescriptor(_class2$T.prototype, "_curves", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor10$5 = _applyDecoratedDescriptor(_class2$T.prototype, "_commonTargets", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor11$3 = _applyDecoratedDescriptor(_class2$T.prototype, "_hash", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$10 = _class2$T)) || _class$10);
    function additive3D(value, weight, propertyBlendState) {
        return propertyBlendState.value || (propertyBlendState.value = new Vec3), 0 === propertyBlendState.weight && Vec3.zero(propertyBlendState.value), 
        0 === weight ? propertyBlendState.value : 1 === weight ? Vec3.copy(propertyBlendState.value, value) : Vec3.scaleAndAdd(propertyBlendState.value, propertyBlendState.value, value, weight);
    }
    function additiveQuat(value, weight, propertyBlendState) {
        if (propertyBlendState.value || (propertyBlendState.value = new Quat), 0 === propertyBlendState.weight && Quat.identity(propertyBlendState.value), 
        0 === weight) return propertyBlendState.value;
        if (1 === weight) return Quat.copy(propertyBlendState.value, value);
        var t = weight / (propertyBlendState.weight + weight);
        return Quat.slerp(propertyBlendState.value, propertyBlendState.value, value, t);
    }
    cc.AnimationClip = AnimationClip;
    var map, PropertySpecialization, BoundTarget = function() {
        function BoundTarget(target, modifiers, valueAdapter) {
            var assignmentModifier;
            _classCallCheck(this, BoundTarget);
            for (var iModifier = 0; iModifier < modifiers.length; ++iModifier) {
                var modifier = modifiers[iModifier];
                if (isPropertyPath(modifier)) if (iModifier !== modifiers.length - 1 || valueAdapter) {
                    if (!(modifier in target)) throw new Error('Target object has no property "'.concat(modifier, '"'));
                    target = target[modifier];
                } else assignmentModifier = modifier; else target = modifier.get(target);
            }
            if (void 0 !== assignmentModifier) this._ap = {
                isProxy: !1,
                object: target,
                property: assignmentModifier
            }; else {
                if (!valueAdapter) throw new Error("Bad animation curve.");
                this._ap = {
                    isProxy: !0,
                    proxy: valueAdapter.forTarget(target)
                };
            }
        }
        return _createClass(BoundTarget, [ {
            key: "setValue",
            value: function setValue(value) {
                this._ap.isProxy ? this._ap.proxy.set(value) : this._ap.object[this._ap.property] = value;
            }
        }, {
            key: "getValue",
            value: function getValue() {
                if (this._ap.isProxy) {
                    if (this._ap.proxy.get) return this._ap.proxy.get();
                    throw new Error("Target doesn't provide a get method.");
                }
                return this._ap.object[this._ap.property];
            }
        } ]), BoundTarget;
    }(), BufferedTarget = function(_BoundTarget) {
        function BufferedTarget(target, modifiers, valueAdapter) {
            var _this;
            _classCallCheck(this, BufferedTarget);
            var value = (_this = _possibleConstructorReturn(this, _getPrototypeOf(BufferedTarget).call(this, target, modifiers, valueAdapter))).getValue(), copyable = getBuiltinCopy(value);
            if (!copyable) throw new Error("Value is not copyable!");
            return _this._buffer = copyable.createBuffer(), _this._copy = copyable.copy, _this;
        }
        return _inherits(BufferedTarget, _BoundTarget), _createClass(BufferedTarget, [ {
            key: "peek",
            value: function peek() {
                return this._buffer;
            }
        }, {
            key: "pull",
            value: function pull() {
                var value = this.getValue();
                this._copy(this._buffer, value);
            }
        }, {
            key: "push",
            value: function push() {
                this.setValue(this._buffer);
            }
        } ]), BufferedTarget;
    }(BoundTarget), getBuiltinCopy = ((map = new Map).set(Vec2, {
        createBuffer: function createBuffer() {
            return new Vec2;
        },
        copy: Vec2.copy
    }), map.set(Vec3, {
        createBuffer: function createBuffer() {
            return new Vec3;
        },
        copy: Vec3.copy
    }), map.set(Vec4, {
        createBuffer: function createBuffer() {
            return new Vec4;
        },
        copy: Vec4.copy
    }), map.set(Color, {
        createBuffer: function createBuffer() {
            return new Color;
        },
        copy: Color.copy
    }), function(value) {
        return map.get(null == value ? void 0 : value.constructor);
    }), Playable = function() {
        function Playable() {
            _classCallCheck(this, Playable), this._isPlaying = !1, this._isPaused = !1, this._stepOnce = !1;
        }
        return _createClass(Playable, [ {
            key: "play",
            value: function play() {
                this._isPlaying ? this._isPaused ? (this._isPaused = !1, this.onResume()) : this.onError(getError(3912)) : (this._isPlaying = !0, 
                this.onPlay());
            }
        }, {
            key: "stop",
            value: function stop() {
                this._isPlaying && (this._isPlaying = !1, this.onStop(), this._isPaused = !1);
            }
        }, {
            key: "pause",
            value: function pause() {
                this._isPlaying && !this._isPaused && (this._isPaused = !0, this.onPause());
            }
        }, {
            key: "resume",
            value: function resume() {
                this._isPlaying && this._isPaused && (this._isPaused = !1, this.onResume());
            }
        }, {
            key: "step",
            value: function step() {
                this.pause(), this._stepOnce = !0, this._isPlaying || this.play();
            }
        }, {
            key: "update",
            value: function update(deltaTime) {}
        }, {
            key: "onPlay",
            value: function onPlay() {}
        }, {
            key: "onPause",
            value: function onPause() {}
        }, {
            key: "onResume",
            value: function onResume() {}
        }, {
            key: "onStop",
            value: function onStop() {}
        }, {
            key: "onError",
            value: function onError(message) {}
        }, {
            key: "isPlaying",
            get: function get() {
                return this._isPlaying;
            }
        }, {
            key: "isPaused",
            get: function get() {
                return this._isPaused;
            }
        } ]), Playable;
    }();
    !function(PropertySpecialization) {
        PropertySpecialization[PropertySpecialization.NodePosition = 0] = "NodePosition", 
        PropertySpecialization[PropertySpecialization.NodeScale = 1] = "NodeScale", PropertySpecialization[PropertySpecialization.NodeRotation = 2] = "NodeRotation", 
        PropertySpecialization[PropertySpecialization.None = 3] = "None";
    }(PropertySpecialization || (PropertySpecialization = {}));
    var ICurveInstance = function() {
        function ICurveInstance(runtimeCurve, target) {
            var blendTarget = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            if (_classCallCheck(this, ICurveInstance), this._curve = runtimeCurve.curve, this._curveDetail = runtimeCurve, 
            this._boundTarget = new BoundTarget(target, runtimeCurve.modifiers, runtimeCurve.valueAdapter), 
            this._rootTarget = target, this._isNodeTarget = target instanceof Node$1, this._propertySpecialization = PropertySpecialization.None, 
            this._blendFunction = null, this._isNodeTarget && Array.isArray(runtimeCurve.modifiers) && 1 === runtimeCurve.modifiers.length) switch (runtimeCurve.modifiers[0]) {
              case "position":
                this._propertySpecialization = PropertySpecialization.NodePosition, this._blendFunction = additive3D;
                break;

              case "rotation":
                this._propertySpecialization = PropertySpecialization.NodeRotation, this._blendFunction = additiveQuat;
                break;

              case "scale":
                this._propertySpecialization = PropertySpecialization.NodeScale, this._blendFunction = additive3D;
            }
            this._blendTarget = blendTarget;
        }
        return _createClass(ICurveInstance, [ {
            key: "attachToBlendState",
            value: function attachToBlendState(blendState) {
                this._rootTargetProperty && (this._blendTarget = blendState.refPropertyBlendTarget(this._rootTarget, this._rootTargetProperty));
            }
        }, {
            key: "detachFromBlendState",
            value: function detachFromBlendState(blendState) {
                this._rootTargetProperty && (this._blendTarget = null, blendState.deRefPropertyBlendTarget(this._rootTarget, this._rootTargetProperty));
            }
        }, {
            key: "applySample",
            value: function applySample(ratio, index, lerpRequired, samplerResultCache, weight) {
                var value;
                this._curve.empty() || (value = this._curve.hasLerp() && lerpRequired ? this._curve.valueBetween(ratio, samplerResultCache.from, samplerResultCache.fromRatio, samplerResultCache.to, samplerResultCache.toRatio) : this._curve.valueAt(index), 
                this._setValue(value, weight));
            }
        }, {
            key: "_setValue",
            value: function _setValue(value, weight) {
                if (!this._blendFunction || !this._blendTarget || this._blendTarget.refCount <= 1) switch (this._propertySpecialization) {
                  case PropertySpecialization.NodePosition:
                    this._rootTarget.setPosition(value);
                    break;

                  case PropertySpecialization.NodeRotation:
                    this._rootTarget.setRotation(value);
                    break;

                  case PropertySpecialization.NodeScale:
                    this._rootTarget.setScale(value);
                    break;

                  default:
                    this._boundTarget.setValue(value);
                } else this._blendTarget.value = this._blendFunction(value, weight, this._blendTarget), 
                this._blendTarget.weight += weight;
            }
        }, {
            key: "propertyName",
            get: function get() {
                return this._rootTargetProperty || "";
            }
        }, {
            key: "curveDetail",
            get: function get() {
                return this._curveDetail;
            }
        } ]), ICurveInstance;
    }();
    var AnimationState = function(_Playable) {
        function AnimationState(clip) {
            var _this, name = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
            return _classCallCheck(this, AnimationState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AnimationState).call(this))).duration = 1, 
            _this.speed = 1, _this.time = 0, _this.weight = 0, _this.frameRate = 0, _this._lastframeEventOn = !1, 
            _this._wrapMode = WrapMode$2.Normal, _this._repeatCount = 1, _this._currentFramePlayed = !1, 
            _this._delay = 0, _this._delayTime = 0, _this._wrappedInfo = new WrappedInfo, _this._lastWrapInfo = null, 
            _this._lastWrapInfoEvent = null, _this._process = _this.process, _this._target = null, 
            _this._targetNode = null, _this._samplerSharedGroups = [], _this._commonTargetStatuses = [], 
            _this._curveLoaded = !1, _this._ignoreIndex = -1, _this._clip = clip, _this._name = name || clip && clip.name, 
            _this;
        }
        return _inherits(AnimationState, _Playable), _createClass(AnimationState, [ {
            key: "clip",
            get: function get() {
                return this._clip;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "length",
            get: function get() {
                return this.duration;
            }
        }, {
            key: "wrapMode",
            get: function get() {
                return this._wrapMode;
            },
            set: function set(value) {
                this._wrapMode = value, this.time = 0, value & WrapModeMask.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1;
            }
        }, {
            key: "repeatCount",
            get: function get() {
                return this._repeatCount;
            },
            set: function set(value) {
                this._repeatCount = value;
                var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap, reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;
                this._process = value !== 1 / 0 || shouldWrap || reverse ? this.process : this.simpleProcess;
            }
        }, {
            key: "delay",
            get: function get() {
                return this._delay;
            },
            set: function set(value) {
                this._delayTime = this._delay = value;
            }
        } ]), _createClass(AnimationState, [ {
            key: "initialize",
            value: function initialize(root, propertyCurves) {
                var _this2 = this;
                if (!this._curveLoaded) {
                    this._curveLoaded = !0, this._samplerSharedGroups.length = 0, this._targetNode = root;
                    var clip = this._clip;
                    this.duration = clip.duration, this.speed = clip.speed, this.wrapMode = clip.wrapMode, 
                    this.frameRate = clip.sample, (this.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1, 
                    this._commonTargetStatuses = clip.commonTargets.map((function(commonTarget, index) {
                        return {
                            target: new BufferedTarget(root, commonTarget.modifiers, commonTarget.valueAdapter),
                            changed: !1
                        };
                    })), propertyCurves || (propertyCurves = clip.getPropertyCurves());
                    for (var _loop = function _loop(iPropertyCurve) {
                        var propertyCurve = propertyCurves[iPropertyCurve], samplerSharedGroup = _this2._samplerSharedGroups.find((function(value) {
                            return value.sampler === propertyCurve.sampler;
                        }));
                        samplerSharedGroup || (samplerSharedGroup = function makeSamplerSharedGroup(sampler) {
                            return {
                                sampler: sampler,
                                curves: [],
                                samplerResultCache: {
                                    from: 0,
                                    fromRatio: 0,
                                    to: 0,
                                    toRatio: 0
                                }
                            };
                        }(propertyCurve.sampler), _this2._samplerSharedGroups.push(samplerSharedGroup));
                        try {
                            var curveInstance = new ICurveInstance(propertyCurve, "number" == typeof propertyCurve.commonTarget ? _this2._commonTargetStatuses[propertyCurve.commonTarget].target.peek() : root);
                            curveInstance.commonTargetIndex = propertyCurve.commonTarget, samplerSharedGroup.curves.push(curveInstance);
                        } catch (err) {}
                    }, iPropertyCurve = 0; iPropertyCurve < propertyCurves.length; ++iPropertyCurve) _loop(iPropertyCurve);
                }
            }
        }, {
            key: "_emit",
            value: function _emit(type, state) {
                this._target && this._target.isValid && this._target.emit(type, type, state);
            }
        }, {
            key: "emit",
            value: function emit() {
                for (var args = new Array(arguments.length), i = 0, l = args.length; i < l; i++) args[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                cc.director.getAnimationManager().pushDelayEvent(this, "_emit", args);
            }
        }, {
            key: "on",
            value: function on(type, callback, target) {
                return this._target && this._target.isValid ? ("lastframe" === type && (this._lastframeEventOn = !0), 
                this._target.on(type, callback, target)) : null;
            }
        }, {
            key: "once",
            value: function once(type, callback, target) {
                var _this3 = this;
                return this._target && this._target.isValid ? ("lastframe" === type && (this._lastframeEventOn = !0), 
                this._target.once(type, (function(event) {
                    callback.call(target, event), _this3._lastframeEventOn = !1;
                }))) : null;
            }
        }, {
            key: "off",
            value: function off(type, callback, target) {
                this._target && this._target.isValid && ("lastframe" === type && (this._target.hasEventListener(type) || (this._lastframeEventOn = !1)), 
                this._target.off(type, callback, target));
            }
        }, {
            key: "_setEventTarget",
            value: function _setEventTarget(target) {
                this._target = target;
            }
        }, {
            key: "setTime",
            value: function setTime(time) {
                this._currentFramePlayed = !1, this.time = time || 0, this._lastWrapInfoEvent = null, 
                this._ignoreIndex = -1;
                var info = this.getWrappedInfo(time, this._wrappedInfo), direction = info.direction, frameIndex = this._clip.getEventGroupIndexAtRatio(info.ratio);
                frameIndex < 0 && (frameIndex = ~frameIndex - 1, direction < 0 && (frameIndex += 1), 
                this._ignoreIndex = frameIndex);
            }
        }, {
            key: "update",
            value: function update(delta) {
                this._delayTime > 0 && (this._delayTime -= delta, this._delayTime > 0) || (this._currentFramePlayed ? this.time += delta * this.speed : this._currentFramePlayed = !0, 
                this._process());
            }
        }, {
            key: "_needReverse",
            value: function _needReverse(currentIterations) {
                var wrapMode = this.wrapMode, needReverse = !1;
                (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong && (currentIterations - (0 | currentIterations) == 0 && currentIterations > 0 && (currentIterations -= 1), 
                1 & currentIterations && (needReverse = !needReverse));
                return (wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse && (needReverse = !needReverse), 
                needReverse;
            }
        }, {
            key: "getWrappedInfo",
            value: function getWrappedInfo(time, info) {
                info = info || new WrappedInfo;
                var stopped = !1, duration = this.duration, repeatCount = this.repeatCount, currentIterations = time > 0 ? time / duration : -time / duration;
                if (currentIterations >= repeatCount) {
                    currentIterations = repeatCount, stopped = !0;
                    var tempRatio = repeatCount - (0 | repeatCount);
                    0 === tempRatio && (tempRatio = 1), time = tempRatio * duration * (time > 0 ? 1 : -1);
                }
                if (time > duration) {
                    var tempTime = time % duration;
                    time = 0 === tempTime ? duration : tempTime;
                } else time < 0 && 0 !== (time %= duration) && (time += duration);
                var needReverse = !1, shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
                shouldWrap && (needReverse = this._needReverse(currentIterations));
                var direction = needReverse ? -1 : 1;
                return this.speed < 0 && (direction *= -1), shouldWrap && needReverse && (time = duration - time), 
                info.ratio = time / duration, info.time = time, info.direction = direction, info.stopped = stopped, 
                info.iterations = currentIterations, info;
            }
        }, {
            key: "sample",
            value: function sample() {
                var info = this.getWrappedInfo(this.time, this._wrappedInfo);
                return this._sampleCurves(info.ratio), this._sampleEvents(info), info;
            }
        }, {
            key: "process",
            value: function process() {
                var lastInfo, info = this.sample();
                this._lastframeEventOn && (lastInfo = this._lastWrapInfo ? this._lastWrapInfo : this._lastWrapInfo = new WrappedInfo(info), 
                this.repeatCount > 1 && (0 | info.iterations) > (0 | lastInfo.iterations) && this.emit("lastframe", this), 
                lastInfo.set(info));
                info.stopped && (this.stop(), this.emit("finished", this));
            }
        }, {
            key: "simpleProcess",
            value: function simpleProcess() {
                var duration = this.duration, time = this.time % duration;
                time < 0 && (time += duration);
                var ratio = time / duration;
                this._sampleCurves(ratio), this._clip.hasEvents() && this._sampleEvents(this.getWrappedInfo(this.time, this._wrappedInfo)), 
                this._lastframeEventOn && (void 0 === this._lastIterations && (this._lastIterations = ratio), 
                (this.time > 0 && this._lastIterations > ratio || this.time < 0 && this._lastIterations < ratio) && this.emit("lastframe", this), 
                this._lastIterations = ratio);
            }
        }, {
            key: "attachToBlendState",
            value: function attachToBlendState(blendState) {
                var _iterator = this._samplerSharedGroups, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var _iterator2 = _ref.curves, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        _ref2.attachToBlendState(blendState);
                    }
                }
            }
        }, {
            key: "detachFromBlendState",
            value: function detachFromBlendState(blendState) {
                var _iterator3 = this._samplerSharedGroups, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var _iterator4 = _ref3.curves, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref4 = _i4.value;
                        }
                        _ref4.detachFromBlendState(blendState);
                    }
                }
            }
        }, {
            key: "cache",
            value: function cache(frames) {}
        }, {
            key: "onPlay",
            value: function onPlay() {
                this.setTime(0), this._delayTime = this._delay, cc.director.getAnimationManager().addAnimation(this), 
                this.emit("play", this);
            }
        }, {
            key: "onStop",
            value: function onStop() {
                this.isPaused || cc.director.getAnimationManager().removeAnimation(this), this.emit("stop", this);
            }
        }, {
            key: "onResume",
            value: function onResume() {
                cc.director.getAnimationManager().addAnimation(this), this.emit("resume", this);
            }
        }, {
            key: "onPause",
            value: function onPause() {
                cc.director.getAnimationManager().removeAnimation(this), this.emit("pause", this);
            }
        }, {
            key: "_sampleCurves",
            value: function _sampleCurves(ratio) {
                for (var iCommonTarget = 0; iCommonTarget < this._commonTargetStatuses.length; ++iCommonTarget) {
                    var commonTarget = this._commonTargetStatuses[iCommonTarget];
                    commonTarget.target.pull(), commonTarget.changed = !1;
                }
                for (var iSamplerSharedGroup = 0, szSamplerSharedGroup = this._samplerSharedGroups.length; iSamplerSharedGroup < szSamplerSharedGroup; ++iSamplerSharedGroup) {
                    var samplerSharedGroup = this._samplerSharedGroups[iSamplerSharedGroup], sampler = samplerSharedGroup.sampler, samplerResultCache = samplerSharedGroup.samplerResultCache, index = 0, lerpRequired = !1;
                    sampler ? (index = sampler.sample(ratio)) < 0 && ((index = ~index) <= 0 ? index = 0 : index >= sampler.ratios.length ? index = sampler.ratios.length - 1 : (lerpRequired = !0, 
                    samplerResultCache.from = index - 1, samplerResultCache.fromRatio = sampler.ratios[samplerResultCache.from], 
                    samplerResultCache.to = index, samplerResultCache.toRatio = sampler.ratios[samplerResultCache.to])) : index = 0;
                    for (var iCurveInstance = 0, szCurves = samplerSharedGroup.curves.length; iCurveInstance < szCurves; ++iCurveInstance) {
                        var curveInstance = samplerSharedGroup.curves[iCurveInstance];
                        curveInstance.applySample(ratio, index, lerpRequired, samplerResultCache, this.weight), 
                        void 0 !== curveInstance.commonTargetIndex && (this._commonTargetStatuses[curveInstance.commonTargetIndex].changed = !0);
                    }
                }
                for (var _iCommonTarget = 0; _iCommonTarget < this._commonTargetStatuses.length; ++_iCommonTarget) {
                    var commonTargetStatus = this._commonTargetStatuses[_iCommonTarget];
                    commonTargetStatus.changed && commonTargetStatus.target.push();
                }
            }
        }, {
            key: "_sampleEvents",
            value: function _sampleEvents(wrapInfo) {
                var length = this._clip.eventGroups.length, direction = wrapInfo.direction, eventIndex = this._clip.getEventGroupIndexAtRatio(wrapInfo.ratio);
                if (eventIndex < 0 && (eventIndex = ~eventIndex - 1, direction < 0 && (eventIndex += 1)), 
                this._ignoreIndex !== eventIndex && (this._ignoreIndex = -1), wrapInfo.frameIndex = eventIndex, 
                !this._lastWrapInfoEvent) return this._fireEvent(eventIndex), void (this._lastWrapInfoEvent = new WrappedInfo(wrapInfo));
                var wrapMode = this.wrapMode, currentIterations = wrapIterations(wrapInfo.iterations), lastWrappedInfo = this._lastWrapInfoEvent, lastIterations = wrapIterations(lastWrappedInfo.iterations), lastIndex = lastWrappedInfo.frameIndex, lastDirection = lastWrappedInfo.direction, iterationsChanged = -1 !== lastIterations && currentIterations !== lastIterations;
                if (lastIndex === eventIndex && iterationsChanged && 1 === length) this._fireEvent(0); else if (lastIndex !== eventIndex || iterationsChanged) {
                    direction = lastDirection;
                    do {
                        if (lastIndex !== eventIndex) {
                            if (-1 === direction && 0 === lastIndex && eventIndex > 0 ? ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = length, 
                            lastIterations++) : 1 === direction && lastIndex === length - 1 && eventIndex < length - 1 && ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = -1, 
                            lastIterations++), lastIndex === eventIndex) break;
                            if (lastIterations > currentIterations) break;
                        }
                        lastIndex += direction, cc.director.getAnimationManager().pushDelayEvent(this, "_fireEvent", [ lastIndex ]);
                    } while (lastIndex !== eventIndex && lastIndex > -1 && lastIndex < length);
                }
                this._lastWrapInfoEvent.set(wrapInfo);
            }
        }, {
            key: "_fireEvent",
            value: function _fireEvent(index) {
                if (this._targetNode && this._targetNode.isValid) {
                    var eventGroups = this._clip.eventGroups;
                    if (!(index < 0 || index >= eventGroups.length || this._ignoreIndex === index)) {
                        var eventGroup = eventGroups[index], components = this._targetNode.components, _iterator5 = eventGroup.events, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i5 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i5++];
                            } else {
                                if ((_i5 = _iterator5.next()).done) break;
                                _ref5 = _i5.value;
                            }
                            var event = _ref5, functionName = event.functionName, _iterator6 = components, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                                var _ref6;
                                if (_isArray6) {
                                    if (_i6 >= _iterator6.length) break;
                                    _ref6 = _iterator6[_i6++];
                                } else {
                                    if ((_i6 = _iterator6.next()).done) break;
                                    _ref6 = _i6.value;
                                }
                                var component = _ref6, fx = component[functionName];
                                "function" == typeof fx && fx.apply(component, event.parameters);
                            }
                        }
                    }
                }
            }
        }, {
            key: "curveLoaded",
            get: function get() {
                return this._curveLoaded;
            }
        } ]), AnimationState;
    }(Playable);
    function wrapIterations(iterations) {
        return iterations - (0 | iterations) == 0 && (iterations -= 1), 0 | iterations;
    }
    cc.AnimationState = AnimationState;
    var _dec$11, _dec2$E, _dec3$p, _dec4$l, _dec5$j, _dec6$f, _dec7$c, _class$11, _class2$U, _descriptor$N, _descriptor2$C, _descriptor3$u, _class3$k, _temp$X, CrossFade = function(_Playable) {
        function CrossFade() {
            var _this;
            return _classCallCheck(this, CrossFade), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CrossFade).call(this)))._managedStates = [], 
            _this._fadings = [], _this;
        }
        return _inherits(CrossFade, _Playable), _createClass(CrossFade, [ {
            key: "update",
            value: function update(deltaTime) {
                if (this.isPlaying && !this.isPaused) {
                    for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                        var state = this._managedStates[iManagedState].state;
                        state && (state.weight = 0);
                    }
                    for (var absoluteWeight = 1, deadFadingBegin = this._fadings.length, iFading = 0; iFading < this._fadings.length; ++iFading) {
                        if (0 === absoluteWeight) {
                            deadFadingBegin = iFading;
                            break;
                        }
                        var fading = this._fadings[iFading];
                        fading.easeTime += deltaTime;
                        var relativeWeight = clamp01(fading.easeTime / fading.easeDuration), weight = relativeWeight * absoluteWeight;
                        absoluteWeight *= 1 - relativeWeight, fading.target.state && (fading.target.state.weight += weight);
                    }
                    if (deadFadingBegin !== this._fadings.length) {
                        for (var iDeadFading = deadFadingBegin; iDeadFading < this._fadings.length; ++iDeadFading) {
                            var deadFading = this._fadings[iDeadFading];
                            --deadFading.target.reference, deadFading.target.reference <= 0 && (deadFading.target.state && deadFading.target.state.stop(), 
                            remove(this._managedStates, deadFading.target));
                        }
                        this._fadings.splice(deadFadingBegin);
                    }
                }
            }
        }, {
            key: "crossFade",
            value: function crossFade(state, duration) {
                0 === duration && this.clear();
                var target = this._managedStates.find((function(weightedState) {
                    return weightedState.state === state;
                }));
                target || (target = {
                    state: state,
                    reference: 0
                }, state && state.play(), this._managedStates.push(target)), ++target.reference, 
                this._fadings.unshift({
                    easeDuration: duration,
                    easeTime: 0,
                    target: target
                });
            }
        }, {
            key: "clear",
            value: function clear() {
                for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                    var state = this._managedStates[iManagedState].state;
                    state && state.stop();
                }
                this._managedStates.length = 0, this._fadings.length = 0;
            }
        }, {
            key: "onPlay",
            value: function onPlay() {
                _get(_getPrototypeOf(CrossFade.prototype), "onPlay", this).call(this), cc.director.getAnimationManager().addCrossFade(this);
            }
        }, {
            key: "onPause",
            value: function onPause() {
                _get(_getPrototypeOf(CrossFade.prototype), "onPause", this).call(this), cc.director.getAnimationManager().removeCrossFade(this);
                for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                    var state = this._managedStates[iManagedState].state;
                    state && state.pause();
                }
            }
        }, {
            key: "onResume",
            value: function onResume() {
                _get(_getPrototypeOf(CrossFade.prototype), "onResume", this).call(this), cc.director.getAnimationManager().addCrossFade(this);
                for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                    var state = this._managedStates[iManagedState].state;
                    state && state.resume();
                }
            }
        }, {
            key: "onStop",
            value: function onStop() {
                _get(_getPrototypeOf(CrossFade.prototype), "onStop", this).call(this), cc.director.getAnimationManager().removeCrossFade(this), 
                this.clear();
            }
        } ]), CrossFade;
    }(Playable);
    !function(EventType) {
        EventType.PLAY = "play", EventType.STOP = "stop", EventType.PAUSE = "pause", EventType.RESUME = "resume", 
        EventType.LASTFRAME = "lastframe", EventType.FINISHED = "finished";
    }(exports.EventType || (exports.EventType = {})), ccenum(exports.EventType);
    var AnimationComponent = (_dec$11 = ccclass("cc.AnimationComponent"), _dec2$E = executionOrder(99), 
    _dec3$p = menu("Components/Animation"), _dec4$l = property({
        type: [ AnimationClip ],
        tooltip: "此动画组件的自有动画剪辑"
    }), _dec5$j = property({
        type: AnimationClip,
        tooltip: "默认动画剪辑"
    }), _dec6$f = property({
        tooltip: "是否在动画组件开始运行时自动播放默认动画剪辑"
    }), _dec7$c = property({
        type: [ AnimationClip ]
    }), _dec$11(_class$11 = _dec2$E(_class$11 = executeInEditMode(_class$11 = _dec3$p((_temp$X = _class3$k = function(_Component) {
        function AnimationComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, AnimationComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "playOnLoad", _descriptor$N, _assertThisInitialized(_this)), 
            _this._callbackTable = createMap(!0), _this._crossFade = new CrossFade, _this._nameToState = createMap(!0), 
            _initializerDefineProperty(_this, "_clips", _descriptor2$C, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_defaultClip", _descriptor3$u, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(AnimationComponent, _Component), _createClass(AnimationComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this.clips = this._clips;
                for (var _i = 0, _Object$keys = Object.keys(this._nameToState); _i < _Object$keys.length; _i++) {
                    var stateName = _Object$keys[_i];
                    this._nameToState[stateName].initialize(this.node);
                }
            }
        }, {
            key: "start",
            value: function start() {
                this.playOnLoad && this._defaultClip && this.crossFade(this._defaultClip.name, 0);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._crossFade.resume();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._crossFade.pause();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._crossFade.stop();
                for (var _i2 = 0, _Object$keys2 = Object.keys(this._nameToState); _i2 < _Object$keys2.length; _i2++) {
                    var _name = _Object$keys2[_i2];
                    this._nameToState[_name].stop();
                }
                this._nameToState = createMap(!0);
            }
        }, {
            key: "play",
            value: function play(name) {
                if (!name) {
                    if (!this._defaultClip) return;
                    name = this._defaultClip.name;
                }
                this.crossFade(name, 0);
            }
        }, {
            key: "crossFade",
            value: function crossFade(name) {
                var duration = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .3, state = this._nameToState[name];
                state && (this._crossFade.play(), this._crossFade.crossFade(state, duration));
            }
        }, {
            key: "pause",
            value: function pause() {
                this._crossFade.pause();
            }
        }, {
            key: "resume",
            value: function resume() {
                this._crossFade.resume();
            }
        }, {
            key: "stop",
            value: function stop() {
                this._crossFade.stop();
            }
        }, {
            key: "getAnimationState",
            value: function getAnimationState(name) {
                return this.getState(name);
            }
        }, {
            key: "getState",
            value: function getState(name) {
                var state = this._nameToState[name];
                return state && !state.curveLoaded && state.initialize(this.node), state || null;
            }
        }, {
            key: "createState",
            value: function createState(clip, name) {
                return name = name || clip.name, this.removeState(name), this._doCreateState(clip, name);
            }
        }, {
            key: "removeState",
            value: function removeState(name) {
                var state = this._nameToState[name];
                state && (state.stop(), delete this._nameToState[name]);
            }
        }, {
            key: "addClip",
            value: function addClip(clip, name) {
                return contains(this._clips, clip) || this._clips.push(clip), this.createState(clip, name);
            }
        }, {
            key: "removeClip",
            value: function removeClip(clip, force) {
                for (var state, _i3 = 0, _Object$keys3 = Object.keys(this._nameToState); _i3 < _Object$keys3.length; _i3++) {
                    var _name2 = _Object$keys3[_i3];
                    if ((state = this._nameToState[_name2]).clip === clip) break;
                }
                if (clip === this._defaultClip) {
                    if (!force) return void warnID(3902);
                    this._defaultClip = null;
                }
                if (state && state.isPlaying) {
                    if (!force) return void warnID(3903);
                    state.stop();
                }
                this._clips = this._clips.filter((function(item) {
                    return item !== clip;
                })), state && delete this._nameToState[state.name];
            }
        }, {
            key: "on",
            value: function on(type, callback, target) {
                var ret = EventTarget.prototype.on.call(this, type, callback, target);
                if ("lastframe" === type) for (var _i4 = 0, _Object$keys4 = Object.keys(this._nameToState); _i4 < _Object$keys4.length; _i4++) {
                    var stateName = _Object$keys4[_i4];
                    this._nameToState[stateName]._lastframeEventOn = !0;
                }
                return ret;
            }
        }, {
            key: "off",
            value: function off(type, callback, target) {
                if ("lastframe" === type) for (var nameToState = this._nameToState, _i5 = 0, _Object$keys5 = Object.keys(nameToState); _i5 < _Object$keys5.length; _i5++) {
                    nameToState[_Object$keys5[_i5]]._lastframeEventOn = !1;
                }
                EventTarget.prototype.off.call(this, type, callback, target);
            }
        }, {
            key: "targetOff",
            value: function targetOff(keyOrTarget) {}
        }, {
            key: "once",
            value: function once(type, callback, target) {}
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {}
        }, {
            key: "hasEventListener",
            value: function hasEventListener(key, callback, target) {
                return !1;
            }
        }, {
            key: "removeAll",
            value: function removeAll(keyOrTarget) {}
        }, {
            key: "emit",
            value: function emit(key) {}
        }, {
            key: "_createState",
            value: function _createState(clip, name) {
                return new AnimationState(clip, name);
            }
        }, {
            key: "_doCreateState",
            value: function _doCreateState(clip, name) {
                var state = this._createState(clip, name);
                return state._setEventTarget(this), this.node && state.initialize(this.node), this._nameToState[state.name] = state, 
                state;
            }
        }, {
            key: "_getStateByNameOrDefaultClip",
            value: function _getStateByNameOrDefaultClip(name) {
                if (!name) {
                    if (!this._defaultClip) return null;
                    name = this._defaultClip.name;
                }
                var state = this._nameToState[name];
                return state || null;
            }
        }, {
            key: "_removeStateOfAutomaticClip",
            value: function _removeStateOfAutomaticClip(clip) {
                for (var _name4 in this._nameToState) {
                    var _state4 = this._nameToState[_name4];
                    equalClips(clip, _state4.clip) && (_state4.stop(), delete this._nameToState[_name4]);
                }
            }
        }, {
            key: "clips",
            get: function get() {
                return this._clips;
            },
            set: function set(value) {
                var _this2 = this;
                this._crossFade && this._crossFade.clear();
                var _iterator = this._clips, _isArray = Array.isArray(_iterator), _i6 = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i6 >= _iterator.length) break;
                        _ref = _iterator[_i6++];
                    } else {
                        if ((_i6 = _iterator.next()).done) break;
                        _ref = _i6.value;
                    }
                    var clip = _ref;
                    clip && this._removeStateOfAutomaticClip(clip);
                }
                var _iterator2 = value, _isArray2 = Array.isArray(_iterator2), _i7 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i7 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i7++];
                    } else {
                        if ((_i7 = _iterator2.next()).done) break;
                        _ref2 = _i7.value;
                    }
                    var _clip = _ref2;
                    _clip && this.createState(_clip);
                }
                var newDefaultClip = value.find((function(clip) {
                    return equalClips(clip, _this2._defaultClip);
                }));
                this._defaultClip = newDefaultClip || null, this._clips = value;
            }
        }, {
            key: "defaultClip",
            get: function get() {
                return this._defaultClip;
            },
            set: function set(value) {
                (this._defaultClip = value, value) && (this._clips.findIndex((function(clip) {
                    return equalClips(clip, value);
                })) >= 0 || (this._clips.push(value), this.createState(value)));
            }
        } ]), AnimationComponent;
    }(Component), _class3$k.EventType = exports.EventType, _applyDecoratedDescriptor((_class2$U = _temp$X).prototype, "clips", [ _dec4$l ], Object.getOwnPropertyDescriptor(_class2$U.prototype, "clips"), _class2$U.prototype), 
    _applyDecoratedDescriptor(_class2$U.prototype, "defaultClip", [ _dec5$j ], Object.getOwnPropertyDescriptor(_class2$U.prototype, "defaultClip"), _class2$U.prototype), 
    _descriptor$N = _applyDecoratedDescriptor(_class2$U.prototype, "playOnLoad", [ _dec6$f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$C = _applyDecoratedDescriptor(_class2$U.prototype, "_clips", [ _dec7$c ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor3$u = _applyDecoratedDescriptor(_class2$U.prototype, "_defaultClip", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$11 = _class2$U)) || _class$11) || _class$11) || _class$11) || _class$11), _AnimationComponent$p = AnimationComponent.prototype, on = _AnimationComponent$p.on, off = _AnimationComponent$p.off;
    function equalClips(clip1, clip2) {
        return clip1 === clip2 || !(!clip1 || !clip2 || clip1.name !== clip2.name && clip1._uuid !== clip2._uuid);
    }
    applyMixins(AnimationComponent, [ CallbacksInvoker, EventTarget ]), AnimationComponent.prototype.on = on, 
    AnimationComponent.prototype.off = off, cc.AnimationComponent = AnimationComponent, 
    exports.replaceProperty(AnimationComponent.prototype, "AnimationComponent", [ {
        name: "getAnimationState",
        newName: "getState"
    }, {
        name: "removeClip",
        newName: "removeState",
        customFunction: function customFunction() {
            var arg0 = arguments.length <= 0 ? void 0 : arguments[0];
            return AnimationComponent.prototype.removeState.call(this, arg0.name);
        }
    } ]);
    var _class$12, _class2$V, _temp$Y, AnimationBlendState = function() {
        function AnimationBlendState() {
            _classCallCheck(this, AnimationBlendState), this._blendTargets = [];
        }
        return _createClass(AnimationBlendState, [ {
            key: "refPropertyBlendTarget",
            value: function refPropertyBlendTarget(target, property) {
                var targetState = this._blendTargets.find((function(x) {
                    return x.target === target;
                }));
                targetState || (targetState = {
                    target: target,
                    properties: []
                }, this._blendTargets.push(targetState));
                var propertyStates = targetState.properties, propertyState = propertyStates.find((function(p) {
                    return p.name === property;
                }));
                return propertyState || (propertyState = {
                    name: property,
                    weight: 0,
                    value: void 0,
                    refCount: 0
                }, propertyStates.push(propertyState)), ++propertyState.refCount, propertyState;
            }
        }, {
            key: "deRefPropertyBlendTarget",
            value: function deRefPropertyBlendTarget(target, property) {
                var iTargetState = this._blendTargets.findIndex((function(x) {
                    return x.target === target;
                }));
                if (!(iTargetState < 0)) {
                    var propertyStates = this._blendTargets[iTargetState].properties, iPropertyState = propertyStates.findIndex((function(p) {
                        return p.name === property;
                    }));
                    if (!(iPropertyState < 0)) {
                        var propertyState = propertyStates[iPropertyState];
                        --propertyState.refCount, propertyState.refCount > 0 || (propertyStates.length >= 2 ? propertyStates.splice(iPropertyState, 1) : this._blendTargets.splice(iTargetState, 1));
                    }
                }
            }
        }, {
            key: "apply",
            value: function apply() {
                for (var targets = this._blendTargets, i = 0; i < targets.length; i++) for (var targetState = targets[i], target = targetState.target, propertyStates = targetState.properties, j = 0; j < propertyStates.length; j++) {
                    var p = propertyStates[j];
                    0 !== p.weight && (target instanceof Node$1 ? "position" === p.name ? target.setPosition(p.value) : "rotation" === p.name ? target.setRotation(p.value) : target.setScale(p.value) : target[p.name] = p.value);
                }
            }
        }, {
            key: "clear",
            value: function clear() {
                for (var targets = this._blendTargets, i = 0; i < targets.length; i++) {
                    var _iterator = targets[i].properties, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        _ref.weight = 0;
                    }
                }
            }
        } ]), AnimationBlendState;
    }(), AnimationManager = ccclass((_temp$Y = _class2$V = function(_System) {
        function AnimationManager() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, AnimationManager);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationManager)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._anims = new MutableForwardIterator([]), 
            _this._delayEvents = [], _this._blendState = new AnimationBlendState, _this._crossFades = [], 
            _this;
        }
        return _inherits(AnimationManager, _System), _createClass(AnimationManager, [ {
            key: "addCrossFade",
            value: function addCrossFade(crossFade) {
                this._crossFades.push(crossFade);
            }
        }, {
            key: "removeCrossFade",
            value: function removeCrossFade(crossFade) {
                remove(this._crossFades, crossFade);
            }
        }, {
            key: "update",
            value: function update(dt) {
                var _iterator = this._crossFades, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.update(dt);
                }
                this._blendState.clear();
                var iterator = this._anims, array = iterator.array;
                for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                    var anim = array[iterator.i];
                    anim.isPlaying && !anim.isPaused && anim.update(dt);
                }
                this._blendState.apply();
                for (var events = this._delayEvents, i = 0, l = events.length; i < l; i++) {
                    var event = events[i];
                    event.target[event.func].apply(event.target, event.args);
                }
                events.length = 0;
            }
        }, {
            key: "destruct",
            value: function destruct() {}
        }, {
            key: "addAnimation",
            value: function addAnimation(anim) {
                -1 === this._anims.array.indexOf(anim) && (anim.attachToBlendState(this._blendState), 
                this._anims.push(anim));
            }
        }, {
            key: "removeAnimation",
            value: function removeAnimation(anim) {
                var index = this._anims.array.indexOf(anim);
                index >= 0 ? (anim.detachFromBlendState(this._blendState), this._anims.fastRemoveAt(index)) : errorID(3907);
            }
        }, {
            key: "pushDelayEvent",
            value: function pushDelayEvent(target, func, args) {
                this._delayEvents.push({
                    target: target,
                    func: func,
                    args: args
                });
            }
        }, {
            key: "blendState",
            get: function get() {
                return this._blendState;
            }
        } ]), AnimationManager;
    }(System), _class2$V.ID = "animation", _class$12 = _temp$Y)) || _class$12;
    director.on(Director.EVENT_INIT, (function() {
        var animationManager = new AnimationManager;
        director.registerSystem(AnimationManager.ID, animationManager, Scheduler.PRIORITY_SYSTEM);
    })), cc.AnimationManager = AnimationManager;
    var m4_1$3 = new Mat4;
    function getWorldTransformUntilRoot(target, root, outMatrix) {
        for (Mat4.identity(outMatrix); target !== root; ) Mat4.fromRTS(m4_1$3, target.rotation, target.position, target.scale), 
        Mat4.multiply(outMatrix, m4_1$3, outMatrix), target = target.parent;
    }
    var _dec$12, _dec2$F, _class$13, _class2$W, _descriptor$O, _descriptor2$D, _dec3$q, _dec4$m, _dec5$k, _dec6$g, _dec7$d, _class4$7, _class5$7, _descriptor3$v, _class6, _temp2$7, m4_1$4 = new Mat4, _defaultCurves = [], SkeletalAnimationState = function(_AnimationState) {
        function SkeletalAnimationState(clip) {
            var _this, name = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", preSample = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            return _classCallCheck(this, SkeletalAnimationState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SkeletalAnimationState).call(this, clip, name)))._preSample = !0, 
            _this._frames = 1, _this._animInfo = null, _this._sockets = [], _this._preSample = preSample, 
            _this;
        }
        return _inherits(SkeletalAnimationState, _AnimationState), _createClass(SkeletalAnimationState, [ {
            key: "initialize",
            value: function initialize(root) {
                if (!this._curveLoaded) if (this._preSample) {
                    var info = SkelAnimDataHub.getOrExtract(this.clip).info;
                    _get(_getPrototypeOf(SkeletalAnimationState.prototype), "initialize", this).call(this, root, _defaultCurves), 
                    this._frames = info.frames - 1, this._animInfo = cc.director.root.dataPoolManager.jointsAnimationInfo.create(root.uuid), 
                    this.duration = this._frames / info.sample;
                } else _get(_getPrototypeOf(SkeletalAnimationState.prototype), "initialize", this).call(this, root);
            }
        }, {
            key: "onPlay",
            value: function onPlay() {
                _get(_getPrototypeOf(SkeletalAnimationState.prototype), "onPlay", this).call(this);
                for (var comps = this._targetNode.getComponentsInChildren(SkinningModelComponent), i = 0; i < comps.length; ++i) {
                    var comp = comps[i];
                    comp.skinningRoot === this._targetNode && comp.uploadAnimation(this.clip);
                }
            }
        }, {
            key: "rebuildSocketCurves",
            value: function rebuildSocketCurves(sockets) {
                this._sockets.length = 0;
                for (var i = 0; i < sockets.length; ++i) {
                    var socket = this._buildSocketData(sockets[i]);
                    socket && this._sockets.push(socket);
                }
            }
        }, {
            key: "_sampleCurves",
            value: function _sampleCurves(ratio) {
                var info = this._animInfo, curFrame = ratio * this._frames + .5 | 0;
                info.data[1] = curFrame, info.dirty = !0;
                for (var i = 0; i < this._sockets.length; ++i) {
                    var _this$_sockets$i = this._sockets[i], target = _this$_sockets$i.target, frames = _this$_sockets$i.frames;
                    target.matrix = frames[curFrame];
                }
            }
        }, {
            key: "_buildSocketData",
            value: function _buildSocketData(socket) {
                if (!this._targetNode) return null;
                var targetNode = this._targetNode.getChildByPath(socket.path);
                if (!targetNode || !socket.target) return null;
                for (var targetPath = socket.path, sourceData = SkelAnimDataHub.getOrExtract(this.clip).data, animPath = targetPath, source = sourceData[animPath], animNode = targetNode; !source; ) {
                    var idx = animPath.lastIndexOf("/");
                    if (source = sourceData[animPath = animPath.substring(0, idx)], animNode = animNode.parent, 
                    idx < 0) return null;
                }
                var socketData = {
                    target: socket.target,
                    frames: source.worldMatrix.values.map((function(v) {
                        return v.clone();
                    }))
                };
                getWorldTransformUntilRoot(targetNode, animNode, m4_1$4);
                for (var i = 0; i < socketData.frames.length; i++) {
                    var m = socketData.frames[i];
                    Mat4.multiply(m, m, m4_1$4);
                }
                return socketData;
            }
        } ]), SkeletalAnimationState;
    }(AnimationState);
    cc.SkeletalAnimationState = SkeletalAnimationState;
    var Socket = (_dec$12 = ccclass("cc.SkeletalAnimationComponent.Socket"), _dec2$F = property(Node$1), 
    _dec$12((_descriptor$O = _applyDecoratedDescriptor((_class2$W = function Socket() {
        var path = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", target = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        _classCallCheck(this, Socket), _initializerDefineProperty(this, "path", _descriptor$O, this), 
        _initializerDefineProperty(this, "target", _descriptor2$D, this), this.path = path, 
        this.target = target;
    }).prototype, "path", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor2$D = _applyDecoratedDescriptor(_class2$W.prototype, "target", [ _dec2$F ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$13 = _class2$W)) || _class$13), m4_1$5 = new Mat4, m4_2 = new Mat4;
    function collectRecursively(node) {
        for (var prefix = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", out = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            if (child) {
                var path = prefix ? "".concat(prefix, "/").concat(child.name) : child.name;
                out.push(path), collectRecursively(child, path, out);
            }
        }
        return out;
    }
    var _class$14, _class2$X, _class3$l, _class4$8, SkeletalAnimationComponent = (_dec3$q = ccclass("cc.SkeletalAnimationComponent"), 
    _dec4$m = executionOrder(99), _dec5$k = menu("Components/SkeletalAnimation"), _dec6$g = property({
        type: [ Socket ]
    }), _dec7$d = property({
        type: [ Socket ],
        tooltip: "Joint Sockets"
    }), _dec3$q(_class4$7 = _dec4$m(_class4$7 = executeInEditMode(_class4$7 = _dec5$k((_temp2$7 = _class6 = function(_AnimationComponent) {
        function SkeletalAnimationComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SkeletalAnimationComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SkeletalAnimationComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_sockets", _descriptor3$v, _assertThisInitialized(_this)), 
            _this._enablePreSample = !0, _this;
        }
        return _inherits(SkeletalAnimationComponent, _AnimationComponent), _createClass(SkeletalAnimationComponent, [ {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "onDestroy", this).call(this), 
                cc.director.root.dataPoolManager.jointsAnimationInfo.destroy(this.node.uuid);
            }
        }, {
            key: "start",
            value: function start() {
                _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "start", this).call(this), 
                this.sockets = this._sockets;
            }
        }, {
            key: "querySockets",
            value: function querySockets() {
                var animPaths = this._defaultClip && Object.keys(SkelAnimDataHub.getOrExtract(this._defaultClip).data).sort().reduce((function(acc, cur) {
                    return cur.startsWith(acc[acc.length - 1]) ? acc : (acc.push(cur), acc);
                }), []) || [];
                if (!animPaths.length) return [ "default animation clip missing/invalid" ];
                for (var out = [], i = 0; i < animPaths.length; i++) {
                    var path = animPaths[i], node = this.node.getChildByPath(path);
                    node && (out.push(path), collectRecursively(node, path, out));
                }
                return out;
            }
        }, {
            key: "rebuildSocketAnimations",
            value: function rebuildSocketAnimations() {
                var _iterator = this._sockets, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var socket = _ref, joint = this.node.getChildByPath(socket.path), target = socket.target;
                    joint && target && (target.name = "".concat(socket.path.substring(socket.path.lastIndexOf("/") + 1), " Socket"), 
                    target.parent = this.node, getWorldTransformUntilRoot(joint, this.node, m4_1$5), 
                    Mat4.fromRTS(m4_2, target.rotation, target.position, target.scale), Mat4.equals(m4_2, m4_1$5) || (target.matrix = m4_1$5));
                }
                for (var _i2 = 0, _Object$keys = Object.keys(this._nameToState); _i2 < _Object$keys.length; _i2++) {
                    var stateName = _Object$keys[_i2];
                    this._nameToState[stateName].rebuildSocketCurves(this._sockets);
                }
            }
        }, {
            key: "createSocket",
            value: function createSocket(path) {
                var socket = this._sockets.find((function(s) {
                    return s.path === path;
                }));
                if (socket) return socket.target;
                if (!this.node.getChildByPath(path)) return console.warn("illegal socket path"), 
                null;
                var target = new Node$1;
                return target.parent = this.node, this._sockets.push(new Socket(path, target)), 
                this.rebuildSocketAnimations(), target;
            }
        }, {
            key: "_createState",
            value: function _createState(clip, name) {
                return new SkeletalAnimationState(clip, name, this._enablePreSample);
            }
        }, {
            key: "_doCreateState",
            value: function _doCreateState(clip, name) {
                var state = _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "_doCreateState", this).call(this, clip, name);
                return state.rebuildSocketCurves(this._sockets), state;
            }
        }, {
            key: "sockets",
            get: function get() {
                return this._sockets;
            },
            set: function set(val) {
                this._sockets = val, this.rebuildSocketAnimations();
            }
        }, {
            key: "enablePreSample",
            set: function set(val) {
                this._enablePreSample = val, this.clips = this._clips;
            },
            get: function get() {
                return this._enablePreSample;
            }
        } ]), SkeletalAnimationComponent;
    }(AnimationComponent), _class6.Socket = Socket, _descriptor3$v = _applyDecoratedDescriptor((_class5$7 = _temp2$7).prototype, "_sockets", [ _dec6$g ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _applyDecoratedDescriptor(_class5$7.prototype, "sockets", [ _dec7$d ], Object.getOwnPropertyDescriptor(_class5$7.prototype, "sockets"), _class5$7.prototype), 
    _class4$7 = _class5$7)) || _class4$7) || _class4$7) || _class4$7) || _class4$7);
    cc.SkeletalAnimationComponent = SkeletalAnimationComponent, cc.easing = easing;
    var HierachyModifier = ccclass("cc.HierachyModifier")(_class$14 = function(_HierarchyPath) {
        function HierachyModifier() {
            return _classCallCheck(this, HierachyModifier), _possibleConstructorReturn(this, _getPrototypeOf(HierachyModifier).apply(this, arguments));
        }
        return _inherits(HierachyModifier, _HierarchyPath), HierachyModifier;
    }(HierarchyPath)) || _class$14;
    cc.HierachyModifier = HierachyModifier;
    var ComponentModifier = ccclass("cc.ComponentModifier")(_class2$X = function(_ComponentPath) {
        function ComponentModifier() {
            return _classCallCheck(this, ComponentModifier), _possibleConstructorReturn(this, _getPrototypeOf(ComponentModifier).apply(this, arguments));
        }
        return _inherits(ComponentModifier, _ComponentPath), ComponentModifier;
    }(ComponentPath)) || _class2$X;
    cc.ComponentModifier = ComponentModifier;
    var CurveValueAdapter = ccclass("cc.CurveValueAdapter")(_class3$l = function() {
        function CurveValueAdapter() {
            _classCallCheck(this, CurveValueAdapter);
        }
        return _createClass(CurveValueAdapter, [ {
            key: "forTarget",
            value: function forTarget(target) {
                return {
                    set: function set() {}
                };
            }
        } ]), CurveValueAdapter;
    }()) || _class3$l;
    cc.CurveValueAdapter = CurveValueAdapter;
    var UniformCurveValueAdapter = ccclass("cc.UniformCurveValueAdapter")(_class4$8 = function(_UniformProxyFactory) {
        function UniformCurveValueAdapter() {
            return _classCallCheck(this, UniformCurveValueAdapter), _possibleConstructorReturn(this, _getPrototypeOf(UniformCurveValueAdapter).apply(this, arguments));
        }
        return _inherits(UniformCurveValueAdapter, _UniformProxyFactory), UniformCurveValueAdapter;
    }(UniformProxyFactory)) || _class4$8;
    function isPropertyModifier(path) {
        return "string" == typeof path;
    }
    function isElementModifier(path) {
        return "number" == typeof path;
    }
    function isCustomTargetModifier(path, constructor) {
        return path instanceof constructor;
    }
    cc.UniformCurveValueAdapter = UniformCurveValueAdapter, cc.isPropertyModifier = isPropertyModifier, 
    cc.isElementModifier = isElementModifier, cc.isCustomTargetModifier = isCustomTargetModifier;
    var _class$15, Counter = function() {
        function Counter(id, opts, now) {
            _classCallCheck(this, Counter), this._total = 0, this._value = 0, this._averageValue = 0, 
            this._accumValue = 0, this._accumSamples = 0, this._id = id, this._opts = opts, 
            this._accumStart = now;
        }
        return _createClass(Counter, [ {
            key: "value",
            get: function get() {
                return this._value;
            },
            set: function set(val) {
                this._value = val;
            }
        } ]), _createClass(Counter, [ {
            key: "sample",
            value: function sample(now) {
                this._average(this._value, now);
            }
        }, {
            key: "human",
            value: function human() {
                var _this$_opts = this._opts, average = _this$_opts.average, isInteger = _this$_opts.isInteger, v = average ? this._averageValue : this._value;
                return isInteger ? Math.round(v) : Math.round(100 * v) / 100;
            }
        }, {
            key: "alarm",
            value: function alarm() {
                return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
            }
        }, {
            key: "_average",
            value: function _average(v) {
                var now = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                if (this._opts.average) {
                    this._accumValue += v, ++this._accumSamples;
                    var t = now;
                    t - this._accumStart >= this._opts.average && (this._averageValue = this._accumValue / this._accumSamples, 
                    this._accumValue = 0, this._accumStart = t, this._accumSamples = 0);
                }
            }
        } ]), Counter;
    }(), PerfCounter = ccclass("cc.PerfCounter")(_class$15 = function(_Counter) {
        function PerfCounter(id, opts, now) {
            var _this;
            return _classCallCheck(this, PerfCounter), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PerfCounter).call(this, id, opts, now)))._time = now, 
            _this;
        }
        return _inherits(PerfCounter, _Counter), _createClass(PerfCounter, [ {
            key: "start",
            value: function start() {
                var now = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                this._time = now;
            }
        }, {
            key: "end",
            value: function end() {
                var now = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                this._value = now - this._time, this._average(this._value);
            }
        }, {
            key: "tick",
            value: function tick() {
                this.end(), this.start();
            }
        }, {
            key: "frame",
            value: function frame(now) {
                var t = now, e = t - this._time;
                this._total++, e > (this._opts.average || 1e3) && (this._value = 1e3 * this._total / e, 
                this._total = 0, this._time = t, this._average(this._value));
            }
        } ]), PerfCounter;
    }(Counter)) || _class$15, _string2offset = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        ".": 10
    }, _profileInfo = {
        frame: {
            desc: "Frame time (ms)",
            min: 0,
            max: 50,
            average: 500
        },
        fps: {
            desc: "Framerate (FPS)",
            below: 30,
            average: 500,
            isInteger: !0
        },
        draws: {
            desc: "Draw call",
            isInteger: !0
        },
        tricount: {
            desc: "Triangle",
            isInteger: !0
        },
        logic: {
            desc: "Game Logic (ms)",
            min: 0,
            max: 50,
            average: 500,
            color: "#080"
        },
        physics: {
            desc: "Physics (ms)",
            min: 0,
            max: 50,
            average: 500
        },
        render: {
            desc: "Renderer (ms)",
            min: 0,
            max: 50,
            average: 500,
            color: "#f90"
        },
        textureMemory: {
            desc: "GFX Texture Mem(M)"
        },
        bufferMemory: {
            desc: "GFX Buffer Mem(M)"
        }
    }, _constants_fontSize = 24, _constants_quadHeight = .18, _constants_segmentsPerLine = 8, _constants_textureWidth = 256, _constants_textureHeight = 256, Profiler = function() {
        function Profiler() {
            _classCallCheck(this, Profiler), this._stats = null, this.id = "__Profiler__", this._showFPS = !1, 
            this._rootNode = null, this._device = null, this._canvas = null, this._ctx = null, 
            this._texture = null, this._textureView = null, this._region = new GFXBufferTextureCopy, 
            this._canvasArr = [], this._regionArr = [ this._region ], this.digitsData = null, 
            this._canvasDone = !1, this._statsDone = !1, this._inited = !1, this._lineHeight = _constants_textureHeight / (Object.keys(_profileInfo).length + 1), 
            this._wordHeight = 0, this._eachNumWidth = 0, this._totalLines = 0, this.lastTime = 0, 
            this._uvOffset = [], this._canvas = document.createElement("canvas"), this._ctx = this._canvas.getContext("2d"), 
            this._region = new GFXBufferTextureCopy, this._canvasArr.push(this._canvas);
        }
        return _createClass(Profiler, [ {
            key: "isShowingStats",
            value: function isShowingStats() {
                return this._showFPS;
            }
        }, {
            key: "hideStats",
            value: function hideStats() {
                this._showFPS && (this._rootNode && (this._rootNode.active = !1), cc.director.off(cc.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), 
                cc.director.off(cc.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), cc.director.off(cc.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), 
                cc.director.off(cc.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), cc.director.off(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), 
                cc.director.off(cc.Director.EVENT_AFTER_DRAW, this.afterDraw, this), this._showFPS = !1);
            }
        }, {
            key: "showStats",
            value: function showStats() {
                this._showFPS || (this.initDevice(), this.generateCanvas(), this.generateStats(), 
                cc.game.once(cc.Game.EVENT_ENGINE_INITED, this.generateNode, this), this._rootNode && (this._rootNode.active = !0), 
                cc.director.on(cc.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), cc.director.on(cc.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), 
                cc.director.on(cc.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), cc.director.on(cc.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), 
                cc.director.on(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), cc.director.on(cc.Director.EVENT_AFTER_DRAW, this.afterDraw, this), 
                this._showFPS = !0, this._canvasDone = !0, this._statsDone = !0);
            }
        }, {
            key: "initDevice",
            value: function initDevice() {
                this._device || (this._device = cc.director.root.device);
            }
        }, {
            key: "generateCanvas",
            value: function generateCanvas() {
                if (!this._canvasDone) {
                    var textureWidth = _constants_textureWidth, textureHeight = _constants_textureHeight;
                    this._ctx && this._canvas && (this._canvas.width = textureWidth, this._canvas.height = textureHeight, 
                    this._canvas.style.width = "".concat(this._canvas.width), this._canvas.style.height = "".concat(this._canvas.height), 
                    this._ctx.font = "".concat(_constants_fontSize, "px Arial"), this._ctx.textBaseline = "top", 
                    this._ctx.fillStyle = "#fff", this._texture = this._device.createTexture({
                        type: exports.GFXTextureType.TEX2D,
                        usage: exports.GFXTextureUsageBit.SAMPLED,
                        format: exports.GFXFormat.RGBA8,
                        width: textureWidth,
                        height: textureHeight,
                        mipLevel: 1
                    }), this._textureView = this._device.createTextureView({
                        texture: this._texture,
                        type: exports.GFXTextureViewType.TV2D,
                        format: exports.GFXFormat.RGBA8
                    }), this._region.texExtent.width = textureWidth, this._region.texExtent.height = textureHeight);
                }
            }
        }, {
            key: "generateStats",
            value: function generateStats() {
                if (!this._statsDone && this._ctx && this._canvas) {
                    this._stats = null;
                    var now = performance.now();
                    this._ctx.textAlign = "left";
                    var i = 0;
                    for (var id in _profileInfo) {
                        var element = _profileInfo[id];
                        this._ctx.fillText(element.desc, 0, i * this._lineHeight), element.counter = new PerfCounter(id, element, now), 
                        i++;
                    }
                    this._totalLines = i, this._wordHeight = this._totalLines * this._lineHeight / this._canvas.height;
                    var offsets = new Array;
                    offsets[0] = 0;
                    for (var j = 0; j < "0123456789. ".length; ++j) {
                        var offset = this._ctx.measureText("0123456789. "[j]).width;
                        this._eachNumWidth = Math.max(this._eachNumWidth, offset), offsets[j + 1] = offsets[j] + offset / this._canvas.width;
                    }
                    for (var _j = 0; _j < "0123456789. ".length; ++_j) this._ctx.fillText("0123456789. "[_j], _j * this._eachNumWidth, this._totalLines * this._lineHeight);
                    this._eachNumWidth /= this._canvas.width;
                    for (var len = Math.ceil(offsets.length / 4), _j2 = 0; _j2 < len; _j2++) this._uvOffset.push(new Vec4(offsets[4 * _j2], offsets[4 * _j2 + 1], offsets[4 * _j2 + 2], offsets[4 * _j2 + 3]));
                    this._stats = _profileInfo, this._canvasArr[0] = this._canvas, this.updateTexture();
                }
            }
        }, {
            key: "generateNode",
            value: function generateNode() {
                if (!this._rootNode || !this._rootNode.isValid) {
                    this._rootNode = new Node$1("PROFILER_NODE"), cc.game.addPersistRootNode(this._rootNode);
                    var cameraNode = new Node$1("Profiler_Camera");
                    cameraNode.setPosition(0, 0, 1), cameraNode.parent = this._rootNode;
                    var camera = cameraNode.addComponent("cc.CameraComponent");
                    camera.projection = CameraComponent.ProjectionType.ORTHO, camera.near = 0, camera.far = 0, 
                    camera.orthoHeight = this._device.height, camera.visibility = Layers.BitMask.PROFILER, 
                    camera.clearFlags = exports.GFXClearFlag.NONE, camera.priority = 4294967295, camera.flows = [ "UIFlow" ];
                    var managerNode = new Node$1("Profiler_Root");
                    managerNode.parent = this._rootNode;
                    for (var height = _constants_quadHeight, rowHeight = height / this._totalLines, lWidth = height / this._wordHeight, scale = rowHeight / _constants_fontSize, columnWidth = this._eachNumWidth * this._canvas.width * scale, vertexPos = [ 0, height, 0, lWidth, height, 0, lWidth, 0, 0, 0, 0, 0 ], vertexindices = [ 0, 2, 1, 0, 3, 2 ], vertexUV = [ 0, 0, -1, 0, 1, 0, -1, 0, 1, this._wordHeight, -1, 0, 0, this._wordHeight, -1, 0 ], offset = 0, i = 0; i < this._totalLines; i++) for (var j = 0; j < _constants_segmentsPerLine; j++) {
                        vertexPos.push(lWidth + j * columnWidth, height - i * rowHeight, 0), vertexPos.push(lWidth + (j + 1) * columnWidth, height - i * rowHeight, 0), 
                        vertexPos.push(lWidth + (j + 1) * columnWidth, height - (i + 1) * rowHeight, 0), 
                        vertexPos.push(lWidth + j * columnWidth, height - (i + 1) * rowHeight, 0), offset = 4 * (i * _constants_segmentsPerLine + j + 1), 
                        vertexindices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset);
                        var idx = i * _constants_segmentsPerLine + j, z = Math.floor(idx / 4), w = idx - 4 * z;
                        vertexUV.push(0, this._wordHeight, z, w), vertexUV.push(this._eachNumWidth, this._wordHeight, z, w), 
                        vertexUV.push(this._eachNumWidth, 1, z, w), vertexUV.push(0, 1, z, w);
                    }
                    var modelCom = managerNode.addComponent("cc.ModelComponent");
                    modelCom.mesh = createMesh({
                        positions: vertexPos,
                        indices: vertexindices,
                        colors: vertexUV
                    });
                    var _material = new Material;
                    _material.initialize({
                        effectName: "util/profiler"
                    }), _material.setProperty("offset", new Vec4(-.9, -.9, this._eachNumWidth, 0));
                    var pass = _material.passes[0], handle = pass.getBinding("mainTexture"), binding = pass.getBinding("digits");
                    pass.bindTextureView(handle, this._textureView), this.digitsData = pass.blocks[binding], 
                    modelCom.material = _material, modelCom.node.layer = Layers.Enum.PROFILER, this._inited = !0;
                }
            }
        }, {
            key: "beforeUpdate",
            value: function beforeUpdate() {
                if (this._stats) {
                    var now = performance.now();
                    this.getCounter("frame").end(now), this.getCounter("frame").start(now), this.getCounter("logic").start(now);
                }
            }
        }, {
            key: "afterUpdate",
            value: function afterUpdate() {
                if (this._stats) {
                    var now = performance.now();
                    cc.director.isPaused() ? this.getCounter("frame").start(now) : this.getCounter("logic").end(now);
                }
            }
        }, {
            key: "beforePhysics",
            value: function beforePhysics() {
                if (this._stats) {
                    var now = performance.now();
                    this.getCounter("physics").start(now);
                }
            }
        }, {
            key: "afterPhysics",
            value: function afterPhysics() {
                if (this._stats) {
                    var now = performance.now();
                    this.getCounter("physics").end(now);
                }
            }
        }, {
            key: "beforeDraw",
            value: function beforeDraw() {
                if (this._stats) {
                    var now = performance.now();
                    this.getCounter("render").start(now);
                }
            }
        }, {
            key: "afterDraw",
            value: function afterDraw() {
                if (this._stats && this._inited) {
                    var now = performance.now();
                    if (this.getCounter("fps").frame(now), this.getCounter("render").end(now), !(now - this.lastTime < 500)) {
                        this.lastTime = now;
                        var device = this._device;
                        this.getCounter("draws").value = device.numDrawCalls, this.getCounter("bufferMemory").value = device.memoryStatus.bufferSize / 1048576, 
                        this.getCounter("textureMemory").value = device.memoryStatus.textureSize / 1048576, 
                        this.getCounter("tricount").value = device.numTris;
                        var i = 0, view = this.digitsData.view;
                        for (var id in this._stats) {
                            var stat = this._stats[id];
                            stat.counter.sample(now);
                            for (var result = stat.counter.human().toString(), j = _constants_segmentsPerLine - 1; j >= 0; j--) {
                                var index = i * _constants_segmentsPerLine + j, character = result[result.length - (_constants_segmentsPerLine - j)], offset = _string2offset[character];
                                void 0 === offset && (offset = 11), view[index] = offset;
                            }
                            i++;
                        }
                        this.digitsData.dirty = !0;
                    }
                }
            }
        }, {
            key: "getCounter",
            value: function getCounter(s) {
                return this._stats[s].counter;
            }
        }, {
            key: "updateTexture",
            value: function updateTexture() {
                cc.director.root.device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr);
            }
        } ]), Profiler;
    }(), profiler = new Profiler;
    cc.profiler = profiler;
    var vmath = {};
    function createShader(gl, type, source) {
        var shader = gl.createShader(type);
        if (shader) {
            if (gl.shaderSource(shader, source), gl.compileShader(shader), gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
            console.error("compile shader error", shader), console.log(gl.getShaderInfoLog(shader)), 
            gl.deleteShader(shader);
        } else console.error("create shader error", source);
    }
    exports.replaceProperty(vmath, "vmath", [ {
        name: "vec2",
        newName: "Vec2",
        target: math,
        targetName: "math"
    }, {
        name: "vec3",
        newName: "Vec3",
        target: math,
        targetName: "math"
    }, {
        name: "vec4",
        newName: "Vec4",
        target: math,
        targetName: "math"
    }, {
        name: "quat",
        newName: "Quat",
        target: math,
        targetName: "math"
    }, {
        name: "mat3",
        newName: "Mat3",
        target: math,
        targetName: "math"
    }, {
        name: "mat4",
        newName: "Mat4",
        target: math,
        targetName: "math"
    }, {
        name: "color4",
        newName: "Color",
        target: math,
        targetName: "math"
    }, {
        name: "rect",
        newName: "Rect",
        target: math,
        targetName: "math"
    }, {
        name: "approx",
        newName: "approx",
        target: math,
        targetName: "math"
    }, {
        name: "EPSILON",
        newName: "EPSILON",
        target: math,
        targetName: "math"
    }, {
        name: "equals",
        newName: "equals",
        target: math,
        targetName: "math"
    }, {
        name: "clamp",
        newName: "clamp",
        target: math,
        targetName: "math"
    }, {
        name: "clamp01",
        newName: "clamp01",
        target: math,
        targetName: "math"
    }, {
        name: "lerp",
        newName: "lerp",
        target: math,
        targetName: "math"
    }, {
        name: "toRadian",
        newName: "toRadian",
        target: math,
        targetName: "math"
    }, {
        name: "toDegree",
        newName: "toDegree",
        target: math,
        targetName: "math"
    }, {
        name: "random",
        newName: "random",
        target: math,
        targetName: "math"
    }, {
        name: "randomRange",
        newName: "randomRange",
        target: math,
        targetName: "math"
    }, {
        name: "randomRangeInt",
        newName: "randomRangeInt",
        target: math,
        targetName: "math"
    }, {
        name: "pseudoRandom",
        newName: "pseudoRandom",
        target: math,
        targetName: "math"
    }, {
        name: "pseudoRandomRangeInt",
        newName: "pseudoRandomRangeInt",
        target: math,
        targetName: "math"
    }, {
        name: "nextPow2",
        newName: "nextPow2",
        target: math,
        targetName: "math"
    }, {
        name: "repeat",
        newName: "repeat",
        target: math,
        targetName: "math"
    }, {
        name: "pingPong",
        newName: "pingPong",
        target: math,
        targetName: "math"
    }, {
        name: "inverseLerp",
        newName: "inverseLerp",
        target: math,
        targetName: "math"
    } ]), cc.vmath = vmath, exports.replaceProperty(Scheduler.prototype, "Scheduler.prototype", [ {
        name: "enableForTarget",
        newName: "enableForTarget",
        target: Scheduler,
        targetName: "Scheduler"
    } ]);
    var SplashScreenWebgl = function() {
        function SplashScreenWebgl() {
            _classCallCheck(this, SplashScreenWebgl), this.logoImage = new Image, this.textImage = document.createElement("canvas"), 
            this.vertices = new Float32Array([ -1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 1, 1 ]), 
            this.texcoords = new Float32Array([ 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1 ]), this.logoMat33 = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), 
            this.textMat33 = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), this.callBack = null, 
            this.cancelAnimate = !1, this.handle = -1, this.startTime = -1, this._isStart = !1, 
            this._directCall = !1, this._splashFinish = !1, this._loadFinish = !1;
        }
        return _createClass(SplashScreenWebgl, [ {
            key: "_tryToStart",
            value: function _tryToStart() {
                this._splashFinish && this._loadFinish && this.callBack && (this.cancelAnimate = !0, 
                cancelAnimationFrame(this.handle), this.destroy(), this.callBack());
            }
        }, {
            key: "setOnFinish",
            value: function setOnFinish(cb) {
                if ((!this._isStart || this._directCall) && cb) return delete SplashScreenWebgl._ins, 
                cb();
                this.callBack = cb;
            }
        }, {
            key: "main",
            value: function main(canvas) {
                if (window._CCSettings && window._CCSettings.splashScreen ? (this.setting = window._CCSettings.splashScreen, 
                this.setting.totalTime = null != this.setting.totalTime ? this.setting.totalTime : 3e3, 
                this.setting.base64src = null != this.setting.base64src ? this.setting.base64src : "", 
                this.setting.effect = null != this.setting.effect ? this.setting.effect : "Fade-InOut", 
                this.setting.clearColor = null != this.setting.clearColor ? this.setting.clearColor : {
                    r: .88,
                    g: .88,
                    b: .88,
                    a: 1
                }, this.setting.displayRatio = null != this.setting.displayRatio ? this.setting.displayRatio : .4, 
                this.setting.displayWatermark = null == this.setting.displayWatermark || this.setting.displayWatermark) : this.setting = {
                    totalTime: 3e3,
                    base64src: "",
                    effect: "Fade-InOut",
                    clearColor: {
                        r: .88,
                        g: .88,
                        b: .88,
                        a: 1
                    },
                    displayRatio: .4,
                    displayWatermark: !0
                }, null == canvas || "" == this.setting.base64src || this.setting.totalTime <= 0) return this.callBack && this.callBack(), 
                this.callBack = null, this.setting = null, void (this._directCall = !0);
                var useWebGL2 = !!window.WebGL2RenderingContext, userAgent = window.navigator.userAgent.toLowerCase();
                (-1 !== userAgent.indexOf("safari") && -1 === userAgent.indexOf("chrome") || sys.browserType === sys.BROWSER_TYPE_UC) && (useWebGL2 = !1);
                var webGLCtxAttribs = {
                    alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                    antialias: !0,
                    depth: !0,
                    stencil: !0,
                    premultipliedAlpha: !0,
                    preserveDrawingBuffer: !1,
                    powerPreference: "default",
                    failIfMajorPerformanceCaveat: !1
                }, gl = null, gl2 = null;
                if (useWebGL2 && cc.WebGL2GFXDevice ? null == (gl2 = canvas.getContext("webgl2", webGLCtxAttribs)) && (gl = canvas.getContext("webgl", webGLCtxAttribs)) : gl = canvas.getContext("webgl", webGLCtxAttribs), 
                null == gl && null == gl2) return console.error("this device does not support webgl");
                null != gl && (this.gl = gl), null != gl2 && (this.gl = gl2);
                var textImage = this.textImage;
                textImage.width = 300, textImage.height = 30, textImage.style.width = "".concat(textImage.width), 
                textImage.style.height = "".concat(textImage.height);
                var ctx = textImage.getContext("2d");
                ctx.font = "".concat(18, "px Arial"), ctx.textBaseline = "top", ctx.textAlign = "left", 
                ctx.fillStyle = "`#424242`", ctx.fillText("Powered by Cocos Creator 3D", 30, 8), 
                this.logoImage.onload = this.init.bind(this), this.logoImage.src = this.setting.base64src, 
                this._isStart = !0;
            }
        }, {
            key: "init",
            value: function init() {
                var _this = this;
                this.initMatrix(), this.initProgram(), this.initBuffer(), this.initTexture(), this.initState();
                var that = this;
                this.handle = requestAnimationFrame((function animate(time) {
                    _this.cancelAnimate || (that.frame(time), requestAnimationFrame(animate));
                }));
            }
        }, {
            key: "initMatrix",
            value: function initMatrix() {
                var screenWidth = this.gl.canvas.width, screenHeight = this.gl.canvas.height, displayRatio = this.setting.displayRatio, logoW = this.logoImage.width / 2, logoH = this.logoImage.height / 2, textW = this.textImage.width / 2, textH = this.textImage.height / 2;
                screenWidth < screenHeight ? (logoH = (logoW = screenWidth / 2 * displayRatio) / (this.logoImage.width / this.logoImage.height), 
                textH = (textW = screenWidth / 2 * .5) / (this.textImage.width / this.textImage.height)) : (logoH = (logoW = screenHeight / 2 * displayRatio) / (this.logoImage.width / this.logoImage.height), 
                textH = (textW = screenHeight / 2 * .5) / (this.textImage.width / this.textImage.height)), 
                this.logoMat33[0] = logoW, this.logoMat33[4] = logoH, this.logoMat33[6] = screenWidth / 2, 
                this.logoMat33[7] = screenHeight / 2, this.textMat33[0] = textW, this.textMat33[4] = textH, 
                this.textMat33[6] = screenWidth / 2, this.textMat33[7] = .9 * screenHeight;
            }
        }, {
            key: "initProgram",
            value: function initProgram() {
                var gl = this.gl;
                this.vertexShader = createShader(gl, gl.VERTEX_SHADER, "precision mediump float;attribute vec2 a_position;attribute vec2 a_texCoord;uniform vec2 u_resolution;uniform mat3 u_worldMat;varying vec2 v_texCoord;void main() {vec3 wpos = u_worldMat * vec3(a_position, 1.0);vec2 clipSpace = wpos.xy / u_resolution * 2.0 - 1.0;gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);v_texCoord = a_texCoord;}"), 
                this.fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, "precision mediump float;uniform float u_alpha;uniform sampler2D u_image;varying vec2 v_texCoord;void main(){gl_FragColor = texture2D(u_image,v_texCoord);gl_FragColor.xyz *= clamp(u_alpha, 0.0, 1.0);}"), 
                this.program = function createProgram(gl, vertexShader, fragmentShader) {
                    var program = gl.createProgram();
                    if (program) {
                        gl.attachShader(program, vertexShader), gl.attachShader(program, fragmentShader), 
                        gl.linkProgram(program);
                        var success = gl.getProgramParameter(program, gl.LINK_STATUS);
                        if (success) return program;
                        console.error("link program error", success), console.log(gl.getProgramInfoLog(program)), 
                        gl.deleteProgram(program);
                    } else console.error("create program error");
                }(gl, this.vertexShader, this.fragmentShader);
            }
        }, {
            key: "initBuffer",
            value: function initBuffer() {
                var gl = this.gl;
                gl.useProgram(this.program), this.positionBuffer = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer), 
                gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW), this.texcoordBuffer = gl.createBuffer(), 
                gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer), gl.bufferData(gl.ARRAY_BUFFER, this.texcoords, gl.STATIC_DRAW);
                var positionLocation = gl.getAttribLocation(this.program, "a_position");
                gl.enableVertexAttribArray(positionLocation), gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                var size = 2, type = gl.FLOAT, normalize = !1, stride = 0, offset = 0;
                gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);
                var texcoordLocation = gl.getAttribLocation(this.program, "a_texCoord");
                gl.enableVertexAttribArray(texcoordLocation), gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
                size = 2, type = gl.FLOAT, normalize = !1, stride = 0, offset = 0;
                gl.vertexAttribPointer(texcoordLocation, size, type, normalize, stride, offset);
            }
        }, {
            key: "initTexture",
            value: function initTexture() {
                var gl = this.gl;
                this.textureLogo = gl.createTexture(), gl.bindTexture(gl.TEXTURE_2D, this.textureLogo), 
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), 
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR), 
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.logoImage), 
                this.textureText = gl.createTexture(), gl.bindTexture(gl.TEXTURE_2D, this.textureText), 
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), 
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR), 
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.textImage);
            }
        }, {
            key: "initState",
            value: function initState() {
                var gl = this.gl;
                gl.useProgram(this.program);
                var resolutionLocation = gl.getUniformLocation(this.program, "u_resolution");
                gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height), gl.enable(gl.BLEND), 
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            }
        }, {
            key: "frame",
            value: function frame(time) {
                var gl = this.gl, program = this.program, textureLogo = this.textureLogo, textureText = this.textureText, clearColor = this.setting.clearColor, logoMat33 = this.logoMat33, textMat33 = this.textMat33;
                this.startTime < 0 && (this.startTime = time);
                var elapsedTime = time - this.startTime, alpha = cubicOut(clamp01(elapsedTime / this.setting.totalTime));
                gl.enable(gl.BLEND), gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA), gl.bindFramebuffer(gl.FRAMEBUFFER, null), 
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height), gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a), 
                gl.depthMask(!0), gl.clearDepth(1), gl.clearStencil(0), gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT), 
                gl.useProgram(this.program);
                var resolutionLocation = gl.getUniformLocation(this.program, "u_resolution");
                gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
                var location = gl.getUniformLocation(program, "u_alpha");
                gl.uniform1f(location, alpha), location = gl.getUniformLocation(program, "u_worldMat"), 
                gl.uniformMatrix3fv(location, !1, logoMat33), gl.bindTexture(gl.TEXTURE_2D, textureLogo), 
                gl.drawArrays(gl.TRIANGLES, 0, 6), this.setting.displayWatermark && (gl.uniformMatrix3fv(location, !1, textMat33), 
                gl.bindTexture(gl.TEXTURE_2D, textureText), gl.drawArrays(gl.TRIANGLES, 0, 6)), 
                elapsedTime > this.setting.totalTime && (this.splashFinish = !0);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                delete SplashScreenWebgl._ins, this.gl.deleteProgram(this.program), this.gl.deleteShader(this.vertexShader), 
                this.gl.deleteShader(this.fragmentShader), this.gl.deleteBuffer(this.positionBuffer), 
                this.gl.deleteBuffer(this.texcoordBuffer), this.gl.deleteTexture(this.textureLogo), 
                this.gl.deleteTexture(this.textureText);
            }
        }, {
            key: "loadFinish",
            set: function set(v) {
                this._loadFinish = v, this._tryToStart();
            }
        }, {
            key: "splashFinish",
            set: function set(v) {
                this._splashFinish = v, this._tryToStart();
            }
        } ], [ {
            key: "instance",
            get: function get() {
                return null == SplashScreenWebgl._ins && (SplashScreenWebgl._ins = new SplashScreenWebgl), 
                SplashScreenWebgl._ins;
            }
        } ]), SplashScreenWebgl;
    }();
    cc.internal.SplashScreenWebgl = SplashScreenWebgl, cc.math = math, cc.geometry = geometry;
    var _dec$15, _dec2$H, _class$16, _class2$Y, _descriptor$P, _descriptor2$E, PrimitiveType$1, NodePool = function() {
        function NodePool(poolHandlerComp) {
            _classCallCheck(this, NodePool), this.poolHandlerComp = poolHandlerComp, this._pool = [];
        }
        return _createClass(NodePool, [ {
            key: "size",
            value: function size() {
                return this._pool.length;
            }
        }, {
            key: "clear",
            value: function clear() {
                for (var count = this._pool.length, i = 0; i < count; ++i) this._pool[i].destroy();
                this._pool.length = 0;
            }
        }, {
            key: "put",
            value: function put(obj) {
                if (obj && -1 === this._pool.indexOf(obj)) {
                    obj.removeFromParent();
                    var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                    handler && handler.unuse && handler.unuse(), this._pool.push(obj);
                }
            }
        }, {
            key: "get",
            value: function get() {
                var last = this._pool.length - 1;
                if (last < 0) return null;
                var obj = this._pool[last];
                this._pool.length = last;
                var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                if (handler && handler.reuse) {
                    for (var _handler$reuse, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    (_handler$reuse = handler.reuse).apply.apply(_handler$reuse, [ handler ].concat(args));
                }
                return obj;
            }
        } ]), NodePool;
    }();
    cc.NodePool = NodePool, function(PrimitiveType) {
        PrimitiveType[PrimitiveType.BOX = 0] = "BOX", PrimitiveType[PrimitiveType.SPHERE = 1] = "SPHERE", 
        PrimitiveType[PrimitiveType.CYLINDER = 2] = "CYLINDER", PrimitiveType[PrimitiveType.CONE = 3] = "CONE", 
        PrimitiveType[PrimitiveType.CAPSULE = 4] = "CAPSULE", PrimitiveType[PrimitiveType.TORUS = 5] = "TORUS", 
        PrimitiveType[PrimitiveType.PLANE = 6] = "PLANE", PrimitiveType[PrimitiveType.QUAD = 7] = "QUAD";
    }(PrimitiveType$1 || (PrimitiveType$1 = {})), ccenum(PrimitiveType$1);
    var Primitive = (_dec$15 = ccclass("cc.Primitive"), _dec2$H = property({
        type: PrimitiveType$1
    }), _dec$15((_descriptor$P = _applyDecoratedDescriptor((_class2$Y = function(_Mesh) {
        function Primitive() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Primitive);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Primitive)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "type", _descriptor$P, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "info", _descriptor2$E, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(Primitive, _Mesh), _createClass(Primitive, [ {
            key: "onLoaded",
            value: function onLoaded() {
                createMesh(primitives[PrimitiveType$1[this.type]](this.info), this);
            }
        } ]), Primitive;
    }(Mesh)).prototype, "type", [ _dec2$H ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return PrimitiveType$1.BOX;
        }
    }), _descriptor2$E = _applyDecoratedDescriptor(_class2$Y.prototype, "info", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return {};
        }
    }), _class$16 = _class2$Y)) || _class$16);
    cc.Primitive = Primitive, cc.renderer = renderer;
    var cclegacy = cc;
    cc.primitives = primitives;
    var WebGLEXT, WebGLGFXBindingLayout = function(_GFXBindingLayout) {
        function WebGLGFXBindingLayout(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXBindingLayout).call(this, device)))._gpuBindingLayout = null, 
            _this;
        }
        return _inherits(WebGLGFXBindingLayout, _GFXBindingLayout), _createClass(WebGLGFXBindingLayout, [ {
            key: "gpuBindingLayout",
            get: function get() {
                return this._gpuBindingLayout;
            }
        } ]), _createClass(WebGLGFXBindingLayout, [ {
            key: "initialize",
            value: function initialize(info) {
                this._bindingUnits = new Array(info.bindings.length);
                for (var i = 0; i < info.bindings.length; ++i) {
                    var binding = info.bindings[i];
                    this._bindingUnits[i] = {
                        binding: binding.binding,
                        type: binding.bindingType,
                        name: binding.name,
                        buffer: null,
                        texView: null,
                        sampler: null
                    };
                }
                this._gpuBindingLayout = {
                    gpuBindings: new Array(info.bindings.length)
                };
                for (var _i = 0; _i < info.bindings.length; ++_i) {
                    var _binding = info.bindings[_i];
                    this._gpuBindingLayout.gpuBindings[_i] = {
                        binding: _binding.binding,
                        type: _binding.bindingType,
                        name: _binding.name,
                        gpuBuffer: null,
                        gpuTexView: null,
                        gpuSampler: null
                    };
                }
                return this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuBindingLayout = null, this._status = exports.GFXStatus.UNREADY;
            }
        }, {
            key: "update",
            value: function update() {
                if (this._isDirty && this._gpuBindingLayout) {
                    for (var i = 0; i < this._bindingUnits.length; ++i) {
                        var bindingUnit = this._bindingUnits[i];
                        switch (bindingUnit.type) {
                          case exports.GFXBindingType.UNIFORM_BUFFER:
                            bindingUnit.buffer && (this._gpuBindingLayout.gpuBindings[i].gpuBuffer = bindingUnit.buffer.gpuBuffer);
                            break;

                          case exports.GFXBindingType.SAMPLER:
                            bindingUnit.texView && (this._gpuBindingLayout.gpuBindings[i].gpuTexView = bindingUnit.texView.gpuTextureView), 
                            bindingUnit.sampler && (this._gpuBindingLayout.gpuBindings[i].gpuSampler = bindingUnit.sampler.gpuSampler);
                        }
                    }
                    this._isDirty = !1;
                }
            }
        } ]), WebGLGFXBindingLayout;
    }(GFXBindingLayout);
    function GFXFormatToWebGLType(format, gl) {
        switch (format) {
          case exports.GFXFormat.R8:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.R8SN:
            return gl.BYTE;

          case exports.GFXFormat.R8UI:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.R8I:
            return gl.BYTE;

          case exports.GFXFormat.R16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case exports.GFXFormat.R16UI:
            return gl.UNSIGNED_SHORT;

          case exports.GFXFormat.R16I:
            return gl.SHORT;

          case exports.GFXFormat.R32F:
            return gl.FLOAT;

          case exports.GFXFormat.R32UI:
            return gl.UNSIGNED_INT;

          case exports.GFXFormat.R32I:
            return gl.INT;

          case exports.GFXFormat.RG8:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.RG8SN:
            return gl.BYTE;

          case exports.GFXFormat.RG8UI:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.RG8I:
            return gl.BYTE;

          case exports.GFXFormat.RG16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case exports.GFXFormat.RG16UI:
            return gl.UNSIGNED_SHORT;

          case exports.GFXFormat.RG16I:
            return gl.SHORT;

          case exports.GFXFormat.RG32F:
            return gl.FLOAT;

          case exports.GFXFormat.RG32UI:
            return gl.UNSIGNED_INT;

          case exports.GFXFormat.RG32I:
            return gl.INT;

          case exports.GFXFormat.RGB8:
          case exports.GFXFormat.SRGB8:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.RGB8SN:
            return gl.BYTE;

          case exports.GFXFormat.RGB8UI:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.RGB8I:
            return gl.BYTE;

          case exports.GFXFormat.RGB16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case exports.GFXFormat.RGB16UI:
            return gl.UNSIGNED_SHORT;

          case exports.GFXFormat.RGB16I:
            return gl.SHORT;

          case exports.GFXFormat.RGB32F:
            return gl.FLOAT;

          case exports.GFXFormat.RGB32UI:
            return gl.UNSIGNED_INT;

          case exports.GFXFormat.RGB32I:
            return gl.INT;

          case exports.GFXFormat.RGBA8:
          case exports.GFXFormat.SRGB8_A8:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.RGBA8SN:
            return gl.BYTE;

          case exports.GFXFormat.RGBA8UI:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.RGBA8I:
            return gl.BYTE;

          case exports.GFXFormat.RGBA16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case exports.GFXFormat.RGBA16UI:
            return gl.UNSIGNED_SHORT;

          case exports.GFXFormat.RGBA16I:
            return gl.SHORT;

          case exports.GFXFormat.RGBA32F:
            return gl.FLOAT;

          case exports.GFXFormat.RGBA32UI:
            return gl.UNSIGNED_INT;

          case exports.GFXFormat.RGBA32I:
            return gl.INT;

          case exports.GFXFormat.R5G6B5:
            return gl.UNSIGNED_SHORT_5_6_5;

          case exports.GFXFormat.R11G11B10F:
            return gl.FLOAT;

          case exports.GFXFormat.RGB5A1:
            return gl.UNSIGNED_SHORT_5_5_5_1;

          case exports.GFXFormat.RGBA4:
            return gl.UNSIGNED_SHORT_4_4_4_4;

          case exports.GFXFormat.RGB10A2:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.RGB10A2UI:
            return gl.UNSIGNED_INT;

          case exports.GFXFormat.RGB9E5:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.D16:
          case exports.GFXFormat.D16S8:
            return gl.UNSIGNED_SHORT;

          case exports.GFXFormat.D24:
            return gl.UNSIGNED_INT;

          case exports.GFXFormat.D24S8:
            return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

          case exports.GFXFormat.D32F:
          case exports.GFXFormat.D32F_S8:
            return gl.FLOAT;

          case exports.GFXFormat.BC1:
          case exports.GFXFormat.BC1_SRGB:
          case exports.GFXFormat.BC2:
          case exports.GFXFormat.BC2_SRGB:
          case exports.GFXFormat.BC3:
          case exports.GFXFormat.BC3_SRGB:
          case exports.GFXFormat.BC4:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.BC4_SNORM:
            return gl.BYTE;

          case exports.GFXFormat.BC5:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.BC5_SNORM:
            return gl.BYTE;

          case exports.GFXFormat.BC6H_SF16:
          case exports.GFXFormat.BC6H_UF16:
            return gl.FLOAT;

          case exports.GFXFormat.BC7:
          case exports.GFXFormat.BC7_SRGB:
          case exports.GFXFormat.ETC_RGB8:
          case exports.GFXFormat.ETC2_RGB8:
          case exports.GFXFormat.ETC2_SRGB8:
          case exports.GFXFormat.ETC2_RGB8_A1:
          case exports.GFXFormat.ETC2_SRGB8_A1:
          case exports.GFXFormat.ETC2_RGB8:
          case exports.GFXFormat.ETC2_SRGB8:
          case exports.GFXFormat.EAC_R11:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.EAC_R11SN:
            return gl.BYTE;

          case exports.GFXFormat.EAC_RG11:
            return gl.UNSIGNED_BYTE;

          case exports.GFXFormat.EAC_RG11SN:
            return gl.BYTE;

          case exports.GFXFormat.PVRTC_RGB2:
          case exports.GFXFormat.PVRTC_RGBA2:
          case exports.GFXFormat.PVRTC_RGB4:
          case exports.GFXFormat.PVRTC_RGBA4:
          case exports.GFXFormat.PVRTC2_2BPP:
          case exports.GFXFormat.PVRTC2_4BPP:
          default:
            return gl.UNSIGNED_BYTE;
        }
    }
    function GFXFormatToWebGLInternalFormat(format, gl) {
        switch (format) {
          case exports.GFXFormat.A8:
            return gl.ALPHA;

          case exports.GFXFormat.L8:
            return gl.LUMINANCE;

          case exports.GFXFormat.LA8:
            return gl.LUMINANCE_ALPHA;

          case exports.GFXFormat.RGB8:
          case exports.GFXFormat.RGB16F:
          case exports.GFXFormat.RGB32F:
            return gl.RGB;

          case exports.GFXFormat.RGBA8:
          case exports.GFXFormat.RGBA16F:
          case exports.GFXFormat.RGBA32F:
            return gl.RGBA;

          case exports.GFXFormat.R5G6B5:
            return gl.RGB565;

          case exports.GFXFormat.RGB5A1:
            return gl.RGB5_A1;

          case exports.GFXFormat.RGBA4:
            return gl.RGBA4;

          case exports.GFXFormat.D16:
            return gl.DEPTH_COMPONENT;

          case exports.GFXFormat.D16S8:
            return gl.DEPTH_STENCIL;

          case exports.GFXFormat.D24:
            return gl.DEPTH_COMPONENT;

          case exports.GFXFormat.D24S8:
            return gl.DEPTH_STENCIL;

          case exports.GFXFormat.D32F:
            return gl.DEPTH_COMPONENT;

          case exports.GFXFormat.D32F_S8:
            return gl.DEPTH_STENCIL;

          case exports.GFXFormat.BC1:
            return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_ALPHA:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB_ALPHA:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC2:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC2_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC3:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

          case exports.GFXFormat.BC3_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

          case exports.GFXFormat.ETC_RGB8:
            return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

          case exports.GFXFormat.PVRTC_RGB2:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA2:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGB4:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA4:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

          default:
            return console.error("Unsupported GFXFormat, convert to WebGL internal format failed."), 
            gl.RGBA;
        }
    }
    function GFXFormatToWebGLFormat(format, gl) {
        switch (format) {
          case exports.GFXFormat.A8:
            return gl.ALPHA;

          case exports.GFXFormat.L8:
            return gl.LUMINANCE;

          case exports.GFXFormat.LA8:
            return gl.LUMINANCE_ALPHA;

          case exports.GFXFormat.RGB8:
          case exports.GFXFormat.RGB16F:
          case exports.GFXFormat.RGB32F:
            return gl.RGB;

          case exports.GFXFormat.RGBA8:
          case exports.GFXFormat.RGBA16F:
          case exports.GFXFormat.RGBA32F:
            return gl.RGBA;

          case exports.GFXFormat.R5G6B5:
            return gl.RGB;

          case exports.GFXFormat.RGB5A1:
          case exports.GFXFormat.RGBA4:
            return gl.RGBA;

          case exports.GFXFormat.D16:
            return gl.DEPTH_COMPONENT;

          case exports.GFXFormat.D16S8:
            return gl.DEPTH_STENCIL;

          case exports.GFXFormat.D24:
            return gl.DEPTH_COMPONENT;

          case exports.GFXFormat.D24S8:
            return gl.DEPTH_STENCIL;

          case exports.GFXFormat.D32F:
            return gl.DEPTH_COMPONENT;

          case exports.GFXFormat.D32F_S8:
            return gl.DEPTH_STENCIL;

          case exports.GFXFormat.BC1:
            return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_ALPHA:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB_ALPHA:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC2:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC2_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC3:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

          case exports.GFXFormat.BC3_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

          case exports.GFXFormat.ETC_RGB8:
            return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

          case exports.GFXFormat.ETC2_RGB8:
            return WebGLEXT.COMPRESSED_RGB8_ETC2;

          case exports.GFXFormat.ETC2_SRGB8:
            return WebGLEXT.COMPRESSED_SRGB8_ETC2;

          case exports.GFXFormat.ETC2_RGB8_A1:
            return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case exports.GFXFormat.ETC2_SRGB8_A1:
            return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case exports.GFXFormat.ETC2_RGBA8:
            return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

          case exports.GFXFormat.ETC2_SRGB8_A8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

          case exports.GFXFormat.EAC_R11:
            return WebGLEXT.COMPRESSED_R11_EAC;

          case exports.GFXFormat.EAC_R11SN:
            return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

          case exports.GFXFormat.EAC_RG11:
            return WebGLEXT.COMPRESSED_RG11_EAC;

          case exports.GFXFormat.EAC_RG11SN:
            return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

          case exports.GFXFormat.PVRTC_RGB2:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA2:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGB4:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA4:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

          default:
            return console.error("Unsupported GFXFormat, convert to WebGL format failed."), 
            gl.RGBA;
        }
    }
    function GFXTypeToWebGLType(type, gl) {
        switch (type) {
          case exports.GFXType.BOOL:
            return gl.BOOL;

          case exports.GFXType.BOOL2:
            return gl.BOOL_VEC2;

          case exports.GFXType.BOOL3:
            return gl.BOOL_VEC3;

          case exports.GFXType.BOOL4:
            return gl.BOOL_VEC4;

          case exports.GFXType.INT:
            return gl.INT;

          case exports.GFXType.INT2:
            return gl.INT_VEC2;

          case exports.GFXType.INT3:
            return gl.INT_VEC3;

          case exports.GFXType.INT4:
            return gl.INT_VEC4;

          case exports.GFXType.UINT:
            return gl.UNSIGNED_INT;

          case exports.GFXType.FLOAT:
            return gl.FLOAT;

          case exports.GFXType.FLOAT2:
            return gl.FLOAT_VEC2;

          case exports.GFXType.FLOAT3:
            return gl.FLOAT_VEC3;

          case exports.GFXType.FLOAT4:
            return gl.FLOAT_VEC4;

          case exports.GFXType.MAT2:
            return gl.FLOAT_MAT2;

          case exports.GFXType.MAT3:
            return gl.FLOAT_MAT3;

          case exports.GFXType.MAT4:
            return gl.FLOAT_MAT4;

          case exports.GFXType.SAMPLER2D:
            return gl.SAMPLER_2D;

          case exports.GFXType.SAMPLER_CUBE:
            return gl.SAMPLER_CUBE;

          default:
            return console.error("Unsupported GLType, convert to GL type failed."), exports.GFXType.UNKNOWN;
        }
    }
    function WebGLTypeToGFXType(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return exports.GFXType.BOOL;

          case gl.BOOL_VEC2:
            return exports.GFXType.BOOL2;

          case gl.BOOL_VEC3:
            return exports.GFXType.BOOL3;

          case gl.BOOL_VEC4:
            return exports.GFXType.BOOL4;

          case gl.INT:
            return exports.GFXType.INT;

          case gl.INT_VEC2:
            return exports.GFXType.INT2;

          case gl.INT_VEC3:
            return exports.GFXType.INT3;

          case gl.INT_VEC4:
            return exports.GFXType.INT4;

          case gl.UNSIGNED_INT:
            return exports.GFXType.UINT;

          case gl.FLOAT:
            return exports.GFXType.FLOAT;

          case gl.FLOAT_VEC2:
            return exports.GFXType.FLOAT2;

          case gl.FLOAT_VEC3:
            return exports.GFXType.FLOAT3;

          case gl.FLOAT_VEC4:
            return exports.GFXType.FLOAT4;

          case gl.FLOAT_MAT2:
            return exports.GFXType.MAT2;

          case gl.FLOAT_MAT3:
            return exports.GFXType.MAT3;

          case gl.FLOAT_MAT4:
            return exports.GFXType.MAT4;

          case gl.SAMPLER_2D:
            return exports.GFXType.SAMPLER2D;

          case gl.SAMPLER_CUBE:
            return exports.GFXType.SAMPLER_CUBE;

          default:
            return console.error("Unsupported GLType, convert to GFXType failed."), exports.GFXType.UNKNOWN;
        }
    }
    function WebGLGetTypeSize(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return 4;

          case gl.BOOL_VEC2:
            return 8;

          case gl.BOOL_VEC3:
            return 12;

          case gl.BOOL_VEC4:
            return 16;

          case gl.INT:
            return 4;

          case gl.INT_VEC2:
            return 8;

          case gl.INT_VEC3:
            return 12;

          case gl.INT_VEC4:
            return 16;

          case gl.UNSIGNED_INT:
          case gl.FLOAT:
            return 4;

          case gl.FLOAT_VEC2:
            return 8;

          case gl.FLOAT_VEC3:
            return 12;

          case gl.FLOAT_VEC4:
          case gl.FLOAT_MAT2:
            return 16;

          case gl.FLOAT_MAT3:
            return 36;

          case gl.FLOAT_MAT4:
            return 64;

          case gl.SAMPLER_2D:
          case gl.SAMPLER_CUBE:
            return 4;

          default:
            return console.error("Unsupported GLType, get type failed."), 0;
        }
    }
    function WebGLGetComponentCount(glType, gl) {
        switch (glType) {
          case gl.FLOAT_MAT2:
            return 2;

          case gl.FLOAT_MAT3:
            return 3;

          case gl.FLOAT_MAT4:
            return 4;

          default:
            return 1;
        }
    }
    !function(WebGLEXT) {
        WebGLEXT[WebGLEXT.RGBA16F_EXT = 34842] = "RGBA16F_EXT", WebGLEXT[WebGLEXT.RGB16F_EXT = 34843] = "RGB16F_EXT", 
        WebGLEXT[WebGLEXT.RGBA32F_EXT = 34836] = "RGBA32F_EXT", WebGLEXT[WebGLEXT.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT", 
        WebGLEXT[WebGLEXT.UNSIGNED_NORMALIZED_EXT = 35863] = "UNSIGNED_NORMALIZED_EXT", 
        WebGLEXT[WebGLEXT.UNSIGNED_INT_24_8_WEBGL = 34042] = "UNSIGNED_INT_24_8_WEBGL", 
        WebGLEXT[WebGLEXT.HALF_FLOAT_OES = 36193] = "HALF_FLOAT_OES", WebGLEXT[WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", 
        WebGLEXT[WebGLEXT.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", WebGLEXT[WebGLEXT.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", 
        WebGLEXT[WebGLEXT.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", WebGLEXT[WebGLEXT.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    }(WebGLEXT || (WebGLEXT = {}));
    var WebGLCmd, WebGLCmpFuncs = [ 512, 513, 514, 515, 516, 517, 518, 519 ], WebGLStencilOps = [ 0, 7680, 7681, 7682, 7683, 5386, 34055, 34056 ], WebGLBlendOps = [ 32774, 32778, 32779, 32774, 32774 ], WebGLBlendFactors = [ 0, 1, 770, 772, 771, 773, 768, 774, 769, 775, 776, 32769, 32770, 32771, 32772 ];
    !function(WebGLCmd) {
        WebGLCmd[WebGLCmd.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", WebGLCmd[WebGLCmd.END_RENDER_PASS = 1] = "END_RENDER_PASS", 
        WebGLCmd[WebGLCmd.BIND_STATES = 2] = "BIND_STATES", WebGLCmd[WebGLCmd.DRAW = 3] = "DRAW", 
        WebGLCmd[WebGLCmd.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", WebGLCmd[WebGLCmd.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", 
        WebGLCmd[WebGLCmd.COUNT = 6] = "COUNT";
    }(WebGLCmd || (WebGLCmd = {}));
    var WebGLCmdObject = function WebGLCmdObject(type) {
        _classCallCheck(this, WebGLCmdObject), this.refCount = 0, this.cmdType = type;
    }, WebGLCmdBeginRenderPass = function(_WebGLCmdObject) {
        function WebGLCmdBeginRenderPass() {
            var _this;
            return _classCallCheck(this, WebGLCmdBeginRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdBeginRenderPass).call(this, WebGLCmd.BEGIN_RENDER_PASS))).gpuFramebuffer = null, 
            _this.renderArea = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }, _this.clearFlag = exports.GFXClearFlag.NONE, _this.clearColors = [], _this.clearDepth = 1, 
            _this.clearStencil = 0, _this;
        }
        return _inherits(WebGLCmdBeginRenderPass, _WebGLCmdObject), _createClass(WebGLCmdBeginRenderPass, [ {
            key: "clear",
            value: function clear() {
                this.gpuFramebuffer = null, this.clearColors.length = 0;
            }
        } ]), WebGLCmdBeginRenderPass;
    }(WebGLCmdObject), WebGLCmdBindStates = function(_WebGLCmdObject2) {
        function WebGLCmdBindStates() {
            var _this2;
            return _classCallCheck(this, WebGLCmdBindStates), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdBindStates).call(this, WebGLCmd.BIND_STATES))).gpuPipelineState = null, 
            _this2.gpuBindingLayout = null, _this2.gpuInputAssembler = null, _this2.viewport = null, 
            _this2.scissor = null, _this2.lineWidth = null, _this2.depthBias = null, _this2.blendConstants = null, 
            _this2.depthBounds = null, _this2.stencilWriteMask = null, _this2.stencilCompareMask = null, 
            _this2;
        }
        return _inherits(WebGLCmdBindStates, _WebGLCmdObject2), _createClass(WebGLCmdBindStates, [ {
            key: "clear",
            value: function clear() {
                this.gpuPipelineState = null, this.gpuBindingLayout = null, this.gpuInputAssembler = null, 
                this.viewport = null, this.scissor = null, this.lineWidth = null, this.depthBias = null, 
                this.blendConstants = null, this.depthBounds = null, this.stencilWriteMask = null, 
                this.stencilCompareMask = null;
            }
        } ]), WebGLCmdBindStates;
    }(WebGLCmdObject), WebGLCmdDraw = function(_WebGLCmdObject3) {
        function WebGLCmdDraw() {
            var _this3;
            return _classCallCheck(this, WebGLCmdDraw), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdDraw).call(this, WebGLCmd.DRAW))).drawInfo = {
                vertexCount: 0,
                firstVertex: 0,
                indexCount: 0,
                firstIndex: 0,
                vertexOffset: 0,
                instanceCount: 0,
                firstInstance: 0
            }, _this3;
        }
        return _inherits(WebGLCmdDraw, _WebGLCmdObject3), _createClass(WebGLCmdDraw, [ {
            key: "clear",
            value: function clear() {}
        } ]), WebGLCmdDraw;
    }(WebGLCmdObject), WebGLCmdUpdateBuffer = function(_WebGLCmdObject4) {
        function WebGLCmdUpdateBuffer() {
            var _this4;
            return _classCallCheck(this, WebGLCmdUpdateBuffer), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdUpdateBuffer).call(this, WebGLCmd.UPDATE_BUFFER))).gpuBuffer = null, 
            _this4.buffer = null, _this4.offset = 0, _this4.size = 0, _this4;
        }
        return _inherits(WebGLCmdUpdateBuffer, _WebGLCmdObject4), _createClass(WebGLCmdUpdateBuffer, [ {
            key: "clear",
            value: function clear() {
                this.gpuBuffer = null, this.buffer = null;
            }
        } ]), WebGLCmdUpdateBuffer;
    }(WebGLCmdObject), WebGLCmdCopyBufferToTexture = function(_WebGLCmdObject5) {
        function WebGLCmdCopyBufferToTexture() {
            var _this5;
            return _classCallCheck(this, WebGLCmdCopyBufferToTexture), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdCopyBufferToTexture).call(this, WebGLCmd.COPY_BUFFER_TO_TEXTURE))).gpuBuffer = null, 
            _this5.gpuTexture = null, _this5.dstLayout = null, _this5.regions = [], _this5;
        }
        return _inherits(WebGLCmdCopyBufferToTexture, _WebGLCmdObject5), _createClass(WebGLCmdCopyBufferToTexture, [ {
            key: "clear",
            value: function clear() {
                this.gpuBuffer = null, this.gpuTexture = null, this.dstLayout = null, this.regions.length = 0;
            }
        } ]), WebGLCmdCopyBufferToTexture;
    }(WebGLCmdObject), WebGLCmdPackage = function() {
        function WebGLCmdPackage() {
            _classCallCheck(this, WebGLCmdPackage), this.cmds = new CachedArray(1), this.beginRenderPassCmds = new CachedArray(1), 
            this.bindStatesCmds = new CachedArray(1), this.drawCmds = new CachedArray(1), this.updateBufferCmds = new CachedArray(1), 
            this.copyBufferToTextureCmds = new CachedArray(1);
        }
        return _createClass(WebGLCmdPackage, [ {
            key: "clearCmds",
            value: function clearCmds(allocator) {
                this.beginRenderPassCmds.length && (allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), 
                this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds), 
                this.bindStatesCmds.clear()), this.drawCmds.length && (allocator.drawCmdPool.freeCmds(this.drawCmds), 
                this.drawCmds.clear()), this.updateBufferCmds.length && (allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds), 
                this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), 
                this.copyBufferToTextureCmds.clear()), this.cmds.clear();
            }
        } ]), WebGLCmdPackage;
    }();
    function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
        if (gpuBuffer.usage & exports.GFXBufferUsageBit.UNIFORM) buffer instanceof Float32Array ? gpuBuffer.vf32.set(buffer, offset / Float32Array.BYTES_PER_ELEMENT) : gpuBuffer.vf32.set(new Float32Array(buffer), offset / Float32Array.BYTES_PER_ELEMENT); else if (gpuBuffer.usage & exports.GFXBufferUsageBit.INDIRECT) gpuBuffer.indirects = buffer.drawInfos; else {
            var buff = buffer, gl = device.gl, cache = device.stateCache;
            switch (gpuBuffer.glTarget) {
              case gl.ARRAY_BUFFER:
                device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                device.stateCache.glArrayBuffer = gpuBuffer.glBuffer);
                break;

              case gl.ELEMENT_ARRAY_BUFFER:
                device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer);
                break;

              default:
                return void console.error("Unsupported GFXBufferType, update buffer failed.");
            }
            size === buff.byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buff) : gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
        }
    }
    var cmdIds = new Array(WebGLCmd.COUNT);
    function WebGLCmdFuncExecuteCmds(device, cmdPackage) {
        for (var gl = device.gl, cache = device.stateCache, i = 0; i < WebGLCmd.COUNT; ++i) cmdIds[i] = 0;
        for (var glWrapS, glWrapT, glMinFilter, gpuPipelineState = null, gpuShader = null, isShaderChanged = !1, gpuInputAssembler = null, glPrimitive = gl.TRIANGLES, _i11 = 0; _i11 < cmdPackage.cmds.length; ++_i11) {
            var cmd = cmdPackage.cmds.array[_i11], cmdId = cmdIds[cmd]++;
            switch (cmd) {
              case WebGLCmd.BEGIN_RENDER_PASS:
                var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId], clears = 0;
                if (cmd0.gpuFramebuffer) {
                    cache.glFramebuffer !== cmd0.gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, cmd0.gpuFramebuffer.glFramebuffer), 
                    cache.glFramebuffer = cmd0.gpuFramebuffer.glFramebuffer), cache.viewport.left === cmd0.renderArea.x && cache.viewport.top === cmd0.renderArea.y && cache.viewport.width === cmd0.renderArea.width && cache.viewport.height === cmd0.renderArea.height || (gl.viewport(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                    cache.viewport.left = cmd0.renderArea.x, cache.viewport.top = cmd0.renderArea.y, 
                    cache.viewport.width = cmd0.renderArea.width, cache.viewport.height = cmd0.renderArea.height), 
                    cache.scissorRect.x === cmd0.renderArea.x && cache.scissorRect.y === cmd0.renderArea.y && cache.scissorRect.width === cmd0.renderArea.width && cache.scissorRect.height === cmd0.renderArea.height || (gl.scissor(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                    cache.scissorRect.x = cmd0.renderArea.x, cache.scissorRect.y = cmd0.renderArea.y, 
                    cache.scissorRect.width = cmd0.renderArea.width, cache.scissorRect.height = cmd0.renderArea.height);
                    var curGPURenderPass = cmd0.gpuFramebuffer.gpuRenderPass, clearCount = cmd0.clearColors.length;
                    device.WEBGL_draw_buffers || (clearCount = 1);
                    for (var j = 0; j < clearCount; ++j) {
                        var colorAttachment = curGPURenderPass.colorAttachments[j];
                        if (colorAttachment.format !== exports.GFXFormat.UNKNOWN) switch (colorAttachment.loadOp) {
                          case exports.GFXLoadOp.LOAD:
                            break;

                          case exports.GFXLoadOp.CLEAR:
                            if (cmd0.clearFlag & exports.GFXClearFlag.COLOR) {
                                cache.bs.targets[0].blendColorMask !== exports.GFXColorMask.ALL && gl.colorMask(!0, !0, !0, !0);
                                var clearColor = cmd0.clearColors[0];
                                gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a), clears |= gl.COLOR_BUFFER_BIT;
                            }
                            break;

                          case exports.GFXLoadOp.DISCARD:
                        }
                    }
                    if (curGPURenderPass.depthStencilAttachment && curGPURenderPass.depthStencilAttachment.format !== exports.GFXFormat.UNKNOWN) {
                        switch (curGPURenderPass.depthStencilAttachment.depthLoadOp) {
                          case exports.GFXLoadOp.LOAD:
                            break;

                          case exports.GFXLoadOp.CLEAR:
                            cmd0.clearFlag & exports.GFXClearFlag.DEPTH && (cache.dss.depthWrite || gl.depthMask(!0), 
                            gl.clearDepth(cmd0.clearDepth), clears |= gl.DEPTH_BUFFER_BIT);
                            break;

                          case exports.GFXLoadOp.DISCARD:
                        }
                        if (GFXFormatInfos[curGPURenderPass.depthStencilAttachment.format].hasStencil) switch (curGPURenderPass.depthStencilAttachment.stencilLoadOp) {
                          case exports.GFXLoadOp.LOAD:
                            break;

                          case exports.GFXLoadOp.CLEAR:
                            cmd0.clearFlag & exports.GFXClearFlag.STENCIL && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 65535), 
                            cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 65535), gl.clearStencil(cmd0.clearStencil), 
                            clears |= gl.STENCIL_BUFFER_BIT);
                            break;

                          case exports.GFXLoadOp.DISCARD:
                        }
                    }
                    if (clears && gl.clear(clears), clears & gl.COLOR_BUFFER_BIT) {
                        var colorMask = cache.bs.targets[0].blendColorMask;
                        if (colorMask !== exports.GFXColorMask.ALL) {
                            var r = (colorMask & exports.GFXColorMask.R) !== exports.GFXColorMask.NONE, g = (colorMask & exports.GFXColorMask.G) !== exports.GFXColorMask.NONE, b = (colorMask & exports.GFXColorMask.B) !== exports.GFXColorMask.NONE, a = (colorMask & exports.GFXColorMask.A) !== exports.GFXColorMask.NONE;
                            gl.colorMask(r, g, b, a);
                        }
                    }
                    clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite && gl.depthMask(!1), clears & gl.STENCIL_BUFFER_BIT && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 0), 
                    cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 0));
                }
                break;

              case WebGLCmd.BIND_STATES:
                var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                if (isShaderChanged = !1, cmd2.gpuPipelineState) {
                    if (gpuPipelineState = cmd2.gpuPipelineState, glPrimitive = cmd2.gpuPipelineState.glPrimitive, 
                    cmd2.gpuPipelineState.gpuShader) {
                        var glProgram = cmd2.gpuPipelineState.gpuShader.glProgram;
                        cache.glProgram !== glProgram && (gl.useProgram(glProgram), cache.glProgram = glProgram, 
                        isShaderChanged = !0), gpuShader = cmd2.gpuPipelineState.gpuShader;
                    }
                    var rs = cmd2.gpuPipelineState.rs;
                    if (rs) {
                        if (cache.rs.cullMode !== rs.cullMode) {
                            switch (rs.cullMode) {
                              case exports.GFXCullMode.NONE:
                                gl.disable(gl.CULL_FACE);
                                break;

                              case exports.GFXCullMode.FRONT:
                                gl.enable(gl.CULL_FACE), gl.cullFace(gl.FRONT);
                                break;

                              case exports.GFXCullMode.BACK:
                                gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK);
                            }
                            cache.rs.cullMode = rs.cullMode;
                        }
                        var isFrontFaceCCW = device.reverseCW ? !rs.isFrontFaceCCW : rs.isFrontFaceCCW;
                        cache.rs.isFrontFaceCCW !== isFrontFaceCCW && (gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW), 
                        cache.rs.isFrontFaceCCW = isFrontFaceCCW), cache.rs.depthBias === rs.depthBias && cache.rs.depthBiasSlop === rs.depthBiasSlop || (gl.polygonOffset(rs.depthBias, rs.depthBiasSlop), 
                        cache.rs.depthBias = rs.depthBias, cache.rs.depthBiasSlop = rs.depthBiasSlop), cache.rs.lineWidth !== rs.lineWidth && (gl.lineWidth(rs.lineWidth), 
                        cache.rs.lineWidth = rs.lineWidth);
                    }
                    var dss = cmd2.gpuPipelineState.dss;
                    dss && (cache.dss.depthTest !== dss.depthTest && (dss.depthTest ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST), 
                    cache.dss.depthTest = dss.depthTest), cache.dss.depthWrite !== dss.depthWrite && (gl.depthMask(dss.depthWrite), 
                    cache.dss.depthWrite = dss.depthWrite), cache.dss.depthFunc !== dss.depthFunc && (gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]), 
                    cache.dss.depthFunc = dss.depthFunc), cache.dss.stencilTestFront === dss.stencilTestFront && cache.dss.stencilTestBack === dss.stencilTestBack || (dss.stencilTestFront || dss.stencilTestBack ? gl.enable(gl.STENCIL_TEST) : gl.disable(gl.STENCIL_TEST), 
                    cache.dss.stencilTestFront = dss.stencilTestFront, cache.dss.stencilTestBack = dss.stencilTestBack), 
                    cache.dss.stencilFuncFront === dss.stencilFuncFront && cache.dss.stencilRefFront === dss.stencilRefFront && cache.dss.stencilReadMaskFront === dss.stencilReadMaskFront || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront), 
                    cache.dss.stencilFuncFront = dss.stencilFuncFront, cache.dss.stencilRefFront = dss.stencilRefFront, 
                    cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront), cache.dss.stencilFailOpFront === dss.stencilFailOpFront && cache.dss.stencilZFailOpFront === dss.stencilZFailOpFront && cache.dss.stencilPassOpFront === dss.stencilPassOpFront || (gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]), 
                    cache.dss.stencilFailOpFront = dss.stencilFailOpFront, cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront, 
                    cache.dss.stencilPassOpFront = dss.stencilPassOpFront), cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront && (gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront), 
                    cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront), cache.dss.stencilFuncBack === dss.stencilFuncBack && cache.dss.stencilRefBack === dss.stencilRefBack && cache.dss.stencilReadMaskBack === dss.stencilReadMaskBack || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack), 
                    cache.dss.stencilFuncBack = dss.stencilFuncBack, cache.dss.stencilRefBack = dss.stencilRefBack, 
                    cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack), cache.dss.stencilFailOpBack === dss.stencilFailOpBack && cache.dss.stencilZFailOpBack === dss.stencilZFailOpBack && cache.dss.stencilPassOpBack === dss.stencilPassOpBack || (gl.stencilOpSeparate(gl.BACK, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]), 
                    cache.dss.stencilFailOpBack = dss.stencilFailOpBack, cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack, 
                    cache.dss.stencilPassOpBack = dss.stencilPassOpBack), cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack && (gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack), 
                    cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack));
                    var bs = cmd2.gpuPipelineState.bs;
                    if (bs) {
                        cache.bs.isA2C !== bs.isA2C && (bs.isA2C ? gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
                        cache.bs.isA2C = bs.isA2C), cache.bs.blendColor[0] === bs.blendColor[0] && cache.bs.blendColor[1] === bs.blendColor[1] && cache.bs.blendColor[2] === bs.blendColor[2] && cache.bs.blendColor[3] === bs.blendColor[3] || (gl.blendColor(bs.blendColor[0], bs.blendColor[1], bs.blendColor[2], bs.blendColor[3]), 
                        cache.bs.blendColor[0] = bs.blendColor[0], cache.bs.blendColor[1] = bs.blendColor[1], 
                        cache.bs.blendColor[2] = bs.blendColor[2], cache.bs.blendColor[3] = bs.blendColor[3]);
                        var target0 = bs.targets[0], target0Cache = cache.bs.targets[0];
                        target0Cache.blend !== target0.blend && (target0.blend ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND), 
                        target0Cache.blend = target0.blend), target0Cache.blendEq === target0.blendEq && target0Cache.blendAlphaEq === target0.blendAlphaEq || (gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]), 
                        target0Cache.blendEq = target0.blendEq, target0Cache.blendAlphaEq = target0.blendAlphaEq), 
                        target0Cache.blendSrc === target0.blendSrc && target0Cache.blendDst === target0.blendDst && target0Cache.blendSrcAlpha === target0.blendSrcAlpha && target0Cache.blendDstAlpha === target0.blendDstAlpha || (gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]), 
                        target0Cache.blendSrc = target0.blendSrc, target0Cache.blendDst = target0.blendDst, 
                        target0Cache.blendSrcAlpha = target0.blendSrcAlpha, target0Cache.blendDstAlpha = target0.blendDstAlpha), 
                        target0Cache.blendColorMask !== target0.blendColorMask && (gl.colorMask((target0.blendColorMask & exports.GFXColorMask.R) !== exports.GFXColorMask.NONE, (target0.blendColorMask & exports.GFXColorMask.G) !== exports.GFXColorMask.NONE, (target0.blendColorMask & exports.GFXColorMask.B) !== exports.GFXColorMask.NONE, (target0.blendColorMask & exports.GFXColorMask.A) !== exports.GFXColorMask.NONE), 
                        target0Cache.blendColorMask = target0.blendColorMask);
                    }
                }
                if (cmd2.gpuBindingLayout && gpuShader) for (var bindingLen = cmd2.gpuBindingLayout.gpuBindings.length, _j2 = 0; _j2 < bindingLen; _j2++) {
                    var gpuBinding = cmd2.gpuBindingLayout.gpuBindings[_j2];
                    switch (gpuBinding.type) {
                      case exports.GFXBindingType.UNIFORM_BUFFER:
                        if (gpuBinding.gpuBuffer && gpuBinding.gpuBuffer.buffer) {
                            for (var glBlock = null, blockLen = gpuShader.glBlocks.length, k = 0; k < blockLen; k++) {
                                var block = gpuShader.glBlocks[k];
                                if (block.binding === gpuBinding.binding) {
                                    glBlock = block;
                                    break;
                                }
                            }
                            if (glBlock && gpuBinding.gpuBuffer.vf32) for (var uniformLen = glBlock.glActiveUniforms.length, _k4 = 0; _k4 < uniformLen; _k4++) {
                                var glUniform = glBlock.glActiveUniforms[_k4];
                                switch (glUniform.glType) {
                                  case gl.BOOL:
                                  case gl.INT:
                                    for (var u = 0; u < glUniform.array.length; ++u) {
                                        var idx = glUniform.begin + u;
                                        if (gpuBinding.gpuBuffer.vf32[idx] !== glUniform.array[u]) {
                                            for (var n = u, m = glUniform.begin + u; n < glUniform.array.length; ++n, ++m) glUniform.array[n] = gpuBinding.gpuBuffer.vf32[m];
                                            gl.uniform1iv(glUniform.glLoc, glUniform.array);
                                            break;
                                        }
                                    }
                                    break;

                                  case gl.BOOL_VEC2:
                                  case gl.INT_VEC2:
                                    for (var _u = 0; _u < glUniform.array.length; ++_u) {
                                        var _idx = glUniform.begin + _u;
                                        if (gpuBinding.gpuBuffer.vf32[_idx] !== glUniform.array[_u]) {
                                            for (var _n = _u, _m = glUniform.begin + _u; _n < glUniform.array.length; ++_n, 
                                            ++_m) glUniform.array[_n] = gpuBinding.gpuBuffer.vf32[_m];
                                            gl.uniform2iv(glUniform.glLoc, glUniform.array);
                                            break;
                                        }
                                    }
                                    break;

                                  case gl.BOOL_VEC3:
                                  case gl.INT_VEC3:
                                    for (var _u2 = 0; _u2 < glUniform.array.length; ++_u2) {
                                        var _idx2 = glUniform.begin + _u2;
                                        if (gpuBinding.gpuBuffer.vf32[_idx2] !== glUniform.array[_u2]) {
                                            for (var _n2 = _u2, _m2 = glUniform.begin + _u2; _n2 < glUniform.array.length; ++_n2, 
                                            ++_m2) glUniform.array[_n2] = gpuBinding.gpuBuffer.vf32[_m2];
                                            gl.uniform3iv(glUniform.glLoc, glUniform.array);
                                            break;
                                        }
                                    }
                                    break;

                                  case gl.BOOL_VEC4:
                                  case gl.INT_VEC4:
                                    for (var _u3 = 0; _u3 < glUniform.array.length; ++_u3) {
                                        var _idx3 = glUniform.begin + _u3;
                                        if (gpuBinding.gpuBuffer.vf32[_idx3] !== glUniform.array[_u3]) {
                                            for (var _n3 = _u3, _m3 = glUniform.begin + _u3; _n3 < glUniform.array.length; ++_n3, 
                                            ++_m3) glUniform.array[_n3] = gpuBinding.gpuBuffer.vf32[_m3];
                                            gl.uniform4iv(glUniform.glLoc, glUniform.array);
                                            break;
                                        }
                                    }
                                    break;

                                  case gl.FLOAT:
                                    for (var _u4 = 0; _u4 < glUniform.array.length; ++_u4) {
                                        var _idx4 = glUniform.begin + _u4;
                                        if (gpuBinding.gpuBuffer.vf32[_idx4] !== glUniform.array[_u4]) {
                                            for (var _n4 = _u4, _m4 = glUniform.begin + _u4; _n4 < glUniform.array.length; ++_n4, 
                                            ++_m4) glUniform.array[_n4] = gpuBinding.gpuBuffer.vf32[_m4];
                                            gl.uniform1fv(glUniform.glLoc, glUniform.array);
                                            break;
                                        }
                                    }
                                    break;

                                  case gl.FLOAT_VEC2:
                                    for (var _u5 = 0; _u5 < glUniform.array.length; ++_u5) {
                                        var _idx5 = glUniform.begin + _u5;
                                        if (gpuBinding.gpuBuffer.vf32[_idx5] !== glUniform.array[_u5]) {
                                            for (var _n5 = _u5, _m5 = glUniform.begin + _u5; _n5 < glUniform.array.length; ++_n5, 
                                            ++_m5) glUniform.array[_n5] = gpuBinding.gpuBuffer.vf32[_m5];
                                            gl.uniform2fv(glUniform.glLoc, glUniform.array);
                                            break;
                                        }
                                    }
                                    break;

                                  case gl.FLOAT_VEC3:
                                    for (var _u6 = 0; _u6 < glUniform.array.length; ++_u6) {
                                        var _idx6 = glUniform.begin + _u6;
                                        if (gpuBinding.gpuBuffer.vf32[_idx6] !== glUniform.array[_u6]) {
                                            for (var _n6 = _u6, _m6 = glUniform.begin + _u6; _n6 < glUniform.array.length; ++_n6, 
                                            ++_m6) glUniform.array[_n6] = gpuBinding.gpuBuffer.vf32[_m6];
                                            gl.uniform3fv(glUniform.glLoc, glUniform.array);
                                            break;
                                        }
                                    }
                                    break;

                                  case gl.FLOAT_VEC4:
                                    for (var _u7 = 0; _u7 < glUniform.array.length; ++_u7) {
                                        var _idx7 = glUniform.begin + _u7;
                                        if (gpuBinding.gpuBuffer.vf32[_idx7] !== glUniform.array[_u7]) {
                                            for (var _n7 = _u7, _m7 = glUniform.begin + _u7; _n7 < glUniform.array.length; ++_n7, 
                                            ++_m7) glUniform.array[_n7] = gpuBinding.gpuBuffer.vf32[_m7];
                                            gl.uniform4fv(glUniform.glLoc, glUniform.array);
                                            break;
                                        }
                                    }
                                    break;

                                  case gl.FLOAT_MAT2:
                                    for (var _u8 = 0; _u8 < glUniform.array.length; ++_u8) {
                                        var _idx8 = glUniform.begin + _u8;
                                        if (gpuBinding.gpuBuffer.vf32[_idx8] !== glUniform.array[_u8]) {
                                            for (var _n8 = _u8, _m8 = glUniform.begin + _u8; _n8 < glUniform.array.length; ++_n8, 
                                            ++_m8) glUniform.array[_n8] = gpuBinding.gpuBuffer.vf32[_m8];
                                            gl.uniformMatrix2fv(glUniform.glLoc, !1, glUniform.array);
                                            break;
                                        }
                                    }
                                    break;

                                  case gl.FLOAT_MAT3:
                                    for (var _u9 = 0; _u9 < glUniform.array.length; ++_u9) {
                                        var _idx9 = glUniform.begin + _u9;
                                        if (gpuBinding.gpuBuffer.vf32[_idx9] !== glUniform.array[_u9]) {
                                            for (var _n9 = _u9, _m9 = glUniform.begin + _u9; _n9 < glUniform.array.length; ++_n9, 
                                            ++_m9) glUniform.array[_n9] = gpuBinding.gpuBuffer.vf32[_m9];
                                            gl.uniformMatrix3fv(glUniform.glLoc, !1, glUniform.array);
                                            break;
                                        }
                                    }
                                    break;

                                  case gl.FLOAT_MAT4:
                                    for (var _u10 = 0; _u10 < glUniform.array.length; ++_u10) {
                                        var _idx10 = glUniform.begin + _u10;
                                        if (gpuBinding.gpuBuffer.vf32[_idx10] !== glUniform.array[_u10]) {
                                            for (var _n10 = _u10, _m10 = glUniform.begin + _u10; _n10 < glUniform.array.length; ++_n10, 
                                            ++_m10) glUniform.array[_n10] = gpuBinding.gpuBuffer.vf32[_m10];
                                            gl.uniformMatrix4fv(glUniform.glLoc, !1, glUniform.array);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        break;

                      case exports.GFXBindingType.SAMPLER:
                        if (gpuBinding.gpuSampler) {
                            for (var glSampler = null, samplerLen = gpuShader.glSamplers.length, _k5 = 0; _k5 < samplerLen; _k5++) {
                                var sampler = gpuShader.glSamplers[_k5];
                                if (sampler.binding === gpuBinding.binding) {
                                    glSampler = sampler;
                                    break;
                                }
                            }
                            if (glSampler) for (var texUnitLen = glSampler.units.length, _k6 = 0; _k6 < texUnitLen; _k6++) {
                                var texUnit = glSampler.units[_k6];
                                if (gpuBinding.gpuTexView && gpuBinding.gpuTexView.gpuTexture.size > 0) {
                                    var gpuTexture = gpuBinding.gpuTexView.gpuTexture, glTexUnit = cache.glTexUnits[texUnit];
                                    glTexUnit.glTexture !== gpuTexture.glTexture && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                                    cache.texUnit = texUnit), gpuTexture.glTexture ? gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture) : gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture), 
                                    glTexUnit.glTexture = gpuTexture.glTexture);
                                    var gpuSampler = gpuBinding.gpuSampler;
                                    gpuTexture.isPowerOf2 ? (glWrapS = gpuSampler.glWrapS, glWrapT = gpuSampler.glWrapT) : (glWrapS = gl.CLAMP_TO_EDGE, 
                                    glWrapT = gl.CLAMP_TO_EDGE), glMinFilter = gpuTexture.isPowerOf2 ? gpuTexture.mipLevel <= 1 && (gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR) ? gl.LINEAR : gpuSampler.glMinFilter : gpuSampler.glMinFilter === gl.LINEAR || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR ? gl.LINEAR : gl.NEAREST, 
                                    gpuTexture.glWrapS !== glWrapS && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                                    cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, glWrapS), 
                                    gpuTexture.glWrapS = glWrapS), gpuTexture.glWrapT !== glWrapT && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                                    cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, glWrapT), 
                                    gpuTexture.glWrapT = glWrapT), gpuTexture.glMinFilter !== glMinFilter && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                                    cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, glMinFilter), 
                                    gpuTexture.glMinFilter = glMinFilter), gpuTexture.glMagFilter !== gpuSampler.glMagFilter && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                                    cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter), 
                                    gpuTexture.glMagFilter = gpuSampler.glMagFilter);
                                }
                            }
                        } else console.error("Not found sampler on binding unit " + gpuBinding.binding);
                    }
                }
                if (cmd2.gpuInputAssembler && gpuShader && (isShaderChanged || gpuInputAssembler !== cmd2.gpuInputAssembler)) if (gpuInputAssembler = cmd2.gpuInputAssembler, 
                device.useVAO) {
                    var vao = device.OES_vertex_array_object, ia = device.ANGLE_instanced_arrays, glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);
                    if (!glVAO) {
                        glVAO = vao.createVertexArrayOES(), gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO), 
                        vao.bindVertexArrayOES(glVAO), gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                        for (var glAttrib = void 0, inputLen = gpuShader.glInputs.length, _j3 = 0; _j3 < inputLen; _j3++) {
                            var glInput = gpuShader.glInputs[_j3];
                            glAttrib = null;
                            for (var attribLen = gpuInputAssembler.glAttribs.length, _k7 = 0; _k7 < attribLen; _k7++) {
                                var attrib = gpuInputAssembler.glAttribs[_k7];
                                if (attrib.name === glInput.name) {
                                    glAttrib = attrib;
                                    break;
                                }
                            }
                            if (glAttrib) {
                                gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                                for (var c = 0; c < glAttrib.componentCount; ++c) {
                                    var glLoc = glInput.glLoc + c, attribOffset = glAttrib.offset + glAttrib.size * c;
                                    gl.enableVertexAttribArray(glLoc), cache.glCurrentAttribLocs[glLoc] = !0, gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset), 
                                    ia && ia.vertexAttribDivisorANGLE(glLoc, glAttrib.isInstanced ? 1 : 0);
                                }
                            }
                        }
                        var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                        gpuBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), vao.bindVertexArrayOES(null), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), 
                        cache.glArrayBuffer = null, cache.glElementArrayBuffer = null;
                    }
                    cache.glVAO !== glVAO && (vao.bindVertexArrayOES(glVAO), cache.glVAO = glVAO);
                } else {
                    for (var _a = 0; _a < device.maxVertexAttributes; ++_a) cache.glCurrentAttribLocs[_a] = !1;
                    for (var _inputLen = gpuShader.glInputs.length, _j4 = 0; _j4 < _inputLen; _j4++) {
                        for (var _glInput = gpuShader.glInputs[_j4], _glAttrib = null, _attribLen = gpuInputAssembler.glAttribs.length, _k8 = 0; _k8 < _attribLen; _k8++) {
                            var _attrib = gpuInputAssembler.glAttribs[_k8];
                            if (_attrib.name === _glInput.name) {
                                _glAttrib = _attrib;
                                break;
                            }
                        }
                        if (_glAttrib) {
                            cache.glArrayBuffer !== _glAttrib.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer), 
                            cache.glArrayBuffer = _glAttrib.glBuffer);
                            for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                                var _glLoc2 = _glInput.glLoc + _c, _attribOffset = _glAttrib.offset + _glAttrib.size * _c;
                                !cache.glEnabledAttribLocs[_glLoc2] && _glLoc2 >= 0 && (gl.enableVertexAttribArray(_glLoc2), 
                                cache.glEnabledAttribLocs[_glLoc2] = !0), cache.glCurrentAttribLocs[_glLoc2] = !0, 
                                gl.vertexAttribPointer(_glLoc2, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);
                            }
                        }
                    }
                    var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                    _gpuBuffer && cache.glElementArrayBuffer !== _gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer), 
                    cache.glElementArrayBuffer = _gpuBuffer.glBuffer);
                    for (var _a2 = 0; _a2 < device.maxVertexAttributes; ++_a2) cache.glEnabledAttribLocs[_a2] !== cache.glCurrentAttribLocs[_a2] && (gl.disableVertexAttribArray(_a2), 
                    cache.glEnabledAttribLocs[_a2] = !1);
                }
                if (gpuPipelineState) for (var dsLen = gpuPipelineState.dynamicStates.length, _j5 = 0; _j5 < dsLen; _j5++) {
                    switch (gpuPipelineState.dynamicStates[_j5]) {
                      case exports.GFXDynamicState.VIEWPORT:
                        cmd2.viewport && (cache.viewport.left === cmd2.viewport.left && cache.viewport.top === cmd2.viewport.top && cache.viewport.width === cmd2.viewport.width && cache.viewport.height === cmd2.viewport.height || (gl.viewport(cmd2.viewport.left, cmd2.viewport.top, cmd2.viewport.width, cmd2.viewport.height), 
                        cache.viewport.left = cmd2.viewport.left, cache.viewport.top = cmd2.viewport.top, 
                        cache.viewport.width = cmd2.viewport.width, cache.viewport.height = cmd2.viewport.height));
                        break;

                      case exports.GFXDynamicState.SCISSOR:
                        cmd2.scissor && (cache.scissorRect.x === cmd2.scissor.x && cache.scissorRect.y === cmd2.scissor.y && cache.scissorRect.width === cmd2.scissor.width && cache.scissorRect.height === cmd2.scissor.height || (gl.scissor(cmd2.scissor.x, cmd2.scissor.y, cmd2.scissor.width, cmd2.scissor.height), 
                        cache.scissorRect.x = cmd2.scissor.x, cache.scissorRect.y = cmd2.scissor.y, cache.scissorRect.width = cmd2.scissor.width, 
                        cache.scissorRect.height = cmd2.scissor.height));
                        break;

                      case exports.GFXDynamicState.LINE_WIDTH:
                        cmd2.lineWidth && cache.rs.lineWidth !== cmd2.lineWidth && (gl.lineWidth(cmd2.lineWidth), 
                        cache.rs.lineWidth = cmd2.lineWidth);
                        break;

                      case exports.GFXDynamicState.DEPTH_BIAS:
                        cmd2.depthBias && (cache.rs.depthBias === cmd2.depthBias.constantFactor && cache.rs.depthBiasSlop === cmd2.depthBias.slopeFactor || (gl.polygonOffset(cmd2.depthBias.constantFactor, cmd2.depthBias.slopeFactor), 
                        cache.rs.depthBias = cmd2.depthBias.constantFactor, cache.rs.depthBiasSlop = cmd2.depthBias.slopeFactor));
                        break;

                      case exports.GFXDynamicState.BLEND_CONSTANTS:
                        cmd2.blendConstants && (cache.bs.blendColor[0] === cmd2.blendConstants[0] && cache.bs.blendColor[1] === cmd2.blendConstants[1] && cache.bs.blendColor[2] === cmd2.blendConstants[2] && cache.bs.blendColor[3] === cmd2.blendConstants[3] || (gl.blendColor(cmd2.blendConstants[0], cmd2.blendConstants[1], cmd2.blendConstants[2], cmd2.blendConstants[3]), 
                        cache.bs.blendColor[0] = cmd2.blendConstants[0], cache.bs.blendColor[1] = cmd2.blendConstants[1], 
                        cache.bs.blendColor[2] = cmd2.blendConstants[2], cache.bs.blendColor[3] = cmd2.blendConstants[3]));
                        break;

                      case exports.GFXDynamicState.STENCIL_WRITE_MASK:
                        if (cmd2.stencilWriteMask) switch (cmd2.stencilWriteMask.face) {
                          case exports.GFXStencilFace.FRONT:
                            cache.dss.stencilWriteMaskFront !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.FRONT, cmd2.stencilWriteMask.writeMask), 
                            cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask);
                            break;

                          case exports.GFXStencilFace.BACK:
                            cache.dss.stencilWriteMaskBack !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.BACK, cmd2.stencilWriteMask.writeMask), 
                            cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                            break;

                          case exports.GFXStencilFace.ALL:
                            cache.dss.stencilWriteMaskFront === cmd2.stencilWriteMask.writeMask && cache.dss.stencilWriteMaskBack === cmd2.stencilWriteMask.writeMask || (gl.stencilMask(cmd2.stencilWriteMask.writeMask), 
                            cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask, cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                        }
                        break;

                      case exports.GFXDynamicState.STENCIL_COMPARE_MASK:
                        if (cmd2.stencilCompareMask) switch (cmd2.stencilCompareMask.face) {
                          case exports.GFXStencilFace.FRONT:
                            cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[cache.dss.stencilFuncFront], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                            cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask);
                            break;

                          case exports.GFXStencilFace.BACK:
                            cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                            cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                            break;

                          case exports.GFXStencilFace.ALL:
                            cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask && cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFunc(WebGLCmpFuncs[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                            cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask, 
                            cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                        }
                    }
                }
                break;

              case WebGLCmd.DRAW:
                var cmd3 = cmdPackage.drawCmds.array[cmdId], _ia = device.ANGLE_instanced_arrays;
                if (gpuInputAssembler && gpuShader) if (gpuInputAssembler.gpuIndirectBuffer) for (var diLen = gpuInputAssembler.gpuIndirectBuffer.indirects.length, _j6 = 0; _j6 < diLen; _j6++) {
                    var drawInfo = gpuInputAssembler.gpuIndirectBuffer.indirects[_j6], _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;
                    if (drawInfo.instanceCount && _ia) if (_gpuBuffer2 && drawInfo.indexCount > -1) {
                        var offset = drawInfo.firstIndex * _gpuBuffer2.stride;
                        _ia.drawElementsInstancedANGLE(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
                    } else _ia.drawArraysInstancedANGLE(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount); else if (_gpuBuffer2 && drawInfo.indexCount > -1) {
                        var _offset = drawInfo.firstIndex * _gpuBuffer2.stride;
                        gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                    } else gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                } else {
                    var _gpuBuffer3 = gpuInputAssembler.gpuIndexBuffer;
                    if (cmd3.drawInfo.instanceCount && _ia) if (_gpuBuffer3 && cmd3.drawInfo.indexCount > -1) {
                        var _offset2 = cmd3.drawInfo.firstIndex * _gpuBuffer3.stride;
                        _ia.drawElementsInstancedANGLE(glPrimitive, cmd3.drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset2, cmd3.drawInfo.instanceCount);
                    } else _ia.drawArraysInstancedANGLE(glPrimitive, cmd3.drawInfo.firstVertex, cmd3.drawInfo.vertexCount, cmd3.drawInfo.instanceCount); else if (_gpuBuffer3 && cmd3.drawInfo.indexCount > -1) {
                        var _offset3 = cmd3.drawInfo.firstIndex * _gpuBuffer3.stride;
                        gl.drawElements(glPrimitive, cmd3.drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset3);
                    } else gl.drawArrays(glPrimitive, cmd3.drawInfo.firstVertex, cmd3.drawInfo.vertexCount);
                }
                break;

              case WebGLCmd.UPDATE_BUFFER:
                var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                WebGLCmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                break;

              case WebGLCmd.COPY_BUFFER_TO_TEXTURE:
                var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                WebGLCmdFuncCopyBuffersToTexture(device, [ cmd5.gpuBuffer.buffer ], cmd5.gpuTexture, cmd5.regions);
            }
        }
    }
    function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
        var gl = device.gl, glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
        glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture), 
        glTexUnit.glTexture = gpuTexture.glTexture);
        var m = 0, n = 0, w = 1, h = 1, f = 0, isCompressed = GFXFormatInfos[gpuTexture.format].isCompressed;
        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            for (var i = 0; i < regions.length; i++) {
                var region = regions[i];
                for (w = region.texExtent.width, h = region.texExtent.height, m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) {
                    var pixels = buffers[n++];
                    isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels) : gl.compressedTexImage2D(gl.TEXTURE_2D, m, gpuTexture.glInternelFmt, w, h, 0, pixels) : gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels), 
                    w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                }
            }
            break;

          case gl.TEXTURE_CUBE_MAP:
            for (var _i13 = 0; _i13 < regions.length; _i13++) {
                var _region2 = regions[_i13];
                n = 0;
                var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;
                for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                    w = _region2.texExtent.width, h = _region2.texExtent.height;
                    var mcount = _region2.texSubres.baseMipLevel + _region2.texSubres.levelCount;
                    for (m = _region2.texSubres.baseMipLevel; m < mcount; ++m) {
                        var _pixels = buffers[n++];
                        isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, _pixels) : gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, gpuTexture.glInternelFmt, w, h, 0, _pixels) : gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, _pixels), 
                        w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                    }
                }
            }
            break;

          default:
            console.error("Unsupported GL texture type, copy buffer to texture failed.");
        }
        gpuTexture.flags & exports.GFXTextureFlagBit.GEN_MIPMAP && gl.generateMipmap(gpuTexture.glTarget);
    }
    var WebGLGFXBuffer = function(_GFXBuffer) {
        function WebGLGFXBuffer(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXBuffer).call(this, device)))._gpuBuffer = null, 
            _this._uniformBuffer = null, _this._indirectBuffer = null, _this;
        }
        return _inherits(WebGLGFXBuffer, _GFXBuffer), _createClass(WebGLGFXBuffer, [ {
            key: "gpuBuffer",
            get: function get() {
                return this._gpuBuffer;
            }
        } ]), _createClass(WebGLGFXBuffer, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._usage = info.usage, this._memUsage = info.memUsage, this._size = info.size, 
                this._stride = Math.max(info.stride || this._size, 1), this._count = this._size / this._stride, 
                this._flags = void 0 !== info.flags ? info.flags : exports.GFXBufferFlagBit.NONE, 
                this._usage & exports.GFXBufferUsageBit.INDIRECT ? this._indirectBuffer = {
                    drawInfos: []
                } : this._usage & exports.GFXBufferUsageBit.UNIFORM && this._size > 0 && (this._uniformBuffer = new Uint8Array(this._size)), 
                this._flags & exports.GFXBufferFlagBit.BAKUP_BUFFER && (this._bufferView = new Uint8Array(this._size)), 
                this._gpuBuffer = {
                    usage: info.usage,
                    memUsage: info.memUsage,
                    size: info.size,
                    stride: this._stride,
                    buffer: null,
                    vf32: null,
                    indirects: [],
                    glTarget: 0,
                    glBuffer: null
                }, info.usage & exports.GFXBufferUsageBit.INDIRECT ? this._gpuBuffer.indirects = this._indirectBuffer.drawInfos : this._usage & exports.GFXBufferUsageBit.UNIFORM && (this._gpuBuffer.buffer = this._uniformBuffer), 
                function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
                    var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & exports.GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                    if (gpuBuffer.usage & exports.GFXBufferUsageBit.VERTEX) {
                        gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                        var glBuffer = gl.createBuffer();
                        glBuffer && (gpuBuffer.glBuffer = glBuffer, gpuBuffer.size > 0 && (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                        cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        device.stateCache.glArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, null), device.stateCache.glArrayBuffer = null));
                    } else if (gpuBuffer.usage & exports.GFXBufferUsageBit.INDEX) {
                        gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;
                        var _glBuffer = gl.createBuffer();
                        _glBuffer && (gpuBuffer.glBuffer = _glBuffer, gpuBuffer.size > 0 && (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                        cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null));
                    } else gpuBuffer.usage & exports.GFXBufferUsageBit.UNIFORM ? (gpuBuffer.glTarget = gl.NONE, 
                    gpuBuffer.buffer && (gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer))) : gpuBuffer.usage & exports.GFXBufferUsageBit.INDIRECT ? gpuBuffer.glTarget = gl.NONE : gpuBuffer.usage & exports.GFXBufferUsageBit.TRANSFER_DST ? gpuBuffer.glTarget = gl.NONE : gpuBuffer.usage & exports.GFXBufferUsageBit.TRANSFER_SRC ? gpuBuffer.glTarget = gl.NONE : (console.error("Unsupported GFXBufferType, create buffer failed."), 
                    gpuBuffer.glTarget = gl.NONE);
                }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize += this._size, 
                this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuBuffer && (!function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
                    gpuBuffer.glBuffer && (device.gl.deleteBuffer(gpuBuffer.glBuffer), gpuBuffer.glBuffer = null);
                }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= this._size, 
                this._gpuBuffer = null), this._bufferView = null, this._status = exports.GFXStatus.UNREADY;
            }
        }, {
            key: "resize",
            value: function resize(size) {
                var oldSize = this._size;
                if (this._size = size, this._count = this._size / this._stride, this._uniformBuffer && (this._uniformBuffer = new Uint8Array(this._size)), 
                this._bufferView && oldSize !== size) {
                    var oldView = this._bufferView;
                    this._bufferView = new Uint8Array(this._size), this._bufferView.set(oldView), this._gpuBuffer && (this._gpuBuffer.buffer = this._bufferView);
                }
                this._gpuBuffer && (this._uniformBuffer && (this._gpuBuffer.buffer = this._uniformBuffer), 
                this._gpuBuffer.size = this._size, this._size > 0 && (!function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
                    var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & exports.GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                    gpuBuffer.usage & exports.GFXBufferUsageBit.VERTEX ? (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                    cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    gpuBuffer.buffer ? gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage) : gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(gl.ARRAY_BUFFER, null), device.stateCache.glArrayBuffer = null) : gpuBuffer.usage & exports.GFXBufferUsageBit.INDEX ? (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                    cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    gpuBuffer.buffer ? gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage) : gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null) : gpuBuffer.usage & exports.GFXBufferUsageBit.UNIFORM ? gpuBuffer.buffer && (gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer)) : gpuBuffer.usage & exports.GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & exports.GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & exports.GFXBufferUsageBit.TRANSFER_SRC ? gpuBuffer.glTarget = gl.NONE : (console.error("Unsupported GFXBufferType, create buffer failed."), 
                    gpuBuffer.glTarget = gl.NONE);
                }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= oldSize, 
                this._device.memoryStatus.bufferSize += this._size, this._bufferView && (this._device.memoryStatus.bufferSize -= oldSize, 
                this._device.memoryStatus.bufferSize += this._size)));
            }
        }, {
            key: "update",
            value: function update(buffer, offset, size) {
                var buffSize;
                if (buffSize = void 0 !== size ? size : this._usage & exports.GFXBufferUsageBit.INDIRECT ? 0 : buffer.byteLength, 
                this._bufferView && buffer !== this._bufferView.buffer) {
                    var view = new Uint8Array(buffer, 0, size);
                    this._bufferView.set(view, offset);
                }
                WebGLCmdFuncUpdateBuffer(this._device, this._gpuBuffer, buffer, offset || 0, buffSize);
            }
        } ]), WebGLGFXBuffer;
    }(GFXBuffer), WebGLGFXCommandPool = function() {
        function WebGLGFXCommandPool(clazz, count) {
            _classCallCheck(this, WebGLGFXCommandPool), this._freeIdx = 0, this._frees = new Array(count), 
            this._freeCmds = new CachedArray(count);
            for (var i = 0; i < count; ++i) this._frees[i] = new clazz;
            this._freeIdx = count - 1;
        }
        return _createClass(WebGLGFXCommandPool, [ {
            key: "alloc",
            value: function alloc(clazz) {
                if (this._freeIdx < 0) {
                    var size = 2 * this._frees.length, temp = this._frees;
                    this._frees = new Array(size);
                    for (var increase = size - temp.length, i = 0; i < increase; ++i) this._frees[i] = new clazz;
                    for (var _i = increase, j = 0; _i < size; ++_i, ++j) this._frees[_i] = temp[j];
                    this._freeIdx += increase;
                }
                var cmd = this._frees[this._freeIdx];
                return this._frees[this._freeIdx--] = null, ++cmd.refCount, cmd;
            }
        }, {
            key: "free",
            value: function free(cmd) {
                0 == --cmd.refCount && this._freeCmds.push(cmd);
            }
        }, {
            key: "freeCmds",
            value: function freeCmds(cmds) {
                for (var i = 0; i < cmds.length; ++i) 0 == --cmds.array[i].refCount && this._freeCmds.push(cmds.array[i]);
            }
        }, {
            key: "release",
            value: function release() {
                for (var i = 0; i < this._freeCmds.length; ++i) {
                    var cmd = this._freeCmds.array[i];
                    cmd.clear(), this._frees[++this._freeIdx] = cmd;
                }
                this._freeCmds.clear();
            }
        } ]), WebGLGFXCommandPool;
    }(), WebGLGFXCommandAllocator = function(_GFXCommandAllocator) {
        function WebGLGFXCommandAllocator(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXCommandAllocator).call(this, device))).beginRenderPassCmdPool = new WebGLGFXCommandPool(WebGLCmdBeginRenderPass, 1), 
            _this.bindStatesCmdPool = new WebGLGFXCommandPool(WebGLCmdBindStates, 1), _this.drawCmdPool = new WebGLGFXCommandPool(WebGLCmdDraw, 1), 
            _this.updateBufferCmdPool = new WebGLGFXCommandPool(WebGLCmdUpdateBuffer, 1), _this.copyBufferToTextureCmdPool = new WebGLGFXCommandPool(WebGLCmdCopyBufferToTexture, 1), 
            _this;
        }
        return _inherits(WebGLGFXCommandAllocator, _GFXCommandAllocator), _createClass(WebGLGFXCommandAllocator, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._status = exports.GFXStatus.UNREADY;
            }
        }, {
            key: "clearCmds",
            value: function clearCmds(cmdPackage) {
                cmdPackage.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds), 
                cmdPackage.beginRenderPassCmds.clear()), cmdPackage.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds), 
                cmdPackage.bindStatesCmds.clear()), cmdPackage.drawCmds.length && (this.drawCmdPool.freeCmds(cmdPackage.drawCmds), 
                cmdPackage.drawCmds.clear()), cmdPackage.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds), 
                cmdPackage.updateBufferCmds.clear()), cmdPackage.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds), 
                cmdPackage.copyBufferToTextureCmds.clear()), cmdPackage.cmds.clear();
            }
        }, {
            key: "releaseCmds",
            value: function releaseCmds() {
                this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), 
                this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release();
            }
        } ]), WebGLGFXCommandAllocator;
    }(GFXCommandAllocator), WebGLGFXCommandBuffer = function(_GFXCommandBuffer) {
        function WebGLGFXCommandBuffer(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXCommandBuffer).call(this, device))).cmdPackage = new WebGLCmdPackage, 
            _this._webGLAllocator = null, _this._isInRenderPass = !1, _this._curGPUPipelineState = null, 
            _this._curGPUBindingLayout = null, _this._curGPUInputAssembler = null, _this._curViewport = null, 
            _this._curScissor = null, _this._curLineWidth = null, _this._curDepthBias = null, 
            _this._curBlendConstants = [], _this._curDepthBounds = null, _this._curStencilWriteMask = null, 
            _this._curStencilCompareMask = null, _this._isStateInvalied = !1, _this;
        }
        return _inherits(WebGLGFXCommandBuffer, _GFXCommandBuffer), _createClass(WebGLGFXCommandBuffer, [ {
            key: "initialize",
            value: function initialize(info) {
                return !!info.allocator && (this._allocator = info.allocator, this._webGLAllocator = this._allocator, 
                this._type = info.type, this._status = exports.GFXStatus.SUCCESS, !0);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._webGLAllocator && (this._webGLAllocator.clearCmds(this.cmdPackage), this._allocator = null, 
                this._webGLAllocator = null), this._status = exports.GFXStatus.UNREADY;
            }
        }, {
            key: "begin",
            value: function begin() {
                this._webGLAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, 
                this._curGPUBindingLayout = null, this._curGPUInputAssembler = null, this._curViewport = null, 
                this._curScissor = null, this._curLineWidth = null, this._curDepthBias = null, this._curBlendConstants = [], 
                this._curDepthBounds = null, this._curStencilWriteMask = null, this._curStencilCompareMask = null, 
                this._numDrawCalls = 0, this._numTris = 0;
            }
        }, {
            key: "end",
            value: function end() {
                this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1;
            }
        }, {
            key: "beginRenderPass",
            value: function beginRenderPass(framebuffer, renderArea, clearFlag, clearColors, clearDepth, clearStencil) {
                var cmd = this._webGLAllocator.beginRenderPassCmdPool.alloc(WebGLCmdBeginRenderPass);
                cmd.gpuFramebuffer = framebuffer.gpuFramebuffer, cmd.renderArea = renderArea, cmd.clearFlag = clearFlag, 
                cmd.clearColors.length = clearColors.length;
                for (var i = 0; i < clearColors.length; ++i) cmd.clearColors[i] = clearColors[i];
                cmd.clearDepth = clearDepth, cmd.clearStencil = clearStencil, this.cmdPackage.beginRenderPassCmds.push(cmd), 
                this.cmdPackage.cmds.push(WebGLCmd.BEGIN_RENDER_PASS), this._isInRenderPass = !0;
            }
        }, {
            key: "endRenderPass",
            value: function endRenderPass() {
                this._isInRenderPass = !1;
            }
        }, {
            key: "bindPipelineState",
            value: function bindPipelineState(pipelineState) {
                var gpuPipelineState = pipelineState.gpuPipelineState;
                this._curGPUPipelineState = gpuPipelineState, this._isStateInvalied = !0;
            }
        }, {
            key: "bindBindingLayout",
            value: function bindBindingLayout(bindingLayout) {
                var gpuBindingLayout = bindingLayout.gpuBindingLayout;
                this._curGPUBindingLayout = gpuBindingLayout, this._isStateInvalied = !0;
            }
        }, {
            key: "bindInputAssembler",
            value: function bindInputAssembler(inputAssembler) {
                var gpuInputAssembler = inputAssembler.gpuInputAssembler;
                this._curGPUInputAssembler = gpuInputAssembler, this._isStateInvalied = !0;
            }
        }, {
            key: "setViewport",
            value: function setViewport(viewport) {
                this._curViewport ? this._curViewport.left === viewport.left && this._curViewport.top === viewport.top && this._curViewport.width === viewport.width && this._curViewport.height === viewport.height && this._curViewport.minDepth === viewport.minDepth && this._curViewport.maxDepth === viewport.maxDepth || (this._curViewport.left = viewport.left, 
                this._curViewport.top = viewport.top, this._curViewport.width = viewport.width, 
                this._curViewport.height = viewport.height, this._curViewport.minDepth = viewport.minDepth, 
                this._curViewport.maxDepth = viewport.maxDepth, this._isStateInvalied = !0) : this._curViewport = {
                    left: viewport.left,
                    top: viewport.top,
                    width: viewport.width,
                    height: viewport.height,
                    minDepth: viewport.minDepth,
                    maxDepth: viewport.maxDepth
                }, this._curViewport !== viewport && (this._curViewport = viewport, this._isStateInvalied = !0);
            }
        }, {
            key: "setScissor",
            value: function setScissor(scissor) {
                this._curScissor ? this._curScissor.x === scissor.x && this._curScissor.y === scissor.y && this._curScissor.width === scissor.width && this._curScissor.height === scissor.height || (this._curScissor.x = scissor.x, 
                this._curScissor.y = scissor.y, this._curScissor.width = scissor.width, this._curScissor.height = scissor.height, 
                this._isStateInvalied = !0) : this._curScissor = {
                    x: scissor.x,
                    y: scissor.y,
                    width: scissor.width,
                    height: scissor.height
                };
            }
        }, {
            key: "setLineWidth",
            value: function setLineWidth(lineWidth) {
                this._curLineWidth !== lineWidth && (this._curLineWidth = lineWidth, this._isStateInvalied = !0);
            }
        }, {
            key: "setDepthBias",
            value: function setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
                this._curDepthBias ? this._curDepthBias.constantFactor === depthBiasConstantFactor && this._curDepthBias.clamp === depthBiasClamp && this._curDepthBias.slopeFactor === depthBiasSlopeFactor || (this._curDepthBias.constantFactor = depthBiasConstantFactor, 
                this._curDepthBias.clamp = depthBiasClamp, this._curDepthBias.slopeFactor = depthBiasSlopeFactor, 
                this._isStateInvalied = !0) : (this._curDepthBias = {
                    constantFactor: depthBiasConstantFactor,
                    clamp: depthBiasClamp,
                    slopeFactor: depthBiasSlopeFactor
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "setBlendConstants",
            value: function setBlendConstants(blendConstants) {
                (this._curBlendConstants || 4 !== blendConstants.length) && (4 !== blendConstants.length || this._curBlendConstants[0] === blendConstants[0] && this._curBlendConstants[1] === blendConstants[1] && this._curBlendConstants[2] === blendConstants[2] && this._curBlendConstants[3] === blendConstants[3]) || (this._curBlendConstants = [ blendConstants[0], blendConstants[1], blendConstants[2], blendConstants[3] ], 
                this._isStateInvalied = !0);
            }
        }, {
            key: "setDepthBound",
            value: function setDepthBound(minDepthBounds, maxDepthBounds) {
                this._curDepthBounds && this._curDepthBounds.minBounds === minDepthBounds && this._curDepthBounds.maxBounds === maxDepthBounds || (this._curDepthBounds = {
                    minBounds: minDepthBounds,
                    maxBounds: maxDepthBounds
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "setStencilWriteMask",
            value: function setStencilWriteMask(face, writeMask) {
                this._curStencilWriteMask ? this._curStencilWriteMask.face === face && this._curStencilWriteMask.writeMask === writeMask || (this._curStencilWriteMask.face = face, 
                this._curStencilWriteMask.writeMask = writeMask, this._isStateInvalied = !0) : (this._curStencilWriteMask = {
                    face: face,
                    writeMask: writeMask
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "setStencilCompareMask",
            value: function setStencilCompareMask(face, reference, compareMask) {
                this._curStencilCompareMask ? this._curStencilCompareMask.face === face && this._curStencilCompareMask.reference === reference && this._curStencilCompareMask.compareMask === compareMask || (this._curStencilCompareMask.face = face, 
                this._curStencilCompareMask.reference = reference, this._curStencilCompareMask.compareMask = compareMask, 
                this._isStateInvalied = !0) : (this._curStencilCompareMask = {
                    face: face,
                    reference: reference,
                    compareMask: compareMask
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "draw",
            value: function draw(inputAssembler) {
                if (this._type === exports.GFXCommandBufferType.PRIMARY && this._isInRenderPass || this._type === exports.GFXCommandBufferType.SECONDARY) {
                    this._isStateInvalied && this.bindStates();
                    var cmd = this._allocator.drawCmdPool.alloc(WebGLCmdDraw);
                    inputAssembler.extractCmdDraw(cmd), this.cmdPackage.drawCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.DRAW), 
                    ++this._numDrawCalls;
                    var indexCount = inputAssembler.indexCount || inputAssembler.vertexCount;
                    if (this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                      case 4:
                        this._numTris += indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                        break;

                      case 5:
                      case 6:
                        this._numTris += (indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                    }
                } else console.error("Command 'draw' must be recorded inside a render pass.");
            }
        }, {
            key: "updateBuffer",
            value: function updateBuffer(buffer, data, offset, size) {
                if (this._type === exports.GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === exports.GFXCommandBufferType.SECONDARY) {
                    var gpuBuffer = buffer.gpuBuffer;
                    if (gpuBuffer) {
                        var cmd = this._webGLAllocator.updateBufferCmdPool.alloc(WebGLCmdUpdateBuffer);
                        if (cmd) {
                            var buffSize;
                            buffSize = void 0 !== size ? size : buffer.usage & exports.GFXBufferUsageBit.INDIRECT ? 0 : data.byteLength;
                            var buff = data;
                            cmd.gpuBuffer = gpuBuffer, cmd.buffer = buff, cmd.offset = void 0 !== offset ? offset : 0, 
                            cmd.size = buffSize, this.cmdPackage.updateBufferCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.UPDATE_BUFFER);
                        }
                    }
                } else console.error("Command 'updateBuffer' must be recorded outside a render pass.");
            }
        }, {
            key: "copyBufferToTexture",
            value: function copyBufferToTexture(srcBuff, dstTex, dstLayout, regions) {
                if (this._type === exports.GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === exports.GFXCommandBufferType.SECONDARY) {
                    var gpuBuffer = srcBuff.gpuBuffer, gpuTexture = dstTex.gpuTexture;
                    if (gpuBuffer && gpuTexture) {
                        var cmd = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(WebGLCmdCopyBufferToTexture);
                        cmd && (cmd.gpuBuffer = gpuBuffer, cmd.gpuTexture = gpuTexture, cmd.dstLayout = dstLayout, 
                        cmd.regions = regions, this.cmdPackage.copyBufferToTextureCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.COPY_BUFFER_TO_TEXTURE));
                    }
                } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
            }
        }, {
            key: "execute",
            value: function execute(cmdBuffs, count) {
                for (var i = 0; i < count; ++i) {
                    for (var webGLCmdBuff = cmdBuffs[i], c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                        var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                        ++cmd.refCount, this.cmdPackage.beginRenderPassCmds.push(cmd);
                    }
                    for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                        var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
                        ++_cmd.refCount, this.cmdPackage.bindStatesCmds.push(_cmd);
                    }
                    for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                        var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
                        ++_cmd2.refCount, this.cmdPackage.drawCmds.push(_cmd2);
                    }
                    for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                        var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                        ++_cmd3.refCount, this.cmdPackage.updateBufferCmds.push(_cmd3);
                    }
                    for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                        var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                        ++_cmd4.refCount, this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                    }
                    this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds.array), this._numDrawCalls += webGLCmdBuff._numDrawCalls, 
                    this._numTris += webGLCmdBuff._numTris;
                }
            }
        }, {
            key: "bindStates",
            value: function bindStates() {
                var bindStatesCmd = this._webGLAllocator.bindStatesCmdPool.alloc(WebGLCmdBindStates);
                bindStatesCmd && (bindStatesCmd.gpuPipelineState = this._curGPUPipelineState, bindStatesCmd.gpuBindingLayout = this._curGPUBindingLayout, 
                bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler, bindStatesCmd.viewport = this._curViewport, 
                bindStatesCmd.scissor = this._curScissor, bindStatesCmd.lineWidth = this._curLineWidth, 
                bindStatesCmd.depthBias = this._curDepthBias, bindStatesCmd.blendConstants = this._curBlendConstants, 
                bindStatesCmd.depthBounds = this._curDepthBounds, bindStatesCmd.stencilWriteMask = this._curStencilWriteMask, 
                bindStatesCmd.stencilCompareMask = this._curStencilCompareMask, this.cmdPackage.bindStatesCmds.push(bindStatesCmd), 
                this.cmdPackage.cmds.push(WebGLCmd.BIND_STATES), this._isStateInvalied = !1);
            }
        }, {
            key: "webGLDevice",
            get: function get() {
                return this._device;
            }
        } ]), WebGLGFXCommandBuffer;
    }(GFXCommandBuffer), WebGLGFXFramebuffer = function(_GFXFramebuffer) {
        function WebGLGFXFramebuffer(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXFramebuffer).call(this, device)))._gpuFramebuffer = null, 
            _this;
        }
        return _inherits(WebGLGFXFramebuffer, _GFXFramebuffer), _createClass(WebGLGFXFramebuffer, [ {
            key: "gpuFramebuffer",
            get: function get() {
                return this._gpuFramebuffer;
            }
        } ]), _createClass(WebGLGFXFramebuffer, [ {
            key: "initialize",
            value: function initialize(info) {
                if (this._renderPass = info.renderPass, this._colorViews = info.colorViews || [], 
                this._depthStencilView = info.depthStencilView || null, this._isOffscreen = void 0 === info.isOffscreen || info.isOffscreen, 
                this._isOffscreen) {
                    var gpuColorViews = [];
                    if (void 0 !== info.colorViews) {
                        var _iterator = info.colorViews, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var colorView = _ref;
                            gpuColorViews.push(colorView.gpuTextureView);
                        }
                    }
                    var gpuDepthStencilView = null;
                    info.depthStencilView && (gpuDepthStencilView = info.depthStencilView.gpuTextureView), 
                    this._gpuFramebuffer = {
                        gpuRenderPass: info.renderPass.gpuRenderPass,
                        gpuColorViews: gpuColorViews,
                        gpuDepthStencilView: gpuDepthStencilView,
                        isOffscreen: this._isOffscreen,
                        glFramebuffer: null
                    }, function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
                        if (gpuFramebuffer.isOffscreen) {
                            var gl = device.gl, attachments = [], glFramebuffer = gl.createFramebuffer();
                            if (glFramebuffer) {
                                gpuFramebuffer.glFramebuffer = glFramebuffer, device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                                device.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                                for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
                                    var cv = gpuFramebuffer.gpuColorViews[i];
                                    cv && (cv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, cv.gpuTexture.glTarget, cv.gpuTexture.glTexture, cv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, cv.gpuTexture.glRenderbuffer), 
                                    attachments.push(gl.COLOR_ATTACHMENT0 + i));
                                }
                                var dsv = gpuFramebuffer.gpuDepthStencilView;
                                if (dsv) {
                                    var glAttachment = GFXFormatInfos[dsv.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                                    dsv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dsv.gpuTexture.glTarget, dsv.gpuTexture.glTexture, dsv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dsv.gpuTexture.glRenderbuffer);
                                }
                                device.WEBGL_draw_buffers && device.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
                                var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                                if (status !== gl.FRAMEBUFFER_COMPLETE) switch (status) {
                                  case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                                    break;

                                  case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                                    break;

                                  case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                                    break;

                                  case gl.FRAMEBUFFER_UNSUPPORTED:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED");
                                }
                            }
                        }
                    }(this._device, this._gpuFramebuffer);
                } else this._gpuFramebuffer = {
                    gpuRenderPass: info.renderPass.gpuRenderPass,
                    gpuColorViews: [],
                    gpuDepthStencilView: null,
                    isOffscreen: !1,
                    glFramebuffer: null
                };
                return this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._isOffscreen && this._gpuFramebuffer && function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
                    gpuFramebuffer.glFramebuffer && (device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer), 
                    gpuFramebuffer.glFramebuffer = null);
                }(this._device, this._gpuFramebuffer), this._gpuFramebuffer = null, this._status = exports.GFXStatus.UNREADY;
            }
        } ]), WebGLGFXFramebuffer;
    }(GFXFramebuffer), WebGLGFXInputAssembler = function(_GFXInputAssembler) {
        function WebGLGFXInputAssembler(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXInputAssembler).call(this, device)))._gpuInputAssembler = null, 
            _this;
        }
        return _inherits(WebGLGFXInputAssembler, _GFXInputAssembler), _createClass(WebGLGFXInputAssembler, [ {
            key: "gpuInputAssembler",
            get: function get() {
                return this._gpuInputAssembler;
            }
        } ]), _createClass(WebGLGFXInputAssembler, [ {
            key: "initialize",
            value: function initialize(info) {
                if (0 === info.vertexBuffers.length) return console.error("GFXInputAssemblerInfo.vertexBuffers is null."), 
                !1;
                if (this._attributes = info.attributes, this._vertexBuffers = info.vertexBuffers, 
                void 0 !== info.indexBuffer) this._indexBuffer = info.indexBuffer, this._indexCount = this._indexBuffer.size / this._indexBuffer.stride; else {
                    var vertBuff = this._vertexBuffers[0];
                    this._vertexCount = vertBuff.size / vertBuff.stride;
                }
                this._indirectBuffer = info.indirectBuffer || null;
                for (var gpuVertexBuffers = new Array(info.vertexBuffers.length), i = 0; i < info.vertexBuffers.length; ++i) {
                    var vb = info.vertexBuffers[i];
                    vb.gpuBuffer && (gpuVertexBuffers[i] = vb.gpuBuffer);
                }
                var gpuIndexBuffer = null, glIndexType = 0;
                if (info.indexBuffer && (gpuIndexBuffer = info.indexBuffer.gpuBuffer)) switch (gpuIndexBuffer.stride) {
                  case 1:
                    glIndexType = 5121;
                    break;

                  case 2:
                    glIndexType = 5123;
                    break;

                  case 4:
                    glIndexType = 5125;
                    break;

                  default:
                    console.error("Error index buffer stride.");
                }
                var gpuIndirectBuffer = null;
                return void 0 !== info.indirectBuffer && (gpuIndirectBuffer = info.indirectBuffer.gpuBuffer), 
                this._gpuInputAssembler = {
                    attributes: info.attributes,
                    gpuVertexBuffers: gpuVertexBuffers,
                    gpuIndexBuffer: gpuIndexBuffer,
                    gpuIndirectBuffer: gpuIndirectBuffer,
                    glAttribs: [],
                    glIndexType: glIndexType,
                    glVAOs: new Map
                }, function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
                    var gl = device.gl;
                    gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
                    for (var offsets = [ 0, 0, 0, 0, 0, 0, 0, 0 ], i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                        var attrib = gpuInputAssembler.attributes[i], stream = void 0 !== attrib.stream ? attrib.stream : 0, gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream], glType = GFXFormatToWebGLType(attrib.format, gl), size = GFXFormatInfos[attrib.format].size;
                        gpuInputAssembler.glAttribs[i] = {
                            name: attrib.name,
                            glBuffer: gpuBuffer.glBuffer,
                            glType: glType,
                            size: size,
                            count: GFXFormatInfos[attrib.format].count,
                            stride: gpuBuffer.stride,
                            componentCount: WebGLGetComponentCount(glType, gl),
                            isNormalized: void 0 !== attrib.isNormalized && attrib.isNormalized,
                            isInstanced: void 0 !== attrib.isInstanced && attrib.isInstanced,
                            offset: offsets[stream]
                        }, offsets[stream] += size;
                    }
                }(this._device, this._gpuInputAssembler), this._status = exports.GFXStatus.SUCCESS, 
                !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var webglDev = this._device;
                this._gpuInputAssembler && webglDev.useVAO && function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
                    for (var it = gpuInputAssembler.glVAOs.values(), res = it.next(); !res.done; ) device.OES_vertex_array_object.deleteVertexArrayOES(res.value), 
                    res = it.next();
                    gpuInputAssembler.glVAOs.clear();
                }(webglDev, this._gpuInputAssembler), this._gpuInputAssembler = null, this._status = exports.GFXStatus.UNREADY;
            }
        }, {
            key: "extractCmdDraw",
            value: function extractCmdDraw(cmd) {
                cmd.drawInfo.vertexCount = this._vertexCount, cmd.drawInfo.firstVertex = this._firstVertex, 
                cmd.drawInfo.indexCount = this._indexCount, cmd.drawInfo.firstIndex = this._firstIndex, 
                cmd.drawInfo.vertexOffset = this._vertexOffset, cmd.drawInfo.instanceCount = this._instanceCount, 
                cmd.drawInfo.firstInstance = this._firstInstance;
            }
        } ]), WebGLGFXInputAssembler;
    }(GFXInputAssembler), WebGLGFXPipelineLayout = function(_GFXPipelineLayout) {
        function WebGLGFXPipelineLayout(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXPipelineLayout).call(this, device)))._gpuPipelineLayout = null, 
            _this;
        }
        return _inherits(WebGLGFXPipelineLayout, _GFXPipelineLayout), _createClass(WebGLGFXPipelineLayout, [ {
            key: "gpuPipelineLayout",
            get: function get() {
                return this._gpuPipelineLayout;
            }
        } ]), _createClass(WebGLGFXPipelineLayout, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._layouts = info.layouts, this._pushConstantsRanges = info.pushConstantsRanges || [], 
                this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._status = exports.GFXStatus.UNREADY;
            }
        } ]), WebGLGFXPipelineLayout;
    }(GFXPipelineLayout), WebGLPrimitives = [ 0, 1, 3, 2, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0 ], WebGLGFXPipelineState = function(_GFXPipelineState) {
        function WebGLGFXPipelineState(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXPipelineState).call(this, device)))._gpuPipelineState = null, 
            _this;
        }
        return _inherits(WebGLGFXPipelineState, _GFXPipelineState), _createClass(WebGLGFXPipelineState, [ {
            key: "gpuPipelineState",
            get: function get() {
                return this._gpuPipelineState;
            }
        } ]), _createClass(WebGLGFXPipelineState, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._primitive = info.primitive, this._shader = info.shader, this._is = info.inputState, 
                this._rs = info.rasterizerState, this._dss = info.depthStencilState, this._bs = info.blendState, 
                this._dynamicStates = info.dynamicStates || [], this._hash = info.hash, this._layout = info.layout, 
                this._renderPass = info.renderPass, this._gpuPipelineState = {
                    glPrimitive: WebGLPrimitives[info.primitive],
                    gpuShader: info.shader.gpuShader,
                    rs: info.rasterizerState,
                    dss: info.depthStencilState,
                    bs: info.blendState,
                    dynamicStates: void 0 !== info.dynamicStates ? info.dynamicStates : [],
                    gpuLayout: info.layout.gpuPipelineLayout,
                    gpuRenderPass: info.renderPass.gpuRenderPass
                }, this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuPipelineState = null, this._status = exports.GFXStatus.UNREADY;
            }
        } ]), WebGLGFXPipelineState;
    }(GFXPipelineState), WebGLGFXQueue = function(_GFXQueue) {
        function WebGLGFXQueue(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXQueue).call(this, device))).numDrawCalls = 0, 
            _this.numTris = 0, _this._isAsync = !1, _this;
        }
        return _inherits(WebGLGFXQueue, _GFXQueue), _createClass(WebGLGFXQueue, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._type = info.type, this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._status = exports.GFXStatus.UNREADY;
            }
        }, {
            key: "submit",
            value: function submit(cmdBuffs, fence) {
                if (!this._isAsync) for (var len = cmdBuffs.length, i = 0; i < len; i++) {
                    var cmdBuff = cmdBuffs[i];
                    WebGLCmdFuncExecuteCmds(this._device, cmdBuff.cmdPackage), this.numDrawCalls += cmdBuff.numDrawCalls, 
                    this.numTris += cmdBuff.numTris;
                }
            }
        }, {
            key: "clear",
            value: function clear() {
                this.numDrawCalls = 0, this.numTris = 0;
            }
        } ]), WebGLGFXQueue;
    }(GFXQueue), WebGLGFXRenderPass = function(_GFXRenderPass) {
        function WebGLGFXRenderPass(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXRenderPass).call(this, device)))._gpuRenderPass = null, 
            _this;
        }
        return _inherits(WebGLGFXRenderPass, _GFXRenderPass), _createClass(WebGLGFXRenderPass, [ {
            key: "gpuRenderPass",
            get: function get() {
                return this._gpuRenderPass;
            }
        } ]), _createClass(WebGLGFXRenderPass, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._colorInfos = info.colorAttachments || [], this._depthStencilInfo = info.depthStencilAttachment || null, 
                this._gpuRenderPass = {
                    colorAttachments: this._colorInfos,
                    depthStencilAttachment: this._depthStencilInfo
                }, this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuRenderPass = null, this._status = exports.GFXStatus.UNREADY;
            }
        } ]), WebGLGFXRenderPass;
    }(GFXRenderPass), WebGLWraps = [ 10497, 33648, 33071, 33071 ], WebGLGFXSampler = function(_GFXSampler) {
        function WebGLGFXSampler(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXSampler).call(this, device)))._gpuSampler = null, 
            _this._state = new GFXSamplerState, _this;
        }
        return _inherits(WebGLGFXSampler, _GFXSampler), _createClass(WebGLGFXSampler, [ {
            key: "gpuSampler",
            get: function get() {
                return this._gpuSampler;
            }
        } ]), _createClass(WebGLGFXSampler, [ {
            key: "initialize",
            value: function initialize(info) {
                void 0 !== info.name && (this._state.name = info.name), void 0 !== info.minFilter && (this._state.minFilter = info.minFilter), 
                void 0 !== info.magFilter && (this._state.magFilter = info.magFilter), void 0 !== info.mipFilter && (this._state.mipFilter = info.mipFilter), 
                void 0 !== info.addressU && (this._state.addressU = info.addressU), void 0 !== info.addressV && (this._state.addressV = info.addressV), 
                void 0 !== info.addressW && (this._state.addressW = info.addressW), void 0 !== info.maxAnisotropy && (this._state.maxAnisotropy = info.maxAnisotropy), 
                void 0 !== info.cmpFunc && (this._state.cmpFunc = info.cmpFunc), void 0 !== info.borderColor && (this._state.borderColor = info.borderColor), 
                void 0 !== info.minLOD && (this._state.minLOD = info.minLOD), void 0 !== info.maxLOD && (this._state.maxLOD = info.maxLOD), 
                void 0 !== info.mipLODBias && (this._state.mipLODBias = info.mipLODBias);
                var glMinFilter = 0, glMagFilter = 0, minFilter = this._state.minFilter, magFilter = this._state.magFilter, mipFilter = this._state.mipFilter;
                glMinFilter = minFilter === exports.GFXFilter.LINEAR || minFilter === exports.GFXFilter.ANISOTROPIC ? mipFilter === exports.GFXFilter.LINEAR || mipFilter === exports.GFXFilter.ANISOTROPIC ? 9987 : mipFilter === exports.GFXFilter.POINT ? 9985 : 9729 : mipFilter === exports.GFXFilter.LINEAR || mipFilter === exports.GFXFilter.ANISOTROPIC ? 9986 : mipFilter === exports.GFXFilter.POINT ? 9984 : 9728, 
                glMagFilter = magFilter === exports.GFXFilter.LINEAR || magFilter === exports.GFXFilter.ANISOTROPIC ? 9729 : 9728;
                var glWrapS = WebGLWraps[this._state.addressU], glWrapT = WebGLWraps[this._state.addressV], glWrapR = WebGLWraps[this._state.addressW];
                return this._gpuSampler = {
                    glMinFilter: glMinFilter,
                    glMagFilter: glMagFilter,
                    glWrapS: glWrapS,
                    glWrapT: glWrapT,
                    glWrapR: glWrapR
                }, this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuSampler = null, this._status = exports.GFXStatus.UNREADY;
            }
        } ]), WebGLGFXSampler;
    }(GFXSampler), WebGLGFXShader = function(_GFXShader) {
        function WebGLGFXShader(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXShader).call(this, device)))._gpuShader = null, 
            _this;
        }
        return _inherits(WebGLGFXShader, _GFXShader), _createClass(WebGLGFXShader, [ {
            key: "gpuShader",
            get: function get() {
                return this._gpuShader;
            }
        } ]), _createClass(WebGLGFXShader, [ {
            key: "initialize",
            value: function initialize(info) {
                this._name = info.name, this._stages = info.stages, void 0 !== info.blocks && (this._blocks = info.blocks), 
                void 0 !== info.samplers && (this._samplers = info.samplers), this._gpuShader = {
                    name: info.name ? info.name : "",
                    blocks: void 0 !== info.blocks ? info.blocks : [],
                    samplers: void 0 !== info.samplers ? info.samplers : [],
                    gpuStages: new Array(info.stages.length),
                    glProgram: null,
                    glInputs: [],
                    glUniforms: [],
                    glBlocks: [],
                    glSamplers: []
                };
                for (var i = 0; i < info.stages.length; ++i) {
                    var stage = info.stages[i];
                    this._gpuShader.gpuStages[i] = {
                        type: stage.type,
                        source: stage.source,
                        macros: stage.macros ? stage.macros : [],
                        glShader: null
                    };
                }
                return function WebGLCmdFuncCreateShader(device, gpuShader) {
                    for (var gl = device.gl, _loop = function _loop(k) {
                        var gpuStage = gpuShader.gpuStages[k], glShaderType = 0, shaderTypeStr = "", lineNumber = 1;
                        switch (gpuStage.type) {
                          case exports.GFXShaderType.VERTEX:
                            shaderTypeStr = "VertexShader", glShaderType = gl.VERTEX_SHADER;
                            break;

                          case exports.GFXShaderType.FRAGMENT:
                            shaderTypeStr = "FragmentShader", glShaderType = gl.FRAGMENT_SHADER;
                            break;

                          default:
                            return console.error("Unsupported GFXShaderType."), {
                                v: void 0
                            };
                        }
                        var glShader = gl.createShader(glShaderType);
                        if (glShader && (gpuStage.glShader = glShader, gl.shaderSource(gpuStage.glShader, gpuStage.source), 
                        gl.compileShader(gpuStage.glShader), !gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS))) {
                            console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed."), 
                            console.error("Shader source dump:", gpuStage.source.replace(/^|\n/g, (function() {
                                return "\n".concat(lineNumber++, " ");
                            }))), console.error(gl.getShaderInfoLog(gpuStage.glShader));
                            for (var l = 0; l < gpuShader.gpuStages.length; l++) {
                                var stage = gpuShader.gpuStages[k];
                                stage.glShader && (gl.deleteShader(stage.glShader), stage.glShader = null);
                            }
                            return {
                                v: void 0
                            };
                        }
                    }, k = 0; k < gpuShader.gpuStages.length; k++) {
                        var _ret = _loop(k);
                        if ("object" === _typeof(_ret)) return _ret.v;
                    }
                    var glProgram = gl.createProgram();
                    if (glProgram) {
                        gpuShader.glProgram = glProgram;
                        for (var _k = 0; _k < gpuShader.gpuStages.length; _k++) {
                            var gpuStage = gpuShader.gpuStages[_k];
                            gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
                        }
                        gl.linkProgram(gpuShader.glProgram);
                        for (var _k2 = 0; _k2 < gpuShader.gpuStages.length; _k2++) {
                            var _gpuStage = gpuShader.gpuStages[_k2];
                            _gpuStage.glShader && (gl.detachShader(gpuShader.glProgram, _gpuStage.glShader), 
                            gl.deleteShader(_gpuStage.glShader), _gpuStage.glShader = null);
                        }
                        if (!gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) return console.error("Failed to link shader '" + gpuShader.name + "'."), 
                        void console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                        console.info("Shader '" + gpuShader.name + "' compilation succeeded.");
                        var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
                        gpuShader.glInputs = new Array(activeAttribCount);
                        for (var i = 0; i < activeAttribCount; ++i) {
                            var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
                            if (attribInfo) {
                                var varName = void 0, nameOffset = attribInfo.name.indexOf("[");
                                varName = -1 !== nameOffset ? attribInfo.name.substr(0, nameOffset) : attribInfo.name;
                                var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName), type = WebGLTypeToGFXType(attribInfo.type, gl), stride = WebGLGetTypeSize(attribInfo.type, gl);
                                gpuShader.glInputs[i] = {
                                    binding: glLoc,
                                    name: varName,
                                    type: type,
                                    stride: stride,
                                    count: attribInfo.size,
                                    size: stride * attribInfo.size,
                                    glType: attribInfo.type,
                                    glLoc: glLoc
                                };
                            }
                        }
                        if (gpuShader.blocks.length > 0) {
                            gpuShader.glBlocks = new Array(gpuShader.blocks.length);
                            for (var _i7 = 0; _i7 < gpuShader.blocks.length; ++_i7) {
                                var block = gpuShader.blocks[_i7], glBlock = {
                                    binding: block.binding,
                                    name: block.name,
                                    size: 0,
                                    glUniforms: new Array(block.members.length),
                                    glActiveUniforms: [],
                                    isUniformPackage: !0
                                };
                                gpuShader.glBlocks[_i7] = glBlock;
                                for (var u = 0; u < block.members.length; ++u) {
                                    var uniform = block.members[u], glType = GFXTypeToWebGLType(uniform.type, gl), _stride = WebGLGetTypeSize(glType, gl), size = _stride * uniform.count, begin = glBlock.size / 4, array = new Array(size / 4);
                                    array.fill(0), glBlock.glUniforms[u] = {
                                        binding: -1,
                                        name: uniform.name,
                                        type: uniform.type,
                                        stride: _stride,
                                        count: uniform.count,
                                        size: size,
                                        offset: glBlock.size,
                                        glType: glType,
                                        glLoc: -1,
                                        array: array,
                                        begin: begin
                                    }, glBlock.size += size;
                                }
                            }
                        }
                        if (gpuShader.samplers.length > 0) {
                            gpuShader.glSamplers = new Array(gpuShader.samplers.length);
                            for (var _i8 = 0; _i8 < gpuShader.samplers.length; ++_i8) {
                                var sampler = gpuShader.samplers[_i8];
                                gpuShader.glSamplers[_i8] = {
                                    binding: sampler.binding,
                                    name: sampler.name,
                                    type: sampler.type,
                                    units: [],
                                    glType: GFXTypeToWebGLType(sampler.type, gl),
                                    glLoc: -1
                                };
                            }
                        }
                        for (var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS), unitIdx = 0, glActiveSamplers = [], _i9 = 0; _i9 < activeUniformCount; ++_i9) {
                            var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i9);
                            if (uniformInfo) {
                                var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);
                                if (null !== _glLoc) {
                                    var _varName = void 0, _nameOffset = uniformInfo.name.indexOf("[");
                                    if (_varName = -1 !== _nameOffset ? uniformInfo.name.substr(0, _nameOffset) : uniformInfo.name, 
                                    uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE) for (var _j = 0; _j < gpuShader.glSamplers.length; _j++) {
                                        var glSampler = gpuShader.glSamplers[_j];
                                        if (glSampler.name === _varName) {
                                            for (var t = 0; t < uniformInfo.size; ++t) glSampler.units.push(unitIdx + t);
                                            glSampler.glLoc = _glLoc, unitIdx += uniformInfo.size, glActiveSamplers.push(glSampler);
                                            break;
                                        }
                                    } else for (var j = 0; j < gpuShader.glBlocks.length; j++) for (var _glBlock = gpuShader.glBlocks[j], _k3 = 0; _k3 < _glBlock.glUniforms.length; _k3++) {
                                        var glUniform = _glBlock.glUniforms[_k3];
                                        if (glUniform.name === _varName) {
                                            glUniform.glLoc = _glLoc, _glBlock.glActiveUniforms.push(glUniform);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        if (glActiveSamplers.length) {
                            device.stateCache.glProgram !== gpuShader.glProgram && (gl.useProgram(gpuShader.glProgram), 
                            device.stateCache.glProgram = gpuShader.glProgram);
                            for (var _i10 = 0; _i10 < glActiveSamplers.length; _i10++) {
                                var _glSampler = glActiveSamplers[_i10];
                                gl.uniform1iv(_glSampler.glLoc, _glSampler.units);
                            }
                        }
                    }
                }(this._device, this._gpuShader), this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuShader && (!function WebGLCmdFuncDestroyShader(device, gpuShader) {
                    gpuShader.glProgram && (device.gl.deleteProgram(gpuShader.glProgram), gpuShader.glProgram = null);
                }(this._device, this._gpuShader), this._gpuShader = null), this._status = exports.GFXStatus.UNREADY;
            }
        } ]), WebGLGFXShader;
    }(GFXShader), WebGLStateCache = function WebGLStateCache() {
        _classCallCheck(this, WebGLStateCache), this.glArrayBuffer = null, this.glElementArrayBuffer = null, 
        this.glVAO = null, this.texUnit = 0, this.glRenderbuffer = null, this.glFramebuffer = null, 
        this.glProgram = null, this.glTexUnits = new Array(16), this.viewport = {
            left: 0,
            top: 0,
            width: 0,
            height: 0,
            minDepth: 0,
            maxDepth: 0
        }, this.scissorRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }, this.rs = new GFXRasterizerState, this.dss = new GFXDepthStencilState, this.bs = new GFXBlendState, 
        this.glEnabledAttribLocs = new Array(16), this.glCurrentAttribLocs = new Array(16), 
        this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.fill(!1);
        for (var i = 0; i < 16; ++i) this.glTexUnits[i] = {
            glTexture: null
        };
    };
    function IsPowerOf2(x) {
        return x > 0 && 0 == (x & x - 1);
    }
    var WebGLGFXTexture = function(_GFXTexture) {
        function WebGLGFXTexture(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXTexture).call(this, device)))._gpuTexture = null, 
            _this;
        }
        return _inherits(WebGLGFXTexture, _GFXTexture), _createClass(WebGLGFXTexture, [ {
            key: "gpuTexture",
            get: function get() {
                return this._gpuTexture;
            }
        } ]), _createClass(WebGLGFXTexture, [ {
            key: "initialize",
            value: function initialize(info) {
                var viewType;
                switch (this._type = info.type, this._usage = info.usage, this._format = info.format, 
                this._width = info.width, this._height = info.height, void 0 !== info.depth && (this._depth = info.depth), 
                void 0 !== info.arrayLayer && (this._arrayLayer = info.arrayLayer), void 0 !== info.mipLevel && (this._mipLevel = info.mipLevel), 
                void 0 !== info.samples && (this._samples = info.samples), void 0 !== info.flags && (this._flags = info.flags), 
                this._isPowerOf2 = IsPowerOf2(this._width) && IsPowerOf2(this._height), this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
                this._flags & exports.GFXTextureFlagBit.BAKUP_BUFFER && (this._buffer = new ArrayBuffer(this._size)), 
                info.type) {
                  case exports.GFXTextureType.TEX1D:
                    viewType = info.arrayLayer ? info.arrayLayer <= 1 ? exports.GFXTextureViewType.TV1D : exports.GFXTextureViewType.TV1D_ARRAY : exports.GFXTextureViewType.TV1D;
                    break;

                  case exports.GFXTextureType.TEX2D:
                    var flags = exports.GFXTextureFlagBit.NONE;
                    info.flags && (flags = info.flags), viewType = info.arrayLayer ? info.arrayLayer <= 1 ? exports.GFXTextureViewType.TV2D : flags & exports.GFXTextureFlagBit.CUBEMAP ? exports.GFXTextureViewType.CUBE : exports.GFXTextureViewType.TV2D_ARRAY : exports.GFXTextureViewType.TV2D;
                    break;

                  case exports.GFXTextureType.TEX3D:
                    viewType = exports.GFXTextureViewType.TV3D;
                    break;

                  default:
                    viewType = exports.GFXTextureViewType.TV2D;
                }
                return this._gpuTexture = {
                    type: this._type,
                    viewType: viewType,
                    format: this._format,
                    usage: this._usage,
                    width: this._width,
                    height: this._height,
                    depth: this._depth,
                    size: this._size,
                    arrayLayer: this._arrayLayer,
                    mipLevel: this._mipLevel,
                    samples: this._samples,
                    flags: this._flags,
                    isPowerOf2: this._isPowerOf2,
                    glTarget: 0,
                    glInternelFmt: 0,
                    glFormat: 0,
                    glType: 0,
                    glUsage: 0,
                    glTexture: null,
                    glRenderbuffer: null,
                    glWrapS: 0,
                    glWrapT: 0,
                    glMinFilter: 0,
                    glMagFilter: 0
                }, function WebGLCmdFuncCreateTexture(device, gpuTexture) {
                    var gl = device.gl;
                    gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl), 
                    gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
                    var w = gpuTexture.width, h = gpuTexture.height;
                    switch (gpuTexture.viewType) {
                      case exports.GFXTextureViewType.TV2D:
                        gpuTexture.viewType = exports.GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D;
                        var maxSize = Math.max(w, h);
                        if (maxSize > device.maxTextureSize && errorID(9100, maxSize, device.maxTextureSize), 
                        !device.WEBGL_depth_texture && GFXFormatInfos[gpuTexture.format].hasDepth) {
                            var glRenderbuffer = gl.createRenderbuffer();
                            glRenderbuffer && gpuTexture.size > 0 && (gpuTexture.glRenderbuffer = glRenderbuffer, 
                            device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer), 
                            device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer), gpuTexture.glInternelFmt === gl.DEPTH_COMPONENT && (gpuTexture.glInternelFmt = gl.DEPTH_COMPONENT16), 
                            gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternelFmt, w, h));
                        } else if (gpuTexture.samples === exports.GFXSampleCount.X1) {
                            var glTexture = gl.createTexture();
                            if (glTexture && gpuTexture.size > 0) {
                                gpuTexture.glTexture = glTexture;
                                var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                                if (glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                                glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                                    var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                    gl.compressedTexImage2D(gl.TEXTURE_2D, _i, gpuTexture.glInternelFmt, w, h, 0, view), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                } else {
                                    var _imgSize = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view = new Uint8Array(_imgSize);
                                    gl.compressedTexImage2D(gl.TEXTURE_2D, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view);
                                } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                gpuTexture.isPowerOf2 ? (gpuTexture.glWrapS = gl.REPEAT, gpuTexture.glWrapT = gl.REPEAT) : (gpuTexture.glWrapS = gl.CLAMP_TO_EDGE, 
                                gpuTexture.glWrapT = gl.CLAMP_TO_EDGE), gpuTexture.glMinFilter = gl.LINEAR, gpuTexture.glMagFilter = gl.LINEAR, 
                                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT), 
                                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter), 
                                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                            }
                        }
                        break;

                      case exports.GFXTextureViewType.CUBE:
                        gpuTexture.viewType = exports.GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                        var _maxSize = Math.max(w, h);
                        _maxSize > device.maxCubeMapTextureSize && errorID(9100, _maxSize, device.maxTextureSize);
                        var _glTexture = gl.createTexture();
                        if (_glTexture && gpuTexture.size > 0) {
                            gpuTexture.glTexture = _glTexture;
                            var _glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                            if (_glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                            _glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f = 0; _f < 6; ++_f) {
                                w = gpuTexture.width, h = gpuTexture.height;
                                for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                                    var _imgSize2 = GFXFormatSize(gpuTexture.format, w, h, 1), _view2 = new Uint8Array(_imgSize2);
                                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternelFmt, w, h, 0, _view2), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                }
                            } else for (var _f2 = 0; _f2 < 6; ++_f2) {
                                var _imgSize3 = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view3 = new Uint8Array(_imgSize3);
                                gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view3);
                            } else for (var f = 0; f < 6; ++f) {
                                w = gpuTexture.width, h = gpuTexture.height;
                                for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            }
                            gpuTexture.isPowerOf2 ? (gpuTexture.glWrapS = gl.REPEAT, gpuTexture.glWrapT = gl.REPEAT) : (gpuTexture.glWrapS = gl.CLAMP_TO_EDGE, 
                            gpuTexture.glWrapT = gl.CLAMP_TO_EDGE), gpuTexture.glMinFilter = gl.LINEAR, gpuTexture.glMagFilter = gl.LINEAR, 
                            gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT), 
                            gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter), 
                            gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                        }
                        break;

                      default:
                        console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = exports.GFXTextureViewType.TV2D, 
                        gpuTexture.glTarget = gl.TEXTURE_2D;
                    }
                }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize += this._size, 
                this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuTexture && (!function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
                    gpuTexture.glTexture && (device.gl.deleteTexture(gpuTexture.glTexture), gpuTexture.glTexture = null), 
                    gpuTexture.glRenderbuffer && (device.gl.deleteRenderbuffer(gpuTexture.glRenderbuffer), 
                    gpuTexture.glRenderbuffer = null);
                }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= this._size, 
                this._gpuTexture = null), this._status = exports.GFXStatus.UNREADY, this._buffer = null;
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                var oldSize = this._size;
                this._width = width, this._height = height, this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
                this._gpuTexture && (this._gpuTexture.width = this._width, this._gpuTexture.height = this._height, 
                this._gpuTexture.size = this._size, function WebGLCmdFuncResizeTexture(device, gpuTexture) {
                    var gl = device.gl;
                    gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl), 
                    gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
                    var w = gpuTexture.width, h = gpuTexture.height;
                    switch (gpuTexture.viewType) {
                      case exports.GFXTextureViewType.TV2D:
                        gpuTexture.viewType = exports.GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D;
                        var maxSize = Math.max(w, h);
                        if (maxSize > device.maxTextureSize && errorID(9100, maxSize, device.maxTextureSize), 
                        gpuTexture.samples === exports.GFXSampleCount.X1) {
                            var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                            if (glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                            glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                                if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                                    var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                    gl.compressedTexImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternelFmt, w, h, 0, view), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                }
                            } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                        }
                        break;

                      case exports.GFXTextureViewType.CUBE:
                        gpuTexture.viewType = exports.GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                        var _maxSize2 = Math.max(w, h);
                        _maxSize2 > device.maxCubeMapTextureSize && errorID(9100, _maxSize2, device.maxTextureSize);
                        var _glTexUnit2 = device.stateCache.glTexUnits[device.stateCache.texUnit];
                        if (_glTexUnit2.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                        _glTexUnit2.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                            if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f3 = 0; _f3 < 6; ++_f3) {
                                w = gpuTexture.width, h = gpuTexture.height;
                                for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                                    var _imgSize4 = GFXFormatSize(gpuTexture.format, w, h, 1), _view4 = new Uint8Array(_imgSize4);
                                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f3, _i6, gpuTexture.glInternelFmt, w, h, 0, _view4), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                }
                            }
                        } else for (var f = 0; f < 6; ++f) {
                            w = gpuTexture.width, h = gpuTexture.height;
                            for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                        }
                        break;

                      default:
                        console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = exports.GFXTextureViewType.TV2D, 
                        gpuTexture.glTarget = gl.TEXTURE_2D;
                    }
                }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= oldSize, 
                this._device.memoryStatus.textureSize += this._size), this._status = exports.GFXStatus.UNREADY;
            }
        } ]), WebGLGFXTexture;
    }(GFXTexture), WebGLGFXTextureView = function(_GFXTextureView) {
        function WebGLGFXTextureView(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXTextureView).call(this, device)))._gpuTextureView = null, 
            _this;
        }
        return _inherits(WebGLGFXTextureView, _GFXTextureView), _createClass(WebGLGFXTextureView, [ {
            key: "gpuTextureView",
            get: function get() {
                return this._gpuTextureView;
            }
        } ]), _createClass(WebGLGFXTextureView, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._texture = info.texture, this._type = info.type, this._format = info.format, 
                void 0 !== info.baseLevel && (this._baseLevel = info.baseLevel), void 0 !== info.levelCount && (this._levelCount = info.levelCount), 
                void 0 !== info.baseLayer && (this._baseLayer = info.baseLayer), void 0 !== info.layerCount && (this._layerCount = info.layerCount), 
                this._gpuTextureView = {
                    gpuTexture: info.texture.gpuTexture,
                    type: info.type,
                    format: info.format,
                    baseLevel: info.baseLevel ? info.baseLevel : 0,
                    levelCount: info.levelCount ? info.levelCount : 1
                }, this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuTextureView = null, this._texture = null, this._status = exports.GFXStatus.UNREADY;
            }
        } ]), WebGLGFXTextureView;
    }(GFXTextureView), WebGLGFXWindow = function(_GFXWindow) {
        function WebGLGFXWindow(device) {
            return _classCallCheck(this, WebGLGFXWindow), _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXWindow).call(this, device));
        }
        return _inherits(WebGLGFXWindow, _GFXWindow), _createClass(WebGLGFXWindow, [ {
            key: "initialize",
            value: function initialize(info) {
                void 0 !== info.title && (this._title = info.title), void 0 !== info.left && (this._left = info.left), 
                void 0 !== info.top && (this._top = info.top), void 0 !== info.isOffscreen && (this._isOffscreen = info.isOffscreen), 
                this._width = info.width, this._height = info.height, this._nativeWidth = this._width, 
                this._nativeHeight = this._height, this._colorFmt = info.colorFmt, this._depthStencilFmt = info.depthStencilFmt, 
                this._renderPass = this._device.createRenderPass({
                    colorAttachments: [ {
                        format: this._colorFmt,
                        loadOp: exports.GFXLoadOp.CLEAR,
                        storeOp: exports.GFXStoreOp.STORE,
                        sampleCount: 1,
                        beginLayout: exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                        endLayout: exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                    } ],
                    depthStencilAttachment: {
                        format: this._depthStencilFmt,
                        depthLoadOp: exports.GFXLoadOp.CLEAR,
                        depthStoreOp: exports.GFXStoreOp.STORE,
                        stencilLoadOp: exports.GFXLoadOp.CLEAR,
                        stencilStoreOp: exports.GFXStoreOp.STORE,
                        sampleCount: 1,
                        beginLayout: exports.GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                        endLayout: exports.GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                    }
                });
                var colorViews = [];
                return this._isOffscreen && (this._colorFmt !== exports.GFXFormat.UNKNOWN && (this._colorTex = this._device.createTexture({
                    type: exports.GFXTextureType.TEX2D,
                    usage: exports.GFXTextureUsageBit.COLOR_ATTACHMENT | exports.GFXTextureUsageBit.SAMPLED,
                    format: this._colorFmt,
                    width: this._width,
                    height: this._height,
                    depth: 1,
                    arrayLayer: 1,
                    mipLevel: 1,
                    flags: exports.GFXTextureFlagBit.NONE
                }), this._colorTexView = this._device.createTextureView({
                    texture: this._colorTex,
                    type: exports.GFXTextureViewType.TV2D,
                    format: this._colorFmt,
                    baseLevel: 0,
                    levelCount: 1,
                    baseLayer: 0,
                    layerCount: 1
                }), colorViews.push(this._colorTexView)), this._depthStencilFmt !== exports.GFXFormat.UNKNOWN && (this._depthStencilTex = this._device.createTexture({
                    type: exports.GFXTextureType.TEX2D,
                    usage: exports.GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT,
                    format: this._depthStencilFmt,
                    width: this._width,
                    height: this._height,
                    depth: 1,
                    arrayLayer: 1,
                    mipLevel: 1,
                    flags: exports.GFXTextureFlagBit.NONE
                }), this._depthStencilTexView = this._device.createTextureView({
                    texture: this._depthStencilTex,
                    type: exports.GFXTextureViewType.TV2D,
                    format: this._depthStencilFmt,
                    baseLevel: 0,
                    levelCount: 1,
                    baseLayer: 0,
                    layerCount: 1
                }))), this._framebuffer = this._device.createFramebuffer({
                    renderPass: this._renderPass,
                    colorViews: colorViews,
                    depthStencilView: this._depthStencilTexView,
                    isOffscreen: this._isOffscreen
                }), this._status = exports.GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._depthStencilTexView && (this._depthStencilTexView.destroy(), this._depthStencilTexView = null), 
                this._depthStencilTex && (this._depthStencilTex.destroy(), this._depthStencilTex = null), 
                this._colorTexView && (this._colorTexView.destroy(), this._colorTexView = null), 
                this._colorTex && (this._colorTex.destroy(), this._colorTex = null), this._framebuffer && (this._framebuffer.destroy(), 
                this._framebuffer = null), this._renderPass && (this._renderPass.destroy(), this._renderPass = null), 
                this._status = exports.GFXStatus.UNREADY;
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._width = width, this._height = height, (width > this._nativeWidth || height > this._nativeHeight) && (this._nativeWidth = width, 
                this._nativeHeight = height, this._depthStencilTex && (this._depthStencilTex.resize(width, height), 
                this._depthStencilTexView.destroy(), this._depthStencilTexView.initialize({
                    texture: this._depthStencilTex,
                    type: exports.GFXTextureViewType.TV2D,
                    format: this._depthStencilFmt
                })), this._colorTex && (this._colorTex.resize(width, height), this._colorTexView.destroy(), 
                this._colorTexView.initialize({
                    texture: this._colorTex,
                    type: exports.GFXTextureViewType.TV2D,
                    format: this._colorFmt
                })), this._framebuffer && this._framebuffer.isOffscreen && (this._framebuffer.destroy(), 
                this._framebuffer.initialize({
                    renderPass: this._renderPass,
                    colorViews: [ this._colorTexView ],
                    depthStencilView: this._depthStencilTexView
                })));
            }
        } ]), WebGLGFXWindow;
    }(GFXWindow), WebGLGFXDevice = function(_GFXDevice) {
        function WebGLGFXDevice() {
            var _this;
            return _classCallCheck(this, WebGLGFXDevice), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXDevice).call(this))).stateCache = new WebGLStateCache, 
            _this.nullTex2D = null, _this.nullTexCube = null, _this._webGLRC = null, _this._isAntialias = !0, 
            _this._isPremultipliedAlpha = !0, _this._useVAO = !1, _this._extensions = null, 
            _this._EXT_texture_filter_anisotropic = null, _this._EXT_frag_depth = null, _this._EXT_shader_texture_lod = null, 
            _this._EXT_sRGB = null, _this._OES_vertex_array_object = null, _this._EXT_color_buffer_half_float = null, 
            _this._WEBGL_color_buffer_float = null, _this._WEBGL_compressed_texture_etc1 = null, 
            _this._WEBGL_compressed_texture_etc = null, _this._WEBGL_compressed_texture_pvrtc = null, 
            _this._WEBGL_compressed_texture_astc = null, _this._WEBGL_compressed_texture_s3tc = null, 
            _this._WEBGL_compressed_texture_s3tc_srgb = null, _this._WEBGL_debug_shaders = null, 
            _this._WEBGL_draw_buffers = null, _this._WEBGL_lose_context = null, _this._WEBGL_depth_texture = null, 
            _this._WEBGL_debug_renderer_info = null, _this._OES_texture_half_float = null, _this._OES_texture_half_float_linear = null, 
            _this._OES_texture_float = null, _this._OES_texture_float_linear = null, _this._OES_standard_derivatives = null, 
            _this._OES_element_index_uint = null, _this._ANGLE_instanced_arrays = null, _this;
        }
        return _inherits(WebGLGFXDevice, _GFXDevice), _createClass(WebGLGFXDevice, [ {
            key: "gl",
            get: function get() {
                return this._webGLRC;
            }
        }, {
            key: "webGLQueue",
            get: function get() {
                return this._queue;
            }
        }, {
            key: "isAntialias",
            get: function get() {
                return this._isAntialias;
            }
        }, {
            key: "isPremultipliedAlpha",
            get: function get() {
                return this._isPremultipliedAlpha;
            }
        }, {
            key: "useVAO",
            get: function get() {
                return this._useVAO;
            }
        }, {
            key: "EXT_texture_filter_anisotropic",
            get: function get() {
                return this._EXT_texture_filter_anisotropic;
            }
        }, {
            key: "EXT_frag_depth",
            get: function get() {
                return this._EXT_frag_depth;
            }
        }, {
            key: "EXT_shader_texture_lod",
            get: function get() {
                return this._EXT_shader_texture_lod;
            }
        }, {
            key: "EXT_sRGB",
            get: function get() {
                return this._EXT_sRGB;
            }
        }, {
            key: "OES_vertex_array_object",
            get: function get() {
                return this._OES_vertex_array_object;
            }
        }, {
            key: "WEBGL_color_buffer_float",
            get: function get() {
                return this._WEBGL_color_buffer_float;
            }
        }, {
            key: "WEBGL_compressed_texture_etc1",
            get: function get() {
                return this._WEBGL_compressed_texture_etc1;
            }
        }, {
            key: "WEBGL_compressed_texture_pvrtc",
            get: function get() {
                return this._WEBGL_compressed_texture_pvrtc;
            }
        }, {
            key: "WEBGL_compressed_texture_astc",
            get: function get() {
                return this._WEBGL_compressed_texture_astc;
            }
        }, {
            key: "WEBGL_compressed_texture_s3tc",
            get: function get() {
                return this._WEBGL_compressed_texture_s3tc;
            }
        }, {
            key: "WEBGL_compressed_texture_s3tc_srgb",
            get: function get() {
                return this._WEBGL_compressed_texture_s3tc_srgb;
            }
        }, {
            key: "WEBGL_debug_shaders",
            get: function get() {
                return this._WEBGL_debug_shaders;
            }
        }, {
            key: "WEBGL_draw_buffers",
            get: function get() {
                return this._WEBGL_draw_buffers;
            }
        }, {
            key: "WEBGL_lose_context",
            get: function get() {
                return this._WEBGL_lose_context;
            }
        }, {
            key: "WEBGL_depth_texture",
            get: function get() {
                return this._WEBGL_depth_texture;
            }
        }, {
            key: "WEBGL_debug_renderer_info",
            get: function get() {
                return this._WEBGL_debug_renderer_info;
            }
        }, {
            key: "OES_texture_half_float",
            get: function get() {
                return this._OES_texture_half_float;
            }
        }, {
            key: "OES_texture_half_float_linear",
            get: function get() {
                return this._OES_texture_half_float_linear;
            }
        }, {
            key: "OES_texture_float",
            get: function get() {
                return this._OES_texture_float;
            }
        }, {
            key: "OES_standard_derivatives",
            get: function get() {
                return this._OES_standard_derivatives;
            }
        }, {
            key: "OES_element_index_uint",
            get: function get() {
                return this._OES_element_index_uint;
            }
        }, {
            key: "ANGLE_instanced_arrays",
            get: function get() {
                return this._ANGLE_instanced_arrays;
            }
        } ]), _createClass(WebGLGFXDevice, [ {
            key: "initialize",
            value: function initialize(info) {
                this._canvas = info.canvasElm, this._isAntialias = void 0 === info.isAntialias || info.isAntialias, 
                this._isPremultipliedAlpha = void 0 === info.isPremultipliedAlpha || info.isPremultipliedAlpha;
                try {
                    var webGLCtxAttribs = {
                        alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                        antialias: this._isAntialias,
                        depth: !0,
                        stencil: !0,
                        premultipliedAlpha: this._isPremultipliedAlpha,
                        preserveDrawingBuffer: !1,
                        powerPreference: "default",
                        failIfMajorPerformanceCaveat: !1
                    };
                    this._webGLRC = this._canvas.getContext("webgl", webGLCtxAttribs);
                } catch (err) {
                    return console.error(err), !1;
                }
                if (!this._webGLRC) return console.error("This device does not support WebGL."), 
                !1;
                this._canvas2D = document.createElement("canvas"), console.info("WebGL device initialized."), 
                this._gfxAPI = exports.GFXAPI.WEBGL, this._deviceName = "WebGL";
                var gl = this._webGLRC;
                this._WEBGL_debug_renderer_info = this.getExtension("WEBGL_debug_renderer_info"), 
                this._WEBGL_debug_renderer_info ? (this._renderer = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), 
                this._vendor = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = gl.getParameter(gl.RENDERER), 
                this._vendor = gl.getParameter(gl.VENDOR)), this._version = gl.getParameter(gl.VERSION), 
                this._maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), this._maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS), 
                this._maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS), 
                this._maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), this._maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), 
                this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE), this._maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE), 
                this._depthBits = gl.getParameter(gl.DEPTH_BITS), this._stencilBits = gl.getParameter(gl.STENCIL_BITS), 
                this._devicePixelRatio = info.devicePixelRatio || 1, this._width = this._canvas.width, 
                this._height = this._canvas.height, this._nativeWidth = Math.max(info.nativeWidth || this._width, 0), 
                this._nativeHeight = Math.max(info.nativeHeight || this._height, 0), this._colorFmt = exports.GFXFormat.RGBA8, 
                24 === this._depthBits ? 8 === this._stencilBits ? this._depthStencilFmt = exports.GFXFormat.D24S8 : this._depthStencilFmt = exports.GFXFormat.D24 : 8 === this._stencilBits ? this._depthStencilFmt = exports.GFXFormat.D16S8 : this._depthStencilFmt = exports.GFXFormat.D16, 
                this._extensions = gl.getSupportedExtensions();
                var extensions = "";
                if (this._extensions) {
                    var _iterator = this._extensions, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        extensions += _ref + " ";
                    }
                    console.debug("EXTENSIONS: " + extensions);
                }
                this._EXT_texture_filter_anisotropic = this.getExtension("EXT_texture_filter_anisotropic"), 
                this._EXT_frag_depth = this.getExtension("EXT_frag_depth"), this._EXT_shader_texture_lod = this.getExtension("EXT_shader_texture_lod"), 
                this._EXT_sRGB = this.getExtension("EXT_sRGB"), this._OES_vertex_array_object = this.getExtension("OES_vertex_array_object"), 
                this._EXT_color_buffer_half_float = this.getExtension("EXT_color_buffer_half_float"), 
                this._WEBGL_color_buffer_float = this.getExtension("WEBGL_color_buffer_float"), 
                this._WEBGL_compressed_texture_etc1 = this.getExtension("WEBGL_compressed_texture_etc1"), 
                this._WEBGL_compressed_texture_etc = this.getExtension("WEBGL_compressed_texture_etc"), 
                this._WEBGL_compressed_texture_pvrtc = this.getExtension("WEBGL_compressed_texture_pvrtc"), 
                this._WEBGL_compressed_texture_astc = this.getExtension("WEBGL_compressed_texture_astc"), 
                this._WEBGL_compressed_texture_s3tc = this.getExtension("WEBGL_compressed_texture_s3tc"), 
                this._WEBGL_compressed_texture_s3tc_srgb = this.getExtension("WEBGL_compressed_texture_s3tc_srgb"), 
                this._WEBGL_debug_shaders = this.getExtension("WEBGL_debug_shaders"), this._WEBGL_draw_buffers = this.getExtension("WEBGL_draw_buffers"), 
                this._WEBGL_lose_context = this.getExtension("WEBGL_lose_context"), this._WEBGL_depth_texture = this.getExtension("WEBGL_depth_texture"), 
                this._OES_texture_half_float = this.getExtension("OES_texture_half_float"), this._OES_texture_half_float_linear = this.getExtension("OES_texture_half_float_linear"), 
                this._OES_texture_float = this.getExtension("OES_texture_float"), this._OES_texture_float_linear = this.getExtension("OES_texture_float_linear"), 
                this._OES_standard_derivatives = this.getExtension("OES_standard_derivatives"), 
                this._OES_element_index_uint = this.getExtension("OES_element_index_uint"), this._ANGLE_instanced_arrays = this.getExtension("ANGLE_instanced_arrays"), 
                this._features.fill(!1), this._WEBGL_color_buffer_float && (this._features[exports.GFXFeature.COLOR_FLOAT] = !0), 
                this._EXT_color_buffer_half_float && (this._features[exports.GFXFeature.COLOR_HALF_FLOAT] = !0), 
                this._OES_texture_float && (this._features[exports.GFXFeature.TEXTURE_FLOAT] = !0), 
                this._OES_texture_half_float && (this._features[exports.GFXFeature.TEXTURE_HALF_FLOAT] = !0), 
                this._OES_texture_float_linear && (this._features[exports.GFXFeature.TEXTURE_FLOAT_LINEAR] = !0), 
                this._OES_texture_half_float_linear && (this._features[exports.GFXFeature.TEXTURE_HALF_FLOAT_LINEAR] = !0), 
                this._WEBGL_depth_texture && (this._features[exports.GFXFeature.FORMAT_D24S8] = !0);
                var compressedFormat = "";
                this._WEBGL_compressed_texture_etc1 && (this._features[exports.GFXFeature.FORMAT_ETC1] = !0, 
                compressedFormat += "etc1 "), this._WEBGL_compressed_texture_etc && (this._features[exports.GFXFeature.FORMAT_ETC2] = !0, 
                compressedFormat += "etc2 "), this._WEBGL_compressed_texture_s3tc && (this._features[exports.GFXFeature.FORMAT_DXT] = !0, 
                compressedFormat += "dxt "), this._WEBGL_compressed_texture_pvrtc && (this._features[exports.GFXFeature.FORMAT_PVRTC] = !0, 
                compressedFormat += "pvrtc "), this._WEBGL_compressed_texture_astc && (this._features[exports.GFXFeature.FORMAT_ASTC] = !0, 
                compressedFormat += "astc "), this._features[exports.GFXFeature.MSAA] = !1, this._OES_vertex_array_object && "function" == typeof loadRuntime && "function" == typeof loadRuntime().getFeature && loadRuntime().getFeature("webgl.extensions.oes_vertex_array_object.revision") > 0 && (this._useVAO = !0), 
                sys.platform === sys.WECHAT_GAME && sys.os === sys.OS_ANDROID && (gl.detachShader = function() {}), 
                this._OES_element_index_uint && (this._features[exports.GFXFeature.ELEMENT_INDEX_UINT] = !0), 
                console.info("RENDERER: " + this._renderer), console.info("VENDOR: " + this._vendor), 
                console.info("VERSION: " + this._version), console.info("DPR: " + this._devicePixelRatio), 
                console.info("SCREEN_SIZE: " + this._width + " x " + this._height), console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight), 
                console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._maxVertexUniformVectors), console.info("DEPTH_BITS: " + this._depthBits), 
                console.info("STENCIL_BITS: " + this._stencilBits), this._EXT_texture_filter_anisotropic && console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), 
                console.info("USE_VAO: " + this._useVAO), console.info("COMPRESSED_FORMAT: " + compressedFormat), 
                this.initStates(gl), this._queue = this.createQueue({
                    type: exports.GFXQueueType.GRAPHICS
                });
                var canvas = this._webGLRC.canvas;
                this._mainWindow = this.createWindow({
                    title: canvas.title || "",
                    left: canvas.offsetLeft || 0,
                    top: canvas.offsetTop || 0,
                    width: this._webGLRC.drawingBufferWidth,
                    height: this._webGLRC.drawingBufferHeight,
                    colorFmt: this._colorFmt,
                    depthStencilFmt: this._depthStencilFmt
                }), this._cmdAllocator = this.createCommandAllocator({}), this.nullTex2D = new WebGLGFXTexture(this), 
                this.nullTex2D.initialize({
                    type: exports.GFXTextureType.TEX2D,
                    usage: exports.GFXTextureUsageBit.SAMPLED,
                    format: exports.GFXFormat.RGBA8,
                    width: 2,
                    height: 2,
                    flags: exports.GFXTextureFlagBit.GEN_MIPMAP
                }), this.nullTexCube = new WebGLGFXTexture(this), this.nullTexCube.initialize({
                    type: exports.GFXTextureType.TEX2D,
                    usage: exports.GFXTextureUsageBit.SAMPLED,
                    format: exports.GFXFormat.RGBA8,
                    width: 2,
                    height: 2,
                    arrayLayer: 6,
                    flags: exports.GFXTextureFlagBit.CUBEMAP | exports.GFXTextureFlagBit.GEN_MIPMAP
                });
                var nullTexRegion = {
                    buffOffset: 0,
                    buffStride: 0,
                    buffTexHeight: 0,
                    texOffset: {
                        x: 0,
                        y: 0,
                        z: 0
                    },
                    texExtent: {
                        width: 2,
                        height: 2,
                        depth: 1
                    },
                    texSubres: {
                        baseMipLevel: 0,
                        levelCount: 1,
                        baseArrayLayer: 0,
                        layerCount: 1
                    }
                }, nullTexBuff = new Uint8Array(this.nullTex2D.size);
                return nullTexBuff.fill(0), this.copyBuffersToTexture([ nullTexBuff ], this.nullTex2D, [ nullTexRegion ]), 
                nullTexRegion.texSubres.layerCount = 6, this.copyBuffersToTexture([ nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff ], this.nullTexCube, [ nullTexRegion ]), 
                !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), 
                this.nullTexCube = null), this._mainWindow && (this._mainWindow.destroy(), this._mainWindow = null), 
                this._cmdAllocator && (this._cmdAllocator.destroy(), this._cmdAllocator = null), 
                this._queue && (this._queue.destroy(), this._queue = null), this._webGLRC = null;
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._width === width && this._height === height || (console.info("Resizing device: " + width + "x" + height), 
                this._canvas.width = width, this._canvas.height = height, this._width = width, this._height = height);
            }
        }, {
            key: "createBuffer",
            value: function createBuffer(info) {
                var buffer = new WebGLGFXBuffer(this);
                return buffer.initialize(info), buffer;
            }
        }, {
            key: "createTexture",
            value: function createTexture(info) {
                var texture = new WebGLGFXTexture(this);
                return texture.initialize(info), texture;
            }
        }, {
            key: "createTextureView",
            value: function createTextureView(info) {
                var texView = new WebGLGFXTextureView(this);
                return texView.initialize(info), texView;
            }
        }, {
            key: "createSampler",
            value: function createSampler(info) {
                var sampler = new WebGLGFXSampler(this);
                return sampler.initialize(info), sampler;
            }
        }, {
            key: "createBindingLayout",
            value: function createBindingLayout(info) {
                var bindingLayout = new WebGLGFXBindingLayout(this);
                return bindingLayout.initialize(info), bindingLayout;
            }
        }, {
            key: "createShader",
            value: function createShader(info) {
                var shader = new WebGLGFXShader(this);
                return shader.initialize(info), shader;
            }
        }, {
            key: "createInputAssembler",
            value: function createInputAssembler(info) {
                var inputAssembler = new WebGLGFXInputAssembler(this);
                return inputAssembler.initialize(info), inputAssembler;
            }
        }, {
            key: "createRenderPass",
            value: function createRenderPass(info) {
                var renderPass = new WebGLGFXRenderPass(this);
                return renderPass.initialize(info), renderPass;
            }
        }, {
            key: "createFramebuffer",
            value: function createFramebuffer(info) {
                var framebuffer = new WebGLGFXFramebuffer(this);
                return framebuffer.initialize(info), framebuffer;
            }
        }, {
            key: "createPipelineLayout",
            value: function createPipelineLayout(info) {
                var pipelineLayout = new WebGLGFXPipelineLayout(this);
                return pipelineLayout.initialize(info), pipelineLayout;
            }
        }, {
            key: "createPipelineState",
            value: function createPipelineState(info) {
                var pipelineState = new WebGLGFXPipelineState(this);
                return pipelineState.initialize(info), pipelineState;
            }
        }, {
            key: "createCommandAllocator",
            value: function createCommandAllocator(info) {
                var cmdAllocator = new WebGLGFXCommandAllocator(this);
                return cmdAllocator.initialize(info), cmdAllocator;
            }
        }, {
            key: "createCommandBuffer",
            value: function createCommandBuffer(info) {
                var cmdBuff = new WebGLGFXCommandBuffer(this);
                return cmdBuff.initialize(info), cmdBuff;
            }
        }, {
            key: "createQueue",
            value: function createQueue(info) {
                var queue = new WebGLGFXQueue(this);
                return queue.initialize(info), queue;
            }
        }, {
            key: "createWindow",
            value: function createWindow(info) {
                var window = new WebGLGFXWindow(this);
                return window.initialize(info), window;
            }
        }, {
            key: "present",
            value: function present() {
                this._cmdAllocator.releaseCmds();
                var queue = this._queue;
                this._numDrawCalls = queue.numDrawCalls, this._numTris = queue.numTris, queue.clear();
            }
        }, {
            key: "copyBuffersToTexture",
            value: function copyBuffersToTexture(buffers, texture, regions) {
                WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
            }
        }, {
            key: "copyTexImagesToTexture",
            value: function copyTexImagesToTexture(texImages, texture, regions) {
                !function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
                    var gl = device.gl, glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                    glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture), 
                    glTexUnit.glTexture = gpuTexture.glTexture);
                    var m = 0, n = 0, f = 0;
                    switch (gpuTexture.glTarget) {
                      case gl.TEXTURE_2D:
                        for (var i = 0; i < regions.length; i++) {
                            var region = regions[i];
                            for (m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                        }
                        break;

                      case gl.TEXTURE_CUBE_MAP:
                        for (var _i12 = 0; _i12 < regions.length; _i12++) {
                            var _region = regions[_i12], fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;
                            for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                                var mcount = _region.texSubres.baseMipLevel + _region.texSubres.levelCount;
                                for (m = _region.texSubres.baseMipLevel; m < mcount; ++m) gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                            }
                        }
                        break;

                      default:
                        console.error("Unsupported GL texture type, copy buffer to texture failed.");
                    }
                    gpuTexture.flags & exports.GFXTextureFlagBit.GEN_MIPMAP && gpuTexture.isPowerOf2 && gl.generateMipmap(gpuTexture.glTarget);
                }(this, texImages, texture.gpuTexture, regions);
            }
        }, {
            key: "copyFramebufferToBuffer",
            value: function copyFramebufferToBuffer(srcFramebuffer, dstBuffer, regions) {
                var gl = this._webGLRC, gpuFramebuffer = srcFramebuffer.gpuFramebuffer, curFBO = this.stateCache.glFramebuffer;
                this.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                this.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                var view = new Uint8Array(dstBuffer), _iterator2 = regions, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var region = _ref2, buffOffset = region.buffOffset + region.buffTexHeight * region.buffStride, w = region.texExtent.width, h = region.texExtent.height, memSize = GFXFormatSize(exports.GFXFormat.RGBA8, w, h, 1), data = view.subarray(buffOffset, buffOffset + memSize);
                    gl.readPixels(region.texOffset.x, region.texOffset.y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, data);
                }
                this.stateCache.glFramebuffer !== curFBO && (gl.bindFramebuffer(gl.FRAMEBUFFER, curFBO), 
                this.stateCache.glFramebuffer = curFBO);
            }
        }, {
            key: "blitFramebuffer",
            value: function blitFramebuffer(src, dst, srcRect, dstRect, filter) {}
        }, {
            key: "getExtension",
            value: function getExtension(ext) {
                for (var prefixes = [ "", "WEBKIT_", "MOZ_" ], i = 0; i < prefixes.length; ++i) {
                    var _ext = this._webGLRC.getExtension(prefixes[i] + ext);
                    if (_ext) return _ext;
                }
                return null;
            }
        }, {
            key: "initStates",
            value: function initStates(gl) {
                gl.activeTexture(gl.TEXTURE0), gl.pixelStorei(gl.PACK_ALIGNMENT, 1), gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1), 
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0), gl.bindFramebuffer(gl.FRAMEBUFFER, null), 
                gl.disable(gl.SCISSOR_TEST), gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK), gl.frontFace(gl.CCW), 
                gl.disable(gl.POLYGON_OFFSET_FILL), gl.polygonOffset(0, 0), gl.enable(gl.DEPTH_TEST), 
                gl.depthMask(!0), gl.depthFunc(gl.LESS), gl.depthRange(0, 1), gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 65535), 
                gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP), gl.stencilMaskSeparate(gl.FRONT, 65535), 
                gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 65535), gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP), 
                gl.stencilMaskSeparate(gl.BACK, 65535), gl.disable(gl.STENCIL_TEST), gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
                gl.disable(gl.BLEND), gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO), 
                gl.colorMask(!0, !0, !0, !0), gl.blendColor(0, 0, 0, 0);
            }
        } ]), WebGLGFXDevice;
    }(GFXDevice);
    cc.WebGLGFXDevice = WebGLGFXDevice;
    var _dec$16, _dec2$I, _dec3$s, _dec4$o, _dec5$l, _dec6$h, _dec7$e, _dec8$9, _dec9$6, _dec10$6, _dec11$6, _dec12$5, _dec13$4, _dec14$3, _dec15$3, _dec16$3, _dec17$1, _dec18$1, _class$17, _class2$Z, _descriptor$Q, _descriptor2$F, _descriptor3$w, _descriptor4$n, _descriptor5$i, _descriptor6$9, _descriptor7$8, _descriptor8$7, _descriptor9$6, _descriptor10$6, _descriptor11$4, _descriptor12$3, _descriptor13$3, _descriptor14$3, _class3$m, _temp$$, Transition, State, EventType$1, vec3_temp = new Vec3, _worldMatrix$1 = new Mat4;
    function fillMeshVertices3D(node, renderer, renderData, color) {
        var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
        vertexCount = 0, indiceOffset = 0, vertexId = 0);
        var vbuf = buffer.vData, ibuf = buffer.iData;
        node.getWorldMatrix(_worldMatrix$1);
        for (var i = 0; i < vertexCount; i++) {
            var vert = datas[i];
            Vec3.set(vec3_temp, vert.x, vert.y, 0), Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix$1), 
            vbuf[vertexOffset++] = vec3_temp.x, vbuf[vertexOffset++] = vec3_temp.y, vbuf[vertexOffset++] = vec3_temp.z, 
            vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.toArray(vbuf, color, vertexOffset), 
            vertexOffset += 4;
        }
        for (var _i2 = 0, count = vertexCount / 4; _i2 < count; _i2++) {
            var start = vertexId + 4 * _i2;
            ibuf[indiceOffset++] = start, ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 2, 
            ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 3, ibuf[indiceOffset++] = start + 2;
        }
    }
    !function(Transition) {
        Transition[Transition.NONE = 0] = "NONE", Transition[Transition.COLOR = 1] = "COLOR", 
        Transition[Transition.SPRITE = 2] = "SPRITE", Transition[Transition.SCALE = 3] = "SCALE";
    }(Transition || (Transition = {})), ccenum(Transition), function(State) {
        State.NORMAL = "normal", State.HOVER = "hover", State.PRESSED = "pressed", State.DISABLED = "disabled";
    }(State || (State = {})), function(EventType) {
        EventType.CLICK = "click";
    }(EventType$1 || (EventType$1 = {}));
    var ButtonComponent = (_dec$16 = ccclass("cc.ButtonComponent"), _dec2$I = executionOrder(110), 
    _dec3$s = menu("UI/Button"), _dec4$o = requireComponent(UITransformComponent), _dec5$l = property({
        displayOrder: 1,
        tooltip: "按钮是否可交互，这一项未选中时，按钮处在禁用状态"
    }), _dec6$h = property({
        type: Transition,
        displayOrder: 2,
        tooltip: "按钮状态变化时的过渡类型"
    }), _dec7$e = property({
        tooltip: "普通状态的按钮背景颜色"
    }), _dec8$9 = property({
        tooltip: "按下状态的按钮背景颜色"
    }), _dec9$6 = property({
        tooltip: "悬停状态的按钮背景颜色"
    }), _dec10$6 = property({
        tooltip: "禁用状态的按钮背景颜色"
    }), _dec11$6 = property({
        min: 0,
        max: 10,
        tooltip: "按钮颜色变化或者缩放变化的过渡时间"
    }), _dec12$5 = property({
        tooltip: "当用户点击按钮后，按钮会缩放到一个值，这个值等于 Button 原始 scale * zoomScale。"
    }), _dec13$4 = property({
        type: SpriteFrame,
        tooltip: "普通状态的按钮背景图资源"
    }), _dec14$3 = property({
        type: SpriteFrame,
        tooltip: "按下状态的按钮背景图资源"
    }), _dec15$3 = property({
        type: SpriteFrame,
        tooltip: "悬停状态的按钮背景图资源"
    }), _dec16$3 = property({
        type: SpriteFrame,
        tooltip: "禁用状态的按钮背景图资源"
    }), _dec17$1 = property({
        type: Node$1,
        displayOrder: 0,
        tooltip: "指定 Button 背景节点，Button 状态改变时会修改此节点的 Color 或 Sprite 属性"
    }), _dec18$1 = property({
        type: [ EventHandler ],
        displayOrder: 3,
        tooltip: "按钮点击事件的列表。先将数量改为1或更多，就可以为每个点击事件设置接受者和处理方法"
    }), _dec$16(_class$17 = _dec2$I(_class$17 = _dec3$s(_class$17 = _dec4$o((_temp$$ = _class3$m = function(_Component) {
        function ButtonComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ButtonComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ButtonComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "clickEvents", _descriptor$Q, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_interactable", _descriptor2$F, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_transition", _descriptor3$w, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_normalColor", _descriptor4$n, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_hoverColor", _descriptor5$i, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_pressColor", _descriptor6$9, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_disabledColor", _descriptor7$8, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_normalSprite", _descriptor8$7, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_hoverSprite", _descriptor9$6, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_pressedSprite", _descriptor10$6, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_disabledSprite", _descriptor11$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_duration", _descriptor12$3, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_zoomScale", _descriptor13$3, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_target", _descriptor14$3, _assertThisInitialized(_this)), 
            _this._pressed = !1, _this._hovered = !1, _this._fromColor = new Color, _this._toColor = new Color, 
            _this._time = 0, _this._transitionFinished = !0, _this._fromScale = new Vec3, _this._toScale = new Vec3, 
            _this._originalScale = new Vec3, _this._sprite = null, _this._targetScale = new Vec3, 
            _this;
        }
        return _inherits(ButtonComponent, _Component), _createClass(ButtonComponent, [ {
            key: "__preload",
            value: function __preload() {
                this.target || (this.target = this.node);
                var sprite = this.node.getComponent(SpriteComponent);
                sprite && (this._normalSprite = sprite.spriteFrame), this._applyTarget(), this._updateState();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._registerEvent();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._resetState(), this.node.off(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), 
                this.node.off(exports.SystemEventType.TOUCH_MOVE, this._onTouchMove, this), this.node.off(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), 
                this.node.off(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this), 
                this.node.off(exports.SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.off(exports.SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
            }
        }, {
            key: "update",
            value: function update(dt) {
                var target = this._target ? this._target : this.node;
                if (!this._transitionFinished && (this._transition === Transition.COLOR || this._transition === Transition.SCALE)) {
                    this._time += dt;
                    var ratio = 1;
                    this._duration > 0 && (ratio = this._time / this._duration), ratio >= 1 && (ratio = 1, 
                    this._transitionFinished = !0);
                    var renderComp = target.getComponent(UIRenderComponent);
                    renderComp && (this._transition === Transition.COLOR ? Color.lerp(renderComp.color, this._fromColor, this._toColor, ratio) : this.transition === Transition.SCALE && (target.getScale(this._targetScale), 
                    this._targetScale.x = lerp(this._fromScale.x, this._toScale.x, ratio), this._targetScale.y = lerp(this._fromScale.y, this._toScale.y, ratio), 
                    target.setScale(this._targetScale)));
                }
            }
        }, {
            key: "_resizeNodeToTargetNode",
            value: function _resizeNodeToTargetNode() {
                0;
            }
        }, {
            key: "_resetState",
            value: function _resetState() {
                this._pressed = !1, this._hovered = !1;
                var target = this._target;
                if (target) {
                    var renderComp = target.getComponent(UIRenderComponent);
                    if (renderComp) {
                        var transition = this._transition;
                        transition === Transition.COLOR && this._interactable ? renderComp.color = this._normalColor : transition === Transition.SCALE && target.setScale(this._originalScale), 
                        this._transitionFinished = !0;
                    }
                }
            }
        }, {
            key: "_registerEvent",
            value: function _registerEvent() {
                this.node.on(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.on(exports.SystemEventType.TOUCH_MOVE, this._onTouchMove, this), 
                this.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), this.node.on(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this), 
                this.node.on(exports.SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.on(exports.SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
            }
        }, {
            key: "_getTargetSprite",
            value: function _getTargetSprite(target) {
                var sprite = null;
                return target && (sprite = target.getComponent(SpriteComponent)), sprite;
            }
        }, {
            key: "_applyTarget",
            value: function _applyTarget() {
                this._sprite = this._getTargetSprite(this._target), this._target && Vec3.copy(this._originalScale, this._target.getScale());
            }
        }, {
            key: "_onTouchBegan",
            value: function _onTouchBegan(event) {
                this._interactable && this.enabledInHierarchy && (this._pressed = !0, this._updateState(), 
                event && (event.propagationStopped = !0));
            }
        }, {
            key: "_onTouchMove",
            value: function _onTouchMove(event) {
                if (this._interactable && this.enabledInHierarchy && this._pressed) {
                    if (!event) return !1;
                    var touch = event.touch;
                    if (!touch) return !1;
                    var state, hit = this.node._uiProps.uiTransformComp.isHit(touch.getUILocation());
                    if (this._transition === Transition.SCALE && this._target) hit ? (Vec3.copy(this._fromScale, this._originalScale), 
                    Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), this._transitionFinished = !1) : (this._time = 0, 
                    this._transitionFinished = !0, this._target && this._target.setScale(this._originalScale)); else state = hit ? State.PRESSED : State.NORMAL, 
                    this._applyTransition(state);
                    event && (event.propagationStopped = !0);
                }
            }
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded(event) {
                this._interactable && this.enabledInHierarchy && (this._pressed && (EventHandler.emitEvents(this.clickEvents, event), 
                this.node.emit(EventType$1.CLICK, this)), this._pressed = !1, this._updateState(), 
                event && (event.propagationStopped = !0));
            }
        }, {
            key: "_onTouchCancel",
            value: function _onTouchCancel(event) {
                this._interactable && this.enabledInHierarchy && (this._pressed = !1, this._updateState());
            }
        }, {
            key: "_onMouseMoveIn",
            value: function _onMouseMoveIn(event) {
                !this._pressed && this.interactable && this.enabledInHierarchy && (this._transition !== Transition.SPRITE || this._hoverSprite) && (this._hovered || (this._hovered = !0, 
                this._updateState()));
            }
        }, {
            key: "_onMouseMoveOut",
            value: function _onMouseMoveOut(event) {
                this._hovered && (this._hovered = !1, this._updateState());
            }
        }, {
            key: "_updateState",
            value: function _updateState() {
                var state = this._getButtonState();
                this._applyTransition(state);
            }
        }, {
            key: "_getButtonState",
            value: function _getButtonState() {
                var state = State.NORMAL;
                return this._interactable ? this._pressed ? state = State.PRESSED : this._hovered && (state = State.HOVER) : state = State.DISABLED, 
                state.toString();
            }
        }, {
            key: "_updateColorTransition",
            value: function _updateColorTransition(state) {
                var color = this[state + "Color"], target = this._target;
                if (target) {
                    var renderComp = target.getComponent(UIRenderComponent);
                    renderComp && (state === State.DISABLED ? renderComp.color = color : (this._fromColor = renderComp.color.clone(), 
                    this._toColor = color, this._time = 0, this._transitionFinished = !1));
                }
            }
        }, {
            key: "_updateSpriteTransition",
            value: function _updateSpriteTransition(state) {
                var sprite = this[state + "Sprite"];
                this._sprite && sprite && (this._sprite.spriteFrame = sprite);
            }
        }, {
            key: "_updateScaleTransition",
            value: function _updateScaleTransition(state) {
                this._interactable && (state === State.PRESSED ? this._zoomUp() : this._zoomBack());
            }
        }, {
            key: "_zoomUp",
            value: function _zoomUp() {
                Vec3.copy(this._fromScale, this._originalScale), Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), 
                this._time = 0, this._transitionFinished = !1;
            }
        }, {
            key: "_zoomBack",
            value: function _zoomBack() {
                this._target && (Vec3.copy(this._fromScale, this._target.getScale()), Vec3.copy(this._toScale, this._originalScale), 
                this._time = 0, this._transitionFinished = !1);
            }
        }, {
            key: "_applyTransition",
            value: function _applyTransition(state) {
                var transition = this._transition;
                transition === Transition.COLOR ? this._updateColorTransition(state) : transition === Transition.SPRITE ? this._updateSpriteTransition(state) : transition === Transition.SCALE && this._updateScaleTransition(state);
            }
        }, {
            key: "interactable",
            get: function get() {
                return this._interactable;
            },
            set: function set(value) {
                this._interactable = value, this._updateState(), this._interactable || this._resetState();
            }
        }, {
            key: "_resizeToTarget",
            set: function set(value) {
                value && this._resizeNodeToTargetNode();
            }
        }, {
            key: "transition",
            get: function get() {
                return this._transition;
            },
            set: function set(value) {
                this._transition !== value && (this._transition = value);
            }
        }, {
            key: "normalColor",
            get: function get() {
                return this._normalColor;
            },
            set: function set(value) {
                this._normalColor !== value && (this._normalColor.set(value), this._updateState());
            }
        }, {
            key: "pressedColor",
            get: function get() {
                return this._pressColor;
            },
            set: function set(value) {
                this._pressColor !== value && this._pressColor.set(value);
            }
        }, {
            key: "hoverColor",
            get: function get() {
                return this._hoverColor;
            },
            set: function set(value) {
                this._hoverColor !== value && this._hoverColor.set(value);
            }
        }, {
            key: "disabledColor",
            get: function get() {
                return this._disabledColor;
            },
            set: function set(value) {
                this._disabledColor !== value && (this._disabledColor.set(value), this._updateState());
            }
        }, {
            key: "duration",
            get: function get() {
                return this._duration;
            },
            set: function set(value) {
                this._duration !== value && (this._duration = value);
            }
        }, {
            key: "zoomScale",
            get: function get() {
                return this._zoomScale;
            },
            set: function set(value) {
                this._zoomScale !== value && (this._zoomScale = value);
            }
        }, {
            key: "normalSprite",
            get: function get() {
                return this._normalSprite;
            },
            set: function set(value) {
                if (this._normalSprite !== value) {
                    this._normalSprite = value;
                    var sprite = this.node.getComponent(SpriteComponent);
                    sprite && (sprite.spriteFrame = value), this._updateState();
                }
            }
        }, {
            key: "pressedSprite",
            get: function get() {
                return this._pressedSprite;
            },
            set: function set(value) {
                this._pressedSprite !== value && (this._pressedSprite = value, this._updateState());
            }
        }, {
            key: "hoverSprite",
            get: function get() {
                return this._hoverSprite;
            },
            set: function set(value) {
                this._hoverSprite !== value && (this._hoverSprite = value, this._updateState());
            }
        }, {
            key: "disabledSprite",
            get: function get() {
                return this._disabledSprite;
            },
            set: function set(value) {
                this._disabledSprite !== value && (this._disabledSprite = value, this._updateState());
            }
        }, {
            key: "target",
            get: function get() {
                return this._target;
            },
            set: function set(value) {
                this._target !== value && (this._target = value, this._applyTarget());
            }
        } ]), ButtonComponent;
    }(Component), _class3$m.Transition = Transition, _class3$m.EventType = EventType$1, 
    _applyDecoratedDescriptor((_class2$Z = _temp$$).prototype, "interactable", [ _dec5$l ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "interactable"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "transition", [ _dec6$h ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "transition"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "normalColor", [ _dec7$e ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "normalColor"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "pressedColor", [ _dec8$9 ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "pressedColor"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "hoverColor", [ _dec9$6 ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "hoverColor"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "disabledColor", [ _dec10$6 ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "disabledColor"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "duration", [ _dec11$6 ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "duration"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "zoomScale", [ _dec12$5 ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "zoomScale"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "normalSprite", [ _dec13$4 ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "normalSprite"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "pressedSprite", [ _dec14$3 ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "pressedSprite"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "hoverSprite", [ _dec15$3 ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "hoverSprite"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "disabledSprite", [ _dec16$3 ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "disabledSprite"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "target", [ _dec17$1 ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "target"), _class2$Z.prototype), 
    _descriptor$Q = _applyDecoratedDescriptor(_class2$Z.prototype, "clickEvents", [ _dec18$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$F = _applyDecoratedDescriptor(_class2$Z.prototype, "_interactable", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor3$w = _applyDecoratedDescriptor(_class2$Z.prototype, "_transition", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Transition.NONE;
        }
    }), _descriptor4$n = _applyDecoratedDescriptor(_class2$Z.prototype, "_normalColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(214, 214, 214, 255);
        }
    }), _descriptor5$i = _applyDecoratedDescriptor(_class2$Z.prototype, "_hoverColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(211, 211, 211, 255);
        }
    }), _descriptor6$9 = _applyDecoratedDescriptor(_class2$Z.prototype, "_pressColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE.clone();
        }
    }), _descriptor7$8 = _applyDecoratedDescriptor(_class2$Z.prototype, "_disabledColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(124, 124, 124, 255);
        }
    }), _descriptor8$7 = _applyDecoratedDescriptor(_class2$Z.prototype, "_normalSprite", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor9$6 = _applyDecoratedDescriptor(_class2$Z.prototype, "_hoverSprite", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor10$6 = _applyDecoratedDescriptor(_class2$Z.prototype, "_pressedSprite", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor11$4 = _applyDecoratedDescriptor(_class2$Z.prototype, "_disabledSprite", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor12$3 = _applyDecoratedDescriptor(_class2$Z.prototype, "_duration", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _descriptor13$3 = _applyDecoratedDescriptor(_class2$Z.prototype, "_zoomScale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1.2;
        }
    }), _descriptor14$3 = _applyDecoratedDescriptor(_class2$Z.prototype, "_target", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$17 = _class2$Z)) || _class$17) || _class$17) || _class$17) || _class$17);
    cc.ButtonComponent = ButtonComponent;
    var _dec$17, _dec2$J, _dec3$t, _dec4$p, _dec5$m, _dec6$i, _dec7$f, _dec8$a, _dec9$7, _dec10$7, _dec11$7, _dec12$6, _dec13$5, _dec14$4, _dec15$4, _dec16$4, _dec17$2, _dec18$2, _class$18, _class2$_, _descriptor$R, _descriptor2$G, _descriptor3$x, _descriptor4$o, _descriptor5$j, _descriptor6$a, _descriptor7$9, _descriptor8$8, _descriptor9$7, _descriptor10$7, _descriptor11$5, _descriptor12$4, _descriptor13$4, _descriptor14$4, _descriptor15$1, _descriptor16$1, _class3$n, _temp$10, HorizontalTextAlignment, CacheMode, CanvasPool = function() {
        function CanvasPool() {
            _classCallCheck(this, CanvasPool), this.pool = [];
        }
        return _createClass(CanvasPool, [ {
            key: "get",
            value: function get() {
                var data = this.pool.pop();
                if (!data) {
                    var canvas = document.createElement("canvas"), context = canvas.getContext("2d");
                    data = {
                        canvas: canvas,
                        context: context
                    };
                }
                return data;
            }
        }, {
            key: "put",
            value: function put(canvas) {
                this.pool.length >= 32 || this.pool.push(canvas);
            }
        } ]), CanvasPool;
    }();
    (HorizontalTextAlignment = exports.HorizontalTextAlignment || (exports.HorizontalTextAlignment = {}))[HorizontalTextAlignment.LEFT = 0] = "LEFT", 
    HorizontalTextAlignment[HorizontalTextAlignment.CENTER = 1] = "CENTER", HorizontalTextAlignment[HorizontalTextAlignment.RIGHT = 2] = "RIGHT", 
    ccenum(exports.HorizontalTextAlignment), function(VerticalTextAlignment) {
        VerticalTextAlignment[VerticalTextAlignment.TOP = 0] = "TOP", VerticalTextAlignment[VerticalTextAlignment.CENTER = 1] = "CENTER", 
        VerticalTextAlignment[VerticalTextAlignment.BOTTOM = 2] = "BOTTOM";
    }(exports.VerticalTextAlignment || (exports.VerticalTextAlignment = {})), ccenum(exports.VerticalTextAlignment), 
    function(Overflow) {
        Overflow[Overflow.NONE = 0] = "NONE", Overflow[Overflow.CLAMP = 1] = "CLAMP", Overflow[Overflow.SHRINK = 2] = "SHRINK", 
        Overflow[Overflow.RESIZE_HEIGHT = 3] = "RESIZE_HEIGHT";
    }(exports.Overflow || (exports.Overflow = {})), ccenum(exports.Overflow), function(CacheMode) {
        CacheMode[CacheMode.NONE = 0] = "NONE", CacheMode[CacheMode.BITMAP = 1] = "BITMAP", 
        CacheMode[CacheMode.CHAR = 2] = "CHAR";
    }(CacheMode || (CacheMode = {})), ccenum(CacheMode);
    var LabelComponent = (_dec$17 = ccclass("cc.LabelComponent"), _dec2$J = executionOrder(110), 
    _dec3$t = menu("UI/Render/Label"), _dec4$p = property({
        displayOrder: 4,
        multiline: !0,
        tooltip: "Label 显示的文本内容字符串"
    }), _dec5$m = property({
        type: exports.HorizontalTextAlignment,
        displayOrder: 5,
        tooltip: "文字水平对齐模式"
    }), _dec6$i = property({
        type: exports.VerticalTextAlignment,
        displayOrder: 6,
        tooltip: "文字垂直对齐模式"
    }), _dec7$f = property({
        readonly: !0,
        displayName: "Actual Font Size",
        visible: !1
    }), _dec8$a = property({
        displayOrder: 7,
        tooltip: "文字尺寸，以 point 为单位"
    }), _dec9$7 = property({
        displayOrder: 8,
        tooltip: "文字字体名字"
    }), _dec10$7 = property({
        displayOrder: 8,
        tooltip: "文字行高，以 point 为单位"
    }), _dec11$7 = property({
        type: exports.Overflow,
        displayOrder: 9,
        tooltip: "文字排版模式，包括以下三种：\n 1. CLAMP: 节点约束框之外的文字会被截断 \n 2. SHRINK: 自动根据节点约束框缩小文字\n 3. RESIZE_HEIGHT: 根据文本内容自动更新节点的 height 属性."
    }), _dec12$6 = property({
        displayOrder: 10,
        tooltip: "自动换行"
    }), _dec13$5 = property({
        type: Font,
        displayOrder: 11,
        tooltip: "Label 使用的字体资源"
    }), _dec14$4 = property({
        displayOrder: 12,
        tooltip: "是否使用系统默认字体"
    }), _dec15$4 = property({
        type: CacheMode,
        displayOrder: 13,
        tooltip: "文本缓存模式，包括以下三种：\n 1. NONE: 不做任何缓存，文本内容进行一次绘制 \n 2. BITMAP: 将文本作为静态图像加入动态图集进行批次合并，但是不能频繁动态修改文本内容 \n 3. CHAR: 将文本拆分为字符并且把字符纹理缓存到一张字符图集中进行复用，适用于字符内容重复并且频繁更新的文本内容"
    }), _dec16$4 = property({
        displayOrder: 15,
        tooltip: "字体加粗"
    }), _dec17$2 = property({
        displayOrder: 16,
        tooltip: "字体倾斜"
    }), _dec18$2 = property({
        displayOrder: 17,
        tooltip: "字体加下划线"
    }), _dec$17(_class$18 = _dec2$J(_class$18 = _dec3$t((_temp$10 = _class3$n = function(_UIRenderComponent) {
        function LabelComponent() {
            var _this;
            return _classCallCheck(this, LabelComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LabelComponent).call(this)), "_useOriginalSize", _descriptor$R, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_string", _descriptor2$G, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$x, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_verticalAlign", _descriptor4$o, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_actualFontSize", _descriptor5$j, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_fontSize", _descriptor6$a, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_fontFamily", _descriptor7$9, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_lineHeight", _descriptor8$8, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_overflow", _descriptor9$7, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_enableWrapText", _descriptor10$7, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_font", _descriptor11$5, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isSystemFontUsed", _descriptor12$4, _assertThisInitialized(_this)), 
            _this._spacingX = 0, _initializerDefineProperty(_this, "_isItalic", _descriptor13$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isBold", _descriptor14$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isUnderline", _descriptor15$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_cacheMode", _descriptor16$1, _assertThisInitialized(_this)), 
            _this._N$file = null, _this._texture = null, _this._ttfSpriteFrame = null, _this._userDefinedFont = null, 
            _this._assemblerData = null, _this._fontAtlas = null, _this._letterTexture = null, 
            _this._ttfSpriteFrame = null, _this;
        }
        return _inherits(LabelComponent, _UIRenderComponent), _createClass(LabelComponent, [ {
            key: "string",
            get: function get() {
                return this._string;
            },
            set: function set(value) {
                value = value.toString(), this._string !== value && (this._string = value, this.updateRenderData());
            }
        }, {
            key: "horizontalAlign",
            get: function get() {
                return this._horizontalAlign;
            },
            set: function set(value) {
                this._horizontalAlign !== value && (this._horizontalAlign = value, this.updateRenderData());
            }
        }, {
            key: "verticalAlign",
            get: function get() {
                return this._verticalAlign;
            },
            set: function set(value) {
                this._verticalAlign !== value && (this._verticalAlign = value, this.updateRenderData());
            }
        }, {
            key: "actualFontSize",
            get: function get() {
                return this._actualFontSize;
            },
            set: function set(value) {
                this._actualFontSize = value;
            }
        }, {
            key: "fontSize",
            get: function get() {
                return this._fontSize;
            },
            set: function set(value) {
                this._fontSize !== value && (this._fontSize = value, this.updateRenderData());
            }
        }, {
            key: "fontFamily",
            get: function get() {
                return this._fontFamily;
            },
            set: function set(value) {
                this._fontFamily !== value && (this._fontFamily = value, this.updateRenderData());
            }
        }, {
            key: "lineHeight",
            get: function get() {
                return this._lineHeight;
            },
            set: function set(value) {
                this._lineHeight !== value && (this._lineHeight = value, this.updateRenderData());
            }
        }, {
            key: "overflow",
            get: function get() {
                return this._overflow;
            },
            set: function set(value) {
                this._overflow !== value && (this._overflow = value, this.updateRenderData());
            }
        }, {
            key: "enableWrapText",
            get: function get() {
                return this._enableWrapText;
            },
            set: function set(value) {
                this._enableWrapText !== value && (this._enableWrapText = value, this.updateRenderData());
            }
        }, {
            key: "font",
            get: function get() {
                return this._font;
            },
            set: function set(value) {
                this._font !== value && (this._isSystemFontUsed = !value, this._font = value, "string" == typeof value && warnID(4e3), 
                this._renderData && (this.destroyRenderData(), this._renderData = null), this._fontAtlas = null, 
                this.updateRenderData(!0));
            }
        }, {
            key: "useSystemFont",
            get: function get() {
                return this._isSystemFontUsed;
            },
            set: function set(value) {
                this._isSystemFontUsed !== value && (this.destroyRenderData(), this._renderData = null, 
                this._isSystemFontUsed = !!value, value && (this.font = null, this._flushAssembler(), 
                this.updateRenderData()));
            }
        }, {
            key: "cacheMode",
            get: function get() {
                return this._cacheMode;
            },
            set: function set(value) {
                this._cacheMode !== value && (this._cacheMode === CacheMode.CHAR && (this._ttfSpriteFrame = null), 
                this._cacheMode = value, this.updateRenderData(!0));
            }
        }, {
            key: "spriteFrame",
            get: function get() {
                return this._texture;
            }
        }, {
            key: "isBold",
            get: function get() {
                return this._isBold;
            },
            set: function set(value) {
                this._isBold !== value && (this._isBold = value, this.updateRenderData());
            }
        }, {
            key: "isItalic",
            get: function get() {
                return this._isItalic;
            },
            set: function set(value) {
                this._isItalic !== value && (this._isItalic = value, this.updateRenderData());
            }
        }, {
            key: "isUnderline",
            get: function get() {
                return this._isUnderline;
            },
            set: function set(value) {
                this._isUnderline !== value && (this._isUnderline = value, this.updateRenderData());
            }
        }, {
            key: "assemblerData",
            get: function get() {
                return this._assemblerData;
            }
        }, {
            key: "fontAtlas",
            get: function get() {
                return this._fontAtlas;
            },
            set: function set(value) {
                this._fontAtlas = value;
            }
        }, {
            key: "spacingX",
            get: function get() {
                return this._spacingX;
            },
            set: function set(value) {
                this._spacingX !== value && (this._spacingX = value, this.updateRenderData());
            }
        }, {
            key: "_bmFontOriginalSize",
            get: function get() {
                return this._font instanceof BitmapFont ? this._font.fontSize : -1;
            }
        } ]), _createClass(LabelComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(LabelComponent.prototype), "onEnable", this).call(this), this._font || this._isSystemFontUsed || (this.useSystemFont = !0), 
                this._isSystemFontUsed && !this._fontFamily && (this.fontFamily = "Arial"), this.updateRenderData(!0);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(LabelComponent.prototype), "onDisable", this).call(this);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                if (this._assembler && this._assembler.resetAssemblerData && this._assembler.resetAssemblerData(this._assemblerData), 
                this._assemblerData = null, this._ttfSpriteFrame) {
                    var tex = this._ttfSpriteFrame.texture;
                    if (tex) {
                        var tex2d = tex;
                        tex2d.image && tex2d.image.destroy(), tex.destroy();
                    }
                    this._ttfSpriteFrame = null;
                }
                this._letterTexture = null, _get(_getPrototypeOf(LabelComponent.prototype), "onDestroy", this).call(this);
            }
        }, {
            key: "updateRenderData",
            value: function updateRenderData() {
                var force = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                this.markForUpdateRenderData(), force && (this._flushAssembler(), this._applyFontTexture(force));
            }
        }, {
            key: "_render",
            value: function _render(render) {
                render.commitComp(this, this._texture.getGFXTextureView(), this._assembler);
            }
        }, {
            key: "_updateColor",
            value: function _updateColor() {
                this._font instanceof BitmapFont ? _get(_getPrototypeOf(LabelComponent.prototype), "_updateColor", this).call(this) : this.updateRenderData(!1);
            }
        }, {
            key: "_canRender",
            value: function _canRender() {
                if (!_get(_getPrototypeOf(LabelComponent.prototype), "_canRender", this).call(this) || !this._string) return !1;
                var font = this._font;
                if (font && font instanceof BitmapFont) {
                    var spriteFrame = font.spriteFrame;
                    if (!spriteFrame || !spriteFrame.textureLoaded()) return !1;
                }
                return !0;
            }
        }, {
            key: "_flushAssembler",
            value: function _flushAssembler() {
                var assembler = LabelComponent.Assembler.getAssembler(this);
                this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
                this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
                this._renderData.material = this._material);
            }
        }, {
            key: "_flushMaterial",
            value: function _flushMaterial() {
                this._updateMaterial(this._material);
            }
        }, {
            key: "_applyFontTexture",
            value: function _applyFontTexture(force) {
                var _this2 = this, font = this._font;
                if (font instanceof BitmapFont) {
                    var spriteFrame = font.spriteFrame, self = this;
                    spriteFrame && spriteFrame.loaded && function onBMFontTextureLoaded() {
                        self._texture = spriteFrame, self._flushMaterial(), force && _this2._renderFlag && _this2._assembler && _this2._renderData && _this2._assembler.updateRenderData(_this2);
                    }();
                } else {
                    if (this.cacheMode === CacheMode.CHAR && sys.browserType !== sys.BROWSER_TYPE_WECHAT_GAME_SUB) this._letterTexture = this._assembler.getAssemblerData(), 
                    this._texture = this._letterTexture; else if (!this._ttfSpriteFrame) {
                        this._ttfSpriteFrame = new SpriteFrame, this._assemblerData = this._assembler.getAssemblerData();
                        var tex = new ImageAsset(this._assemblerData.canvas)._texture;
                        this._ttfSpriteFrame.texture = tex;
                    }
                    this.cacheMode !== CacheMode.CHAR && (this._texture = this._ttfSpriteFrame), this._flushMaterial();
                }
                force && this._renderFlag && this._assembler && this._renderData && this._assembler.updateRenderData(this);
            }
        } ]), LabelComponent;
    }(UIRenderComponent), _class3$n.HorizontalAlign = exports.HorizontalTextAlignment, 
    _class3$n.VerticalAlign = exports.VerticalTextAlignment, _class3$n.Overflow = exports.Overflow, 
    _class3$n.CacheMode = CacheMode, _class3$n._canvasPool = new CanvasPool, _applyDecoratedDescriptor((_class2$_ = _temp$10).prototype, "string", [ _dec4$p ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "string"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "horizontalAlign", [ _dec5$m ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "horizontalAlign"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "verticalAlign", [ _dec6$i ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "verticalAlign"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "actualFontSize", [ _dec7$f ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "actualFontSize"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "fontSize", [ _dec8$a ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "fontSize"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "fontFamily", [ _dec9$7 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "fontFamily"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "lineHeight", [ _dec10$7 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "lineHeight"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "overflow", [ _dec11$7 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "overflow"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "enableWrapText", [ _dec12$6 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "enableWrapText"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "font", [ _dec13$5 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "font"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "useSystemFont", [ _dec14$4 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "useSystemFont"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "cacheMode", [ _dec15$4 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "cacheMode"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "isBold", [ _dec16$4 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "isBold"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "isItalic", [ _dec17$2 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "isItalic"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "isUnderline", [ _dec18$2 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "isUnderline"), _class2$_.prototype), 
    _descriptor$R = _applyDecoratedDescriptor(_class2$_.prototype, "_useOriginalSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor2$G = _applyDecoratedDescriptor(_class2$_.prototype, "_string", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "label";
        }
    }), _descriptor3$x = _applyDecoratedDescriptor(_class2$_.prototype, "_horizontalAlign", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.HorizontalTextAlignment.CENTER;
        }
    }), _descriptor4$o = _applyDecoratedDescriptor(_class2$_.prototype, "_verticalAlign", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.VerticalTextAlignment.CENTER;
        }
    }), _descriptor5$j = _applyDecoratedDescriptor(_class2$_.prototype, "_actualFontSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$a = _applyDecoratedDescriptor(_class2$_.prototype, "_fontSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 40;
        }
    }), _descriptor7$9 = _applyDecoratedDescriptor(_class2$_.prototype, "_fontFamily", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "Arial";
        }
    }), _descriptor8$8 = _applyDecoratedDescriptor(_class2$_.prototype, "_lineHeight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 40;
        }
    }), _descriptor9$7 = _applyDecoratedDescriptor(_class2$_.prototype, "_overflow", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.Overflow.NONE;
        }
    }), _descriptor10$7 = _applyDecoratedDescriptor(_class2$_.prototype, "_enableWrapText", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor11$5 = _applyDecoratedDescriptor(_class2$_.prototype, "_font", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor12$4 = _applyDecoratedDescriptor(_class2$_.prototype, "_isSystemFontUsed", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor13$4 = _applyDecoratedDescriptor(_class2$_.prototype, "_isItalic", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor14$4 = _applyDecoratedDescriptor(_class2$_.prototype, "_isBold", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor15$1 = _applyDecoratedDescriptor(_class2$_.prototype, "_isUnderline", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor16$1 = _applyDecoratedDescriptor(_class2$_.prototype, "_cacheMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return CacheMode.NONE;
        }
    }), _class$18 = _class2$_)) || _class$18) || _class$18) || _class$18);
    cc.LabelComponent = LabelComponent;
    var KeyboardReturnType, InputMode, InputFlag, tabIndexUtil = function() {
        function tabIndexUtil() {
            _classCallCheck(this, tabIndexUtil);
        }
        return _createClass(tabIndexUtil, null, [ {
            key: "add",
            value: function add(editBoxImpl) {
                var list = this._tabIndexList;
                -1 === list.indexOf(editBoxImpl) && list.push(editBoxImpl);
            }
        }, {
            key: "remove",
            value: function remove(editBoxImpl) {
                var list = this._tabIndexList, index = list.indexOf(editBoxImpl);
                -1 !== index && list.splice(index, 1);
            }
        }, {
            key: "resort",
            value: function resort() {
                this._tabIndexList.sort((function(a, b) {
                    return a._delegate.tabIndex - b._delegate.tabIndex;
                }));
            }
        }, {
            key: "next",
            value: function next(editBoxImpl) {
                var list = this._tabIndexList, index = list.indexOf(editBoxImpl);
                if (editBoxImpl.setFocus(!1), -1 !== index) {
                    var nextImpl = list[index + 1];
                    nextImpl && nextImpl._delegate.tabIndex >= 0 && nextImpl.setFocus(!0);
                }
            }
        } ]), tabIndexUtil;
    }();
    tabIndexUtil._tabIndexList = [], function(KeyboardReturnType) {
        KeyboardReturnType[KeyboardReturnType.DEFAULT = 0] = "DEFAULT", KeyboardReturnType[KeyboardReturnType.DONE = 1] = "DONE", 
        KeyboardReturnType[KeyboardReturnType.SEND = 2] = "SEND", KeyboardReturnType[KeyboardReturnType.SEARCH = 3] = "SEARCH", 
        KeyboardReturnType[KeyboardReturnType.GO = 4] = "GO", KeyboardReturnType[KeyboardReturnType.NEXT = 5] = "NEXT";
    }(KeyboardReturnType || (KeyboardReturnType = {})), Enum(KeyboardReturnType), function(InputMode) {
        InputMode[InputMode.ANY = 0] = "ANY", InputMode[InputMode.EMAIL_ADDR = 1] = "EMAIL_ADDR", 
        InputMode[InputMode.NUMERIC = 2] = "NUMERIC", InputMode[InputMode.PHONE_NUMBER = 3] = "PHONE_NUMBER", 
        InputMode[InputMode.URL = 4] = "URL", InputMode[InputMode.DECIMAL = 5] = "DECIMAL", 
        InputMode[InputMode.SINGLE_LINE = 6] = "SINGLE_LINE";
    }(InputMode || (InputMode = {})), Enum(InputMode), function(InputFlag) {
        InputFlag[InputFlag.PASSWORD = 0] = "PASSWORD", InputFlag[InputFlag.SENSITIVE = 1] = "SENSITIVE", 
        InputFlag[InputFlag.INITIAL_CAPS_WORD = 2] = "INITIAL_CAPS_WORD", InputFlag[InputFlag.INITIAL_CAPS_SENTENCE = 3] = "INITIAL_CAPS_SENTENCE", 
        InputFlag[InputFlag.INITIAL_CAPS_ALL_CHARACTERS = 4] = "INITIAL_CAPS_ALL_CHARACTERS", 
        InputFlag[InputFlag.DEFAULT = 5] = "DEFAULT";
    }(InputFlag || (InputFlag = {})), Enum(InputFlag);
    var EditBoxImplBase = function() {
        function EditBoxImplBase() {
            _classCallCheck(this, EditBoxImplBase), this._editing = !1, this._delegate = null;
        }
        return _createClass(EditBoxImplBase, [ {
            key: "init",
            value: function init(delegate) {}
        }, {
            key: "onEnable",
            value: function onEnable() {}
        }, {
            key: "update",
            value: function update() {}
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._editing && this.endEditing();
            }
        }, {
            key: "clear",
            value: function clear() {
                this._delegate = null;
            }
        }, {
            key: "setTabIndex",
            value: function setTabIndex(index) {}
        }, {
            key: "setSize",
            value: function setSize(width, height) {}
        }, {
            key: "setFocus",
            value: function setFocus(value) {
                value ? this.beginEditing() : this.endEditing();
            }
        }, {
            key: "isFocused",
            value: function isFocused() {
                return this._editing;
            }
        }, {
            key: "beginEditing",
            value: function beginEditing() {}
        }, {
            key: "endEditing",
            value: function endEditing() {}
        } ]), EditBoxImplBase;
    }(), _matrix$1 = new Mat4, _matrix_temp = new Mat4, _vec3$1 = new Vec3, _currentEditBoxImpl = null, _domCount = 0, polyfill = {
        zoomInvalid: !1
    };
    sys.OS_ANDROID !== sys.os || sys.browserType !== sys.BROWSER_TYPE_SOUGOU && sys.browserType !== sys.BROWSER_TYPE_360 || (polyfill.zoomInvalid = !0);
    var _dec$18, _dec2$K, _dec3$u, _dec4$q, _dec5$n, _dec6$j, _dec7$g, _dec8$b, _dec9$8, _dec10$8, _dec11$8, _dec12$7, _dec13$6, _dec14$5, _dec15$5, _dec16$5, _dec17$3, _dec18$3, _dec19$1, _dec20$1, _dec21$1, _dec22$1, _dec23$1, _class$19, _class2$$, _descriptor$S, _descriptor2$H, _descriptor3$y, _descriptor4$p, _descriptor5$k, _descriptor6$b, _descriptor7$a, _descriptor8$9, _descriptor9$8, _descriptor10$8, _descriptor11$6, _descriptor12$5, _descriptor13$5, _descriptor14$5, _class3$o, _temp$11, EventType$2, EditBoxImpl = function(_EditBoxImplBase) {
        function EditBoxImpl() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, EditBoxImpl);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditBoxImpl)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._delegate = null, 
            _this._inputMode = InputMode.ANY, _this._inputFlag = InputFlag.DEFAULT, _this._returnType = KeyboardReturnType.DEFAULT, 
            _this._maxLength = 50, _this._placeholderText = "", _this._alwaysOnTop = !1, _this._size = new Size, 
            _this._node = null, _this._editing = !1, _this.__eventListeners = {}, _this.__fullscreen = !1, 
            _this.__autoResize = !1, _this.__rotateScreen = !1, _this._edTxt = null, _this._textColor = Color.WHITE.clone(), 
            _this._edFontSize = 14, _this._isTextArea = !1, _this._textLabelFont = null, _this._textLabelFontSize = null, 
            _this._textLabelFontColor = null, _this._textLabelAlign = null, _this._placeholderLabelFont = null, 
            _this._placeholderLabelFontSize = null, _this._placeholderLabelFontColor = null, 
            _this._placeholderLabelAlign = null, _this._placeholderLineHeight = null, _this._placeholderStyleSheet = null, 
            _this._domId = "EditBoxId_".concat(++_domCount), _this;
        }
        return _inherits(EditBoxImpl, _EditBoxImplBase), _createClass(EditBoxImpl, [ {
            key: "init",
            value: function init(delegate) {
                delegate && (this._delegate = delegate, delegate.inputMode === InputMode.ANY ? this._createTextArea() : this._createInput(), 
                tabIndexUtil.add(this), this.setTabIndex(delegate.tabIndex), this._initStyleSheet(), 
                this._registerEventListeners(), this._addDomToGameContainer(), this.__fullscreen = view.isAutoFullScreenEnabled(), 
                this.__autoResize = view._resizeWithBrowserSize);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {}
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._editing && this._edTxt && this._edTxt.blur();
            }
        }, {
            key: "clear",
            value: function clear() {
                this._removeEventListeners(), this._removeDomFromGameContainer(), tabIndexUtil.remove(this), 
                _currentEditBoxImpl === this && (_currentEditBoxImpl = null), this._delegate = null;
            }
        }, {
            key: "update",
            value: function update() {
                this._updateMatrix();
            }
        }, {
            key: "setTabIndex",
            value: function setTabIndex(index) {
                this._edTxt.tabIndex = index, tabIndexUtil.resort();
            }
        }, {
            key: "setSize",
            value: function setSize(width, height) {
                var elem = this._edTxt;
                elem && (elem.style.width = width + "px", elem.style.height = height + "px");
            }
        }, {
            key: "setFocus",
            value: function setFocus(value) {
                value ? this.beginEditing() : this._edTxt.blur();
            }
        }, {
            key: "isFocused",
            value: function isFocused() {
                return this._editing;
            }
        }, {
            key: "beginEditing",
            value: function beginEditing() {
                _currentEditBoxImpl && _currentEditBoxImpl !== this && _currentEditBoxImpl.setFocus(!1), 
                this._editing = !0, _currentEditBoxImpl = this, this._showDom(), this._edTxt && this._delegate && (this._edTxt.focus(), 
                this._delegate._editBoxEditingDidBegan());
            }
        }, {
            key: "endEditing",
            value: function endEditing() {}
        }, {
            key: "_createInput",
            value: function _createInput() {
                this._isTextArea = !1, this._edTxt = document.createElement("input");
            }
        }, {
            key: "_createTextArea",
            value: function _createTextArea() {
                this._isTextArea = !0, this._edTxt = document.createElement("textarea");
            }
        }, {
            key: "_addDomToGameContainer",
            value: function _addDomToGameContainer() {
                game.container && this._edTxt && (game.container.appendChild(this._edTxt), document.head.appendChild(this._placeholderStyleSheet));
            }
        }, {
            key: "_removeDomFromGameContainer",
            value: function _removeDomFromGameContainer() {
                contains$1(game.container, this._edTxt) && this._edTxt && game.container.removeChild(this._edTxt), 
                contains$1(document.head, this._placeholderStyleSheet) && document.head.removeChild(this._placeholderStyleSheet), 
                delete this._edTxt, delete this._placeholderStyleSheet;
            }
        }, {
            key: "_showDom",
            value: function _showDom() {
                this._updateMaxLength(), this._updateInputType(), this._updateStyleSheet(), this._edTxt && this._delegate && (this._edTxt.style.display = "", 
                this._delegate._hideLabels()), sys.isMobile && this._showDomOnMobile();
            }
        }, {
            key: "_hideDom",
            value: function _hideDom() {
                var elem = this._edTxt;
                elem && this._delegate && (elem.style.display = "none", this._delegate._showLabels()), 
                sys.isMobile && this._hideDomOnMobile();
            }
        }, {
            key: "_showDomOnMobile",
            value: function _showDomOnMobile() {
                sys.os === sys.OS_ANDROID && (this.__fullscreen && (view.enableAutoFullScreen(!1), 
                screen$1.exitFullScreen()), this.__autoResize && view.resizeWithBrowserSize(!1), 
                this._adjustWindowScroll());
            }
        }, {
            key: "_hideDomOnMobile",
            value: function _hideDomOnMobile() {
                var _this2 = this;
                sys.os === sys.OS_ANDROID && setTimeout((function() {
                    _currentEditBoxImpl || (_this2.__fullscreen && view.enableAutoFullScreen(!0), _this2.__autoResize && view.resizeWithBrowserSize(!0));
                }), 400), this._scrollBackWindow();
            }
        }, {
            key: "_adjustWindowScroll",
            value: function _adjustWindowScroll() {
                var self = this;
                setTimeout((function() {
                    window.scrollY < 40 && self._edTxt.scrollIntoView({
                        block: "start",
                        inline: "nearest",
                        behavior: "smooth"
                    });
                }), 400);
            }
        }, {
            key: "_scrollBackWindow",
            value: function _scrollBackWindow() {
                setTimeout((function() {
                    sys.browserType !== sys.BROWSER_TYPE_WECHAT || sys.os !== sys.OS_IOS ? window.scrollTo(0, 0) : window.top && window.top.scrollTo(0, 0);
                }), 400);
            }
        }, {
            key: "_updateMatrix",
            value: function _updateMatrix() {
                if (this._edTxt) {
                    var node = this._delegate.node, scaleX = view.getScaleX(), scaleY = view.getScaleY(), viewport = view.getViewportRect(), dpr = view.getDevicePixelRatio();
                    node.getWorldMatrix(_matrix$1);
                    var transform = node._uiProps.uiTransformComp;
                    if (transform && Vec3.set(_vec3$1, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3$1.z), 
                    Mat4.transform(_matrix$1, _matrix$1, _vec3$1), !node._uiProps.uiTransformComp) return !1;
                    var canvas = director.root.ui.getScreen(node._uiProps.uiTransformComp.visibility);
                    if (canvas) {
                        canvas.node.getWorldRT(_matrix_temp);
                        var m12 = _matrix_temp.m12, m13 = _matrix_temp.m13, center = visibleRect.center;
                        _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13), 
                        _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13), 
                        Mat4.multiply(_matrix_temp, _matrix_temp, _matrix$1), scaleX /= dpr, scaleY /= dpr;
                        var container = game.container, a = _matrix_temp.m00 * scaleX, b = _matrix$1.m01, c = _matrix$1.m04, d = _matrix_temp.m05 * scaleY, offsetX = parseInt(container && container.style.paddingLeft || "0");
                        offsetX += viewport.x / dpr;
                        var offsetY = parseInt(container && container.style.paddingBottom || "0");
                        offsetY += viewport.y / dpr;
                        var tx = _matrix_temp.m12 * scaleX + offsetX, ty = _matrix_temp.m13 * scaleY + offsetY;
                        polyfill.zoomInvalid && (this.setSize(this._size.width * a, this._size.height * d), 
                        a = 1, d = 1);
                        var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
                        this._edTxt.style.transform = matrix, this._edTxt.style["-webkit-transform"] = matrix, 
                        this._edTxt.style["transform-origin"] = "0px 100% 0px", this._edTxt.style["-webkit-transform-origin"] = "0px 100% 0px";
                    }
                }
            }
        }, {
            key: "_updateInputType",
            value: function _updateInputType() {
                var delegate = this._delegate, inputMode = delegate.inputMode, inputFlag = delegate.inputFlag, returnType = delegate.returnType, elem = this._edTxt;
                if (this._inputMode !== inputMode || this._inputFlag !== inputFlag || this._returnType !== returnType) {
                    if (this._inputMode = inputMode, this._inputFlag = inputFlag, this._returnType = returnType, 
                    this._isTextArea) {
                        var _textTransform = "none";
                        return inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? _textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (_textTransform = "capitalize"), 
                        void (elem.style.textTransform = _textTransform);
                    }
                    if (elem = elem, inputFlag !== InputFlag.PASSWORD) {
                        var type = elem.type;
                        inputMode === InputMode.EMAIL_ADDR ? type = "email" : inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL ? type = "number" : inputMode === InputMode.PHONE_NUMBER ? (type = "number", 
                        elem.pattern = "[0-9]*") : inputMode === InputMode.URL ? type = "url" : (type = "text", 
                        returnType === KeyboardReturnType.SEARCH && (type = "search")), elem.type = type;
                        var textTransform = "none";
                        inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (textTransform = "capitalize"), 
                        elem.style.textTransform = textTransform;
                    } else elem.type = "password";
                }
            }
        }, {
            key: "_updateMaxLength",
            value: function _updateMaxLength() {
                var maxLength = this._delegate.maxLength;
                maxLength < 0 && (maxLength = 65535), this._edTxt.maxLength = maxLength;
            }
        }, {
            key: "_initStyleSheet",
            value: function _initStyleSheet() {
                if (this._edTxt) {
                    var elem = this._edTxt;
                    elem.style.fontSize = this._edFontSize + "px", elem.style.color = "#000000", elem.style.border = "0px", 
                    elem.style.background = "transparent", elem.style.width = "100%", elem.style.height = "100%", 
                    elem.style.outline = "medium", elem.style.padding = "0", elem.style.textTransform = "uppercase", 
                    elem.style.display = "none", elem.style.position = "absolute", elem.style.bottom = "0px", 
                    elem.style.left = "2px", elem.className = "cocosEditBox", elem.style.fontFamily = "Arial", 
                    elem.id = this._domId, this._isTextArea ? (elem.style.resize = "none", elem.style.overflowY = "scroll") : ((elem = elem).type = "text", 
                    elem.style["-moz-appearance"] = "textfield"), this._placeholderStyleSheet = document.createElement("style");
                }
            }
        }, {
            key: "_updateStyleSheet",
            value: function _updateStyleSheet() {
                var delegate = this._delegate, elem = this._edTxt;
                elem && delegate && (elem.value = delegate.string, elem.placeholder = delegate.placeholder, 
                this._updateTextLabel(delegate.textLabel), this._updatePlaceholderLabel(delegate.placeholderLabel));
            }
        }, {
            key: "_updateTextLabel",
            value: function _updateTextLabel(textLabel) {
                if (textLabel) {
                    var font = textLabel.font;
                    if (font = !font || font instanceof BitmapFont ? textLabel.fontFamily : font._fontFamily, 
                    (this._textLabelFont !== font || this._textLabelFontSize !== textLabel.fontSize || this._textLabelFontColor !== textLabel.fontColor || this._textLabelAlign !== textLabel.horizontalAlign) && (this._textLabelFont = font, 
                    this._textLabelFontSize = textLabel.fontSize, this._textLabelFontColor = textLabel.fontColor, 
                    this._textLabelAlign = textLabel.horizontalAlign, this._edTxt)) {
                        var elem = this._edTxt;
                        switch (elem.style.fontSize = "".concat(textLabel.fontSize, "px"), elem.style.color = textLabel.color.toCSS("rgba"), 
                        elem.style.fontFamily = font, textLabel.horizontalAlign) {
                          case LabelComponent.HorizontalAlign.LEFT:
                            elem.style.textAlign = "left";
                            break;

                          case LabelComponent.HorizontalAlign.CENTER:
                            elem.style.textAlign = "center";
                            break;

                          case LabelComponent.HorizontalAlign.RIGHT:
                            elem.style.textAlign = "right";
                        }
                    }
                }
            }
        }, {
            key: "_updatePlaceholderLabel",
            value: function _updatePlaceholderLabel(placeholderLabel) {
                if (placeholderLabel) {
                    var font = placeholderLabel.font;
                    if (font = !font || font instanceof BitmapFont ? placeholderLabel.fontFamily : placeholderLabel.font._fontFamily, 
                    this._placeholderLabelFont !== font || this._placeholderLabelFontSize !== placeholderLabel.fontSize || this._placeholderLabelFontColor !== placeholderLabel.fontColor || this._placeholderLabelAlign !== placeholderLabel.horizontalAlign || this._placeholderLineHeight !== placeholderLabel.fontSize) {
                        this._placeholderLabelFont = font, this._placeholderLabelFontSize = placeholderLabel.fontSize, 
                        this._placeholderLabelFontColor = placeholderLabel.fontColor, this._placeholderLabelAlign = placeholderLabel.horizontalAlign, 
                        this._placeholderLineHeight = placeholderLabel.fontSize;
                        var styleEl = this._placeholderStyleSheet, fontSize = placeholderLabel.fontSize, fontColor = placeholderLabel.color.toCSS("rgba"), lineHeight = placeholderLabel.fontSize, horizontalAlign = "";
                        switch (placeholderLabel.horizontalAlign) {
                          case LabelComponent.HorizontalAlign.LEFT:
                            horizontalAlign = "left";
                            break;

                          case LabelComponent.HorizontalAlign.CENTER:
                            horizontalAlign = "center";
                            break;

                          case LabelComponent.HorizontalAlign.RIGHT:
                            horizontalAlign = "right";
                        }
                        styleEl.innerHTML = "\n            #".concat(this._domId, "::-webkit-input-placeholder {\n                text-transform: initial;\n                font-family: ").concat(font, ";\n                font-size: ").concat(fontSize, "px;\n                color: ").concat(fontColor, ";\n                line-height: ").concat(lineHeight, "px;\n                text-align: ").concat(horizontalAlign, ";\n            }\n            #").concat(this._domId, "::-moz-placeholder {\n                text-transform: initial;\n                font-family: ").concat(font, ";\n                font-size: ").concat(fontSize, "px;\n                color: ").concat(fontColor, ";\n                line-height: ").concat(lineHeight, "px;\n                text-align: ").concat(horizontalAlign, ";\n            }\n            #").concat(this._domId, ":-ms-input-placeholder {\n                text-transform: initial;\n                font-family: ").concat(font, ";\n                font-size: ").concat(fontSize, "px;\n                color: ").concat(fontColor, ";\n                line-height: ").concat(lineHeight, "px;\n                text-align: ").concat(horizontalAlign, ";\n            }\n        ");
                    }
                }
            }
        }, {
            key: "_registerEventListeners",
            value: function _registerEventListeners() {
                if (this._edTxt) {
                    var impl = this, elem = this._edTxt, inputLock = !1, cbs = this.__eventListeners;
                    cbs.compositionStart = function() {
                        inputLock = !0;
                    }, cbs.compositionEnd = function() {
                        inputLock = !1, impl._delegate._editBoxTextChanged(elem.value);
                    }, cbs.onInput = function() {
                        inputLock || impl._delegate._editBoxTextChanged(elem.value);
                    }, cbs.onClick = function() {
                        impl._editing && sys.isMobile && impl._adjustWindowScroll();
                    }, cbs.onKeydown = function(e) {
                        e.keyCode === macro.KEY.enter ? (e.propagationStopped = !0, impl._delegate._editBoxEditingReturn(), 
                        impl._isTextArea || elem.blur()) : e.keyCode === macro.KEY.tab && (e.propagationStopped = !0, 
                        e.preventDefault(), tabIndexUtil.next(impl));
                    }, cbs.onBlur = function() {
                        impl._editing = !1, _currentEditBoxImpl = null, impl._hideDom(), impl._delegate._editBoxEditingDidEnded();
                    }, elem.addEventListener("compositionstart", cbs.compositionStart), elem.addEventListener("compositionend", cbs.compositionEnd), 
                    elem.addEventListener("input", cbs.onInput), elem.addEventListener("keydown", cbs.onKeydown), 
                    elem.addEventListener("blur", cbs.onBlur), elem.addEventListener("touchstart", cbs.onClick);
                }
            }
        }, {
            key: "_removeEventListeners",
            value: function _removeEventListeners() {
                if (this._edTxt) {
                    var elem = this._edTxt, cbs = this.__eventListeners;
                    elem.removeEventListener("compositionstart", cbs.compositionStart), elem.removeEventListener("compositionend", cbs.compositionEnd), 
                    elem.removeEventListener("input", cbs.onInput), elem.removeEventListener("keydown", cbs.onKeydown), 
                    elem.removeEventListener("blur", cbs.onBlur), elem.removeEventListener("touchstart", cbs.onClick), 
                    cbs.compositionStart = null, cbs.compositionEnd = null, cbs.onInput = null, cbs.onKeydown = null, 
                    cbs.onBlur = null, cbs.onClick = null;
                }
            }
        } ]), EditBoxImpl;
    }(EditBoxImplBase);
    function capitalize(str) {
        return str.replace(/(?:^|\s)\S/g, (function(a) {
            return a.toUpperCase();
        }));
    }
    function capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    !function(EventType) {
        EventType.EDITING_DID_BEGAN = "editing-did-began", EventType.EDITING_DID_ENDED = "editing-did-ended", 
        EventType.TEXT_CHANGED = "text-changed", EventType.EDITING_RETURN = "editing-return";
    }(EventType$2 || (EventType$2 = {}));
    var _dec$19, _dec2$L, _dec3$v, _dec4$r, _dec5$o, _dec6$k, _dec7$h, _dec8$c, _dec9$9, _dec10$9, _dec11$9, _dec12$8, _dec13$7, _dec14$6, _dec15$6, _dec16$6, _dec17$4, _dec18$4, _class$1a, _class2$10, _descriptor$T, _descriptor2$I, _descriptor3$z, _descriptor4$q, _descriptor5$l, _descriptor6$c, _descriptor7$b, _descriptor8$a, _descriptor9$9, _descriptor10$9, _descriptor11$7, _descriptor12$6, _descriptor13$6, _descriptor14$6, _class3$p, _temp$12, EditBoxComponent = (_dec$18 = ccclass("cc.EditBoxComponent"), 
    _dec2$K = executionOrder(100), _dec3$u = menu("UI/EditBox"), _dec4$q = property({
        tooltip: "输入框的初始输入内容，如果为空则会显示占位符的文本"
    }), _dec5$n = property({
        tooltip: "输入框输入文本节点上挂载的 Label 组件对象",
        type: LabelComponent
    }), _dec6$j = property({
        tooltip: "输入框占位符节点上挂载的 Label 组件对象",
        type: LabelComponent
    }), _dec7$g = property({
        type: SpriteFrame,
        tooltip: "输入框的背景图片"
    }), _dec8$b = property({
        type: KeyboardReturnType,
        tooltip: "指定移动设备上面回车按钮的样式"
    }), _dec9$8 = property({
        type: InputFlag,
        tooltip: "指定输入标志位，可以指定输入方式为密码或者单词首字母大写"
    }), _dec10$8 = property({
        type: InputMode,
        tooltip: "指定输入模式: ANY 表示多行输入，其它都是单行输入，移动平台上还可以指定键盘样式"
    }), _dec11$8 = property({
        tooltip: "输入框文本的字体大小"
    }), _dec12$7 = property({
        tooltip: "输入框文本的行高"
    }), _dec13$6 = property({
        type: Color,
        tooltip: "输入框文本的颜色"
    }), _dec14$5 = property({
        tooltip: "输入框占位符的文本内容"
    }), _dec15$5 = property({
        tooltip: "输入框占位符的字体大小"
    }), _dec16$5 = property({
        tooltip: "输入框占位符的字体颜色"
    }), _dec17$3 = property({
        tooltip: "输入框最大允许输入的字符个数"
    }), _dec18$3 = property({
        tooltip: "输入框总是可见，并且永远在游戏视图的上面（这个属性只有在 Web 上面修改有意义）"
    }), _dec19$1 = property({
        tooltip: "修改 DOM 输入元素的 tabIndex（这个属性只有在 Web 上面修改有意义）"
    }), _dec20$1 = property({
        type: [ EventHandler ],
        tooltip: "该事件在用户点击输入框获取焦点的时候被触发"
    }), _dec21$1 = property({
        type: [ EventHandler ],
        tooltip: "编辑文本输入框时触发的事件回调"
    }), _dec22$1 = property({
        type: [ EventHandler ],
        tooltip: "在单行模式下面，一般是在用户按下回车或者点击屏幕输入框以外的地方调用该函数。 如果是多行输入，一般是在用户点击屏幕输入框以外的地方调用该函数"
    }), _dec23$1 = property({
        type: [ EventHandler ],
        tooltip: "该事件在用户按下回车键的时候被触发, 如果是单行输入框，按回车键还会使输入框失去焦点"
    }), _dec$18(_class$19 = _dec2$K(_class$19 = _dec3$u(_class$19 = executeInEditMode((_temp$11 = _class3$o = function(_Component) {
        function EditBoxComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, EditBoxComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditBoxComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "editingDidBegan", _descriptor$S, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "textChanged", _descriptor2$H, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "editingDidEnded", _descriptor3$y, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "editingReturn", _descriptor4$p, _assertThisInitialized(_this)), 
            _this._impl = null, _this._background = null, _initializerDefineProperty(_this, "_textLabel", _descriptor5$k, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_placeholderLabel", _descriptor6$b, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_returnType", _descriptor7$a, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_useOriginalSize", _descriptor8$9, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_string", _descriptor9$8, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_tabIndex", _descriptor10$8, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_backgroundImage", _descriptor11$6, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_inputFlag", _descriptor12$5, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_inputMode", _descriptor13$5, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_maxLength", _descriptor14$5, _assertThisInitialized(_this)), 
            _this._isLabelVisible = !1, _this;
        }
        return _inherits(EditBoxComponent, _Component), _createClass(EditBoxComponent, [ {
            key: "__preload",
            value: function __preload() {
                this._init();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._registerEvent(), this._impl && this._impl.onEnable();
            }
        }, {
            key: "update",
            value: function update() {
                this._impl && this._impl.update();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._unregisterEvent(), this._impl && this._impl.onDisable();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._impl && this._impl.clear();
            }
        }, {
            key: "setFocus",
            value: function setFocus() {
                this._impl && this._impl.setFocus(!0);
            }
        }, {
            key: "focus",
            value: function focus() {
                this._impl && this._impl.setFocus(!0);
            }
        }, {
            key: "blur",
            value: function blur() {
                this._impl && this._impl.setFocus(!1);
            }
        }, {
            key: "isFocused",
            value: function isFocused() {
                return !!this._impl && this._impl.isFocused();
            }
        }, {
            key: "_editBoxEditingDidBegan",
            value: function _editBoxEditingDidBegan() {
                EventHandler.emitEvents(this.editingDidBegan, this), this.node.emit(EventType$2.EDITING_DID_BEGAN, this);
            }
        }, {
            key: "_editBoxEditingDidEnded",
            value: function _editBoxEditingDidEnded() {
                EventHandler.emitEvents(this.editingDidEnded, this), this.node.emit(EventType$2.EDITING_DID_ENDED, this);
            }
        }, {
            key: "_editBoxTextChanged",
            value: function _editBoxTextChanged(text) {
                text = this._updateLabelStringStyle(text, !0), this.string = text, EventHandler.emitEvents(this.textChanged, text, this), 
                this.node.emit(EventType$2.TEXT_CHANGED, this);
            }
        }, {
            key: "_editBoxEditingReturn",
            value: function _editBoxEditingReturn() {
                EventHandler.emitEvents(this.editingReturn, this), this.node.emit(EventType$2.EDITING_RETURN, this);
            }
        }, {
            key: "_showLabels",
            value: function _showLabels() {
                this._isLabelVisible = !0, this._updateLabels();
            }
        }, {
            key: "_hideLabels",
            value: function _hideLabels() {
                this._isLabelVisible = !1, this._textLabel && (this._textLabel.node.active = !1), 
                this._placeholderLabel && (this._placeholderLabel.node.active = !1);
            }
        }, {
            key: "_onTouchBegan",
            value: function _onTouchBegan(event) {
                event.propagationStopped = !0;
            }
        }, {
            key: "_onTouchCancel",
            value: function _onTouchCancel(event) {
                event.propagationStopped = !0;
            }
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded(event) {
                this._impl && this._impl.beginEditing(), event.propagationStopped = !0;
            }
        }, {
            key: "_init",
            value: function _init() {
                this._createBackgroundSprite(), this._updatePlaceholderLabel(), this._updateTextLabel(), 
                this._isLabelVisible = !0, this.node.on(exports.SystemEventType.SIZE_CHANGED, this._resizeChildNodes, this), 
                (this._impl = new EditBoxComponent._EditBoxImpl).init(this), this._updateString(this._string), 
                this._syncSize();
            }
        }, {
            key: "_createBackgroundSprite",
            value: function _createBackgroundSprite() {
                this._background || (this._background = this.node.getComponent(SpriteComponent), 
                this._background || (this._background = this.node.addComponent(SpriteComponent))), 
                this._background.type = SpriteComponent.Type.SLICED, this._background.spriteFrame = this._backgroundImage;
            }
        }, {
            key: "_updateTextLabel",
            value: function _updateTextLabel() {
                var textLabel = this._textLabel;
                if (!textLabel) {
                    var node = this.node.getChildByName("TEXT_LABEL");
                    node || (node = new Node$1("TEXT_LABEL")), (textLabel = node.getComponent(LabelComponent)) || (textLabel = node.addComponent(LabelComponent)), 
                    node.parent = this.node, this._textLabel = textLabel;
                }
                this._textLabel.node._uiProps.uiTransformComp.setAnchorPoint(0, 1), textLabel.overflow = LabelComponent.Overflow.CLAMP, 
                this._inputMode === InputMode.ANY ? (textLabel.verticalAlign = exports.VerticalTextAlignment.TOP, 
                textLabel.enableWrapText = !0) : (textLabel.verticalAlign = exports.VerticalTextAlignment.CENTER, 
                textLabel.enableWrapText = !1), textLabel.string = this._updateLabelStringStyle(this._string);
            }
        }, {
            key: "_updatePlaceholderLabel",
            value: function _updatePlaceholderLabel() {
                var placeholderLabel = this._placeholderLabel;
                if (!placeholderLabel) {
                    var node = this.node.getChildByName("PLACEHOLDER_LABEL");
                    node || (node = new Node$1("PLACEHOLDER_LABEL")), (placeholderLabel = node.getComponent(LabelComponent)) || (placeholderLabel = node.addComponent(LabelComponent)), 
                    node.parent = this.node, this._placeholderLabel = placeholderLabel;
                }
                this._placeholderLabel.node._uiProps.uiTransformComp.setAnchorPoint(0, 1), placeholderLabel.overflow = LabelComponent.Overflow.CLAMP, 
                this._inputMode === InputMode.ANY ? (placeholderLabel.verticalAlign = exports.VerticalTextAlignment.TOP, 
                placeholderLabel.enableWrapText = !0) : (placeholderLabel.verticalAlign = exports.VerticalTextAlignment.CENTER, 
                placeholderLabel.enableWrapText = !1), placeholderLabel.string = this.placeholder;
            }
        }, {
            key: "_syncSize",
            value: function _syncSize() {
                var size = this.node.getContentSize();
                this._background && (this._background.node._uiProps.uiTransformComp.anchorPoint = this.node._uiProps.uiTransformComp.anchorPoint, 
                this._background.node.setContentSize(size)), this._updateLabelPosition(size), this._impl && this._impl.setSize(size.width, size.height);
            }
        }, {
            key: "_updateLabels",
            value: function _updateLabels() {
                if (this._isLabelVisible) {
                    var content = this._string;
                    this._textLabel && (this._textLabel.node.active = "" !== content), this._placeholderLabel && (this._placeholderLabel.node.active = "" === content);
                }
            }
        }, {
            key: "_updateString",
            value: function _updateString(text) {
                var textLabel = this._textLabel;
                if (textLabel) {
                    var displayText = text;
                    displayText && (displayText = this._updateLabelStringStyle(displayText)), textLabel.string = displayText, 
                    this._updateLabels();
                }
            }
        }, {
            key: "_updateLabelStringStyle",
            value: function _updateLabelStringStyle(text) {
                var ignorePassword = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], inputFlag = this._inputFlag;
                if (ignorePassword || inputFlag !== InputFlag.PASSWORD) inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? text = text.toUpperCase() : inputFlag === InputFlag.INITIAL_CAPS_WORD ? text = capitalize(text) : inputFlag === InputFlag.INITIAL_CAPS_SENTENCE && (text = capitalizeFirstLetter(text)); else {
                    for (var passwordString = "", len = text.length, i = 0; i < len; ++i) passwordString += "●";
                    text = passwordString;
                }
                return text;
            }
        }, {
            key: "_registerEvent",
            value: function _registerEvent() {
                this.node.on(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this);
            }
        }, {
            key: "_unregisterEvent",
            value: function _unregisterEvent() {
                this.node.off(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.off(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this);
            }
        }, {
            key: "_updateLabelPosition",
            value: function _updateLabelPosition(size) {
                var node = this.node, offX = -node.anchorX * node.width, offY = -node.anchorY * node.height, placeholderLabel = this._placeholderLabel, textLabel = this._textLabel;
                textLabel && (textLabel.node.setContentSize(size.width - 2, size.height), textLabel.node.position = new Vec3(offX + 2, offY + size.height, textLabel.node.position.z), 
                textLabel.verticalAlign = this._inputMode === InputMode.ANY ? exports.VerticalTextAlignment.TOP : exports.VerticalTextAlignment.CENTER, 
                textLabel.enableWrapText = this._inputMode === InputMode.ANY), placeholderLabel && (placeholderLabel.node.setContentSize(size.width - 2, size.height), 
                placeholderLabel.lineHeight = size.height, placeholderLabel.node.position = new Vec3(offX + 2, offY + size.height, placeholderLabel.node.position.z), 
                placeholderLabel.verticalAlign = this._inputMode === InputMode.ANY ? exports.VerticalTextAlignment.TOP : exports.VerticalTextAlignment.CENTER, 
                placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY);
            }
        }, {
            key: "_resizeChildNodes",
            value: function _resizeChildNodes() {
                var textLabelNode = this._textLabel && this._textLabel.node;
                textLabelNode && (textLabelNode.position = new Vec3(-this.node.width / 2, this.node.height / 2, textLabelNode.position.z), 
                textLabelNode.width = this.node.width, textLabelNode.height = this.node.height);
                var placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;
                placeholderLabelNode && (placeholderLabelNode.position = new Vec3(-this.node.width / 2, this.node.height / 2, placeholderLabelNode.position.z), 
                placeholderLabelNode.width = this.node.width, placeholderLabelNode.height = this.node.height);
                var backgroundNode = this._background && this._background.node;
                backgroundNode && (backgroundNode.width = this.node.width, backgroundNode.height = this.node.height);
            }
        }, {
            key: "string",
            get: function get() {
                return this._string;
            },
            set: function set(value) {
                this._maxLength >= 0 && value.length >= this._maxLength && (value = value.slice(0, this._maxLength)), 
                this._string = value, this._updateString(value);
            }
        }, {
            key: "textLabel",
            get: function get() {
                return this._textLabel;
            },
            set: function set(oldValue) {
                this._textLabel !== oldValue && (this._textLabel = oldValue, this._textLabel && (this._updateTextLabel(), 
                this._updateLabels()));
            }
        }, {
            key: "placeholderLabel",
            get: function get() {
                return this._placeholderLabel;
            },
            set: function set(oldValue) {
                this._placeholderLabel !== oldValue && (this._placeholderLabel = oldValue, this._placeholderLabel && (this._updatePlaceholderLabel(), 
                this._updateLabels()));
            }
        }, {
            key: "backgroundImage",
            get: function get() {
                return this._backgroundImage;
            },
            set: function set(value) {
                this._backgroundImage !== value && (this._backgroundImage = value, this._createBackgroundSprite());
            }
        }, {
            key: "returnType",
            get: function get() {
                return this._returnType;
            },
            set: function set(value) {
                this._returnType = value;
            }
        }, {
            key: "inputFlag",
            get: function get() {
                return this._inputFlag;
            },
            set: function set(value) {
                this._inputFlag = value, this._updateString(this._string);
            }
        }, {
            key: "inputMode",
            get: function get() {
                return this._inputMode;
            },
            set: function set(oldValue) {
                this._inputMode !== oldValue && (this._inputMode = oldValue, this._updateTextLabel(), 
                this._updatePlaceholderLabel());
            }
        }, {
            key: "fontSize",
            get: function get() {
                return this._textLabel ? this._textLabel.fontSize : 20;
            },
            set: function set(value) {
                this._textLabel && (this._textLabel.fontSize = value);
            }
        }, {
            key: "lineHeight",
            get: function get() {
                return this._textLabel ? this._textLabel.lineHeight : 40;
            },
            set: function set(value) {
                this._textLabel && (this._textLabel.lineHeight = value);
            }
        }, {
            key: "fontColor",
            get: function get() {
                return this._textLabel ? this._textLabel.color : Color.WHITE.clone();
            },
            set: function set(value) {
                this._textLabel && (this._textLabel.color = value);
            }
        }, {
            key: "placeholder",
            get: function get() {
                return this._placeholderLabel ? this._placeholderLabel.string : "";
            },
            set: function set(value) {
                this._placeholderLabel && (this._placeholderLabel.string = value);
            }
        }, {
            key: "placeholderFontSize",
            get: function get() {
                return this._placeholderLabel ? this._placeholderLabel.fontSize : 20;
            },
            set: function set(value) {
                this._placeholderLabel && (this._placeholderLabel.fontSize = value);
            }
        }, {
            key: "placeholderFontColor",
            get: function get() {
                return this._placeholderLabel ? this._placeholderLabel.color : Color.GRAY.clone();
            },
            set: function set(value) {
                this._placeholderLabel && (this._placeholderLabel.color = value);
            }
        }, {
            key: "maxLength",
            get: function get() {
                return this._maxLength;
            },
            set: function set(value) {
                this._maxLength = value;
            }
        }, {
            key: "stayOnTop",
            get: function get() {},
            set: function set(value) {
                console.warn("stayOnTop is removed.");
            }
        }, {
            key: "tabIndex",
            get: function get() {
                return this._tabIndex;
            },
            set: function set(value) {
                this._tabIndex !== value && (this._tabIndex = value, this._impl && this._impl.setTabIndex(value));
            }
        } ]), EditBoxComponent;
    }(Component), _class3$o._EditBoxImpl = EditBoxImplBase, _class3$o.KeyboardReturnType = KeyboardReturnType, 
    _class3$o.InputFlag = InputFlag, _class3$o.InputMode = InputMode, _class3$o.EventType = EventType$2, 
    _applyDecoratedDescriptor((_class2$$ = _temp$11).prototype, "string", [ _dec4$q ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "string"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "textLabel", [ _dec5$n ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "textLabel"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "placeholderLabel", [ _dec6$j ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "placeholderLabel"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "backgroundImage", [ _dec7$g ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "backgroundImage"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "returnType", [ _dec8$b ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "returnType"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "inputFlag", [ _dec9$8 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "inputFlag"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "inputMode", [ _dec10$8 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "inputMode"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "fontSize", [ _dec11$8 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "fontSize"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "lineHeight", [ _dec12$7 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "lineHeight"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "fontColor", [ _dec13$6 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "fontColor"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "placeholder", [ _dec14$5 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "placeholder"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "placeholderFontSize", [ _dec15$5 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "placeholderFontSize"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "placeholderFontColor", [ _dec16$5 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "placeholderFontColor"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "maxLength", [ _dec17$3 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "maxLength"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "stayOnTop", [ _dec18$3 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "stayOnTop"), _class2$$.prototype), 
    _applyDecoratedDescriptor(_class2$$.prototype, "tabIndex", [ _dec19$1 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "tabIndex"), _class2$$.prototype), 
    _descriptor$S = _applyDecoratedDescriptor(_class2$$.prototype, "editingDidBegan", [ _dec20$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$H = _applyDecoratedDescriptor(_class2$$.prototype, "textChanged", [ _dec21$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor3$y = _applyDecoratedDescriptor(_class2$$.prototype, "editingDidEnded", [ _dec22$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor4$p = _applyDecoratedDescriptor(_class2$$.prototype, "editingReturn", [ _dec23$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor5$k = _applyDecoratedDescriptor(_class2$$.prototype, "_textLabel", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor6$b = _applyDecoratedDescriptor(_class2$$.prototype, "_placeholderLabel", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor7$a = _applyDecoratedDescriptor(_class2$$.prototype, "_returnType", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return KeyboardReturnType.DEFAULT;
        }
    }), _descriptor8$9 = _applyDecoratedDescriptor(_class2$$.prototype, "_useOriginalSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor9$8 = _applyDecoratedDescriptor(_class2$$.prototype, "_string", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor10$8 = _applyDecoratedDescriptor(_class2$$.prototype, "_tabIndex", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor11$6 = _applyDecoratedDescriptor(_class2$$.prototype, "_backgroundImage", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor12$5 = _applyDecoratedDescriptor(_class2$$.prototype, "_inputFlag", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return InputFlag.DEFAULT;
        }
    }), _descriptor13$5 = _applyDecoratedDescriptor(_class2$$.prototype, "_inputMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return InputMode.ANY;
        }
    }), _descriptor14$5 = _applyDecoratedDescriptor(_class2$$.prototype, "_maxLength", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 20;
        }
    }), _class$19 = _class2$$)) || _class$19) || _class$19) || _class$19) || _class$19);
    sys.isBrowser && (EditBoxComponent._EditBoxImpl = EditBoxImpl), cc.EditBoxComponent = EditBoxComponent;
    var Type, ResizeMode, AxisDirection, VerticalDirection, HorizontalDirection, NodeEvent = exports.SystemEventType;
    !function(Type) {
        Type[Type.NONE = 0] = "NONE", Type[Type.HORIZONTAL = 1] = "HORIZONTAL", Type[Type.VERTICAL = 2] = "VERTICAL", 
        Type[Type.GRID = 3] = "GRID";
    }(Type || (Type = {})), ccenum(Type), function(ResizeMode) {
        ResizeMode[ResizeMode.NONE = 0] = "NONE", ResizeMode[ResizeMode.CONTAINER = 1] = "CONTAINER", 
        ResizeMode[ResizeMode.CHILDREN = 2] = "CHILDREN";
    }(ResizeMode || (ResizeMode = {})), ccenum(ResizeMode), function(AxisDirection) {
        AxisDirection[AxisDirection.HORIZONTAL = 0] = "HORIZONTAL", AxisDirection[AxisDirection.VERTICAL = 1] = "VERTICAL";
    }(AxisDirection || (AxisDirection = {})), ccenum(AxisDirection), function(VerticalDirection) {
        VerticalDirection[VerticalDirection.BOTTOM_TO_TOP = 0] = "BOTTOM_TO_TOP", VerticalDirection[VerticalDirection.TOP_TO_BOTTOM = 1] = "TOP_TO_BOTTOM";
    }(VerticalDirection || (VerticalDirection = {})), ccenum(VerticalDirection), function(HorizontalDirection) {
        HorizontalDirection[HorizontalDirection.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", HorizontalDirection[HorizontalDirection.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT";
    }(HorizontalDirection || (HorizontalDirection = {})), ccenum(HorizontalDirection);
    var LineCap, LineJoin, PointFlags, _dec$1a, _dec2$M, _dec3$w, _dec4$s, _dec5$p, _dec6$l, _dec7$i, _dec8$d, _dec9$a, _class$1b, _class2$11, _descriptor$U, _descriptor2$J, _descriptor3$A, _descriptor4$r, _descriptor5$m, _descriptor6$d, _class3$q, _temp$13, _tempPos = new Vec3, _tempScale = new Vec3, LayoutComponent = (_dec$19 = ccclass("cc.LayoutComponent"), 
    _dec2$L = executionOrder(110), _dec3$v = menu("UI/Layout"), _dec4$r = requireComponent(UITransformComponent), 
    _dec5$o = property({
        type: Type,
        tooltip: "自动布局模式，包括：\n 1. NONE，不会对子节点进行自动布局 \n 2. HORIZONTAL，横向自动排布子物体 \n 3. VERTICAL，垂直自动排布子物体\n 4. GRID, 采用网格方式对子物体自动进行布局"
    }), _dec6$k = property({
        type: ResizeMode,
        tooltip: "缩放模式，包括：\n 1. NONE，不会对子节点和容器进行大小缩放 \n 2. CONTAINER, 对容器的大小进行缩放 \n 3. CHILDREN, 对子节点的大小进行缩放"
    }), _dec7$h = property({
        tooltip: "每个格子的大小，只有布局类型为 GRID 的时候才有效"
    }), _dec8$c = property({
        type: AxisDirection,
        tooltip: "起始轴方向类型，可进行水平和垂直布局排列，只有布局类型为 GRID 的时候才有效"
    }), _dec9$9 = property({
        tooltip: "容器内左边距，只会在一个布局方向上生效"
    }), _dec10$9 = property({
        tooltip: "容器内右边距，只会在一个布局方向上生效"
    }), _dec11$9 = property({
        tooltip: "容器内上边距，只会在一个布局方向上生效"
    }), _dec12$8 = property({
        tooltip: "容器内下边距，只会在一个布局方向上生效"
    }), _dec13$7 = property({
        tooltip: "子节点之间的水平间距"
    }), _dec14$6 = property({
        tooltip: "子节点之间的垂直间距"
    }), _dec15$6 = property({
        type: VerticalDirection,
        tooltip: "垂直排列子节点的方向"
    }), _dec16$6 = property({
        type: HorizontalDirection,
        tooltip: "水平排列子节点的方向"
    }), _dec17$4 = property({
        tooltip: "容器内边距，该属性会在四个布局方向上生效"
    }), _dec18$4 = property({
        tooltip: "子节点缩放比例是否影响布局"
    }), _dec$19(_class$1a = _dec2$L(_class$1a = _dec3$v(_class$1a = _dec4$r(_class$1a = executeInEditMode((_temp$12 = _class3$p = function(_Component) {
        function LayoutComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, LayoutComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LayoutComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_resizeMode", _descriptor$T, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_N$layoutType", _descriptor2$I, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_N$padding", _descriptor3$z, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_cellSize", _descriptor4$q, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_startAxis", _descriptor5$l, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_paddingLeft", _descriptor6$c, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_paddingRight", _descriptor7$b, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_paddingTop", _descriptor8$a, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_paddingBottom", _descriptor9$9, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_spacingX", _descriptor10$9, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_spacingY", _descriptor11$7, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_verticalDirection", _descriptor12$6, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_horizontalDirection", _descriptor13$6, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_affectedByScale", _descriptor14$6, _assertThisInitialized(_this)), 
            _this._layoutSize = new Size(300, 200), _this._layoutDirty = !0, _this._isAlign = !1, 
            _this;
        }
        return _inherits(LayoutComponent, _Component), _createClass(LayoutComponent, [ {
            key: "updateLayout",
            value: function updateLayout() {
                this._layoutDirty && this.node.children.length > 0 && (this._doLayout(), this._layoutDirty = !1);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._addEventListeners(), this.node.getContentSize().equals(new Size) && this.node.setContentSize(this._layoutSize), 
                0 !== this._N$padding && this._migratePaddingData(), this._doLayoutDirty();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._removeEventListeners();
            }
        }, {
            key: "_migratePaddingData",
            value: function _migratePaddingData() {
                this._paddingLeft = this._N$padding, this._paddingRight = this._N$padding, this._paddingTop = this._N$padding, 
                this._paddingBottom = this._N$padding, this._N$padding = 0;
            }
        }, {
            key: "_addEventListeners",
            value: function _addEventListeners() {
                director.on(Director.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.on(NodeEvent.SIZE_CHANGED, this._resized, this), 
                this.node.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.on(NodeEvent.CHILD_ADDED, this._childAdded, this), 
                this.node.on(NodeEvent.CHILD_REMOVED, this._childRemoved, this), this._addChildrenEventListeners();
            }
        }, {
            key: "_removeEventListeners",
            value: function _removeEventListeners() {
                director.off(Director.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.off(NodeEvent.SIZE_CHANGED, this._resized, this), 
                this.node.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.off(NodeEvent.CHILD_ADDED, this._childAdded, this), 
                this.node.off(NodeEvent.CHILD_REMOVED, this._childRemoved, this), this._removeChildrenEventListeners();
            }
        }, {
            key: "_addChildrenEventListeners",
            value: function _addChildrenEventListeners() {
                var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var child = _ref;
                    child.on(NodeEvent.TRANSFORM_CHANGED, this._doScaleDirty, this), child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                    child.on(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                    child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
                }
            }
        }, {
            key: "_removeChildrenEventListeners",
            value: function _removeChildrenEventListeners() {
                var _iterator2 = this.node.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var child = _ref2;
                    child.off(NodeEvent.TRANSFORM_CHANGED, this._doScaleDirty, this), child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                    child.off(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                    child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
                }
            }
        }, {
            key: "_childAdded",
            value: function _childAdded(child) {
                child.on(NodeEvent.TRANSFORM_CHANGED, this._doScaleDirty, this), child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                child.on(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                child.on("active-in-hierarchy-changed", this._doLayoutDirty, this), this._doLayoutDirty();
            }
        }, {
            key: "_childRemoved",
            value: function _childRemoved(child) {
                child.off(NodeEvent.TRANSFORM_CHANGED, this._doScaleDirty, this), child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                child.off(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                child.off("active-in-hierarchy-changed", this._doLayoutDirty, this), this._doLayoutDirty();
            }
        }, {
            key: "_resized",
            value: function _resized() {
                this._layoutSize = this.node.getContentSize(), this._doLayoutDirty();
            }
        }, {
            key: "_doLayoutHorizontally",
            value: function _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
                var layoutAnchor = this.node.getAnchorPoint(), children = this.node.children, sign = 1, paddingX = this._paddingLeft, startPos = -layoutAnchor.x * baseWidth;
                this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, startPos = (1 - layoutAnchor.x) * baseWidth, 
                paddingX = this._paddingRight);
                var nextX = startPos + sign * paddingX - sign * this._spacingX, rowMaxHeight = 0, tempMaxHeight = 0, secondMaxHeight = 0, row = 0, containerResizeBoundary = 0, maxHeightChildAnchorY = 0, activeChildCount = 0, _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    _ref3.activeInHierarchy && activeChildCount++;
                }
                var newChildWidth = this._cellSize.width;
                this._N$layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN && (newChildWidth = (baseWidth - (this._paddingLeft + this._paddingRight) - (activeChildCount - 1) * this._spacingX) / activeChildCount);
                var _iterator4 = children, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var _child = _ref4;
                    if (_child.activeInHierarchy) {
                        _child.getScale(_tempScale);
                        var childScaleX = this._getUsedScaleValue(_tempScale.x), childScaleY = this._getUsedScaleValue(_tempScale.y);
                        this._resizeMode === ResizeMode.CHILDREN && (_child.width = newChildWidth / childScaleX, 
                        this._N$layoutType === Type.GRID && (_child.height = this._cellSize.height / childScaleY));
                        var anchorX = _child.anchorX, childBoundingBoxWidth = _child.width * childScaleX, childBoundingBoxHeight = _child.height * childScaleY;
                        secondMaxHeight > tempMaxHeight && (tempMaxHeight = secondMaxHeight), childBoundingBoxHeight >= tempMaxHeight && (secondMaxHeight = tempMaxHeight, 
                        tempMaxHeight = childBoundingBoxHeight, maxHeightChildAnchorY = _child.getAnchorPoint().y), 
                        this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (anchorX = 1 - _child.anchorX), 
                        nextX = nextX + sign * anchorX * childBoundingBoxWidth + sign * this._spacingX;
                        var rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;
                        if (rowBreak) {
                            var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this._paddingRight : this._paddingLeft), leftToRightRowBreak = !1;
                            this._horizontalDirection === HorizontalDirection.LEFT_TO_RIGHT && rowBreakBoundary > (1 - layoutAnchor.x) * baseWidth && (leftToRightRowBreak = !0);
                            var rightToLeftRowBreak = !1;
                            this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && rowBreakBoundary < -layoutAnchor.x * baseWidth && (rightToLeftRowBreak = !0), 
                            (leftToRightRowBreak || rightToLeftRowBreak) && (childBoundingBoxHeight >= tempMaxHeight ? (0 === secondMaxHeight && (secondMaxHeight = tempMaxHeight), 
                            rowMaxHeight += secondMaxHeight, secondMaxHeight = tempMaxHeight) : (rowMaxHeight += tempMaxHeight, 
                            secondMaxHeight = childBoundingBoxHeight, tempMaxHeight = 0), nextX = startPos + sign * (paddingX + anchorX * childBoundingBoxWidth), 
                            row++);
                        }
                        var finalPositionY = fnPositionY(_child, rowMaxHeight, row);
                        baseWidth >= childBoundingBoxWidth + this._paddingLeft + this._paddingRight && applyChildren && (_child.getPosition(_tempPos), 
                        _child.setPosition(nextX, finalPositionY, _tempPos.z));
                        var signX = 1, tempFinalPositionY = void 0, topMargin = 0 === tempMaxHeight ? childBoundingBoxHeight : tempMaxHeight;
                        this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM ? (containerResizeBoundary = containerResizeBoundary || this.node.getContentSize().height, 
                        (tempFinalPositionY = finalPositionY + (signX = -1) * (topMargin * maxHeightChildAnchorY + this._paddingBottom)) < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY)) : (containerResizeBoundary = containerResizeBoundary || -this.node.getContentSize().height, 
                        (tempFinalPositionY = finalPositionY + signX * (topMargin * maxHeightChildAnchorY + this._paddingTop)) > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY)), 
                        nextX += rightBoundaryOfChild;
                    }
                }
                return containerResizeBoundary;
            }
        }, {
            key: "_doLayoutVertically",
            value: function _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
                var layoutAnchor = this.node.getAnchorPoint(), children = this.node.children, sign = 1, paddingY = this._paddingBottom, bottomBoundaryOfLayout = -layoutAnchor.y * baseHeight;
                this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * baseHeight, 
                paddingY = this._paddingTop);
                var nextY = bottomBoundaryOfLayout + sign * paddingY - sign * this._spacingY, columnMaxWidth = 0, tempMaxWidth = 0, secondMaxWidth = 0, column = 0, containerResizeBoundary = 0, maxWidthChildAnchorX = 0, activeChildCount = 0, _iterator5 = children, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    _ref5.activeInHierarchy && activeChildCount++;
                }
                var newChildHeight = this._cellSize.height;
                this._N$layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN && (newChildHeight = (baseHeight - (this._paddingTop + this._paddingBottom) - (activeChildCount - 1) * this._spacingY) / activeChildCount);
                var _iterator6 = children, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref6 = _i6.value;
                    }
                    var _child2 = _ref6;
                    if (_child2) {
                        var scale = _child2.getScale(), childScaleX = this._getUsedScaleValue(scale.x), childScaleY = this._getUsedScaleValue(scale.y);
                        if (_child2.activeInHierarchy) {
                            this._resizeMode === ResizeMode.CHILDREN && (_child2.height = newChildHeight / childScaleY, 
                            this._N$layoutType === Type.GRID && (_child2.width = this._cellSize.width / childScaleX));
                            var anchorY = _child2.anchorY, childBoundingBoxWidth = _child2.width * childScaleX, childBoundingBoxHeight = _child2.height * childScaleY;
                            secondMaxWidth > tempMaxWidth && (tempMaxWidth = secondMaxWidth), childBoundingBoxWidth >= tempMaxWidth && (secondMaxWidth = tempMaxWidth, 
                            tempMaxWidth = childBoundingBoxWidth, maxWidthChildAnchorX = _child2.getAnchorPoint().x), 
                            this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (anchorY = 1 - _child2.anchorY), 
                            nextY = nextY + sign * anchorY * childBoundingBoxHeight + sign * this._spacingY;
                            var topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;
                            if (columnBreak) {
                                var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this._paddingTop : this._paddingBottom), bottomToTopColumnBreak = !1;
                                this._verticalDirection === VerticalDirection.BOTTOM_TO_TOP && columnBreakBoundary > (1 - layoutAnchor.y) * baseHeight && (bottomToTopColumnBreak = !0);
                                var topToBottomColumnBreak = !1;
                                this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && columnBreakBoundary < -layoutAnchor.y * baseHeight && (topToBottomColumnBreak = !0), 
                                (bottomToTopColumnBreak || topToBottomColumnBreak) && (childBoundingBoxWidth >= tempMaxWidth ? (0 === secondMaxWidth && (secondMaxWidth = tempMaxWidth), 
                                columnMaxWidth += secondMaxWidth, secondMaxWidth = tempMaxWidth) : (columnMaxWidth += tempMaxWidth, 
                                secondMaxWidth = childBoundingBoxWidth, tempMaxWidth = 0), nextY = bottomBoundaryOfLayout + sign * (paddingY + anchorY * childBoundingBoxHeight), 
                                column++);
                            }
                            var finalPositionX = fnPositionX(_child2, columnMaxWidth, column);
                            baseHeight >= childBoundingBoxHeight + (this._paddingTop + this._paddingBottom) && applyChildren && (_child2.getPosition(_tempPos), 
                            _child2.setPosition(finalPositionX, nextY, _tempPos.z));
                            var signX = 1, tempFinalPositionX = void 0, rightMargin = 0 === tempMaxWidth ? childBoundingBoxWidth : tempMaxWidth;
                            this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT ? (signX = -1, containerResizeBoundary = containerResizeBoundary || this.node.getContentSize().width, 
                            (tempFinalPositionX = finalPositionX + signX * (rightMargin * maxWidthChildAnchorX + this._paddingLeft)) < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX)) : (containerResizeBoundary = containerResizeBoundary || -this.node.getContentSize().width, 
                            (tempFinalPositionX = finalPositionX + signX * (rightMargin * maxWidthChildAnchorX + this._paddingRight)) > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX)), 
                            nextY += topBoundaryOfChild;
                        }
                    }
                }
                return containerResizeBoundary;
            }
        }, {
            key: "_doLayoutBasic",
            value: function _doLayoutBasic() {
                var allChildrenBoundingBox = null, _iterator7 = this.node.children, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i7 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i7++];
                    } else {
                        if ((_i7 = _iterator7.next()).done) break;
                        _ref7 = _i7.value;
                    }
                    var child = _ref7, childTransform = child.getComponent(UITransformComponent);
                    childTransform && (child.activeInHierarchy && (allChildrenBoundingBox ? Rect.union(allChildrenBoundingBox, allChildrenBoundingBox, childTransform.getBoundingBoxToWorld()) : allChildrenBoundingBox = childTransform.getBoundingBoxToWorld()));
                }
                if (allChildrenBoundingBox) {
                    var parentTransform = this.node.parent.getComponent(UITransformComponent);
                    if (!parentTransform) return;
                    Vec3.set(_tempPos, allChildrenBoundingBox.x, allChildrenBoundingBox.y, 0);
                    var leftBottomInParentSpace = new Vec3;
                    parentTransform.convertToNodeSpaceAR(_tempPos, leftBottomInParentSpace), Vec3.set(leftBottomInParentSpace, leftBottomInParentSpace.x - this._paddingLeft, leftBottomInParentSpace.y - this._paddingBottom, leftBottomInParentSpace.z), 
                    Vec3.set(_tempPos, allChildrenBoundingBox.x + allChildrenBoundingBox.width, allChildrenBoundingBox.y + allChildrenBoundingBox.height, 0);
                    var rightTopInParentSpace = new Vec3;
                    parentTransform.convertToNodeSpaceAR(_tempPos, rightTopInParentSpace), Vec3.set(rightTopInParentSpace, rightTopInParentSpace.x + this._paddingRight, rightTopInParentSpace.y + this._paddingTop, rightTopInParentSpace.z);
                    var newSize = cc.size(parseFloat((rightTopInParentSpace.x - leftBottomInParentSpace.x).toFixed(2)), parseFloat((rightTopInParentSpace.y - leftBottomInParentSpace.y).toFixed(2)));
                    if (this.node.getPosition(_tempPos), 0 !== newSize.width) {
                        var newAnchorX = (_tempPos.x - leftBottomInParentSpace.x) / newSize.width;
                        this.node.anchorX = parseFloat(newAnchorX.toFixed(2));
                    }
                    if (0 !== newSize.height) {
                        var newAnchorY = (_tempPos.y - leftBottomInParentSpace.y) / newSize.height;
                        this.node.anchorY = parseFloat(newAnchorY.toFixed(2));
                    }
                    this.node.setContentSize(newSize);
                }
            }
        }, {
            key: "_doLayoutGridAxisHorizontal",
            value: function _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
                var _this2 = this, baseWidth = layoutSize.width, sign = 1, bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height, paddingY = this._paddingBottom;
                this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height, 
                paddingY = this._paddingTop);
                var self = this, fnPositionY = function fnPositionY(child, topOffset, row) {
                    return bottomBoundaryOfLayout + sign * (topOffset + child.anchorY * child.height * self._getUsedScaleValue(child.getScale().y) + paddingY + row * _this2._spacingY);
                }, newHeight = 0;
                if (this._resizeMode === ResizeMode.CONTAINER) {
                    var boundary = this._doLayoutHorizontally(baseWidth, !0, fnPositionY, !1);
                    (newHeight = bottomBoundaryOfLayout - boundary) < 0 && (newHeight *= -1), bottomBoundaryOfLayout = -layoutAnchor.y * newHeight, 
                    this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight);
                }
                this._doLayoutHorizontally(baseWidth, !0, fnPositionY, !0), this._resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(baseWidth, newHeight);
            }
        }, {
            key: "_doLayoutGridAxisVertical",
            value: function _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
                var _this3 = this, baseHeight = layoutSize.height, sign = 1, leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width, paddingX = this._paddingLeft;
                this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width, 
                paddingX = this._paddingRight);
                var self = this, fnPositionX = function fnPositionX(child, leftOffset, column) {
                    return leftBoundaryOfLayout + sign * (leftOffset + child.anchorX * child.width * self._getUsedScaleValue(child.getScale().x) + paddingX + column * _this3._spacingX);
                }, newWidth = 0;
                if (this._resizeMode === ResizeMode.CONTAINER) {
                    var boundary = this._doLayoutVertically(baseHeight, !0, fnPositionX, !1);
                    (newWidth = leftBoundaryOfLayout - boundary) < 0 && (newWidth *= -1), leftBoundaryOfLayout = -layoutAnchor.x * newWidth, 
                    this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth);
                }
                this._doLayoutVertically(baseHeight, !0, fnPositionX, !0), this._resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(newWidth, baseHeight);
            }
        }, {
            key: "_doLayoutGrid",
            value: function _doLayoutGrid() {
                var layoutAnchor = this.node.getAnchorPoint(), layoutSize = this.node.getContentSize();
                this.startAxis === AxisDirection.HORIZONTAL ? this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) : this.startAxis === AxisDirection.VERTICAL && this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
            }
        }, {
            key: "_getHorizontalBaseWidth",
            value: function _getHorizontalBaseWidth(children) {
                var newWidth = 0, activeChildCount = 0;
                if (this._resizeMode === ResizeMode.CONTAINER) {
                    var _iterator8 = children, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
                    for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                        var _ref8;
                        if (_isArray8) {
                            if (_i8 >= _iterator8.length) break;
                            _ref8 = _iterator8[_i8++];
                        } else {
                            if ((_i8 = _iterator8.next()).done) break;
                            _ref8 = _i8.value;
                        }
                        var child = _ref8;
                        child.getScale(_tempScale), child.activeInHierarchy && (activeChildCount++, newWidth += child.width * this._getUsedScaleValue(_tempScale.x));
                    }
                    newWidth += (activeChildCount - 1) * this._spacingX + this._paddingLeft + this._paddingRight;
                } else newWidth = this.node.getContentSize().width;
                return newWidth;
            }
        }, {
            key: "_getVerticalBaseHeight",
            value: function _getVerticalBaseHeight(children) {
                var newHeight = 0, activeChildCount = 0;
                if (this._resizeMode === ResizeMode.CONTAINER) {
                    var _iterator9 = children, _isArray9 = Array.isArray(_iterator9), _i9 = 0;
                    for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                        var _ref9;
                        if (_isArray9) {
                            if (_i9 >= _iterator9.length) break;
                            _ref9 = _iterator9[_i9++];
                        } else {
                            if ((_i9 = _iterator9.next()).done) break;
                            _ref9 = _i9.value;
                        }
                        var child = _ref9;
                        child.getScale(_tempScale), child.activeInHierarchy && (activeChildCount++, newHeight += child.height * this._getUsedScaleValue(_tempScale.y));
                    }
                    newHeight += (activeChildCount - 1) * this._spacingY + this._paddingBottom + this._paddingTop;
                } else newHeight = this.node.getContentSize().height;
                return newHeight;
            }
        }, {
            key: "_doLayout",
            value: function _doLayout() {
                var _this4 = this;
                if (this._N$layoutType === Type.HORIZONTAL) {
                    var newWidth = this._getHorizontalBaseWidth(this.node.children);
                    this._doLayoutHorizontally(newWidth, !1, (function fnPositionY(child) {
                        return (_this4._isAlign ? Vec3.ZERO : child.position).y;
                    }), !0), this._isAlign = !1, this.node.width = newWidth;
                } else if (this._N$layoutType === Type.VERTICAL) {
                    var newHeight = this._getVerticalBaseHeight(this.node.children);
                    this._doLayoutVertically(newHeight, !1, (function fnPositionX(child) {
                        return (_this4._isAlign ? Vec3.ZERO : child.position).x;
                    }), !0), this._isAlign = !1, this.node.height = newHeight;
                } else this._N$layoutType === Type.NONE ? this._resizeMode === ResizeMode.CONTAINER && this._doLayoutBasic() : this._N$layoutType === Type.GRID && this._doLayoutGrid();
            }
        }, {
            key: "_getUsedScaleValue",
            value: function _getUsedScaleValue(value) {
                return this._affectedByScale ? Math.abs(value) : 1;
            }
        }, {
            key: "_transformDirty",
            value: function _transformDirty(type) {
                type & TransformBit.POSITION && this._doLayoutDirty();
            }
        }, {
            key: "_doLayoutDirty",
            value: function _doLayoutDirty() {
                this._layoutDirty = !0;
            }
        }, {
            key: "_doScaleDirty",
            value: function _doScaleDirty(type) {
                type & TransformBit.SCALE && (this._layoutDirty = this._layoutDirty || this._affectedByScale);
            }
        }, {
            key: "type",
            get: function get() {
                return this._N$layoutType;
            },
            set: function set(value) {
                this._N$layoutType = value, this._isAlign = !0, this._doLayoutDirty();
            }
        }, {
            key: "resizeMode",
            get: function get() {
                return this._resizeMode;
            },
            set: function set(value) {
                this._N$layoutType === Type.NONE && value === ResizeMode.CHILDREN || (this._resizeMode = value, 
                this._doLayoutDirty());
            }
        }, {
            key: "cellSize",
            get: function get() {
                return this._cellSize;
            },
            set: function set(value) {
                this._cellSize !== value && (this._cellSize.set(value), this._doLayoutDirty());
            }
        }, {
            key: "startAxis",
            get: function get() {
                return this._startAxis;
            },
            set: function set(value) {
                this._startAxis !== value && (this._startAxis = value, this._doLayoutDirty());
            }
        }, {
            key: "paddingLeft",
            get: function get() {
                return this._paddingLeft;
            },
            set: function set(value) {
                this._paddingLeft !== value && (this._paddingLeft = value, this._doLayoutDirty());
            }
        }, {
            key: "paddingRight",
            get: function get() {
                return this._paddingRight;
            },
            set: function set(value) {
                this._paddingRight !== value && (this._paddingRight = value, this._doLayoutDirty());
            }
        }, {
            key: "paddingTop",
            get: function get() {
                return this._paddingTop;
            },
            set: function set(value) {
                this._paddingTop !== value && (this._paddingTop = value, this._doLayoutDirty());
            }
        }, {
            key: "paddingBottom",
            get: function get() {
                return this._paddingBottom;
            },
            set: function set(value) {
                this._paddingBottom !== value && (this._paddingBottom = value, this._doLayoutDirty());
            }
        }, {
            key: "spacingX",
            get: function get() {
                return this._spacingX;
            },
            set: function set(value) {
                this._spacingX !== value && (this._spacingX = value, this._doLayoutDirty());
            }
        }, {
            key: "spacingY",
            get: function get() {
                return this._spacingY;
            },
            set: function set(value) {
                this._spacingY !== value && (this._spacingY = value, this._doLayoutDirty());
            }
        }, {
            key: "verticalDirection",
            get: function get() {
                return this._verticalDirection;
            },
            set: function set(value) {
                this._verticalDirection !== value && (this._verticalDirection = value, this._doLayoutDirty());
            }
        }, {
            key: "horizontalDirection",
            get: function get() {
                return this._horizontalDirection;
            },
            set: function set(value) {
                this._horizontalDirection !== value && (this._horizontalDirection = value, this._doLayoutDirty());
            }
        }, {
            key: "padding",
            get: function get() {
                return this._paddingLeft;
            },
            set: function set(value) {
                this._N$padding = value, this._migratePaddingData(), this._doLayoutDirty();
            }
        }, {
            key: "affectedByScale",
            get: function get() {
                return this._affectedByScale;
            },
            set: function set(value) {
                this._affectedByScale = value, this._doLayoutDirty();
            }
        } ]), LayoutComponent;
    }(Component), _class3$p.Type = Type, _class3$p.VerticalDirection = VerticalDirection, 
    _class3$p.HorizontalDirection = HorizontalDirection, _class3$p.ResizeMode = ResizeMode, 
    _class3$p.AxisDirection = AxisDirection, _applyDecoratedDescriptor((_class2$10 = _temp$12).prototype, "type", [ _dec5$o ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "type"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "resizeMode", [ _dec6$k ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "resizeMode"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "cellSize", [ _dec7$h ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "cellSize"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "startAxis", [ _dec8$c ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "startAxis"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "paddingLeft", [ _dec9$9 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "paddingLeft"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "paddingRight", [ _dec10$9 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "paddingRight"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "paddingTop", [ _dec11$9 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "paddingTop"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "paddingBottom", [ _dec12$8 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "paddingBottom"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "spacingX", [ _dec13$7 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "spacingX"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "spacingY", [ _dec14$6 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "spacingY"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "verticalDirection", [ _dec15$6 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "verticalDirection"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "horizontalDirection", [ _dec16$6 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "horizontalDirection"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "padding", [ _dec17$4 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "padding"), _class2$10.prototype), 
    _applyDecoratedDescriptor(_class2$10.prototype, "affectedByScale", [ _dec18$4 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "affectedByScale"), _class2$10.prototype), 
    _descriptor$T = _applyDecoratedDescriptor(_class2$10.prototype, "_resizeMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return ResizeMode.NONE;
        }
    }), _descriptor2$I = _applyDecoratedDescriptor(_class2$10.prototype, "_N$layoutType", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Type.NONE;
        }
    }), _descriptor3$z = _applyDecoratedDescriptor(_class2$10.prototype, "_N$padding", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor4$q = _applyDecoratedDescriptor(_class2$10.prototype, "_cellSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Size(40, 40);
        }
    }), _descriptor5$l = _applyDecoratedDescriptor(_class2$10.prototype, "_startAxis", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return AxisDirection.HORIZONTAL;
        }
    }), _descriptor6$c = _applyDecoratedDescriptor(_class2$10.prototype, "_paddingLeft", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor7$b = _applyDecoratedDescriptor(_class2$10.prototype, "_paddingRight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor8$a = _applyDecoratedDescriptor(_class2$10.prototype, "_paddingTop", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor9$9 = _applyDecoratedDescriptor(_class2$10.prototype, "_paddingBottom", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor10$9 = _applyDecoratedDescriptor(_class2$10.prototype, "_spacingX", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor11$7 = _applyDecoratedDescriptor(_class2$10.prototype, "_spacingY", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor12$6 = _applyDecoratedDescriptor(_class2$10.prototype, "_verticalDirection", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return VerticalDirection.TOP_TO_BOTTOM;
        }
    }), _descriptor13$6 = _applyDecoratedDescriptor(_class2$10.prototype, "_horizontalDirection", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return HorizontalDirection.LEFT_TO_RIGHT;
        }
    }), _descriptor14$6 = _applyDecoratedDescriptor(_class2$10.prototype, "_affectedByScale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _class$1a = _class2$10)) || _class$1a) || _class$1a) || _class$1a) || _class$1a) || _class$1a);
    cc.LayoutComponent = LayoutComponent, function(LineCap) {
        LineCap[LineCap.BUTT = 0] = "BUTT", LineCap[LineCap.ROUND = 1] = "ROUND", LineCap[LineCap.SQUARE = 2] = "SQUARE";
    }(LineCap || (LineCap = {})), ccenum(LineCap), function(LineJoin) {
        LineJoin[LineJoin.BEVEL = 0] = "BEVEL", LineJoin[LineJoin.ROUND = 1] = "ROUND", 
        LineJoin[LineJoin.MITER = 2] = "MITER";
    }(LineJoin || (LineJoin = {})), ccenum(LineJoin), function(PointFlags) {
        PointFlags[PointFlags.PT_CORNER = 1] = "PT_CORNER", PointFlags[PointFlags.PT_LEFT = 2] = "PT_LEFT", 
        PointFlags[PointFlags.PT_BEVEL = 4] = "PT_BEVEL", PointFlags[PointFlags.PT_INNERBEVEL = 8] = "PT_INNERBEVEL";
    }(PointFlags || (PointFlags = {})), ccenum(PointFlags);
    var _dec$1b, _dec2$N, _dec3$x, _dec4$t, _dec5$q, _dec6$m, _dec7$j, _dec8$e, _class$1c, _class2$12, _descriptor$V, _descriptor2$K, _descriptor3$B, _class3$r, _temp$14, _matInsInfo$2 = {
        parent: null,
        owner: null,
        subModelIdx: 0
    }, GraphicsComponent = (_dec$1a = ccclass("cc.GraphicsComponent"), _dec2$M = executionOrder(110), 
    _dec3$w = menu("UI/Render/Graphics"), _dec4$s = property({
        type: LineJoin,
        tooltip: "两条线相交时，所创建的拐角类型"
    }), _dec5$p = property({
        type: LineCap,
        tooltip: "线条的结束端点样式"
    }), _dec6$l = property({
        tooltip: "笔触的颜色"
    }), _dec7$i = property({
        tooltip: "填充绘画的颜色"
    }), _dec8$d = property({
        tooltip: "最大斜接长度"
    }), _dec9$a = property({
        override: !0,
        visible: !1
    }), _dec$1a(_class$1b = _dec2$M(_class$1b = _dec3$w((_temp$13 = _class3$q = function(_UIRenderComponent) {
        function GraphicsComponent() {
            var _this;
            return _classCallCheck(this, GraphicsComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GraphicsComponent).call(this))).impl = null, 
            _this.model = null, _initializerDefineProperty(_this, "_lineWidth", _descriptor$U, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_strokeColor", _descriptor2$J, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_lineJoin", _descriptor3$A, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_lineCap", _descriptor4$r, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_fillColor", _descriptor5$m, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_miterLimit", _descriptor6$d, _assertThisInitialized(_this)), 
            _this._instanceMaterialType = exports.InstanceMaterialType.ADDCOLOR, _this;
        }
        return _inherits(GraphicsComponent, _UIRenderComponent), _createClass(GraphicsComponent, [ {
            key: "lineWidth",
            get: function get() {
                return this._lineWidth;
            },
            set: function set(value) {
                this._lineWidth = value, this.impl && (this.impl.lineWidth = value);
            }
        }, {
            key: "lineJoin",
            get: function get() {
                return this._lineJoin;
            },
            set: function set(value) {
                this._lineJoin = value, this.impl && (this.impl.lineJoin = value);
            }
        }, {
            key: "lineCap",
            get: function get() {
                return this._lineCap;
            },
            set: function set(value) {
                this._lineCap = value, this.impl && (this.impl.lineCap = value);
            }
        }, {
            key: "strokeColor",
            get: function get() {
                return this._strokeColor;
            },
            set: function set(value) {
                this.impl && (this._strokeColor.set(value), this.impl.strokeColor = this._strokeColor);
            }
        }, {
            key: "fillColor",
            get: function get() {
                return this._fillColor;
            },
            set: function set(value) {
                this.impl && (this._fillColor.set(value), this.impl.fillColor = this._fillColor);
            }
        }, {
            key: "miterLimit",
            get: function get() {
                return this._miterLimit;
            },
            set: function set(value) {
                this._miterLimit = value;
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(value) {
                this._color !== value && (this._color.set(value), this._updateColor(), this.markForUpdateRenderData());
            }
        } ]), _createClass(GraphicsComponent, [ {
            key: "onRestore",
            value: function onRestore() {
                this.impl || this._flushAssembler();
            }
        }, {
            key: "__preload",
            value: function __preload() {
                _get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this) && _get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this).call(this), 
                this.impl = this._assembler && this._assembler.createImpl(this);
            }
        }, {
            key: "onLoad",
            value: function onLoad() {
                this._sceneGetter = director.root.ui.getRenderSceneGetter(), this.model || (this.model = director.root.createModel(Model));
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(GraphicsComponent.prototype), "onEnable", this).call(this), 
                this._attachToScene(), this._activateMaterial();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._detachFromScene();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(GraphicsComponent.prototype), "onDestroy", this).call(this), 
                this._sceneGetter = null, this.model && (this.model.destroy(), director.root.destroyModel(this.model), 
                this.model = null), this.impl && (this.impl.clear(), this.impl = null);
            }
        }, {
            key: "_activateMaterial",
            value: function _activateMaterial() {
                this._material && this._updateMaterial(this._material);
            }
        }, {
            key: "moveTo",
            value: function moveTo(x, y) {
                this.impl && this.impl.moveTo(x, y);
            }
        }, {
            key: "lineTo",
            value: function lineTo(x, y) {
                this.impl && this.impl.lineTo(x, y);
            }
        }, {
            key: "bezierCurveTo",
            value: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                this.impl && this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
            }
        }, {
            key: "quadraticCurveTo",
            value: function quadraticCurveTo(cx, cy, x, y) {
                this.impl && this.impl.quadraticCurveTo(cx, cy, x, y);
            }
        }, {
            key: "arc",
            value: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
                this.impl && this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
            }
        }, {
            key: "ellipse",
            value: function ellipse(cx, cy, rx, ry) {
                this.impl && this.impl.ellipse(cx, cy, rx, ry);
            }
        }, {
            key: "circle",
            value: function circle(cx, cy, r) {
                this.impl && this.impl.circle(cx, cy, r);
            }
        }, {
            key: "rect",
            value: function rect(x, y, w, h) {
                this.impl && this.impl.rect(x, y, w, h);
            }
        }, {
            key: "roundRect",
            value: function roundRect(x, y, w, h, r) {
                this.impl && this.impl.roundRect(x, y, w, h, r);
            }
        }, {
            key: "fillRect",
            value: function fillRect(x, y, w, h) {
                this.rect(x, y, w, h), this.fill();
            }
        }, {
            key: "clear",
            value: function clear() {
                var clean = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                this.impl && (this.impl.clear(clean), this.model && this.model.destroy(), this.markForUpdateRenderData());
            }
        }, {
            key: "close",
            value: function close() {
                this.impl && this.impl.close();
            }
        }, {
            key: "stroke",
            value: function stroke() {
                this._assembler.stroke(this);
            }
        }, {
            key: "fill",
            value: function fill() {
                this._assembler.fill(this);
            }
        }, {
            key: "helpInstanceMaterial",
            value: function helpInstanceMaterial() {
                var mat = null;
                _matInsInfo$2.owner = new RenderableComponent, this._sharedMaterial ? (_matInsInfo$2.parent = this._sharedMaterial, 
                mat = new MaterialInstance(_matInsInfo$2)) : (_matInsInfo$2.parent = builtinResMgr.get("ui-base-material"), 
                (mat = new MaterialInstance(_matInsInfo$2)).recompileShaders({
                    USE_LOCAL: !0
                })), this._updateMaterial(mat), this.impl || (this._flushAssembler(), this.impl = this._assembler && this._assembler.createImpl(this));
            }
        }, {
            key: "_render",
            value: function _render(render) {
                render.commitModel(this, this.model, this._material);
            }
        }, {
            key: "_instanceMaterial",
            value: function _instanceMaterial() {
                this.helpInstanceMaterial();
            }
        }, {
            key: "_flushAssembler",
            value: function _flushAssembler() {
                var assembler = GraphicsComponent.Assembler.getAssembler(this);
                this._assembler !== assembler && (this._assembler = assembler);
            }
        }, {
            key: "_canRender",
            value: function _canRender() {
                return !!_get(_getPrototypeOf(GraphicsComponent.prototype), "_canRender", this).call(this) && (!!this.model && this.model.inited);
            }
        }, {
            key: "_attachToScene",
            value: function _attachToScene() {
                var scene = director.root.ui.renderScene;
                this.model && (null != this.model.scene && this._detachFromScene(), scene.addModel(this.model));
            }
        }, {
            key: "_detachFromScene",
            value: function _detachFromScene() {
                this.model && this.model.scene && this.model.scene.removeModel(this.model);
            }
        } ]), GraphicsComponent;
    }(UIRenderComponent), _class3$q.LineJoin = LineJoin, _class3$q.LineCap = LineCap, 
    _applyDecoratedDescriptor((_class2$11 = _temp$13).prototype, "lineJoin", [ _dec4$s ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "lineJoin"), _class2$11.prototype), 
    _applyDecoratedDescriptor(_class2$11.prototype, "lineCap", [ _dec5$p ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "lineCap"), _class2$11.prototype), 
    _applyDecoratedDescriptor(_class2$11.prototype, "strokeColor", [ _dec6$l ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "strokeColor"), _class2$11.prototype), 
    _applyDecoratedDescriptor(_class2$11.prototype, "fillColor", [ _dec7$i ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "fillColor"), _class2$11.prototype), 
    _applyDecoratedDescriptor(_class2$11.prototype, "miterLimit", [ _dec8$d ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "miterLimit"), _class2$11.prototype), 
    _applyDecoratedDescriptor(_class2$11.prototype, "color", [ _dec9$a ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "color"), _class2$11.prototype), 
    _descriptor$U = _applyDecoratedDescriptor(_class2$11.prototype, "_lineWidth", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor2$J = _applyDecoratedDescriptor(_class2$11.prototype, "_strokeColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.BLACK.clone();
        }
    }), _descriptor3$A = _applyDecoratedDescriptor(_class2$11.prototype, "_lineJoin", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return LineJoin.MITER;
        }
    }), _descriptor4$r = _applyDecoratedDescriptor(_class2$11.prototype, "_lineCap", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return LineCap.BUTT;
        }
    }), _descriptor5$m = _applyDecoratedDescriptor(_class2$11.prototype, "_fillColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE.clone();
        }
    }), _descriptor6$d = _applyDecoratedDescriptor(_class2$11.prototype, "_miterLimit", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 10;
        }
    }), _class$1b = _class2$11)) || _class$1b) || _class$1b) || _class$1b);
    cc.GraphicsComponent = GraphicsComponent;
    var MaskType, _worldMatrix$2 = new Mat4, _vec2_temp = new Vec2, _mat4_temp$1 = new Mat4, _circlePoints = [];
    !function(MaskType) {
        MaskType[MaskType.RECT = 0] = "RECT", MaskType[MaskType.ELLIPSE = 1] = "ELLIPSE", 
        MaskType[MaskType.GRAPHICS_STENCIL = 2] = "GRAPHICS_STENCIL";
    }(MaskType || (MaskType = {})), ccenum(MaskType);
    var _dec$1c, _dec2$O, _dec3$y, _dec4$u, _dec5$r, _dec6$n, _dec7$k, _dec8$f, _class$1d, _class2$13, _descriptor$W, _descriptor2$L, _descriptor3$C, _descriptor4$s, _descriptor5$n, _class3$s, _temp$15, Mode, MaskComponent = (_dec$1b = ccclass("cc.MaskComponent"), 
    _dec2$N = executionOrder(110), _dec3$x = menu("UI/Render/Mask"), _dec4$t = property({
        type: MaskType,
        displayOrder: 4,
        tooltip: "遮罩类型"
    }), _dec5$q = property({
        tooltip: "反向遮罩"
    }), _dec6$m = property({
        visible: !1,
        override: !0
    }), _dec7$j = property({
        visible: !1,
        override: !0
    }), _dec8$e = property({
        visible: !1,
        override: !0
    }), _dec$1b(_class$1c = _dec2$N(_class$1c = _dec3$x((_temp$14 = _class3$r = function(_UIRenderComponent) {
        function MaskComponent() {
            var _this;
            return _classCallCheck(this, MaskComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(MaskComponent).call(this)), "_type", _descriptor$V, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_inverted", _descriptor2$K, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_segments", _descriptor3$B, _assertThisInitialized(_this)), 
            _this._graphics = null, _this._clearGraphics = null, _this._instanceMaterialType = exports.InstanceMaterialType.ADDCOLOR, 
            _this;
        }
        return _inherits(MaskComponent, _UIRenderComponent), _createClass(MaskComponent, [ {
            key: "type",
            get: function get() {
                return this._type;
            },
            set: function set(value) {
                this._type !== value && (this._type = value, this._updateGraphics(), this._renderData && (this.destroyRenderData(), 
                this._renderData = null));
            }
        }, {
            key: "inverted",
            get: function get() {
                return this._inverted;
            },
            set: function set(value) {
                cc.game.renderType !== Game.RENDER_TYPE_CANVAS ? this._inverted = value : cc.warnID(4202);
            }
        }, {
            key: "segments",
            get: function get() {
                return this._segments;
            },
            set: function set(value) {
                this._segments !== value && (this._segments = clamp(value, 3, 1e4), this._updateGraphics());
            }
        }, {
            key: "graphics",
            get: function get() {
                return this._graphics;
            }
        }, {
            key: "clearGraphics",
            get: function get() {
                return this._clearGraphics;
            }
        }, {
            key: "dstBlendFactor",
            get: function get() {
                return this._dstBlendFactor;
            },
            set: function set(value) {
                this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
            }
        }, {
            key: "srcBlendFactor",
            get: function get() {
                return this._srcBlendFactor;
            },
            set: function set(value) {
                this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(value) {
                this._color !== value && (this._color.set(value), this.markForUpdateRenderData());
            }
        } ]), _createClass(MaskComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this._createGraphics(), this._clearGraphics && this._clearGraphics.onLoad(), this._graphics && this._graphics.onLoad();
            }
        }, {
            key: "onRestore",
            value: function onRestore() {
                this._createGraphics(), this._updateGraphics();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(MaskComponent.prototype), "onEnable", this).call(this), this._enableGraphics(), 
                view.on("design-resolution-changed", this._updateClearGraphics, this);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(MaskComponent.prototype), "onDisable", this).call(this), this._disableGraphics(), 
                view.off("design-resolution-changed", this._updateClearGraphics);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(MaskComponent.prototype), "onDestroy", this).call(this), this._removeGraphics();
            }
        }, {
            key: "isHit",
            value: function isHit(cameraPt) {
                var node = this.node, size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp;
                this.node.getWorldMatrix(_worldMatrix$2), Mat4.invert(_mat4_temp$1, _worldMatrix$2), 
                Vec2.transformMat4(testPt, cameraPt, _mat4_temp$1);
                var ap = node.getAnchorPoint();
                testPt.x += ap.x * w, testPt.y += ap.y * h;
                var result = !1;
                if (this.type === MaskType.RECT) result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h; else if (this.type === MaskType.ELLIPSE) {
                    var rx = w / 2, ry = h / 2, px = testPt.x - .5 * w, py = testPt.y - .5 * h;
                    result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
                }
                return this._inverted && (result = !result), result;
            }
        }, {
            key: "_render",
            value: function _render(render) {
                render.commitComp(this, null, this._assembler);
            }
        }, {
            key: "_postRender",
            value: function _postRender(render) {
                this._postAssembler && render.commitComp(this, null, this._postAssembler);
            }
        }, {
            key: "_nodeStateChange",
            value: function _nodeStateChange(type) {
                _get(_getPrototypeOf(MaskComponent.prototype), "_nodeStateChange", this).call(this, type), 
                this._updateGraphics();
            }
        }, {
            key: "_resolutionChanged",
            value: function _resolutionChanged() {
                this._updateClearGraphics();
            }
        }, {
            key: "_canRender",
            value: function _canRender() {
                return !!_get(_getPrototypeOf(MaskComponent.prototype), "_canRender", this).call(this) && (null !== this._clearGraphics && null !== this._graphics);
            }
        }, {
            key: "_flushAssembler",
            value: function _flushAssembler() {
                var assembler = MaskComponent.Assembler.getAssembler(this), posAssembler = MaskComponent.PostAssembler.getAssembler(this);
                this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
                this._postAssembler !== posAssembler && (this._postAssembler = posAssembler), this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
                this._renderData.material = this.sharedMaterial, this.markForUpdateRenderData());
            }
        }, {
            key: "_createGraphics",
            value: function _createGraphics() {
                if (!this._clearGraphics) {
                    var node = new Node$1("clear-graphics"), clearGraphics = this._clearGraphics = node.addComponent(GraphicsComponent);
                    clearGraphics.delegateSrc = this.node, clearGraphics.helpInstanceMaterial(), clearGraphics.lineWidth = 0;
                    var color = Color.WHITE.clone();
                    color.a = 0, clearGraphics.fillColor = color;
                }
                if (!this._graphics) {
                    var graphics = this._graphics = new GraphicsComponent;
                    graphics.node = this.node, graphics.node.getWorldMatrix(), graphics.helpInstanceMaterial(), 
                    graphics.lineWidth = 0;
                    var _color = Color.WHITE.clone();
                    _color.a = 0, graphics.fillColor = _color;
                }
            }
        }, {
            key: "_updateClearGraphics",
            value: function _updateClearGraphics() {
                if (this._clearGraphics) {
                    var size = visibleRect;
                    this._clearGraphics.node.setWorldPosition(size.width / 2, size.height / 2, 0), this._clearGraphics.clear(), 
                    this._clearGraphics.rect(-size.width / 2, -size.height / 2, size.width, size.height), 
                    this._clearGraphics.fill();
                }
            }
        }, {
            key: "_updateGraphics",
            value: function _updateGraphics() {
                if (this._graphics) {
                    var node = this.node, graphics = this._graphics;
                    graphics.clear();
                    var size = node.getContentSize(), width = size.width, height = size.height, ap = node.getAnchorPoint(), x = -width * ap.x, y = -height * ap.y;
                    if (this._type === MaskType.RECT) graphics.rect(x, y, width, height); else if (this._type === MaskType.ELLIPSE) {
                        for (var points = function _calculateCircle(center, radius, segments) {
                            _circlePoints.length = 0;
                            for (var anglePerStep = 2 * Math.PI / segments, step = 0; step < segments; ++step) _circlePoints.push(new Vec3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
                            return _circlePoints;
                        }(new Vec3(x + width / 2, y + height / 2, 0), new Vec3(width / 2, height / 2, 0), this._segments), i = 0; i < points.length; ++i) {
                            var point = points[i];
                            0 === i ? graphics.moveTo(point.x, point.y) : graphics.lineTo(point.x, point.y);
                        }
                        graphics.close();
                    }
                    graphics.fill();
                }
            }
        }, {
            key: "_enableGraphics",
            value: function _enableGraphics() {
                this._clearGraphics && (this._clearGraphics.onEnable(), this._updateClearGraphics()), 
                this._graphics && (this._graphics.onEnable(), this._updateGraphics());
            }
        }, {
            key: "_disableGraphics",
            value: function _disableGraphics() {
                this._graphics && this._graphics.onDisable(), this._clearGraphics && this._clearGraphics.onDisable();
            }
        }, {
            key: "_removeGraphics",
            value: function _removeGraphics() {
                this._graphics && this._graphics.destroy(), this._clearGraphics && this._clearGraphics.destroy();
            }
        } ]), MaskComponent;
    }(UIRenderComponent), _class3$r.Type = MaskType, _applyDecoratedDescriptor((_class2$12 = _temp$14).prototype, "type", [ _dec4$t ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "type"), _class2$12.prototype), 
    _applyDecoratedDescriptor(_class2$12.prototype, "inverted", [ _dec5$q ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "inverted"), _class2$12.prototype), 
    _applyDecoratedDescriptor(_class2$12.prototype, "segments", [ property ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "segments"), _class2$12.prototype), 
    _applyDecoratedDescriptor(_class2$12.prototype, "dstBlendFactor", [ _dec6$m ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "dstBlendFactor"), _class2$12.prototype), 
    _applyDecoratedDescriptor(_class2$12.prototype, "srcBlendFactor", [ _dec7$j ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "srcBlendFactor"), _class2$12.prototype), 
    _applyDecoratedDescriptor(_class2$12.prototype, "color", [ _dec8$e ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "color"), _class2$12.prototype), 
    _descriptor$V = _applyDecoratedDescriptor(_class2$12.prototype, "_type", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return MaskType.RECT;
        }
    }), _descriptor2$K = _applyDecoratedDescriptor(_class2$12.prototype, "_inverted", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$B = _applyDecoratedDescriptor(_class2$12.prototype, "_segments", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 64;
        }
    }), _class$1c = _class2$12)) || _class$1c) || _class$1c) || _class$1c);
    cc.MaskComponent = MaskComponent, function(Mode) {
        Mode[Mode.HORIZONTAL = 0] = "HORIZONTAL", Mode[Mode.VERTICAL = 1] = "VERTICAL", 
        Mode[Mode.FILLED = 2] = "FILLED";
    }(Mode || (Mode = {})), Enum(Mode);
    var _dec$1d, _dec2$P, _dec3$z, _dec4$v, _dec5$s, _class$1e, _class2$14, _descriptor$X, _descriptor2$M, ProgressBarComponent = (_dec$1c = ccclass("cc.ProgressBarComponent"), 
    _dec2$O = executionOrder(110), _dec3$y = menu("UI/ProgressBar"), _dec4$u = property({
        type: SpriteComponent,
        tooltip: "进度条显示用的 Sprite 节点，可以动态改变尺寸"
    }), _dec5$r = property({
        type: Mode,
        tooltip: "进度条显示模式，目前支持水平和垂直两种"
    }), _dec6$n = property({
        tooltip: "进度条在 progress 为 1 时的最大长度"
    }), _dec7$k = property({
        range: [ 0, 1, .1 ],
        slide: !0,
        tooltip: "当前进度指示，范围从 0 到 1"
    }), _dec8$f = property({
        tooltip: "是否反向驱动进度条"
    }), _dec$1c(_class$1d = _dec2$O(_class$1d = _dec3$y((_temp$15 = _class3$s = function(_Component) {
        function ProgressBarComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ProgressBarComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ProgressBarComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_barSprite", _descriptor$W, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_mode", _descriptor2$L, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_totalLength", _descriptor3$C, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_progress", _descriptor4$s, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_reverse", _descriptor5$n, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(ProgressBarComponent, _Component), _createClass(ProgressBarComponent, [ {
            key: "_initBarSprite",
            value: function _initBarSprite() {
                if (this._barSprite) {
                    var entity = this._barSprite.node;
                    if (!entity) return;
                    var nodeSize = this.node.getContentSize(), nodeAnchor = this.node.getAnchorPoint(), barSpriteSize = entity.getContentSize();
                    if (this._barSprite.fillType === SpriteComponent.FillType.RADIAL && (this._mode = Mode.FILLED), 
                    this._mode === Mode.HORIZONTAL ? this.totalLength = barSpriteSize.width : this._mode === Mode.VERTICAL ? this.totalLength = barSpriteSize.height : this.totalLength = this._barSprite.fillRange, 
                    entity.parent === this.node) {
                        var x = -nodeSize.width * nodeAnchor.x;
                        entity.setPosition(x, 0, 0);
                    }
                }
            }
        }, {
            key: "_updateBarStatus",
            value: function _updateBarStatus() {
                if (this._barSprite) {
                    var entity = this._barSprite.node;
                    if (!entity) return;
                    var entityAnchorPoint = entity.getAnchorPoint(), entitySize = entity.getContentSize(), entityPosition = entity.getPosition(), anchorPoint = new Vec2(0, .5), progress = clamp01(this._progress), actualLenth = this._totalLength * progress, finalContentSize = entitySize, totalWidth = 0, totalHeight = 0;
                    switch (this._mode) {
                      case Mode.HORIZONTAL:
                        this._reverse && (anchorPoint = new Vec2(1, .5)), finalContentSize = new Size(actualLenth, entitySize.height), 
                        totalWidth = this._totalLength, totalHeight = entitySize.height;
                        break;

                      case Mode.VERTICAL:
                        anchorPoint = this._reverse ? new Vec2(.5, 1) : new Vec2(.5, 0), finalContentSize = new Size(entitySize.width, actualLenth), 
                        totalWidth = entitySize.width, totalHeight = this._totalLength;
                    }
                    if (this._mode === Mode.FILLED) this._barSprite.type !== SpriteComponent.Type.FILLED ? warn("ProgressBar FILLED mode only works when barSprite's Type is FILLED!") : (this._reverse && (actualLenth *= -1), 
                    this._barSprite.fillRange = actualLenth); else if (this._barSprite.type !== SpriteComponent.Type.FILLED) {
                        var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x, anchorOffsetY = anchorPoint.y - entityAnchorPoint.y, finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
                        entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z), 
                        entity.setAnchorPoint(anchorPoint), entity.setContentSize(finalContentSize);
                    } else warn("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!");
                }
            }
        }, {
            key: "barSprite",
            get: function get() {
                return this._barSprite;
            },
            set: function set(value) {
                this._barSprite !== value && (this._barSprite = value, this._initBarSprite());
            }
        }, {
            key: "mode",
            get: function get() {
                return this._mode;
            },
            set: function set(value) {
                if (this._mode !== value && (this._mode = value, this._barSprite)) {
                    var entity = this._barSprite.node;
                    if (!entity) return;
                    var entitySize = entity.getContentSize();
                    this._mode === Mode.HORIZONTAL ? this.totalLength = entitySize.width : this._mode === Mode.VERTICAL ? this.totalLength = entitySize.height : this._mode === Mode.FILLED && (this.totalLength = this._barSprite.fillRange);
                }
            }
        }, {
            key: "totalLength",
            get: function get() {
                return this._totalLength;
            },
            set: function set(value) {
                this._mode === Mode.FILLED && (value = clamp01(value)), this._totalLength = value, 
                this._updateBarStatus();
            }
        }, {
            key: "progress",
            get: function get() {
                return this._progress;
            },
            set: function set(value) {
                this._progress !== value && (this._progress = value, this._updateBarStatus());
            }
        }, {
            key: "reverse",
            get: function get() {
                return this._reverse;
            },
            set: function set(value) {
                this._reverse !== value && (this._reverse = value, this._barSprite && (this._barSprite.fillStart = 1 - this._barSprite.fillStart), 
                this._updateBarStatus());
            }
        } ]), ProgressBarComponent;
    }(Component), _class3$s.Mode = Mode, _applyDecoratedDescriptor((_class2$13 = _temp$15).prototype, "barSprite", [ _dec4$u ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "barSprite"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "mode", [ _dec5$r ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "mode"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "totalLength", [ _dec6$n ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "totalLength"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "progress", [ _dec7$k ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "progress"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "reverse", [ _dec8$f ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "reverse"), _class2$13.prototype), 
    _descriptor$W = _applyDecoratedDescriptor(_class2$13.prototype, "_barSprite", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$L = _applyDecoratedDescriptor(_class2$13.prototype, "_mode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Mode.HORIZONTAL;
        }
    }), _descriptor3$C = _applyDecoratedDescriptor(_class2$13.prototype, "_totalLength", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor4$s = _applyDecoratedDescriptor(_class2$13.prototype, "_progress", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _descriptor5$n = _applyDecoratedDescriptor(_class2$13.prototype, "_reverse", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _class$1d = _class2$13)) || _class$1d) || _class$1d) || _class$1d);
    cc.ProgressBarComponent = ProgressBarComponent;
    var _dec$1e, _dec2$Q, _dec3$A, _dec4$w, _dec5$t, _dec6$o, _dec7$l, _dec8$g, _dec9$b, _dec10$a, _dec11$a, _class$1f, _class2$15, _descriptor$Y, _descriptor2$N, _descriptor3$D, _descriptor4$t, _descriptor5$o, _descriptor6$e, _descriptor7$c, _descriptor8$b, _class3$t, _temp$17, LabelOutlineComponent = (_dec$1d = ccclass("cc.LabelOutlineComponent"), 
    _dec2$P = executionOrder(110), _dec3$z = menu("UI/LabelOutline"), _dec4$v = property({
        tooltip: "描边的颜色"
    }), _dec5$s = property({
        tooltip: "描边的宽度"
    }), _dec$1d(_class$1e = _dec2$P(_class$1e = _dec3$z((_descriptor$X = _applyDecoratedDescriptor((_class2$14 = function(_Component) {
        function LabelOutlineComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, LabelOutlineComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LabelOutlineComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_color", _descriptor$X, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_width", _descriptor2$M, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(LabelOutlineComponent, _Component), _createClass(LabelOutlineComponent, [ {
            key: "_updateRenderData",
            value: function _updateRenderData() {
                var label = this.node.getComponent(LabelComponent);
                label && label.updateRenderData(!0);
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(value) {
                this._color !== value && (this._color.set(value), this._updateRenderData());
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            },
            set: function set(value) {
                this._width !== value && (this._width = value, this._updateRenderData());
            }
        } ]), LabelOutlineComponent;
    }(Component)).prototype, "_color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(255, 255, 255, 255);
        }
    }), _descriptor2$M = _applyDecoratedDescriptor(_class2$14.prototype, "_width", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _applyDecoratedDescriptor(_class2$14.prototype, "color", [ _dec4$v ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "color"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "width", [ _dec5$s ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "width"), _class2$14.prototype), 
    _class$1e = _class2$14)) || _class$1e) || _class$1e) || _class$1e);
    cc.LabelOutlineComponent = LabelOutlineComponent;
    var _htmlTextParser = new HtmlTextParser;
    var pool$1 = new Pool((function(labelSeg) {
        return !!cc.isValid(labelSeg.node) && !labelSeg.node.getComponent(LabelOutlineComponent);
    }), 20);
    pool$1.get = function(str, richtext) {
        var labelSeg = this._get();
        labelSeg || (labelSeg = {
            node: new PrivateNode("RICHTEXT_CHILD"),
            comp: null,
            lineCount: 0,
            styleIndex: 0,
            clickHandler: ""
        });
        var labelNode = labelSeg.node;
        labelNode || (labelNode = new PrivateNode("RICHTEXT_CHILD"));
        var labelComponent = labelNode.getComponent(LabelComponent);
        return labelComponent || (labelComponent = labelNode.addComponent(LabelComponent)), 
        labelComponent = labelComponent, labelNode.setPosition(0, 0, 0), labelNode.setAnchorPoint(.5, .5), 
        labelNode.setContentSize(128, 128), "string" != typeof str && (str = "" + str), 
        richtext.font instanceof Font ? labelComponent.font = richtext.font : labelComponent.fontFamily = "Arial", 
        labelComponent.string = str, labelComponent.horizontalAlign = exports.HorizontalTextAlignment.LEFT, 
        labelComponent.verticalAlign = exports.VerticalTextAlignment.TOP, labelComponent.fontSize = richtext.fontSize || 40, 
        labelComponent.overflow = 0, labelComponent.enableWrapText = !0, labelComponent.lineHeight = 40, 
        labelComponent.isBold = !1, labelComponent.isItalic = !1, labelComponent.isUnderline = !1, 
        {
            node: labelNode,
            comp: labelComponent,
            lineCount: 0,
            clickHandler: "",
            styleIndex: 0
        };
    };
    var _dec$1f, _dec2$R, _dec3$B, _dec4$x, _dec5$u, _dec6$p, _dec7$m, _class$1g, _class2$16, _descriptor$Z, _descriptor2$O, _descriptor3$E, _descriptor4$u, _descriptor5$p, _class3$u, _temp$18, RichTextComponent = (_dec$1e = ccclass("cc.RichTextComponent"), 
    _dec2$Q = executionOrder(110), _dec3$A = menu("UI/Render/RichText"), _dec4$w = property({
        multiline: !0,
        tooltip: "富文本显示的文本内容"
    }), _dec5$t = property({
        type: exports.HorizontalTextAlignment,
        tooltip: "文本内容的水平对齐方式"
    }), _dec6$o = property({
        tooltip: "富文本字体大小"
    }), _dec7$l = property({
        type: TTFFont,
        tooltip: "富文本定制字体"
    }), _dec8$g = property({
        tooltip: "富文本的最大宽度"
    }), _dec9$b = property({
        tooltip: "富文本行高"
    }), _dec10$a = property({
        type: SpriteAtlas,
        tooltip: "对于 img 标签里面的 src 属性名称，都需要在 imageAtlas 里面找到一个有效的 spriteFrame，否则 img tag 会判定为无效"
    }), _dec11$a = property({
        tooltip: "选中此选项后，RichText 将阻止节点边界框中的所有输入事件（鼠标和触摸），从而防止输入事件穿透到底层节点"
    }), _dec$1e(_class$1f = _dec2$Q(_class$1f = _dec3$A(_class$1f = executeInEditMode((_temp$17 = _class3$t = function(_UIComponent) {
        function RichTextComponent() {
            var _this;
            return _classCallCheck(this, RichTextComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(RichTextComponent).call(this)), "_lineHeight", _descriptor$Y, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_string", _descriptor2$N, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$D, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_fontSize", _descriptor4$t, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_maxWidth", _descriptor5$o, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_font", _descriptor6$e, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_imageAtlas", _descriptor7$c, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_handleTouchEvent", _descriptor8$b, _assertThisInitialized(_this)), 
            _this._textArray = [], _this._labelSegments = [], _this._labelSegmentsCache = [], 
            _this._linesWidth = [], _this._lineCount = 1, _this._labelWidth = 0, _this._labelHeight = 0, 
            _this._layoutDirty = !0, _this._lineOffsetX = 0, _this._updateRichTextStatus = _this._updateRichText, 
            _this;
        }
        return _inherits(RichTextComponent, _UIComponent), _createClass(RichTextComponent, [ {
            key: "string",
            get: function get() {
                return this._string;
            },
            set: function set(value) {
                this._string !== value && (this._string = value, this._updateRichTextStatus());
            }
        }, {
            key: "horizontalAlign",
            get: function get() {
                return this._horizontalAlign;
            },
            set: function set(value) {
                this.horizontalAlign !== value && (this._horizontalAlign = value, this._layoutDirty = !0, 
                this._updateRichTextStatus());
            }
        }, {
            key: "fontSize",
            get: function get() {
                return this._fontSize;
            },
            set: function set(value) {
                this._fontSize !== value && (this._fontSize = value, this._layoutDirty = !0, this._updateRichTextStatus());
            }
        }, {
            key: "font",
            get: function get() {
                return this._font;
            },
            set: function set(value) {
                this._font !== value && (this._font = value, this._layoutDirty = !0, this._font && this._onTTFLoaded(), 
                this._updateRichTextStatus());
            }
        }, {
            key: "maxWidth",
            get: function get() {
                return this._maxWidth;
            },
            set: function set(value) {
                this._maxWidth !== value && (this._maxWidth = value, this._layoutDirty = !0, this._updateRichTextStatus());
            }
        }, {
            key: "lineHeight",
            get: function get() {
                return this._lineHeight;
            },
            set: function set(value) {
                this._lineHeight !== value && (this._lineHeight = value, this._layoutDirty = !0, 
                this._updateRichTextStatus());
            }
        }, {
            key: "imageAtlas",
            get: function get() {
                return this._imageAtlas;
            },
            set: function set(value) {
                this._imageAtlas !== value && (this._imageAtlas = value, this._layoutDirty = !0, 
                this._updateRichTextStatus());
            }
        }, {
            key: "handleTouchEvent",
            get: function get() {
                return this._handleTouchEvent;
            },
            set: function set(value) {
                this._handleTouchEvent !== value && (this._handleTouchEvent = value, this.enabledInHierarchy && (this.handleTouchEvent ? this._addEventListeners() : this._removeEventListeners()));
            }
        } ]), _createClass(RichTextComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                this.handleTouchEvent && this._addEventListeners(), this._updateRichText(), this._activateChildren(!0);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.handleTouchEvent && this._removeEventListeners(), this._activateChildren(!1);
            }
        }, {
            key: "start",
            value: function start() {
                this._onTTFLoaded(), this.node.on(Node$1.EventType.ANCHOR_CHANGED, this._anchorChanged, this);
            }
        }, {
            key: "onRestore",
            value: function onRestore() {
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                var _iterator = this._labelSegments, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var seg = _ref;
                    seg.node.removeFromParent(), pool$1.put(seg);
                }
                this.node.off(Node$1.EventType.ANCHOR_CHANGED, this._anchorChanged);
            }
        }, {
            key: "_addEventListeners",
            value: function _addEventListeners() {
                this.node.on(Node$1.EventType.TOUCH_END, this._onTouchEnded, this);
            }
        }, {
            key: "_removeEventListeners",
            value: function _removeEventListeners() {
                this.node.off(Node$1.EventType.TOUCH_END, this._onTouchEnded, this);
            }
        }, {
            key: "_updateLabelSegmentTextAttributes",
            value: function _updateLabelSegmentTextAttributes() {
                var _this2 = this;
                this._labelSegments.forEach((function(item) {
                    _this2._applyTextAttribute(item);
                }));
            }
        }, {
            key: "_createFontLabel",
            value: function _createFontLabel(str) {
                return pool$1.get(str, this);
            }
        }, {
            key: "_onTTFLoaded",
            value: function _onTTFLoaded() {
                if (this._font instanceof TTFFont) if (this._font._nativeAsset) this._layoutDirty = !0, 
                this._updateRichText(); else {
                    var self = this;
                    loader.load(this._font.nativeUrl, (function(err, fontFamily) {
                        self._layoutDirty = !0, self._updateRichText();
                    }));
                } else this._layoutDirty = !0, this._updateRichText();
            }
        }, {
            key: "_measureText",
            value: function _measureText(styleIndex, string) {
                var self = this, func = function func(s) {
                    var label;
                    return 0 === self._labelSegmentsCache.length ? (label = self._createFontLabel(s), 
                    self._labelSegmentsCache.push(label)) : (label = self._labelSegmentsCache[0]).node.getComponent(LabelComponent).string = s, 
                    label.styleIndex = styleIndex, self._applyTextAttribute(label), label.node.getContentSize().width;
                };
                return string ? func(string) : func;
            }
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded(event) {
                var _this3 = this, components = this.node.getComponents(UIComponent), self = this, _loop = function _loop() {
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) return "break";
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) return "break";
                        _ref2 = _i2.value;
                    }
                    var seg = _ref2, clickHandler = seg.clickHandler;
                    clickHandler && _this3._containsTouchLocation(seg, event.touch.getUILocation()) && (components.forEach((function(component) {
                        var func = component[clickHandler];
                        component.enabledInHierarchy && func && func.call(self, event);
                    })), event.propagationStopped = !0);
                }, _iterator2 = this._labelSegments, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if ("break" === _loop()) break;
                }
            }
        }, {
            key: "_containsTouchLocation",
            value: function _containsTouchLocation(label, point) {
                var comp = label.node.getComponent(UITransformComponent);
                return !!comp && comp.getBoundingBoxToWorld().contains(point);
            }
        }, {
            key: "_resetState",
            value: function _resetState() {
                for (var _this4 = this, children = this.node.children, _loop2 = function _loop2(i) {
                    var child = children[i];
                    if (("RICHTEXT_CHILD" === child.name || "RICHTEXT_Image_CHILD" === child.name) && (child.parent === _this4.node ? child.parent = null : children.splice(i, 1), 
                    "RICHTEXT_CHILD" === child.name)) {
                        var index = _this4._labelSegments.findIndex((function(seg) {
                            return seg.node === child;
                        }));
                        -1 !== index && pool$1.put(_this4._labelSegments[index]);
                    }
                }, i = children.length - 1; i >= 0; i--) _loop2(i);
                this._labelSegments.length = 0, this._labelSegmentsCache.length = 0, this._linesWidth.length = 0, 
                this._lineOffsetX = 0, this._lineCount = 1, this._labelWidth = 0, this._labelHeight = 0, 
                this._layoutDirty = !0;
            }
        }, {
            key: "_activateChildren",
            value: function _activateChildren(active) {
                for (var i = this.node.children.length - 1; i >= 0; i--) {
                    var child = this.node.children[i];
                    "RICHTEXT_CHILD" !== child.name && "RICHTEXT_Image_CHILD" !== child.name || (child.active = active);
                }
            }
        }, {
            key: "_addLabelSegment",
            value: function _addLabelSegment(stringToken, styleIndex) {
                var labelSegment;
                if (0 === this._labelSegmentsCache.length) labelSegment = this._createFontLabel(stringToken); else {
                    var label = (labelSegment = this._labelSegmentsCache.pop()).node.getComponent(LabelComponent);
                    label && (label.string = stringToken);
                }
                return labelSegment.styleIndex = styleIndex, labelSegment.lineCount = this._lineCount, 
                labelSegment.node.setAnchorPoint(0, 0), this._applyTextAttribute(labelSegment), 
                this.node.addChild(labelSegment.node), this._labelSegments.push(labelSegment), labelSegment;
            }
        }, {
            key: "_updateRichTextWithMaxWidth",
            value: function _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
                var fragmentWidth = labelWidth;
                if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this.maxWidth) for (var checkStartIndex = 0; this._lineOffsetX <= this.maxWidth; ) {
                    var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length), checkString = labelString.substr(checkStartIndex, checkEndIndex), checkStringWidth = this._measureText(styleIndex, checkString);
                    if (!(this._lineOffsetX + checkStringWidth <= this.maxWidth)) {
                        if (checkStartIndex > 0) {
                            var remainingString = labelString.substr(0, checkStartIndex);
                            this._addLabelSegment(remainingString, styleIndex), labelString = labelString.substr(checkStartIndex, labelString.length), 
                            fragmentWidth = this._measureText(styleIndex, labelString);
                        }
                        this._updateLineInfo();
                        break;
                    }
                    this._lineOffsetX += checkStringWidth, checkStartIndex += checkEndIndex;
                }
                if (fragmentWidth > this.maxWidth) for (var fragments = fragmentText(labelString, fragmentWidth, this.maxWidth, this._measureText(styleIndex)), k = 0; k < fragments.length; ++k) {
                    var splitString = fragments[k], labelSize = this._addLabelSegment(splitString, styleIndex).node.getContentSize();
                    this._lineOffsetX += labelSize.width, fragments.length > 1 && k < fragments.length - 1 && this._updateLineInfo();
                } else this._lineOffsetX += fragmentWidth, this._addLabelSegment(labelString, styleIndex);
            }
        }, {
            key: "_isLastComponentCR",
            value: function _isLastComponentCR(stringToken) {
                return stringToken.length - 1 === stringToken.lastIndexOf("\n");
            }
        }, {
            key: "_updateLineInfo",
            value: function _updateLineInfo() {
                this._linesWidth.push(this._lineOffsetX), this._lineOffsetX = 0, this._lineCount++;
            }
        }, {
            key: "_needsUpdateTextLayout",
            value: function _needsUpdateTextLayout(newTextArray) {
                if (this._layoutDirty || !this._textArray || !newTextArray) return !0;
                if (this._textArray.length !== newTextArray.length) return !0;
                for (var i = 0; i < this._textArray.length; i++) {
                    var oldItem = this._textArray[i], newItem = newTextArray[i];
                    if (oldItem.text !== newItem.text) return !0;
                    if (oldItem.style) {
                        if (newItem.style) {
                            if (!!newItem.style.outline != !!oldItem.style.outline) return !0;
                            if (oldItem.style.size !== newItem.style.size || oldItem.style.italic !== newItem.style.italic || oldItem.style.isImage !== newItem.style.isImage) return !0;
                            if (oldItem.style.isImage === newItem.style.isImage && oldItem.style.src !== newItem.style.src) return !0;
                        } else if (oldItem.style.size || oldItem.style.italic || oldItem.style.isImage || oldItem.style.outline) return !0;
                    } else if (newItem.style && (newItem.style.size || newItem.style.italic || newItem.style.isImage || newItem.style.outline)) return !0;
                }
                return !1;
            }
        }, {
            key: "_addRichTextImageElement",
            value: function _addRichTextImageElement(richTextElement) {
                if (richTextElement.style) {
                    var spriteFrameName = richTextElement.style.src, spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);
                    if (spriteFrame) {
                        var spriteNode = new PrivateNode("RICHTEXT_Image_CHILD"), spriteComponent = spriteNode.addComponent(SpriteComponent);
                        spriteNode.setAnchorPoint(0, 0), spriteComponent.type = SpriteComponent.Type.SLICED, 
                        spriteComponent.sizeMode = SpriteComponent.SizeMode.CUSTOM, this.node.addChild(spriteNode);
                        var obj = {
                            node: spriteNode,
                            comp: spriteComponent,
                            lineCount: 0,
                            clickHandler: "",
                            styleIndex: 0
                        };
                        this._labelSegments.push(obj);
                        var spriteRect = spriteFrame.getRect(), scaleFactor = 1, spriteWidth = spriteRect.width, spriteHeight = spriteRect.height, expectWidth = richTextElement.style.imageWidth, expectHeight = richTextElement.style.imageHeight;
                        if (void 0 !== expectHeight && expectHeight > 0 && expectHeight < this.lineHeight ? (spriteWidth *= scaleFactor = expectHeight / spriteHeight, 
                        spriteHeight *= scaleFactor) : (spriteWidth *= scaleFactor = this.lineHeight / spriteHeight, 
                        spriteHeight *= scaleFactor), void 0 !== expectWidth && expectWidth > 0 && (spriteWidth = expectWidth), 
                        this.maxWidth > 0 ? (this._lineOffsetX + spriteWidth > this.maxWidth && this._updateLineInfo(), 
                        this._lineOffsetX += spriteWidth) : (this._lineOffsetX += spriteWidth, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX)), 
                        spriteComponent.spriteFrame = spriteFrame, spriteNode.setContentSize(spriteWidth, spriteHeight), 
                        obj.lineCount = this._lineCount, richTextElement.style.event) {
                            var c = "click";
                            richTextElement.style.event[c] && (obj.clickHandler = richTextElement.style.event[c]);
                        }
                    } else warnID(4400);
                }
            }
        }, {
            key: "_updateRichText",
            value: function _updateRichText() {
                if (this.enabled) {
                    var newTextArray = _htmlTextParser.parse(this._string);
                    if (!this._needsUpdateTextLayout(newTextArray)) return this._textArray = newTextArray.slice(), 
                    void this._updateLabelSegmentTextAttributes();
                    this._textArray = newTextArray.slice(), this._resetState();
                    for (var labelSize, lastEmptyLine = !1, i = 0; i < this._textArray.length; ++i) {
                        var richTextElement = this._textArray[i], text = richTextElement.text;
                        if (void 0 !== text) {
                            if ("" === text) {
                                if (richTextElement.style && richTextElement.style.isNewLine) {
                                    this._updateLineInfo();
                                    continue;
                                }
                                if (richTextElement.style && richTextElement.style.isImage && this.imageAtlas) {
                                    this._addRichTextImageElement(richTextElement);
                                    continue;
                                }
                            }
                            for (var multilineTexts = text.split("\n"), j = 0; j < multilineTexts.length; ++j) {
                                var labelString = multilineTexts[j];
                                if ("" !== labelString) if (lastEmptyLine = !1, this.maxWidth > 0) {
                                    var labelWidth = this._measureText(i, labelString);
                                    this._updateRichTextWithMaxWidth(labelString, labelWidth, i), multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo();
                                } else labelSize = this._addLabelSegment(labelString, i).node.getContentSize(), 
                                this._lineOffsetX += labelSize.width, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX), 
                                multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo(); else {
                                    if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) continue;
                                    this._updateLineInfo(), lastEmptyLine = !0;
                                }
                            }
                        }
                    }
                    lastEmptyLine || this._linesWidth.push(this._lineOffsetX), this.maxWidth > 0 && (this._labelWidth = this.maxWidth), 
                    this._labelHeight = this._lineCount * this.lineHeight, this.node.setContentSize(this._labelWidth, this._labelHeight), 
                    this._updateRichTextPosition(), this._layoutDirty = !1;
                }
            }
        }, {
            key: "_getFirstWordLen",
            value: function _getFirstWordLen(text, startIndex, textLen) {
                var character = text.charAt(startIndex);
                if (isUnicodeCJK(character) || isUnicodeSpace(character)) return 1;
                for (var len = 1, index = startIndex + 1; index < textLen && (!isUnicodeSpace(character = text.charAt(index)) && !isUnicodeCJK(character)); ++index) len++;
                return len;
            }
        }, {
            key: "_updateRichTextPosition",
            value: function _updateRichTextPosition() {
                var nextTokenX = 0, nextLineIndex = 1, totalLineCount = this._lineCount, _iterator3 = this._labelSegments, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var label = _ref3, lineCount = label.lineCount;
                    lineCount > nextLineIndex && (nextTokenX = 0, nextLineIndex = lineCount);
                    var anchorX = this.node.anchorX, lineOffsetX = this._labelWidth * (.5 * this.horizontalAlign - anchorX);
                    switch (this.horizontalAlign) {
                      case exports.HorizontalTextAlignment.LEFT:
                        break;

                      case exports.HorizontalTextAlignment.CENTER:
                        lineOffsetX -= this._linesWidth[lineCount - 1] / 2;
                        break;

                      case exports.HorizontalTextAlignment.RIGHT:
                        lineOffsetX -= this._linesWidth[lineCount - 1];
                    }
                    var pos = label.node.position, anchorY = this.node.anchorY;
                    label.node.setPosition(nextTokenX + lineOffsetX, this.lineHeight * (totalLineCount - lineCount) - this._labelHeight * anchorY, pos.z), 
                    lineCount === nextLineIndex && (nextTokenX += label.node.width);
                }
            }
        }, {
            key: "_convertLiteralColorValue",
            value: function _convertLiteralColorValue(color) {
                var colorValue = color.toUpperCase();
                return Color[colorValue] ? Color[colorValue] : (new Color).fromHEX(color);
            }
        }, {
            key: "_applyTextAttribute",
            value: function _applyTextAttribute(labelSeg) {
                var labelComponent = labelSeg.node.getComponent(LabelComponent);
                if (labelComponent) {
                    var textStyle, index = labelSeg.styleIndex;
                    labelComponent.lineHeight = this.lineHeight, labelComponent.horizontalAlign = exports.HorizontalTextAlignment.LEFT, 
                    labelComponent.verticalAlign = exports.VerticalTextAlignment.CENTER, this._textArray[index] && (textStyle = this._textArray[index].style);
                    var labelComp = labelSeg.node.getComponent(LabelComponent);
                    if (labelComp && (textStyle && textStyle.color ? labelComp.color = this._convertLiteralColorValue(textStyle.color) : labelComp.color = this._convertLiteralColorValue("white")), 
                    labelComponent.isBold = !(!textStyle || !textStyle.bold), labelComponent.isItalic = !(!textStyle || !textStyle.italic), 
                    labelComponent.isUnderline = !(!textStyle || !textStyle.underline), textStyle && textStyle.outline) {
                        var labelOutlineComponent = labelSeg.node.getComponent(LabelOutlineComponent);
                        labelOutlineComponent || (labelOutlineComponent = labelSeg.node.addComponent(LabelOutlineComponent)), 
                        labelOutlineComponent.color = this._convertLiteralColorValue(textStyle.outline.color), 
                        labelOutlineComponent.width = textStyle.outline.width;
                    }
                    if (textStyle && textStyle.size ? labelComponent.fontSize = textStyle.size : labelComponent.fontSize = this._fontSize, 
                    labelComponent.updateRenderData(!0), textStyle && textStyle.event) {
                        var c = "click";
                        textStyle.event[c] && (labelSeg.clickHandler = textStyle.event[c]);
                    }
                }
            }
        }, {
            key: "_anchorChanged",
            value: function _anchorChanged() {
                this._updateRichTextPosition();
            }
        } ]), RichTextComponent;
    }(UIComponent), _class3$t.HorizontalAlign = exports.HorizontalTextAlignment, _class3$t.VerticalAlign = exports.VerticalTextAlignment, 
    _applyDecoratedDescriptor((_class2$15 = _temp$17).prototype, "string", [ _dec4$w ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "string"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "horizontalAlign", [ _dec5$t ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "horizontalAlign"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "fontSize", [ _dec6$o ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "fontSize"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "font", [ _dec7$l ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "font"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "maxWidth", [ _dec8$g ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "maxWidth"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "lineHeight", [ _dec9$b ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "lineHeight"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "imageAtlas", [ _dec10$a ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "imageAtlas"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "handleTouchEvent", [ _dec11$a ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "handleTouchEvent"), _class2$15.prototype), 
    _descriptor$Y = _applyDecoratedDescriptor(_class2$15.prototype, "_lineHeight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 40;
        }
    }), _descriptor2$N = _applyDecoratedDescriptor(_class2$15.prototype, "_string", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "<color=#00ff00>Rich</c><color=#0fffff>Text</color>";
        }
    }), _descriptor3$D = _applyDecoratedDescriptor(_class2$15.prototype, "_horizontalAlign", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.HorizontalTextAlignment.LEFT;
        }
    }), _descriptor4$t = _applyDecoratedDescriptor(_class2$15.prototype, "_fontSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 40;
        }
    }), _descriptor5$o = _applyDecoratedDescriptor(_class2$15.prototype, "_maxWidth", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$e = _applyDecoratedDescriptor(_class2$15.prototype, "_font", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor7$c = _applyDecoratedDescriptor(_class2$15.prototype, "_imageAtlas", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor8$b = _applyDecoratedDescriptor(_class2$15.prototype, "_handleTouchEvent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _class$1f = _class2$15)) || _class$1f) || _class$1f) || _class$1f) || _class$1f);
    cc.RichTextComponent = RichTextComponent;
    var Direction, ZERO = new Vec3, _tempPos_1 = new Vec3, _tempPos_2 = new Vec3, defaultAnchor = (new Size, 
    new Vec2, new Vec2), _tempColor = new Color;
    !function(Direction) {
        Direction[Direction.HORIZONTAL = 0] = "HORIZONTAL", Direction[Direction.VERTICAL = 1] = "VERTICAL";
    }(Direction || (Direction = {})), ccenum(Direction);
    var _class$1h, ScrollBarComponent = (_dec$1f = ccclass("cc.ScrollBarComponent"), 
    _dec2$R = executionOrder(110), _dec3$B = menu("UI/ScrollBar"), _dec4$x = property({
        type: SpriteComponent,
        tooltip: "作为当前滚动区域位置显示的滑块 Sprite"
    }), _dec5$u = property({
        type: Direction,
        tooltip: "ScrollBar 的滚动方向"
    }), _dec6$p = property({
        tooltip: "是否在没有滚动动作时自动隐藏 ScrollBar"
    }), _dec7$m = property({
        tooltip: "没有滚动动作后经过多久会自动隐藏。\n注意：只要当 “enableAutoHide” 为 true 时，才有效。"
    }), _dec$1f(_class$1g = _dec2$R(_class$1g = _dec3$B((_temp$18 = _class3$u = function(_Component) {
        function ScrollBarComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ScrollBarComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollBarComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_scrollView", _descriptor$Z, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_handle", _descriptor2$O, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_direction", _descriptor3$E, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_enableAutoHide", _descriptor4$u, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_autoHideTime", _descriptor5$p, _assertThisInitialized(_this)), 
            _this._touching = !1, _this._opacity = 255, _this._autoHideRemainingTime = 0, _this;
        }
        return _inherits(ScrollBarComponent, _Component), _createClass(ScrollBarComponent, [ {
            key: "hide",
            value: function hide() {
                this._autoHideRemainingTime = 0, this._setOpacity(0);
            }
        }, {
            key: "show",
            value: function show() {
                this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity);
            }
        }, {
            key: "onScroll",
            value: function onScroll(outOfBoundary) {
                if (this._scrollView) {
                    var content = this._scrollView.content;
                    if (content) {
                        var contentSize = content.getContentSize(), scrollViewSize = this._scrollView.node.getContentSize(), barSize = this.node.getContentSize();
                        if (!this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                            this._enableAutoHide && (this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity));
                            var contentMeasure = 0, scrollViewMeasure = 0, outOfBoundaryValue = 0, contentPosition = 0, handleNodeMeasure = 0;
                            this._direction === Direction.HORIZONTAL ? (contentMeasure = contentSize.width, 
                            scrollViewMeasure = scrollViewSize.width, handleNodeMeasure = barSize.width, outOfBoundaryValue = outOfBoundary.x, 
                            contentPosition = -this._convertToScrollViewSpace(content).x) : this._direction === Direction.VERTICAL && (contentMeasure = contentSize.height, 
                            scrollViewMeasure = scrollViewSize.height, handleNodeMeasure = barSize.height, outOfBoundaryValue = outOfBoundary.y, 
                            contentPosition = -this._convertToScrollViewSpace(content).y);
                            var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue), position = this._calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);
                            this._updateLength(length), this._updateHandlerPosition(position);
                        }
                    }
                }
            }
        }, {
            key: "setScrollView",
            value: function setScrollView(scrollView) {
                this._scrollView = scrollView;
            }
        }, {
            key: "onTouchBegan",
            value: function onTouchBegan() {
                this._enableAutoHide && (this._touching = !0);
            }
        }, {
            key: "onTouchEnded",
            value: function onTouchEnded() {
                if (this._enableAutoHide && (this._touching = !1, !(this._autoHideTime <= 0))) {
                    if (this._scrollView) {
                        var content = this._scrollView.content;
                        if (content) {
                            var contentSize = content.getContentSize(), scrollViewSize = this._scrollView.node.getContentSize();
                            if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) return;
                        }
                    }
                    this._autoHideRemainingTime = this._autoHideTime;
                }
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                var renderComp = this.node.getComponent(SpriteComponent);
                renderComp && (this._opacity = renderComp.color.a);
            }
        }, {
            key: "start",
            value: function start() {
                this._enableAutoHide && this._setOpacity(0);
            }
        }, {
            key: "update",
            value: function update(dt) {
                this._processAutoHide(dt);
            }
        }, {
            key: "_convertToScrollViewSpace",
            value: function _convertToScrollViewSpace(content) {
                if (!this._scrollView) return ZERO;
                var scrollTrans = this._scrollView.node._uiProps.uiTransformComp, contentTrans = content._uiProps.uiTransformComp;
                if (!scrollTrans || !contentTrans) return ZERO;
                _tempPos_1.set(-content.anchorX * content.width, -content.anchorY * content.height, 0), 
                contentTrans.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);
                var scrollViewSpacePos = scrollTrans.convertToNodeSpaceAR(_tempPos_2);
                return scrollViewSpacePos.x += scrollTrans.anchorX * scrollTrans.width, scrollViewSpacePos.y += scrollTrans.anchorY * scrollTrans.height, 
                scrollViewSpacePos;
            }
        }, {
            key: "_setOpacity",
            value: function _setOpacity(opacity) {
                if (this._handle) {
                    var renderComp = this.node.getComponent(SpriteComponent);
                    renderComp && (_tempColor.set(renderComp.color), _tempColor.a = opacity, renderComp.color = _tempColor), 
                    (renderComp = this._handle.getComponent(SpriteComponent)) && (_tempColor.set(renderComp.color), 
                    _tempColor.a = opacity, renderComp.color = _tempColor);
                }
            }
        }, {
            key: "_updateHandlerPosition",
            value: function _updateHandlerPosition(position) {
                if (this._handle) {
                    var oldPosition = this._fixupHandlerPosition();
                    this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
                }
            }
        }, {
            key: "_fixupHandlerPosition",
            value: function _fixupHandlerPosition() {
                var barSize = this.node.getContentSize(), barAnchor = this.node.getAnchorPoint(), handleSize = this.handle.node.getContentSize(), handleParent = this.handle.node.parent;
                Vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);
                var leftBottomWorldPosition = this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2), fixupPosition = new Vec3;
                return handleParent._uiProps.uiTransformComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition), 
                this.direction === Direction.HORIZONTAL ? fixupPosition = new Vec3(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, 0) : this.direction === Direction.VERTICAL && (fixupPosition = new Vec3(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, 0)), 
                this.handle.node.setPosition(fixupPosition), fixupPosition;
            }
        }, {
            key: "_conditionalDisableScrollBar",
            value: function _conditionalDisableScrollBar(contentSize, scrollViewSize) {
                return contentSize.width <= scrollViewSize.width && this._direction === Direction.HORIZONTAL || contentSize.height <= scrollViewSize.height && this._direction === Direction.VERTICAL;
            }
        }, {
            key: "_calculateLength",
            value: function _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
                var denominatorValue = contentMeasure;
                return outOfBoundary && (denominatorValue += 20 * (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary)), 
                handleNodeMeasure * (scrollViewMeasure / denominatorValue);
            }
        }, {
            key: "_calculatePosition",
            value: function _calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
                var denominatorValue = contentMeasure - scrollViewMeasure;
                outOfBoundary && (denominatorValue += Math.abs(outOfBoundary));
                var positionRatio = 0;
                denominatorValue && (positionRatio = clamp01(positionRatio = contentPosition / denominatorValue));
                var position = (handleNodeMeasure - actualLenth) * positionRatio;
                return this._direction === Direction.VERTICAL ? new Vec3(0, position, 0) : new Vec3(position, 0, 0);
            }
        }, {
            key: "_updateLength",
            value: function _updateLength(length) {
                if (this._handle) {
                    var handleNode = this._handle.node, handleNodeSize = handleNode.getContentSize(), anchor = handleNode.getAnchorPoint();
                    anchor.x === defaultAnchor.x && anchor.y === defaultAnchor.y || handleNode.setAnchorPoint(defaultAnchor), 
                    this._direction === Direction.HORIZONTAL ? handleNode.setContentSize(length, handleNodeSize.height) : handleNode.setContentSize(handleNodeSize.width, length);
                }
            }
        }, {
            key: "_processAutoHide",
            value: function _processAutoHide(deltaTime) {
                if (this._enableAutoHide && !(this._autoHideRemainingTime <= 0) && !this._touching && (this._autoHideRemainingTime -= deltaTime, 
                this._autoHideRemainingTime <= this._autoHideTime)) {
                    this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
                    var opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);
                    this._setOpacity(opacity);
                }
            }
        }, {
            key: "handle",
            get: function get() {
                return this._handle;
            },
            set: function set(value) {
                this._handle !== value && (this._handle = value, this.onScroll(new Vec3(0, 0, 0)));
            }
        }, {
            key: "direction",
            get: function get() {
                return this._direction;
            },
            set: function set(value) {
                this._direction !== value && (this._direction = value, this.onScroll(new Vec3));
            }
        }, {
            key: "enableAutoHide",
            get: function get() {
                return this._enableAutoHide;
            },
            set: function set(value) {
                this._enableAutoHide !== value && (this._enableAutoHide = value, this._enableAutoHide && this._setOpacity(0));
            }
        }, {
            key: "autoHideTime",
            get: function get() {
                return this._autoHideTime;
            },
            set: function set(value) {
                this._autoHideTime !== value && (this._autoHideTime = value);
            }
        } ]), ScrollBarComponent;
    }(Component), _class3$u.Direction = Direction, _applyDecoratedDescriptor((_class2$16 = _temp$18).prototype, "handle", [ _dec4$x ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "handle"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "direction", [ _dec5$u ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "direction"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "enableAutoHide", [ _dec6$p ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "enableAutoHide"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "autoHideTime", [ _dec7$m ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "autoHideTime"), _class2$16.prototype), 
    _descriptor$Z = _applyDecoratedDescriptor(_class2$16.prototype, "_scrollView", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$O = _applyDecoratedDescriptor(_class2$16.prototype, "_handle", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$E = _applyDecoratedDescriptor(_class2$16.prototype, "_direction", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Direction.HORIZONTAL;
        }
    }), _descriptor4$u = _applyDecoratedDescriptor(_class2$16.prototype, "_enableAutoHide", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor5$p = _applyDecoratedDescriptor(_class2$16.prototype, "_autoHideTime", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _class$1g = _class2$16)) || _class$1g) || _class$1g) || _class$1g);
    cc.ScrollBarComponent = ScrollBarComponent;
    var _dec$1h, _dec2$T, _dec3$C, _dec4$y, _dec5$v, _dec6$q, _dec7$n, _dec8$h, _dec9$c, _dec10$b, _dec11$b, _dec12$9, _dec13$8, _dec14$7, _class$1i, _class2$17, _descriptor$_, _descriptor2$P, _descriptor3$F, _descriptor4$v, _descriptor5$q, _descriptor6$f, _descriptor7$d, _descriptor8$c, _descriptor9$a, _descriptor10$a, _descriptor11$8, _class3$v, _temp$19, ViewGroupComponent = ccclass("cc.ViewGroupComponent")(_class$1h = executionOrder(110)(_class$1h = function(_Component) {
        function ViewGroupComponent() {
            return _classCallCheck(this, ViewGroupComponent), _possibleConstructorReturn(this, _getPrototypeOf(ViewGroupComponent).apply(this, arguments));
        }
        return _inherits(ViewGroupComponent, _Component), ViewGroupComponent;
    }(Component)) || _class$1h) || _class$1h;
    cc.ViewGroupComponent = ViewGroupComponent;
    var EventType$3, ZERO$1 = new Vec3, _tempVec3$1 = new Vec3, _tempVec3_1 = new Vec3, _tempVec2$1 = new Vec2, _tempVec2_1 = new Vec2, getTimeInMilliseconds = function getTimeInMilliseconds() {
        return (new Date).getMilliseconds();
    }, eventMap = {
        "scroll-to-top": 0,
        "scroll-to-bottom": 1,
        "scroll-to-left": 2,
        "scroll-to-right": 3,
        scrolling: 4,
        "bounce-bottom": 6,
        "bounce-left": 7,
        "bounce-right": 8,
        "bounce-top": 5,
        "scroll-ended": 9,
        "touch-up": 10,
        "scroll-ended-with-threshold": 11,
        "scroll-began": 12
    };
    !function(EventType) {
        EventType.SCROLL_TO_TOP = "scroll-to-top", EventType.SCROLL_TO_BOTTOM = "scroll-to-bottom", 
        EventType.SCROLL_TO_LEFT = "scroll-to-left", EventType.SCROLL_TO_RIGHT = "scroll-to-right", 
        EventType.SCROLL_BEGAN = "scroll-began", EventType.SCROLL_ENDED = "scroll-ended", 
        EventType.BOUNCE_TOP = "bounce-top", EventType.BOUNCE_BOTTOM = "bounce-bottom", 
        EventType.BOUNCE_LEFT = "bounce-left", EventType.BOUNCE_RIGHT = "bounce-right", 
        EventType.SCROLLING = "scrolling", EventType.SCROLL_ENG_WITH_THRESHOLD = "scroll-ended-with-threshold", 
        EventType.TOUCH_UP = "touch-up";
    }(EventType$3 || (EventType$3 = {}));
    var _dec$1i, _dec2$U, _dec3$D, _dec4$z, _dec5$w, _dec6$r, _dec7$o, _class$1j, _class2$18, _descriptor$$, _descriptor2$Q, _descriptor3$G, _descriptor4$w, _class3$w, _temp$1a, ScrollViewComponent = (_dec$1h = ccclass("cc.ScrollViewComponent"), 
    _dec2$T = executionOrder(110), _dec3$C = menu("UI/ScrollView"), _dec4$y = property({
        type: Node$1,
        tooltip: "可滚动展示内容的节点"
    }), _dec5$v = property({
        type: ScrollBarComponent,
        tooltip: "水平滚动的 ScrollBar"
    }), _dec6$q = property({
        type: ScrollBarComponent,
        tooltip: "垂直滚动的 ScrollBar"
    }), _dec7$n = property({
        tooltip: "是否开启水平滚动"
    }), _dec8$h = property({
        tooltip: "是否开启垂直滚动"
    }), _dec9$c = property({
        tooltip: "是否开启滚动惯性"
    }), _dec10$b = property({
        range: [ 0, 1, .1 ],
        tooltip: "开启惯性后，在用户停止触摸后滚动多快停止，0 表示永不停止，1 表示立刻停止"
    }), _dec11$b = property({
        tooltip: "是否允许滚动内容超过边界，并在停止触摸后回弹"
    }), _dec12$9 = property({
        range: [ 0, 10 ],
        tooltip: "回弹持续的时间，0 表示将立即反弹"
    }), _dec13$8 = property({
        type: [ EventHandler ],
        tooltip: "滚动视图的事件回调函数"
    }), _dec14$7 = property({
        tooltip: "滚动行为是否会取消子节点上注册的触摸事件"
    }), _dec$1h(_class$1i = _dec2$T(_class$1i = _dec3$C((_temp$19 = _class3$v = function(_ViewGroupComponent) {
        function ScrollViewComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ScrollViewComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollViewComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "horizontal", _descriptor$_, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "vertical", _descriptor2$P, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "inertia", _descriptor3$F, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "brake", _descriptor4$v, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "elastic", _descriptor5$q, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "bounceDuration", _descriptor6$f, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "scrollEvents", _descriptor7$d, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor8$c, _assertThisInitialized(_this)), 
            _this._autoScrolling = !1, _this._scrolling = !1, _initializerDefineProperty(_this, "_content", _descriptor9$a, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_horizontalScrollBar", _descriptor10$a, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_verticalScrollBar", _descriptor11$8, _assertThisInitialized(_this)), 
            _this._topBoundary = 0, _this._bottomBoundary = 0, _this._leftBoundary = 0, _this._rightBoundary = 0, 
            _this._touchMoveDisplacements = [], _this._touchMoveTimeDeltas = [], _this._touchMovePreviousTimestamp = 0, 
            _this._touchMoved = !1, _this._autoScrollAttenuate = !1, _this._autoScrollStartPosition = new Vec3, 
            _this._autoScrollTargetDelta = new Vec3, _this._autoScrollTotalTime = 0, _this._autoScrollAccumulatedTime = 0, 
            _this._autoScrollCurrentlyOutOfBoundary = !1, _this._autoScrollBraking = !1, _this._autoScrollBrakingStartPosition = new Vec3, 
            _this._outOfBoundaryAmount = new Vec3, _this._outOfBoundaryAmountDirty = !0, _this._stopMouseWheel = !1, 
            _this._mouseWheelEventElapsedTime = 0, _this._isScrollEndedWithThresholdEventFired = !1, 
            _this._scrollEventEmitMask = 0, _this._isBouncing = !1, _this._contentPos = new Vec3, 
            _this._deltaPos = new Vec3, _this;
        }
        return _inherits(ScrollViewComponent, _ViewGroupComponent), _createClass(ScrollViewComponent, [ {
            key: "scrollToBottom",
            value: function scrollToBottom(timeInSecond) {
                var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, 0),
                    applyToHorizontal: !1,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta, !0);
            }
        }, {
            key: "scrollToTop",
            value: function scrollToTop(timeInSecond) {
                var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, 1),
                    applyToHorizontal: !1,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToLeft",
            value: function scrollToLeft(timeInSecond) {
                var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, 0),
                    applyToHorizontal: !0,
                    applyToVertical: !1
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToRight",
            value: function scrollToRight(timeInSecond) {
                var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(1, 0),
                    applyToHorizontal: !0,
                    applyToVertical: !1
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToTopLeft",
            value: function scrollToTopLeft(timeInSecond) {
                var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, 1),
                    applyToHorizontal: !0,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToTopRight",
            value: function scrollToTopRight(timeInSecond) {
                var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(1, 1),
                    applyToHorizontal: !0,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToBottomLeft",
            value: function scrollToBottomLeft(timeInSecond) {
                var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, 0),
                    applyToHorizontal: !0,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToBottomRight",
            value: function scrollToBottomRight(timeInSecond) {
                var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(1, 0),
                    applyToHorizontal: !0,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToOffset",
            value: function scrollToOffset(offset, timeInSecond) {
                var attenuated = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], maxScrollOffset = this.getMaxScrollOffset(), anchor = new Vec2(0, 0);
                0 === maxScrollOffset.x ? anchor.x = 0 : anchor.x = offset.x / maxScrollOffset.x, 
                0 === maxScrollOffset.y ? anchor.y = 1 : anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y, 
                this.scrollTo(anchor, timeInSecond, attenuated);
            }
        }, {
            key: "getScrollOffset",
            value: function getScrollOffset() {
                var topDelta = this._getContentTopBoundary() - this._topBoundary, leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
                return new Vec3(leftDelta, topDelta, 0);
            }
        }, {
            key: "getMaxScrollOffset",
            value: function getMaxScrollOffset() {
                var scrollSize = this.node._uiProps.uiTransformComp.contentSize, contentSize = this._content._uiProps.uiTransformComp.contentSize, horizontalMaximizeOffset = contentSize.width - scrollSize.width, verticalMaximizeOffset = contentSize.height - scrollSize.height;
                return new Vec3(horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0, verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0, 0);
            }
        }, {
            key: "scrollToPercentHorizontal",
            value: function scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(percent, 0),
                    applyToHorizontal: !0,
                    applyToVertical: !1
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollTo",
            value: function scrollTo(anchor, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(anchor),
                    applyToHorizontal: !0,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToPercentVertical",
            value: function scrollToPercentVertical(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, percent),
                    applyToHorizontal: !1,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "stopAutoScroll",
            value: function stopAutoScroll() {
                this._autoScrolling = !1, this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
            }
        }, {
            key: "setContentPosition",
            value: function setContentPosition(position) {
                var contentPos = this.getContentPosition();
                Math.abs(position.x - contentPos.x) < 1e-4 && Math.abs(position.y - contentPos.y) < 1e-4 || (this._content.setPosition(position), 
                this._outOfBoundaryAmountDirty = !0);
            }
        }, {
            key: "getContentPosition",
            value: function getContentPosition() {
                return this._content ? (this._contentPos.set(this._content.position), this._contentPos) : ZERO$1;
            }
        }, {
            key: "isScrolling",
            value: function isScrolling() {
                return this._scrolling;
            }
        }, {
            key: "isAutoScrolling",
            value: function isAutoScrolling() {
                return this._autoScrolling;
            }
        }, {
            key: "getScrollEndedEventTiming",
            value: function getScrollEndedEventTiming() {
                return 1e-4;
            }
        }, {
            key: "start",
            value: function start() {
                this._calculateBoundary(), this._content && director.once(Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._registerEvent(), this.content && (this.content.on(Node$1.EventType.SIZE_CHANGED, this._calculateBoundary, this), 
                this.content.on(Node$1.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), this.view && (this.view.on(Node$1.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), 
                this.view.on(Node$1.EventType.SIZE_CHANGED, this._calculateBoundary, this))), this._calculateBoundary(), 
                this._showScrollBar();
            }
        }, {
            key: "update",
            value: function update(dt) {
                this._autoScrolling && this._processAutoScrolling(dt);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._unregisterEvent(), this.content && (this.content.off(Node$1.EventType.SIZE_CHANGED, this._calculateBoundary, this), 
                this.content.off(Node$1.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), 
                this.view && (this.view.off(Node$1.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), 
                this.view.off(Node$1.EventType.SIZE_CHANGED, this._calculateBoundary, this))), this._hideScrollBar(), 
                this.stopAutoScroll();
            }
        }, {
            key: "_registerEvent",
            value: function _registerEvent() {
                this.node.on(Node$1.EventType.TOUCH_START, this._onTouchBegan, this, !0), this.node.on(Node$1.EventType.TOUCH_MOVE, this._onTouchMoved, this, !0), 
                this.node.on(Node$1.EventType.TOUCH_END, this._onTouchEnded, this, !0), this.node.on(Node$1.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, !0), 
                this.node.on(Node$1.EventType.MOUSE_WHEEL, this._onMouseWheel, this, !0);
            }
        }, {
            key: "_unregisterEvent",
            value: function _unregisterEvent() {
                this.node.off(Node$1.EventType.TOUCH_START, this._onTouchBegan, this, !0), this.node.off(Node$1.EventType.TOUCH_MOVE, this._onTouchMoved, this, !0), 
                this.node.off(Node$1.EventType.TOUCH_END, this._onTouchEnded, this, !0), this.node.off(Node$1.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, !0), 
                this.node.off(Node$1.EventType.MOUSE_WHEEL, this._onMouseWheel, this, !0);
            }
        }, {
            key: "_onMouseWheel",
            value: function _onMouseWheel(event, captureListeners) {
                if (this.enabledInHierarchy && !this._hasNestedViewGroup(event, captureListeners)) {
                    var deltaMove = new Vec3, scrollY = event.getScrollY();
                    this.vertical ? deltaMove.set(0, -.1 * scrollY, 0) : this.horizontal && deltaMove.set(-.1 * scrollY, 0, 0), 
                    this._mouseWheelEventElapsedTime = 0, this._processDeltaMove(deltaMove), this._stopMouseWheel || (this._handlePressLogic(), 
                    this.schedule(this._checkMouseWheel, 1 / 60, NaN, 0), this._stopMouseWheel = !0), 
                    this._stopPropagationIfTargetIsMe(event);
                }
            }
        }, {
            key: "_onTouchBegan",
            value: function _onTouchBegan(event, captureListeners) {
                this.enabledInHierarchy && this._content && (this._hasNestedViewGroup(event, captureListeners) || (this._content && this._handlePressLogic(), 
                this._touchMoved = !1, this._stopPropagationIfTargetIsMe(event)));
            }
        }, {
            key: "_onTouchMoved",
            value: function _onTouchMoved(event, captureListeners) {
                if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(event, captureListeners)) {
                    var touch = event.touch;
                    if (this._content && this._handleMoveLogic(touch), this.cancelInnerEvents) {
                        var deltaMove = touch.getUILocation(_tempVec2$1);
                        if (deltaMove.subtract(touch.getUIStartLocation(_tempVec2_1)), deltaMove.length() > 7 && !this._touchMoved && event.target !== this.node) {
                            var cancelEvent = new EventTouch(event.getTouches(), event.bubbles);
                            cancelEvent.type = Node$1.EventType.TOUCH_CANCEL, cancelEvent.touch = event.touch, 
                            cancelEvent.simulate = !0, event.target.dispatchEvent(cancelEvent), this._touchMoved = !0;
                        }
                        this._stopPropagationIfTargetIsMe(event);
                    }
                }
            }
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded(event, captureListeners) {
                if (this.enabledInHierarchy && this._content && event && !this._hasNestedViewGroup(event, captureListeners)) {
                    this._dispatchEvent(EventType$3.TOUCH_UP);
                    var touch = event.touch;
                    this._content && this._handleReleaseLogic(touch), this._touchMoved ? event.propagationStopped = !0 : this._stopPropagationIfTargetIsMe(event);
                }
            }
        }, {
            key: "_onTouchCancelled",
            value: function _onTouchCancelled(event, captureListeners) {
                if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(event, captureListeners)) {
                    if (event && !event.simulate) {
                        var touch = event.touch;
                        this._content && this._handleReleaseLogic(touch);
                    }
                    this._stopPropagationIfTargetIsMe(event);
                }
            }
        }, {
            key: "_calculateBoundary",
            value: function _calculateBoundary() {
                if (this.content) {
                    var layout = this.content.getComponent(LayoutComponent);
                    layout && layout.enabledInHierarchy && layout.updateLayout();
                    var viewSize = this.view._uiProps.uiTransformComp.contentSize, anchorX = viewSize.width * this.view.anchorX, anchorY = viewSize.height * this.view.anchorY;
                    this._leftBoundary = -anchorX, this._bottomBoundary = -anchorY, this._rightBoundary = this._leftBoundary + viewSize.width, 
                    this._topBoundary = this._bottomBoundary + viewSize.height, this._moveContentToTopLeft(viewSize);
                }
            }
        }, {
            key: "_hasNestedViewGroup",
            value: function _hasNestedViewGroup(event, captureListeners) {
                if (event && event.eventPhase === Event.CAPTURING_PHASE) {
                    if (captureListeners) {
                        var _iterator = captureListeners, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var item = _ref;
                            if (this.node === item) return !(!event.target || !event.target.getComponent(ViewGroupComponent));
                            if (item.getComponent(ViewGroupComponent)) return !0;
                        }
                    }
                    return !1;
                }
            }
        }, {
            key: "_startInertiaScroll",
            value: function _startInertiaScroll(touchMoveVelocity) {
                var inertiaTotalMovement = new Vec3(touchMoveVelocity);
                inertiaTotalMovement.multiplyScalar(.7), this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
            }
        }, {
            key: "_calculateAttenuatedFactor",
            value: function _calculateAttenuatedFactor(distance) {
                return this.brake <= 0 ? 1 - this.brake : (1 - this.brake) * (1 / (1 + 14e-6 * distance + distance * distance * 8e-9));
            }
        }, {
            key: "_startAttenuatingAutoScroll",
            value: function _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
                var time = this._calculateAutoScrollTimeByInitialSpeed(initialVelocity.length()), targetDelta = new Vec3(deltaMove);
                targetDelta.normalize();
                var contentSize = this._content._uiProps.uiTransformComp.contentSize, scrollViewSize = this.node._uiProps.uiTransformComp.contentSize, totalMoveWidth = contentSize.width - scrollViewSize.width, totalMoveHeight = contentSize.height - scrollViewSize.height, attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth), attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
                targetDelta.x = targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX, 
                targetDelta.y = targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake), 
                targetDelta.z = 0;
                var originalMoveLength = deltaMove.length(), factor = targetDelta.length() / originalMoveLength;
                if (targetDelta.add(deltaMove), this.brake > 0 && factor > 7) {
                    factor = Math.sqrt(factor);
                    var a = new Vec3(deltaMove);
                    a.multiplyScalar(factor), targetDelta.set(a), targetDelta.add(deltaMove);
                }
                this.brake > 0 && factor > 3 && (time *= factor = 3), 0 === this.brake && factor > 1 && (time *= factor), 
                this._startAutoScroll(targetDelta, time, !0);
            }
        }, {
            key: "_calculateAutoScrollTimeByInitialSpeed",
            value: function _calculateAutoScrollTimeByInitialSpeed(initialSpeed) {
                return Math.sqrt(Math.sqrt(initialSpeed / 5));
            }
        }, {
            key: "_startAutoScroll",
            value: function _startAutoScroll(deltaMove, timeInSecond) {
                var attenuated = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
                this._autoScrolling = !0, this._autoScrollTargetDelta = adjustedDeltaMove, this._autoScrollAttenuate = attenuated, 
                Vec3.copy(this._autoScrollStartPosition, this.getContentPosition()), this._autoScrollTotalTime = timeInSecond, 
                this._autoScrollAccumulatedTime = 0, this._autoScrollBraking = !1, this._isScrollEndedWithThresholdEventFired = !1, 
                this._autoScrollBrakingStartPosition = new Vec3;
                var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
                currentOutOfBoundary.equals(ZERO$1, 1e-4) || (this._autoScrollCurrentlyOutOfBoundary = !0);
            }
        }, {
            key: "_calculateTouchMoveVelocity",
            value: function _calculateTouchMoveVelocity() {
                var totalTime = 0;
                if ((totalTime = this._touchMoveTimeDeltas.reduce((function(a, b) {
                    return a + b;
                }), totalTime)) <= 0 || totalTime >= .5) return new Vec3;
                var totalMovement = new Vec3;
                return totalMovement = this._touchMoveDisplacements.reduce((function(a, b) {
                    return a.add(b), a;
                }), totalMovement), new Vec3(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, 0);
            }
        }, {
            key: "_flattenVectorByDirection",
            value: function _flattenVectorByDirection(vector) {
                var result = vector;
                return result.x = this.horizontal ? result.x : 0, result.y = this.vertical ? result.y : 0, 
                result;
            }
        }, {
            key: "_moveContent",
            value: function _moveContent(deltaMove, canStartBounceBack) {
                var adjustedMove = this._flattenVectorByDirection(deltaMove);
                _tempVec3$1.set(this.getContentPosition()), _tempVec3$1.add(adjustedMove), _tempVec3$1.set(1e-4 * Math.floor(1e4 * _tempVec3$1.x), 1e-4 * Math.floor(1e4 * _tempVec3$1.y), _tempVec3$1.z), 
                this.setContentPosition(_tempVec3$1);
                var outOfBoundary = this._getHowMuchOutOfBoundary();
                this._updateScrollBar(outOfBoundary), this.elastic && canStartBounceBack && this._startBounceBackIfNeeded();
            }
        }, {
            key: "_getContentLeftBoundary",
            value: function _getContentLeftBoundary() {
                return this.getContentPosition().x - this._content.anchorX * this._content.width;
            }
        }, {
            key: "_getContentRightBoundary",
            value: function _getContentRightBoundary() {
                return this._getContentLeftBoundary() + this._content.width;
            }
        }, {
            key: "_getContentTopBoundary",
            value: function _getContentTopBoundary() {
                return this._getContentBottomBoundary() + this._content.height;
            }
        }, {
            key: "_getContentBottomBoundary",
            value: function _getContentBottomBoundary() {
                return this.getContentPosition().y - this._content.anchorY * this._content.height;
            }
        }, {
            key: "_getHowMuchOutOfBoundary",
            value: function _getHowMuchOutOfBoundary(addition) {
                if ((addition = addition || new Vec3).equals(ZERO$1, 1e-4) && !this._outOfBoundaryAmountDirty) return this._outOfBoundaryAmount;
                var outOfBoundaryAmount = new Vec3;
                return this._getContentLeftBoundary() + addition.x > this._leftBoundary ? outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x) : this._getContentRightBoundary() + addition.x < this._rightBoundary && (outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x)), 
                this._getContentTopBoundary() + addition.y < this._topBoundary ? outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y) : this._getContentBottomBoundary() + addition.y > this._bottomBoundary && (outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y)), 
                addition.equals(ZERO$1, 1e-4) && (this._outOfBoundaryAmount = outOfBoundaryAmount, 
                this._outOfBoundaryAmountDirty = !1), outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
            }
        }, {
            key: "_updateScrollBar",
            value: function _updateScrollBar(outOfBoundary) {
                this._horizontalScrollBar && this._horizontalScrollBar.onScroll(outOfBoundary), 
                this.verticalScrollBar && this.verticalScrollBar.onScroll(outOfBoundary);
            }
        }, {
            key: "_onScrollBarTouchBegan",
            value: function _onScrollBarTouchBegan() {
                this._horizontalScrollBar && this._horizontalScrollBar.onTouchBegan(), this.verticalScrollBar && this.verticalScrollBar.onTouchBegan();
            }
        }, {
            key: "_onScrollBarTouchEnded",
            value: function _onScrollBarTouchEnded() {
                this._horizontalScrollBar && this._horizontalScrollBar.onTouchEnded(), this.verticalScrollBar && this.verticalScrollBar.onTouchEnded();
            }
        }, {
            key: "_dispatchEvent",
            value: function _dispatchEvent(event) {
                if (event === EventType$3.SCROLL_ENDED) this._scrollEventEmitMask = 0; else if (event === EventType$3.SCROLL_TO_TOP || event === EventType$3.SCROLL_TO_BOTTOM || event === EventType$3.SCROLL_TO_LEFT || event === EventType$3.SCROLL_TO_RIGHT) {
                    var flag = 1 << eventMap[event];
                    if (this._scrollEventEmitMask & flag) return;
                    this._scrollEventEmitMask |= flag;
                }
                EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]), this.node.emit(event, this);
            }
        }, {
            key: "_adjustContentOutOfBoundary",
            value: function _adjustContentOutOfBoundary() {
                if (this._content && (this._outOfBoundaryAmountDirty = !0, this._isOutOfBoundary())) {
                    var outOfBoundary = this._getHowMuchOutOfBoundary();
                    _tempVec3$1.set(this.getContentPosition()), _tempVec3$1.add(outOfBoundary), this._content && (this._content.setPosition(_tempVec3$1), 
                    this._updateScrollBar(ZERO$1));
                }
            }
        }, {
            key: "_hideScrollBar",
            value: function _hideScrollBar() {
                this._horizontalScrollBar && this._horizontalScrollBar.hide(), this._verticalScrollBar && this._verticalScrollBar.hide();
            }
        }, {
            key: "_showScrollBar",
            value: function _showScrollBar() {
                this._horizontalScrollBar && this._horizontalScrollBar.show(), this._verticalScrollBar && this._verticalScrollBar.show();
            }
        }, {
            key: "_stopPropagationIfTargetIsMe",
            value: function _stopPropagationIfTargetIsMe(event) {
                event.eventPhase === Event.AT_TARGET && event.target === this.node && (event.propagationStopped = !0);
            }
        }, {
            key: "_processDeltaMove",
            value: function _processDeltaMove(deltaMove) {
                this._scrollChildren(deltaMove), this._gatherTouchMove(deltaMove);
            }
        }, {
            key: "_handleMoveLogic",
            value: function _handleMoveLogic(touch) {
                this._deltaPos.set(this._getLocalAxisAlignDelta(touch)), this._processDeltaMove(this._deltaPos);
            }
        }, {
            key: "_handleReleaseLogic",
            value: function _handleReleaseLogic(touch) {
                this._deltaPos.set(this._getLocalAxisAlignDelta(touch)), this._gatherTouchMove(this._deltaPos), 
                this._processInertiaScroll(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent(EventType$3.SCROLL_ENDED));
            }
        }, {
            key: "_getLocalAxisAlignDelta",
            value: function _getLocalAxisAlignDelta(touch) {
                var uiTransformComp = this.node._uiProps.uiTransformComp, vec = new Vec3;
                return uiTransformComp && (touch.getUILocation(_tempVec2$1), touch.getUIPreviousLocation(_tempVec2_1), 
                _tempVec3$1.set(_tempVec2$1.x, _tempVec2$1.y, 0), _tempVec3_1.set(_tempVec2_1.x, _tempVec2_1.y, 0), 
                uiTransformComp.convertToNodeSpaceAR(_tempVec3$1, _tempVec3$1), uiTransformComp.convertToNodeSpaceAR(_tempVec3_1, _tempVec3_1), 
                Vec3.subtract(vec, _tempVec3$1, _tempVec3_1)), vec;
            }
        }, {
            key: "_scrollChildren",
            value: function _scrollChildren(deltaMove) {
                var outOfBoundary, scrollEventType, realMove = deltaMove = this._clampDelta(deltaMove);
                this.elastic && (outOfBoundary = this._getHowMuchOutOfBoundary(), realMove.x *= 0 === outOfBoundary.x ? 1 : .5, 
                realMove.y *= 0 === outOfBoundary.y ? 1 : .5), this.elastic || (outOfBoundary = this._getHowMuchOutOfBoundary(realMove), 
                realMove.add(outOfBoundary));
                var pos = this._content.position;
                if (realMove.y > 0) pos.y - this._content.anchorY * this._content.height + realMove.y >= this._bottomBoundary && (scrollEventType = EventType$3.SCROLL_TO_BOTTOM); else if (realMove.y < 0) {
                    pos.y - this._content.anchorY * this._content.height + this._content.height + realMove.y <= this._topBoundary && (scrollEventType = EventType$3.SCROLL_TO_TOP);
                } else if (realMove.x < 0) {
                    pos.x - this._content.anchorX * this._content.width + this._content.width + realMove.x <= this._rightBoundary && (scrollEventType = EventType$3.SCROLL_TO_RIGHT);
                } else if (realMove.x > 0) {
                    pos.x - this._content.anchorX * this._content.width + realMove.x >= this._leftBoundary && (scrollEventType = EventType$3.SCROLL_TO_LEFT);
                }
                this._moveContent(realMove, !1), 0 === realMove.x && 0 === realMove.y || (this._scrolling || (this._scrolling = !0, 
                this._dispatchEvent(EventType$3.SCROLL_BEGAN)), this._dispatchEvent(EventType$3.SCROLLING)), 
                scrollEventType && scrollEventType.length > 0 && this._dispatchEvent(scrollEventType);
            }
        }, {
            key: "_handlePressLogic",
            value: function _handlePressLogic() {
                this._autoScrolling && this._dispatchEvent(EventType$3.SCROLL_ENDED), this._autoScrolling = !1, 
                this._isBouncing = !1, this._touchMovePreviousTimestamp = getTimeInMilliseconds(), 
                this._touchMoveDisplacements.length = 0, this._touchMoveTimeDeltas.length = 0, this._onScrollBarTouchBegan();
            }
        }, {
            key: "_clampDelta",
            value: function _clampDelta(delta) {
                var contentSize = this._content._uiProps.uiTransformComp.contentSize, scrollViewSize = this.node._uiProps.uiTransformComp.contentSize;
                return contentSize.width < scrollViewSize.width && (delta.x = 0), contentSize.height < scrollViewSize.height && (delta.y = 0), 
                delta;
            }
        }, {
            key: "_gatherTouchMove",
            value: function _gatherTouchMove(delta) {
                var clampDt = delta.clone();
                for (this._clampDelta(clampDt); this._touchMoveDisplacements.length >= 5; ) this._touchMoveDisplacements.shift(), 
                this._touchMoveTimeDeltas.shift();
                this._touchMoveDisplacements.push(clampDt);
                var timeStamp = getTimeInMilliseconds();
                this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1e3), 
                this._touchMovePreviousTimestamp = timeStamp;
            }
        }, {
            key: "_startBounceBackIfNeeded",
            value: function _startBounceBackIfNeeded() {
                if (!this.elastic) return !1;
                var bounceBackAmount = this._getHowMuchOutOfBoundary();
                if ((bounceBackAmount = this._clampDelta(bounceBackAmount)).equals(ZERO$1, 1e-4)) return !1;
                var bounceBackTime = Math.max(this.bounceDuration, 0);
                return this._startAutoScroll(bounceBackAmount, bounceBackTime, !0), this._isBouncing || (bounceBackAmount.y > 0 && this._dispatchEvent(EventType$3.BOUNCE_TOP), 
                bounceBackAmount.y < 0 && this._dispatchEvent(EventType$3.BOUNCE_BOTTOM), bounceBackAmount.x > 0 && this._dispatchEvent(EventType$3.BOUNCE_RIGHT), 
                bounceBackAmount.x < 0 && this._dispatchEvent(EventType$3.BOUNCE_LEFT), this._isBouncing = !0), 
                !0;
            }
        }, {
            key: "_processInertiaScroll",
            value: function _processInertiaScroll() {
                if (!this._startBounceBackIfNeeded() && this.inertia) {
                    var touchMoveVelocity = this._calculateTouchMoveVelocity();
                    !touchMoveVelocity.equals(_tempVec3$1, 1e-4) && this.brake < 1 && this._startInertiaScroll(touchMoveVelocity);
                }
                this._onScrollBarTouchEnded();
            }
        }, {
            key: "_isOutOfBoundary",
            value: function _isOutOfBoundary() {
                return !this._getHowMuchOutOfBoundary().equals(ZERO$1, 1e-4);
            }
        }, {
            key: "_isNecessaryAutoScrollBrake",
            value: function _isNecessaryAutoScrollBrake() {
                if (this._autoScrollBraking) return !0;
                if (this._isOutOfBoundary()) {
                    if (!this._autoScrollCurrentlyOutOfBoundary) return this._autoScrollCurrentlyOutOfBoundary = !0, 
                    this._autoScrollBraking = !0, this._autoScrollBrakingStartPosition = this.getContentPosition(), 
                    !0;
                } else this._autoScrollCurrentlyOutOfBoundary = !1;
                return !1;
            }
        }, {
            key: "_processAutoScrolling",
            value: function _processAutoScrolling(dt) {
                var isAutoScrollBrake = this._isNecessaryAutoScrollBrake(), brakingFactor = isAutoScrollBrake ? .05 : 1;
                this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
                var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
                this._autoScrollAttenuate && (percentage = function quintEaseOut(time) {
                    return (time -= 1) * time * time * time * time + 1;
                }(percentage));
                var a = new Vec3(this._autoScrollTargetDelta);
                a.multiplyScalar(percentage);
                var newPosition = new Vec3(this._autoScrollStartPosition);
                newPosition.add(a);
                var reachedEnd = Math.abs(percentage - 1) <= 1e-4;
                if (Math.abs(percentage - 1) <= this.getScrollEndedEventTiming() && !this._isScrollEndedWithThresholdEventFired && (this._dispatchEvent(EventType$3.SCROLL_ENG_WITH_THRESHOLD), 
                this._isScrollEndedWithThresholdEventFired = !0), this.elastic) {
                    var brakeOffsetPosition = new Vec3(newPosition);
                    brakeOffsetPosition.subtract(this._autoScrollBrakingStartPosition), isAutoScrollBrake && brakeOffsetPosition.multiplyScalar(brakingFactor), 
                    newPosition.set(this._autoScrollBrakingStartPosition), newPosition.add(brakeOffsetPosition);
                } else {
                    var moveDelta = new Vec3(newPosition);
                    moveDelta.subtract(this.getContentPosition());
                    var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
                    outOfBoundary.equals(ZERO$1, 1e-4) || (newPosition.add(outOfBoundary), reachedEnd = !0);
                }
                reachedEnd && (this._autoScrolling = !1);
                var deltaMove = new Vec3(newPosition);
                deltaMove.subtract(this.getContentPosition()), this._moveContent(this._clampDelta(deltaMove), reachedEnd), 
                this._dispatchEvent(EventType$3.SCROLLING), this._autoScrolling || (this._isBouncing = !1, 
                this._scrolling = !1, this._dispatchEvent(EventType$3.SCROLL_ENDED));
            }
        }, {
            key: "_checkMouseWheel",
            value: function _checkMouseWheel(dt) {
                if (!this._getHowMuchOutOfBoundary().equals(ZERO$1, 1e-4)) return this._processInertiaScroll(), 
                this.unschedule(this._checkMouseWheel), void (this._stopMouseWheel = !1);
                this._mouseWheelEventElapsedTime += dt, this._mouseWheelEventElapsedTime > .1 && (this._onScrollBarTouchEnded(), 
                this.unschedule(this._checkMouseWheel), this._stopMouseWheel = !1);
            }
        }, {
            key: "_calculateMovePercentDelta",
            value: function _calculateMovePercentDelta(options) {
                var anchor = options.anchor, applyToHorizontal = options.applyToHorizontal, applyToVertical = options.applyToVertical;
                this._calculateBoundary(), anchor.clampf(new Vec2(0, 0), new Vec2(1, 1));
                var scrollSize = this.node._uiProps.uiTransformComp.contentSize, contentSize = this._content._uiProps.uiTransformComp.contentSize, bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;
                bottomDelta = -bottomDelta;
                var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
                leftDelta = -leftDelta;
                var moveDelta = new Vec3, totalScrollDelta = 0;
                return applyToHorizontal && (totalScrollDelta = contentSize.width - scrollSize.width, 
                moveDelta.x = leftDelta - totalScrollDelta * anchor.x), applyToVertical && (totalScrollDelta = contentSize.height - scrollSize.height, 
                moveDelta.y = bottomDelta - totalScrollDelta * anchor.y), moveDelta;
            }
        }, {
            key: "_moveContentToTopLeft",
            value: function _moveContentToTopLeft(scrollViewSize) {
                var contentSize = this._content._uiProps.uiTransformComp.contentSize, bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;
                bottomDelta = -bottomDelta;
                var moveDelta = new Vec3, totalScrollDelta = 0, leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
                leftDelta = -leftDelta, contentSize.height < scrollViewSize.height ? (totalScrollDelta = contentSize.height - scrollViewSize.height, 
                moveDelta.y = bottomDelta - totalScrollDelta, this.verticalScrollBar && this.verticalScrollBar.hide()) : this.verticalScrollBar && this.verticalScrollBar.show(), 
                contentSize.width < scrollViewSize.width ? (totalScrollDelta = contentSize.width - scrollViewSize.width, 
                moveDelta.x = leftDelta, this._horizontalScrollBar && this._horizontalScrollBar.hide()) : this._horizontalScrollBar && this._horizontalScrollBar.show(), 
                this._moveContent(moveDelta), this._adjustContentOutOfBoundary();
            }
        }, {
            key: "_scaleChanged",
            value: function _scaleChanged(value) {
                value === TransformBit.SCALE && this._calculateBoundary();
            }
        }, {
            key: "content",
            get: function get() {
                return this._content;
            },
            set: function set(value) {
                this._content !== value && (this._content = value, this._calculateBoundary());
            }
        }, {
            key: "horizontalScrollBar",
            get: function get() {
                return this._horizontalScrollBar;
            },
            set: function set(value) {
                this._horizontalScrollBar !== value && (this._horizontalScrollBar = value, this._horizontalScrollBar && (this._horizontalScrollBar.setScrollView(this), 
                this._updateScrollBar(ZERO$1)));
            }
        }, {
            key: "verticalScrollBar",
            get: function get() {
                return this._verticalScrollBar;
            },
            set: function set(value) {
                this._verticalScrollBar !== value && (this._verticalScrollBar = value, this._verticalScrollBar && (this._verticalScrollBar.setScrollView(this), 
                this._updateScrollBar(ZERO$1)));
            }
        }, {
            key: "view",
            get: function get() {
                return this._content ? this._content.parent : null;
            }
        } ]), ScrollViewComponent;
    }(ViewGroupComponent), _class3$v.EventType = EventType$3, _applyDecoratedDescriptor((_class2$17 = _temp$19).prototype, "content", [ _dec4$y ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "content"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "horizontalScrollBar", [ _dec5$v ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "horizontalScrollBar"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "verticalScrollBar", [ _dec6$q ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "verticalScrollBar"), _class2$17.prototype), 
    _descriptor$_ = _applyDecoratedDescriptor(_class2$17.prototype, "horizontal", [ _dec7$n ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor2$P = _applyDecoratedDescriptor(_class2$17.prototype, "vertical", [ _dec8$h ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor3$F = _applyDecoratedDescriptor(_class2$17.prototype, "inertia", [ _dec9$c ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor4$v = _applyDecoratedDescriptor(_class2$17.prototype, "brake", [ _dec10$b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .5;
        }
    }), _descriptor5$q = _applyDecoratedDescriptor(_class2$17.prototype, "elastic", [ _dec11$b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor6$f = _applyDecoratedDescriptor(_class2$17.prototype, "bounceDuration", [ _dec12$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor7$d = _applyDecoratedDescriptor(_class2$17.prototype, "scrollEvents", [ _dec13$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor8$c = _applyDecoratedDescriptor(_class2$17.prototype, "cancelInnerEvents", [ _dec14$7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor9$a = _applyDecoratedDescriptor(_class2$17.prototype, "_content", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor10$a = _applyDecoratedDescriptor(_class2$17.prototype, "_horizontalScrollBar", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor11$8 = _applyDecoratedDescriptor(_class2$17.prototype, "_verticalScrollBar", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$1i = _class2$17)) || _class$1i) || _class$1i) || _class$1i);
    cc.ScrollViewComponent = ScrollViewComponent;
    var Direction$1, _tempPos$1 = new Vec3;
    !function(Direction) {
        Direction[Direction.Horizontal = 0] = "Horizontal", Direction[Direction.Vertical = 1] = "Vertical";
    }(Direction$1 || (Direction$1 = {})), ccenum(Direction$1);
    var _dec$1j, _dec2$V, _dec3$E, _dec4$A, _dec5$x, _class$1k, _class2$19, _descriptor$10, _descriptor2$R, SliderComponent = (_dec$1i = ccclass("cc.SliderComponent"), 
    _dec2$U = executionOrder(110), _dec3$D = menu("UI/Slider"), _dec4$z = property({
        type: SpriteComponent,
        tooltip: "滑块按钮部件"
    }), _dec5$w = property({
        type: Direction$1,
        tooltip: "滑动方向"
    }), _dec6$r = property({
        slide: !0,
        range: [ 0, 1, .01 ],
        tooltip: "当前进度值，该数值的区间是 0 - 1 之间。"
    }), _dec7$o = property({
        type: EventHandler,
        tooltip: "滑动器组件事件回调函数"
    }), _dec$1i(_class$1j = _dec2$U(_class$1j = _dec3$D((_temp$1a = _class3$w = function(_Component) {
        function SliderComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SliderComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SliderComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "slideEvents", _descriptor$$, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_handle", _descriptor2$Q, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_direction", _descriptor3$G, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_progress", _descriptor4$w, _assertThisInitialized(_this)), 
            _this._offset = new Vec3, _this._dragging = !1, _this._touchHandle = !1, _this._handlelocalPos = new Vec3, 
            _this._touchPos = new Vec3, _this;
        }
        return _inherits(SliderComponent, _Component), _createClass(SliderComponent, [ {
            key: "__preload",
            value: function __preload() {
                this._updateHandlePosition();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._updateHandlePosition(), this.node.on(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), 
                this.node.on(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), this.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), 
                this.node.on(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this), 
                this._handle && this._handle.isValid && (this._handle.node.on(exports.SystemEventType.TOUCH_START, this._onHandleDragStart, this), 
                this._handle.node.on(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), 
                this._handle.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this));
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.node.off(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.off(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), 
                this.node.off(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), this.node.off(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this), 
                this._handle && this._handle.isValid && (this._handle.node.off(exports.SystemEventType.TOUCH_START, this._onHandleDragStart, this), 
                this._handle.node.off(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), 
                this._handle.node.off(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this));
            }
        }, {
            key: "_onHandleDragStart",
            value: function _onHandleDragStart(event) {
                if (event && this._handle && this._handle.node._uiProps.uiTransformComp) {
                    this._dragging = !0, this._touchHandle = !0;
                    var touhPos = event.touch.getUILocation();
                    Vec3.set(this._touchPos, touhPos.x, touhPos.y, 0), this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, this._offset), 
                    event.propagationStopped = !0;
                }
            }
        }, {
            key: "_onTouchBegan",
            value: function _onTouchBegan(event) {
                this._handle && event && (this._dragging = !0, this._touchHandle || this._handleSliderLogic(event.touch), 
                event.propagationStopped = !0);
            }
        }, {
            key: "_onTouchMoved",
            value: function _onTouchMoved(event) {
                this._dragging && event && (this._handleSliderLogic(event.touch), event.propagationStopped = !0);
            }
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded(event) {
                this._dragging = !1, this._touchHandle = !1, this._offset = new Vec3, event && (event.propagationStopped = !0);
            }
        }, {
            key: "_onTouchCancelled",
            value: function _onTouchCancelled(event) {
                this._dragging = !1, event && (event.propagationStopped = !0);
            }
        }, {
            key: "_handleSliderLogic",
            value: function _handleSliderLogic(touch) {
                this._updateProgress(touch), this._emitSlideEvent();
            }
        }, {
            key: "_emitSlideEvent",
            value: function _emitSlideEvent() {
                EventHandler.emitEvents(this.slideEvents, this), this.node.emit("slide", this);
            }
        }, {
            key: "_updateProgress",
            value: function _updateProgress(touch) {
                if (this._handle && touch) {
                    var touchPos = touch.getUILocation();
                    Vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
                    var localTouchPos = this.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, _tempPos$1);
                    this.direction === Direction$1.Horizontal ? this.progress = clamp01(.5 + (localTouchPos.x - this._offset.x) / this.node.width) : this.progress = clamp01(.5 + (localTouchPos.y - this._offset.y) / this.node.height);
                }
            }
        }, {
            key: "_updateHandlePosition",
            value: function _updateHandlePosition() {
                this._handle && (this._handlelocalPos.set(this._handle.node.getPosition()), this._direction === Direction$1.Horizontal ? this._handlelocalPos.x = -this.node.width * this.node.anchorX + this.progress * this.node.width : this._handlelocalPos.y = -this.node.height * this.node.anchorY + this.progress * this.node.height, 
                this._handle.node.setPosition(this._handlelocalPos));
            }
        }, {
            key: "_changeLayout",
            value: function _changeLayout() {
                var contentSize = this.node.getContentSize();
                if (this.node.setContentSize(contentSize.height, contentSize.width), this._handle) {
                    var pos = this._handle.node.position;
                    this._direction === Direction$1.Horizontal ? this._handle.node.setPosition(pos.x, 0, pos.z) : this._handle.node.setPosition(0, pos.y, pos.z), 
                    this._updateHandlePosition();
                }
            }
        }, {
            key: "handle",
            get: function get() {
                return this._handle;
            },
            set: function set(value) {
                this._handle !== value && (this._handle = value);
            }
        }, {
            key: "direction",
            get: function get() {
                return this._direction;
            },
            set: function set(value) {
                this._direction !== value && (this._direction = value, this._changeLayout());
            }
        }, {
            key: "progress",
            get: function get() {
                return this._progress;
            },
            set: function set(value) {
                this._progress !== value && (this._progress = value, this._updateHandlePosition());
            }
        } ]), SliderComponent;
    }(Component), _class3$w.Direction = Direction$1, _applyDecoratedDescriptor((_class2$18 = _temp$1a).prototype, "handle", [ _dec4$z ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "handle"), _class2$18.prototype), 
    _applyDecoratedDescriptor(_class2$18.prototype, "direction", [ _dec5$w ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "direction"), _class2$18.prototype), 
    _applyDecoratedDescriptor(_class2$18.prototype, "progress", [ _dec6$r ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "progress"), _class2$18.prototype), 
    _descriptor$$ = _applyDecoratedDescriptor(_class2$18.prototype, "slideEvents", [ _dec7$o ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$Q = _applyDecoratedDescriptor(_class2$18.prototype, "_handle", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$G = _applyDecoratedDescriptor(_class2$18.prototype, "_direction", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Direction$1.Horizontal;
        }
    }), _descriptor4$w = _applyDecoratedDescriptor(_class2$18.prototype, "_progress", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _class$1j = _class2$18)) || _class$1j) || _class$1j) || _class$1j);
    cc.SliderComponent = SliderComponent;
    var _dec$1k, _dec2$W, _dec3$F, _dec4$B, _dec5$y, _dec6$s, _dec7$p, _dec8$i, _class$1l, _class2$1a, _descriptor$11, _descriptor2$S, _descriptor3$H, _descriptor4$x, _class3$x, _temp$1c, EventType$4, ToggleContainerComponent = (_dec$1j = ccclass("cc.ToggleContainerComponent"), 
    _dec2$V = executionOrder(110), _dec3$E = menu("UI/ToggleContainer"), _dec4$A = property({
        type: [ EventHandler ],
        tooltip: "选中事件。列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。"
    }), _dec5$x = property({
        tooltip: "如果这个设置为 true， 那么 toggle 按钮在被点击的时候可以反复地被选中和未选中。"
    }), _dec$1j(_class$1k = _dec2$V(_class$1k = _dec3$E(_class$1k = executeInEditMode((_descriptor$10 = _applyDecoratedDescriptor((_class2$19 = function(_Component) {
        function ToggleContainerComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ToggleContainerComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ToggleContainerComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "checkEvents", _descriptor$10, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_allowSwitchOff", _descriptor2$R, _assertThisInitialized(_this)), 
            _this._toggleItems = [], _this;
        }
        return _inherits(ToggleContainerComponent, _Component), _createClass(ToggleContainerComponent, [ {
            key: "start",
            value: function start() {
                this._makeAtLeastOneToggleChecked();
            }
        }, {
            key: "updateToggles",
            value: function updateToggles(toggle) {
                this.enabledInHierarchy && toggle.isChecked && (this.toggleItems.forEach((function(item) {
                    item !== toggle && item.isChecked && item.enabled && (item.isChecked = !1);
                })), this.checkEvents && EventHandler.emitEvents(this.checkEvents, toggle));
            }
        }, {
            key: "addToggle",
            value: function addToggle(toggle) {
                -1 === this._toggleItems.indexOf(toggle) && this._toggleItems.push(toggle), this._allowOnlyOneToggleChecked();
            }
        }, {
            key: "removeToggle",
            value: function removeToggle(toggle) {
                var index = this._toggleItems.indexOf(toggle);
                index > -1 && this._toggleItems.splice(index, 1), this._makeAtLeastOneToggleChecked();
            }
        }, {
            key: "_allowOnlyOneToggleChecked",
            value: function _allowOnlyOneToggleChecked() {
                var isChecked = !1;
                return this._toggleItems.forEach((function(item) {
                    isChecked && item.enabled && (item.isChecked = !1), item.isChecked && item.enabled && (isChecked = !0);
                })), isChecked;
            }
        }, {
            key: "_makeAtLeastOneToggleChecked",
            value: function _makeAtLeastOneToggleChecked() {
                this._allowOnlyOneToggleChecked() || this._allowSwitchOff || this._toggleItems.length > 0 && (this._toggleItems[0].isChecked = !0);
            }
        }, {
            key: "allowSwitchOff",
            get: function get() {
                return this._allowSwitchOff;
            },
            set: function set(value) {
                this._allowSwitchOff = value;
            }
        }, {
            key: "toggleItems",
            get: function get() {
                return this._toggleItems;
            }
        } ]), ToggleContainerComponent;
    }(Component)).prototype, "checkEvents", [ _dec4$A ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$R = _applyDecoratedDescriptor(_class2$19.prototype, "_allowSwitchOff", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _applyDecoratedDescriptor(_class2$19.prototype, "allowSwitchOff", [ _dec5$x ], Object.getOwnPropertyDescriptor(_class2$19.prototype, "allowSwitchOff"), _class2$19.prototype), 
    _class$1k = _class2$19)) || _class$1k) || _class$1k) || _class$1k) || _class$1k);
    function extendsEnum() {
        for (var _len = arguments.length, enums = new Array(_len), _key = 0; _key < _len; _key++) enums[_key] = arguments[_key];
        return Object.assign.apply(Object, [ {} ].concat(enums));
    }
    cc.ToggleContainerComponent = ToggleContainerComponent, function(EventType) {
        EventType.TOGGLE = "toggle";
    }(EventType$4 || (EventType$4 = {}));
    var _class$1m, ToggleComponent = (_dec$1k = ccclass("cc.ToggleComponent"), _dec2$W = executionOrder(110), 
    _dec3$F = menu("UI/Toggle"), _dec4$B = requireComponent(UITransformComponent), _dec5$y = property({
        tooltip: "如果这个设置为 true，则 check mark 组件会处于 enabled 状态，否则处于 disabled 状态。"
    }), _dec6$s = property({
        type: ToggleContainerComponent,
        tooltip: "Toggle 所属的 ToggleGroup，这个属性是可选的。如果这个属性为 null，则 Toggle 是一个 CheckBox，否则，Toggle 是一个 RadioButton。"
    }), _dec7$p = property({
        type: SpriteComponent,
        tooltip: "Toggle 处于选中状态时显示的精灵图片"
    }), _dec8$i = property({
        type: [ EventHandler ],
        tooltip: "列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成"
    }), _dec$1k(_class$1l = _dec2$W(_class$1l = _dec3$F(_class$1l = _dec4$B((_temp$1c = _class3$x = function(_ButtonComponent) {
        function ToggleComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ToggleComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ToggleComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "checkEvents", _descriptor$11, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isChecked", _descriptor2$S, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_toggleGroup", _descriptor3$H, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_checkMark", _descriptor4$x, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(ToggleComponent, _ButtonComponent), _createClass(ToggleComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(ToggleComponent.prototype), "onEnable", this).call(this), this._registerToggleEvent(), 
                this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.addToggle(this);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(ToggleComponent.prototype), "onDisable", this).call(this), 
                this._unregisterToggleEvent(), this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.removeToggle(this);
            }
        }, {
            key: "toggle",
            value: function toggle() {
                var group = this.toggleGroup || this._toggleContainer;
                group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !this.isChecked, 
                group && group.enabled && group.updateToggles(this), this._emitToggleEvents());
            }
        }, {
            key: "check",
            value: function check() {
                var group = this.toggleGroup || this._toggleContainer;
                group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !0, 
                group && group.enabled && group.updateToggles(this), this._emitToggleEvents());
            }
        }, {
            key: "uncheck",
            value: function uncheck() {
                var group = this.toggleGroup || this._toggleContainer;
                group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !1, 
                this._emitToggleEvents());
            }
        }, {
            key: "_updateCheckMark",
            value: function _updateCheckMark() {
                this._checkMark && (this._checkMark.node.active = !!this.isChecked);
            }
        }, {
            key: "_registerToggleEvent",
            value: function _registerToggleEvent() {
                this.node.on(ToggleComponent.EventType.CLICK, this.toggle, this);
            }
        }, {
            key: "_unregisterToggleEvent",
            value: function _unregisterToggleEvent() {
                this.node.off(ToggleComponent.EventType.CLICK, this.toggle, this);
            }
        }, {
            key: "_emitToggleEvents",
            value: function _emitToggleEvents() {
                this.node.emit(ToggleComponent.EventType.TOGGLE, this), this.checkEvents && EventHandler.emitEvents(this.checkEvents, this);
            }
        }, {
            key: "isChecked",
            get: function get() {
                return this._isChecked;
            },
            set: function set(value) {
                this._isChecked !== value && (this._isChecked = value, this._updateCheckMark());
            }
        }, {
            key: "toggleGroup",
            get: function get() {
                return this._toggleGroup;
            },
            set: function set(value) {
                this._toggleGroup !== value && (this._toggleGroup && this._toggleGroup.removeToggle(this), 
                this._toggleGroup = value, this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.addToggle(this));
            }
        }, {
            key: "checkMark",
            get: function get() {
                return this._checkMark;
            },
            set: function set(value) {
                this._checkMark !== value && (this._checkMark = value);
            }
        }, {
            key: "_resizeToTarget",
            set: function set(value) {
                value && this._resizeNodeToTargetNode();
            }
        }, {
            key: "_toggleContainer",
            get: function get() {
                this.node.parent;
                return null;
            }
        } ]), ToggleComponent;
    }(ButtonComponent), _class3$x.EventType = extendsEnum(EventType$4, EventType$1), 
    _applyDecoratedDescriptor((_class2$1a = _temp$1c).prototype, "isChecked", [ _dec5$y ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "isChecked"), _class2$1a.prototype), 
    _applyDecoratedDescriptor(_class2$1a.prototype, "toggleGroup", [ _dec6$s ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "toggleGroup"), _class2$1a.prototype), 
    _applyDecoratedDescriptor(_class2$1a.prototype, "checkMark", [ _dec7$p ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "checkMark"), _class2$1a.prototype), 
    _descriptor$11 = _applyDecoratedDescriptor(_class2$1a.prototype, "checkEvents", [ _dec8$i ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$S = _applyDecoratedDescriptor(_class2$1a.prototype, "_isChecked", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor3$H = _applyDecoratedDescriptor(_class2$1a.prototype, "_toggleGroup", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor4$x = _applyDecoratedDescriptor(_class2$1a.prototype, "_checkMark", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$1l = _class2$1a)) || _class$1l) || _class$1l) || _class$1l) || _class$1l);
    cc.ToggleComponent = ToggleComponent;
    var _class$1n, _class2$1b, _temp$1e, UIModelComponent = ccclass("cc.UIModelComponent")(_class$1m = executionOrder(110)(_class$1m = menu("UI/Model")(_class$1m = function(_UIComponent) {
        function UIModelComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, UIModelComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._models = null, 
            _this._modelComponent = null, _this;
        }
        return _inherits(UIModelComponent, _UIComponent), _createClass(UIModelComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this.node._uiProps.uiTransformComp || this.node.addComponent("cc.UITransformComponent"), 
                this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent ? (this._modelComponent._sceneGetter = director.root.ui.getRenderSceneGetter(), 
                this._models = this._modelComponent._collectModels()) : console.warn("node '".concat(this.node && this.node.name, "' doesn't have any renderable component"));
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(UIModelComponent.prototype), "onEnable", this).call(this), 
                this._modelComponent && this._modelComponent._attachToScene();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(UIModelComponent.prototype), "onDisable", this).call(this), 
                this._modelComponent && this._modelComponent._detachFromScene();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(UIModelComponent.prototype), "onDestroy", this).call(this), 
                this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent && (this._modelComponent._sceneGetter = null, 
                cc.isValid(this._modelComponent, !0) && this._modelComponent._attachToScene(), this._models = null);
            }
        }, {
            key: "updateAssembler",
            value: function updateAssembler(render) {
                if (this._models) {
                    var _iterator = this._models, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var m = _ref;
                        render.commitModel.call(render, this, m, this._modelComponent.material);
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "update",
            value: function update() {
                this._fitUIRenderQueue();
            }
        }, {
            key: "_fitUIRenderQueue",
            value: function _fitUIRenderQueue() {
                if (this._modelComponent) {
                    for (var matNum = this._modelComponent.sharedMaterials.length, i = 0; i < matNum; i++) {
                        var material = this._modelComponent.getMaterialInstance(i);
                        if (null != material) for (var passes = material.passes, ea = material.effectAsset, techIdx = material.technique, passNum = passes.length, j = 0; j < passNum; j++) {
                            if (!passes[j].blendState.targets[0].blend) passes[j].blendState.targets[0].blend = !0, 
                            passes[j].overridePipelineStates(ea.techniques[techIdx].passes[j], {
                                blendState: passes[j].blendState
                            });
                        }
                    }
                    for (var _i2 = 0; _i2 < matNum; _i2++) {
                        var _material = this._modelComponent.getMaterialInstance(_i2);
                        if (null != _material) {
                            var _iterator2 = _material.passes, _isArray2 = Array.isArray(_iterator2), _i3 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref2;
                                if (_isArray2) {
                                    if (_i3 >= _iterator2.length) break;
                                    _ref2 = _iterator2[_i3++];
                                } else {
                                    if ((_i3 = _iterator2.next()).done) break;
                                    _ref2 = _i3.value;
                                }
                                _ref2._priority = RenderPriority.MAX - 11;
                            }
                        }
                    }
                }
            }
        }, {
            key: "modelComponent",
            get: function get() {
                return this._modelComponent;
            }
        } ]), UIModelComponent;
    }(UIComponent)) || _class$1m) || _class$1m) || _class$1m;
    cc.UIModelComponent = UIModelComponent;
    var WebViewEventType, _mat4_temp$2 = new Mat4;
    !function(WebViewEventType) {
        WebViewEventType[WebViewEventType.LOADING = 0] = "LOADING", WebViewEventType[WebViewEventType.LOADED = 1] = "LOADED", 
        WebViewEventType[WebViewEventType.ERROR = 2] = "ERROR", WebViewEventType[WebViewEventType.JS_EVALUATED = 3] = "JS_EVALUATED";
    }(WebViewEventType || (WebViewEventType = {}));
    var polyfill$1 = {
        devicePixelRatio: !1,
        enableDiv: !1
    };
    sys.os === sys.OS_IOS && (polyfill$1.enableDiv = !0), sys.isMobile ? sys.browserType === sys.BROWSER_TYPE_FIREFOX && (polyfill$1.enableBG = !0) : sys.browserType === sys.BROWSER_TYPE_IE && (polyfill$1.closeHistory = !0);
    var _dec$1n, _dec2$Y, _dec3$H, _dec4$C, _dec5$z, _class$1o, _class2$1c, _descriptor$12, _descriptor2$T, _class3$y, _temp$1f, WebViewImpl = ccclass("cc.WebviewImpl")((_temp$1e = _class2$1b = function() {
        function WebViewImpl() {
            _classCallCheck(this, WebViewImpl), this._EventList = new Map, this._visible = !1, 
            this._div = null, this._iframe = null, this._forceUpdate = !0, this._m00 = 0, this._m01 = 0, 
            this._m04 = 0, this._m05 = 0, this._m12 = 0, this._m13 = 0, this._w = 0, this._h = 0, 
            this._eventListeners = {
                load: function load() {},
                error: function error() {}
            };
        }
        return _createClass(WebViewImpl, [ {
            key: "createDomElementIfNeeded",
            value: function createDomElementIfNeeded(w, h) {
                this._div ? this._updateSize(w, h) : this._createNativeControl(w, h);
            }
        }, {
            key: "removeDom",
            value: function removeDom() {
                var div = this._div;
                div && (contains$1(cc.game.container, div) && cc.game.container.removeChild(div), 
                this._div = null);
                var iframe = this._iframe;
                if (iframe) {
                    var cbs = this._eventListeners;
                    iframe.removeEventListener("load", cbs.load), iframe.removeEventListener("error", cbs.error), 
                    cbs.load = null, cbs.error = null, this._iframe = null;
                }
            }
        }, {
            key: "loadURL",
            value: function loadURL(url) {
                var iframe = this._iframe;
                if (iframe) {
                    iframe.src = url;
                    var self = this;
                    iframe.addEventListener("load", (function cb() {
                        self._updateVisibility(), iframe.removeEventListener("load", cb);
                    })), this._dispatchEvent(WebViewImpl.EventType.LOADING);
                }
            }
        }, {
            key: "stopLoading",
            value: function stopLoading() {
                logID(7800);
            }
        }, {
            key: "reload",
            value: function reload() {
                var iframe = this._iframe;
                if (iframe) {
                    var win = iframe.contentWindow;
                    win && win.location && win.location.reload();
                }
            }
        }, {
            key: "canGoBack",
            value: function canGoBack() {
                return logID(7801), !0;
            }
        }, {
            key: "canGoForward",
            value: function canGoForward() {
                return logID(7802), !0;
            }
        }, {
            key: "goBack",
            value: function goBack() {
                try {
                    if (WebViewImpl.Polyfill.closeHistory) return logID(7803);
                    var iframe = this._iframe;
                    if (iframe) {
                        var win = iframe.contentWindow;
                        win && win.location && win.history.back.call(win);
                    }
                } catch (err) {
                    log(err);
                }
            }
        }, {
            key: "goForward",
            value: function goForward() {
                try {
                    if (WebViewImpl.Polyfill.closeHistory) return logID(7804);
                    var iframe = this._iframe;
                    if (iframe) {
                        var win = iframe.contentWindow;
                        win && win.location && win.history.forward.call(win);
                    }
                } catch (err) {
                    log(err);
                }
            }
        }, {
            key: "evaluateJS",
            value: function evaluateJS(str) {
                var iframe = this._iframe;
                if (iframe) iframe.contentWindow;
            }
        }, {
            key: "setScalesPageToFit",
            value: function setScalesPageToFit() {
                logID(7805);
            }
        }, {
            key: "setEventListener",
            value: function setEventListener(event, callback) {
                this._EventList[event] = callback;
            }
        }, {
            key: "removeEventListener",
            value: function removeEventListener(event) {
                this._EventList[event] = null;
            }
        }, {
            key: "_dispatchEvent",
            value: function _dispatchEvent(event) {
                var callback = this._EventList[event];
                callback && this._iframe && callback.call(this, this, this._iframe.src);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.removeDom();
            }
        }, {
            key: "setVisible",
            value: function setVisible(visible) {
                this._visible !== visible && (this._visible = !!visible, this._updateVisibility());
            }
        }, {
            key: "updateMatrix",
            value: function updateMatrix(node) {
                if (this._div && this._visible) {
                    node.getWorldMatrix(_mat4_temp$2);
                    var contentSize = node.getContentSize();
                    if (this._forceUpdate || this._m00 !== _mat4_temp$2.m00 || this._m01 !== _mat4_temp$2.m01 || this._m04 !== _mat4_temp$2.m04 || this._m05 !== _mat4_temp$2.m05 || this._m12 !== _mat4_temp$2.m12 || this._m13 !== _mat4_temp$2.m13 || this._w !== contentSize.width || this._h !== contentSize.height) {
                        this._m00 = _mat4_temp$2.m00, this._m01 = _mat4_temp$2.m01, this._m04 = _mat4_temp$2.m04, 
                        this._m05 = _mat4_temp$2.m05, this._m12 = _mat4_temp$2.m12, this._m13 = _mat4_temp$2.m13, 
                        this._w = contentSize.width, this._h = contentSize.height;
                        var scaleX = view.getScaleX(), scaleY = view.getScaleY(), dpr = view.getDevicePixelRatio();
                        scaleX /= dpr, scaleY /= dpr;
                        var container = cc.game.container, a = _mat4_temp$2.m00 * scaleX, b = _mat4_temp$2.m01, c = _mat4_temp$2.m04, d = _mat4_temp$2.m05 * scaleY, offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0, offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
                        this._updateSize(this._w, this._h);
                        var w = this._div.clientWidth * scaleX, h = this._div.clientHeight * scaleY, ap = node.getAnchorPoint(), appx = w * _mat4_temp$2.m00 * ap.x, appy = h * _mat4_temp$2.m05 * ap.y, matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + (_mat4_temp$2.m12 * scaleX - appx + offsetX) + "," + -(_mat4_temp$2.m13 * scaleY - appy + offsetY) + ")";
                        this._div.style.transform = matrix, this._div.style["-webkit-transform"] = matrix, 
                        this._div.style["transform-origin"] = "0px 100% 0px", this._div.style["-webkit-transform-origin"] = "0px 100% 0px";
                        var renderComp = node.getComponent(UIRenderComponent);
                        renderComp && this._setOpacity(renderComp.color.a);
                    }
                }
            }
        }, {
            key: "setOnJSCallback",
            value: function setOnJSCallback(callback) {}
        }, {
            key: "setJavascriptInterfaceScheme",
            value: function setJavascriptInterfaceScheme(scheme) {}
        }, {
            key: "loadData",
            value: function loadData(data, MIMEType, encoding, baseURL) {}
        }, {
            key: "loadHTMLString",
            value: function loadHTMLString(string, baseURL) {}
        }, {
            key: "_updateVisibility",
            value: function _updateVisibility() {
                if (this._div) {
                    var div = this._div;
                    this._visible ? div.style.visibility = "visible" : div.style.visibility = "hidden", 
                    this._forceUpdate = !0;
                }
            }
        }, {
            key: "_updateSize",
            value: function _updateSize(w, h) {
                var div = this._div;
                div && (div.style.width = w + "px", div.style.height = h + "px");
            }
        }, {
            key: "_initEvent",
            value: function _initEvent() {
                var iframe = this._iframe;
                if (iframe) {
                    var cbs = this._eventListeners, self = this;
                    cbs.load = function() {
                        self._dispatchEvent(WebViewImpl.EventType.LOADED);
                    }, cbs.error = function() {
                        self._dispatchEvent(WebViewImpl.EventType.ERROR);
                    }, iframe.addEventListener("load", cbs.load), iframe.addEventListener("error", cbs.error);
                }
            }
        }, {
            key: "_initStyle",
            value: function _initStyle() {
                if (this._div) {
                    var div = this._div;
                    div.style.position = "absolute", div.style.bottom = "0px", div.style.left = "0px";
                }
            }
        }, {
            key: "_setOpacity",
            value: function _setOpacity(opacity) {
                var iframe = this._iframe;
                iframe && iframe.style && (iframe.style.opacity = (opacity / 255).toString());
            }
        }, {
            key: "_createDom",
            value: function _createDom(w, h) {
                WebViewImpl.Polyfill.enableDiv ? (this._div = document.createElement("div"), this._div.style["-webkit-overflow"] = "auto", 
                this._div.style["-webkit-overflow-scrolling"] = "touch", this._iframe = document.createElement("iframe"), 
                this._div.appendChild(this._iframe), this._iframe.style.width = "100%", this._iframe.style.height = "100%") : this._div = this._iframe = document.createElement("iframe"), 
                WebViewImpl.Polyfill.enableBG && (this._div.style.background = "#FFF"), this._div.style.background = "#FFF", 
                this._div.style.height = h + "px", this._div.style.width = w + "px", this._div.style.overflow = "scroll", 
                this._iframe.style.border = "none", cc.game.container.appendChild(this._div), this._updateVisibility();
            }
        }, {
            key: "_createNativeControl",
            value: function _createNativeControl(w, h) {
                this._createDom(w, h), this._initStyle(), this._initEvent();
            }
        } ]), WebViewImpl;
    }(), _class2$1b.Polyfill = polyfill$1, _class2$1b.EventType = WebViewEventType, 
    _class$1n = _temp$1e)) || _class$1n, EventType$5 = WebViewEventType;
    function emptyCallback() {}
    var _dec$1o, _dec2$Z, _dec3$I, _dec4$D, _dec5$A, _dec6$t, _dec7$q, _dec8$j, _dec9$d, _dec10$c, _dec11$c, _dec12$a, _dec13$9, _dec14$8, _class$1p, _class2$1d, _descriptor$13, _descriptor2$U, _descriptor3$I, _descriptor4$y, _descriptor5$r, _descriptor6$g, _descriptor7$e, _descriptor8$d, _descriptor9$b, _descriptor10$b, _descriptor11$9, _descriptor12$7, _descriptor13$7, _descriptor14$7, _descriptor15$2, _descriptor16$2, _descriptor17$1, _class3$z, _temp$1g, WebviewComponent = (_dec$1n = ccclass("cc.WebviewComponent"), 
    _dec2$Y = menu("UI/WebView"), _dec3$H = executionOrder(100), _dec4$C = property({
        tooltip: "指定 WebView 加载的网址，它应该是一个 http 或者 https 开头的字符串"
    }), _dec5$z = property({
        type: EventHandler,
        tooltip: "WebView 的回调事件，当网页加载过程中，加载完成后或者加载出错时都会回调此函数"
    }), _dec$1n(_class$1o = _dec2$Y(_class$1o = _dec3$H((_temp$1f = _class3$y = function(_UIComponent) {
        function WebviewComponent() {
            var _this;
            return _classCallCheck(this, WebviewComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(WebviewComponent).call(this)), "webviewEvents", _descriptor$12, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_url", _descriptor2$T, _assertThisInitialized(_this)), 
            _this._impl = null, _this._impl = new WebViewImpl, _this;
        }
        return _inherits(WebviewComponent, _UIComponent), _createClass(WebviewComponent, [ {
            key: "url",
            get: function get() {
                return this._url;
            },
            set: function set(url) {
                this._url = url;
                var impl = this._impl;
                impl && impl.loadURL(url);
            }
        } ]), _createClass(WebviewComponent, [ {
            key: "onRestore",
            value: function onRestore() {
                this._impl || (this._impl = new WebViewImpl);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                if (this._impl) {
                    var impl = this._impl;
                    impl.createDomElementIfNeeded(this.node.width, this.node.height), impl.loadURL(this._url), 
                    impl.setVisible(!0), impl.setEventListener(EventType$5.LOADED, this._onWebViewLoaded.bind(this)), 
                    impl.setEventListener(EventType$5.LOADING, this._onWebViewLoading.bind(this)), impl.setEventListener(EventType$5.ERROR, this._onWebViewLoadError.bind(this));
                }
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                if (this._impl) {
                    var impl = this._impl;
                    impl.setVisible(!1), impl.setEventListener(EventType$5.LOADED, emptyCallback), impl.setEventListener(EventType$5.LOADING, emptyCallback), 
                    impl.setEventListener(EventType$5.ERROR, emptyCallback);
                }
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._impl && (this._impl.destroy(), this._impl = null);
            }
        }, {
            key: "update",
            value: function update(dt) {
                this._impl && this._impl.updateMatrix(this.node);
            }
        }, {
            key: "setJavascriptInterfaceScheme",
            value: function setJavascriptInterfaceScheme(scheme) {
                this._impl && this._impl.setJavascriptInterfaceScheme(scheme);
            }
        }, {
            key: "setOnJSCallback",
            value: function setOnJSCallback(callback) {
                this._impl && this._impl.setOnJSCallback(callback);
            }
        }, {
            key: "evaluateJS",
            value: function evaluateJS(str) {
                this._impl && this._impl.evaluateJS(str);
            }
        }, {
            key: "_onWebViewLoaded",
            value: function _onWebViewLoaded() {
                EventHandler.emitEvents(this.webviewEvents, this, EventType$5.LOADED), this.node.emit("loaded", this);
            }
        }, {
            key: "_onWebViewLoading",
            value: function _onWebViewLoading() {
                return EventHandler.emitEvents(this.webviewEvents, this, EventType$5.LOADING), this.node.emit("loading", this), 
                !0;
            }
        }, {
            key: "_onWebViewLoadError",
            value: function _onWebViewLoadError() {
                EventHandler.emitEvents(this.webviewEvents, this, EventType$5.ERROR), this.node.emit("error", this);
            }
        } ]), WebviewComponent;
    }(UIComponent), _class3$y.EventType = EventType$5, _applyDecoratedDescriptor((_class2$1c = _temp$1f).prototype, "url", [ _dec4$C ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "url"), _class2$1c.prototype), 
    _descriptor$12 = _applyDecoratedDescriptor(_class2$1c.prototype, "webviewEvents", [ _dec5$z ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$T = _applyDecoratedDescriptor(_class2$1c.prototype, "_url", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _class$1o = _class2$1c)) || _class$1o) || _class$1o) || _class$1o);
    cc.WebviewComponent = WebviewComponent;
    var AlignMode, AlignFlags, _zeroVec3 = new Vec3;
    function getReadonlyNodeSize(parent) {
        return parent instanceof Scene ? visibleRect : parent.getContentSize();
    }
    function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
        for (var scale = widgetNode.parent ? widgetNode.parent.getScale() : _zeroVec3, scaleX = scale.x, scaleY = scale.y, translateX = 0, translateY = 0, node = widgetNode.parent; ;) {
            if (!node) return out_inverseTranslate.x = out_inverseTranslate.y = 0, void (out_inverseScale.x = out_inverseScale.y = 1);
            var pos = node.getPosition();
            if (translateX += pos.x, translateY += pos.y, (node = node.parent) === target) break;
            var sx = (scale = node ? node.getScale() : _zeroVec3).x, sy = scale.y;
            translateX *= sx, translateY *= sy, scaleX *= sx, scaleY *= sy;
        }
        out_inverseScale.x = 0 !== scaleX ? 1 / scaleX : 1, out_inverseScale.y = 0 !== scaleY ? 1 / scaleY : 1, 
        out_inverseTranslate.x = -translateX, out_inverseTranslate.y = -translateY;
    }
    !function(AlignMode) {
        AlignMode[AlignMode.ONCE = 0] = "ONCE", AlignMode[AlignMode.ALWAYS = 1] = "ALWAYS";
    }(AlignMode || (AlignMode = {})), ccenum(AlignMode), function(AlignFlags) {
        AlignFlags[AlignFlags.TOP = 1] = "TOP", AlignFlags[AlignFlags.MID = 2] = "MID", 
        AlignFlags[AlignFlags.BOT = 4] = "BOT", AlignFlags[AlignFlags.LEFT = 8] = "LEFT", 
        AlignFlags[AlignFlags.CENTER = 16] = "CENTER", AlignFlags[AlignFlags.RIGHT = 32] = "RIGHT", 
        AlignFlags[AlignFlags.HORIZONTAL = 56] = "HORIZONTAL", AlignFlags[AlignFlags.VERTICAL = 7] = "VERTICAL";
    }(AlignFlags || (AlignFlags = {}));
    var _class$1q, TOP_BOT = AlignFlags.TOP | AlignFlags.BOT, LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT, WidgetComponent = (_dec$1o = ccclass("cc.WidgetComponent"), 
    _dec2$Z = executionOrder(110), _dec3$I = menu("UI/Widget"), _dec4$D = requireComponent(UITransformComponent), 
    _dec5$A = property({
        type: Node$1,
        tooltip: "对齐目标"
    }), _dec6$t = property({
        tooltip: "是否对齐上边"
    }), _dec7$q = property({
        tooltip: "是否对齐下边"
    }), _dec8$j = property({
        tooltip: "是否对齐左边"
    }), _dec9$d = property({
        tooltip: "是否对齐右边"
    }), _dec10$c = property({
        tooltip: "是否垂直方向对齐中点，开启此项会将垂直方向其他对齐选项取消"
    }), _dec11$c = property({
        tooltip: "是否水平方向对齐中点，开启此选项会将水平方向其他对齐选项取消"
    }), _dec12$a = property({
        visible: !1
    }), _dec13$9 = property({
        visible: !1
    }), _dec14$8 = property({
        type: AlignMode,
        tooltip: "指定 widget 的对齐方式，用于决定运行时 widget 应何时更新"
    }), _dec$1o(_class$1p = _dec2$Z(_class$1p = _dec3$I(_class$1p = _dec4$D(_class$1p = executeInEditMode((_temp$1g = _class3$z = function(_Component) {
        function WidgetComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, WidgetComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WidgetComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._lastPos = new Vec3, 
            _this._lastSize = new Size, _this._dirty = !0, _initializerDefineProperty(_this, "_alignFlags", _descriptor$13, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_target", _descriptor2$U, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_left", _descriptor3$I, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_right", _descriptor4$y, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_top", _descriptor5$r, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_bottom", _descriptor6$g, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_horizontalCenter", _descriptor7$e, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_verticalCenter", _descriptor8$d, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isAbsLeft", _descriptor9$b, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isAbsRight", _descriptor10$b, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isAbsTop", _descriptor11$9, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isAbsBottom", _descriptor12$7, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isAbsHorizontalCenter", _descriptor13$7, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isAbsVerticalCenter", _descriptor14$7, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_originalWidth", _descriptor15$2, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_originalHeight", _descriptor16$2, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_alignMode", _descriptor17$1, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(WidgetComponent, _Component), _createClass(WidgetComponent, [ {
            key: "updateAlignment",
            value: function updateAlignment() {
                cc._widgetManager.updateAlignment(this.node);
            }
        }, {
            key: "_validateTargetInDEV",
            value: function _validateTargetInDEV() {
            }
        }, {
            key: "setDirty",
            value: function setDirty() {
                this._recursiveDirty();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this.node.getPosition(this._lastPos), this.node.getContentSize(this._lastSize), 
                cc._widgetManager.add(this), this._registerEvent(), this._registerTargetEvents();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                cc._widgetManager.remove(this), this._unregisterEvent(), this._unregisterTargetEvents();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._removeParentEvent();
            }
        }, {
            key: "_adjustWidgetToAllowMovingInEditor",
            value: function _adjustWidgetToAllowMovingInEditor(eventType) {
                if (eventType & TransformBit.POSITION && !cc._widgetManager.isAligning) {
                    var newPos = this.node.getPosition(), oldPos = this._lastPos, delta = new Vec3(newPos);
                    delta.subtract(oldPos);
                    var target = this.node.parent, inverseScale = new Vec3(1, 1, 1);
                    if (this.target && (target = this.target, computeInverseTransForTarget(this.node, target, new Vec3, inverseScale)), 
                    target) {
                        var targetSize = getReadonlyNodeSize(target), deltaInPercent = new Vec3;
                        0 !== targetSize.width && 0 !== targetSize.height && Vec3.set(deltaInPercent, delta.x / targetSize.width, delta.y / targetSize.height, deltaInPercent.z), 
                        this.isAlignTop && (this._top -= (this._isAbsTop ? delta.y : deltaInPercent.y) * inverseScale.y), 
                        this.isAlignBottom && (this._bottom += (this._isAbsBottom ? delta.y : deltaInPercent.y) * inverseScale.y), 
                        this.isAlignLeft && (this._left += (this._isAbsLeft ? delta.x : deltaInPercent.x) * inverseScale.x), 
                        this.isAlignRight && (this._right -= (this._isAbsRight ? delta.x : deltaInPercent.x) * inverseScale.x), 
                        this.isAlignHorizontalCenter && (this._horizontalCenter += (this._isAbsHorizontalCenter ? delta.x : deltaInPercent.x) * inverseScale.x), 
                        this.isAlignVerticalCenter && (this._verticalCenter += (this._isAbsVerticalCenter ? delta.y : deltaInPercent.y) * inverseScale.y), 
                        this._recursiveDirty();
                    }
                }
            }
        }, {
            key: "_adjustWidgetToAllowResizingInEditor",
            value: function _adjustWidgetToAllowResizingInEditor() {
                if (!cc._widgetManager.isAligning) {
                    this.setDirty();
                    var newSize = this.node.getContentSize(), oldSize = this._lastSize, delta = new Vec3(newSize.width - oldSize.width, newSize.height - oldSize.height, 0), target = this.node.parent, inverseScale = new Vec3(1, 1, 1);
                    if (this.target && (target = this.target, computeInverseTransForTarget(this.node, target, new Vec3, inverseScale)), 
                    target) {
                        var targetSize = getReadonlyNodeSize(target), deltaInPercent = new Vec3;
                        0 !== targetSize.width && 0 !== targetSize.height && Vec3.set(deltaInPercent, delta.x / targetSize.width, delta.y / targetSize.height, deltaInPercent.z);
                        var anchor = this.node.getAnchorPoint();
                        this.isAlignTop && (this._top -= (this._isAbsTop ? delta.y : deltaInPercent.y) * (1 - anchor.y) * inverseScale.y), 
                        this.isAlignBottom && (this._bottom -= (this._isAbsBottom ? delta.y : deltaInPercent.y) * anchor.y * inverseScale.y), 
                        this.isAlignLeft && (this._left -= (this._isAbsLeft ? delta.x : deltaInPercent.x) * anchor.x * inverseScale.x), 
                        this.isAlignRight && (this._right -= (this._isAbsRight ? delta.x : deltaInPercent.x) * (1 - anchor.x) * inverseScale.x), 
                        this._recursiveDirty();
                    }
                }
            }
        }, {
            key: "_adjustWidgetToAnchorChanged",
            value: function _adjustWidgetToAnchorChanged() {
                this.setDirty();
            }
        }, {
            key: "_adjustTargetToParentChanged",
            value: function _adjustTargetToParentChanged(oldParent) {
                oldParent && this._unregisterOldParentEvents(oldParent), this.node.getParent() && this._registerTargetEvents();
            }
        }, {
            key: "_registerEvent",
            value: function _registerEvent() {
                this.node.on(exports.SystemEventType.TRANSFORM_CHANGED, this._adjustWidgetToAllowMovingInEditor, this), 
                this.node.on(exports.SystemEventType.SIZE_CHANGED, this._adjustWidgetToAllowResizingInEditor, this), 
                this.node.on(exports.SystemEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this), 
                this.node.on(exports.SystemEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
            }
        }, {
            key: "_unregisterEvent",
            value: function _unregisterEvent() {
                this.node.off(exports.SystemEventType.TRANSFORM_CHANGED, this._adjustWidgetToAllowMovingInEditor, this), 
                this.node.off(exports.SystemEventType.SIZE_CHANGED, this._adjustWidgetToAllowResizingInEditor, this), 
                this.node.off(exports.SystemEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
            }
        }, {
            key: "_removeParentEvent",
            value: function _removeParentEvent() {
                this.node.off(exports.SystemEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
            }
        }, {
            key: "_autoChangedValue",
            value: function _autoChangedValue(flag, isAbs) {
                if ((this._alignFlags & flag) > 0 && this.node.parent && this.node.parent._uiProps.uiTransformComp) {
                    var size = this.node.parent.getContentSize();
                    this.isAlignLeft && flag === AlignFlags.LEFT ? this._left = isAbs ? this._left * size.width : this._left / size.width : this.isAlignRight && flag === AlignFlags.RIGHT ? this._right = isAbs ? this._right * size.width : this._right / size.width : this.isAlignHorizontalCenter && flag === AlignFlags.CENTER ? this._horizontalCenter = isAbs ? this._horizontalCenter * size.width : this._horizontalCenter / size.width : this.isAlignTop && flag === AlignFlags.TOP ? this._top = isAbs ? this._top * size.height : this._top / size.height : this.isAlignBottom && flag === AlignFlags.BOT ? this._bottom = isAbs ? this._bottom * size.height : this._bottom / size.height : this.isAbsoluteVerticalCenter && flag === AlignFlags.MID && (this._verticalCenter = this._verticalCenter / size.height), 
                    this._recursiveDirty();
                }
            }
        }, {
            key: "_registerTargetEvents",
            value: function _registerTargetEvents() {
                var target = this._target || this.node.parent;
                target && (target.getComponent(UITransformComponent) ? (target.on(exports.SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this), 
                target.on(exports.SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this)) : cc.warnID(6501, this.node.name));
            }
        }, {
            key: "_unregisterTargetEvents",
            value: function _unregisterTargetEvents() {
                var target = this._target || this.node.parent;
                target && (target.off(exports.SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this), 
                target.off(exports.SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this));
            }
        }, {
            key: "_unregisterOldParentEvents",
            value: function _unregisterOldParentEvents(oldParent) {
                var target = this._target || oldParent;
                target && (target.off(exports.SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this), 
                target.off(exports.SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this));
            }
        }, {
            key: "_targetChangedOperation",
            value: function _targetChangedOperation() {
                this._recursiveDirty();
            }
        }, {
            key: "_setAlign",
            value: function _setAlign(flag, isAlign) {
                if (isAlign !== (this._alignFlags & flag) > 0) {
                    var isHorizontal = (flag & LEFT_RIGHT) > 0;
                    isAlign ? (this._alignFlags |= flag, isHorizontal ? (this.isAlignHorizontalCenter = !1, 
                    this.isStretchWidth && (this._originalWidth = this.node.width)) : (this.isAlignVerticalCenter = !1, 
                    this.isStretchHeight && (this._originalHeight = this.node.height))) : (isHorizontal ? this.isStretchWidth && (this.node.width = this._originalWidth) : this.isStretchHeight && (this.node.height = this._originalHeight), 
                    this._alignFlags &= ~flag);
                }
            }
        }, {
            key: "_recursiveDirty",
            value: function _recursiveDirty() {
                this._dirty || (this._dirty = !0);
            }
        }, {
            key: "target",
            get: function get() {
                return this._target;
            },
            set: function set(value) {
                this._target !== value && (this._unregisterTargetEvents(), this._target = value, 
                this._registerTargetEvents(), this._validateTargetInDEV(), this._recursiveDirty());
            }
        }, {
            key: "isAlignTop",
            get: function get() {
                return (this._alignFlags & AlignFlags.TOP) > 0;
            },
            set: function set(value) {
                this._setAlign(AlignFlags.TOP, value), this._recursiveDirty();
            }
        }, {
            key: "isAlignBottom",
            get: function get() {
                return (this._alignFlags & AlignFlags.BOT) > 0;
            },
            set: function set(value) {
                this._setAlign(AlignFlags.BOT, value), this._recursiveDirty();
            }
        }, {
            key: "isAlignLeft",
            get: function get() {
                return (this._alignFlags & AlignFlags.LEFT) > 0;
            },
            set: function set(value) {
                this._setAlign(AlignFlags.LEFT, value), this._recursiveDirty();
            }
        }, {
            key: "isAlignRight",
            get: function get() {
                return (this._alignFlags & AlignFlags.RIGHT) > 0;
            },
            set: function set(value) {
                this._setAlign(AlignFlags.RIGHT, value), this._recursiveDirty();
            }
        }, {
            key: "isAlignVerticalCenter",
            get: function get() {
                return (this._alignFlags & AlignFlags.MID) > 0;
            },
            set: function set(value) {
                value ? (this.isAlignTop = !1, this.isAlignBottom = !1, this._alignFlags |= AlignFlags.MID) : this._alignFlags &= ~AlignFlags.MID, 
                this._recursiveDirty();
            }
        }, {
            key: "isAlignHorizontalCenter",
            get: function get() {
                return (this._alignFlags & AlignFlags.CENTER) > 0;
            },
            set: function set(value) {
                value ? (this.isAlignLeft = !1, this.isAlignRight = !1, this._alignFlags |= AlignFlags.CENTER) : this._alignFlags &= ~AlignFlags.CENTER, 
                this._recursiveDirty();
            }
        }, {
            key: "isStretchWidth",
            get: function get() {
                return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
            }
        }, {
            key: "isStretchHeight",
            get: function get() {
                return (this._alignFlags & TOP_BOT) === TOP_BOT;
            }
        }, {
            key: "top",
            get: function get() {
                return this._top;
            },
            set: function set(value) {
                this._top = value, this._recursiveDirty();
            }
        }, {
            key: "editorTop",
            get: function get() {
                return this._isAbsTop ? this._top : 100 * this._top;
            },
            set: function set(value) {
                this._top = this._isAbsTop ? value : value / 100, this._recursiveDirty();
            }
        }, {
            key: "bottom",
            get: function get() {
                return this._bottom;
            },
            set: function set(value) {
                this._bottom = value, this._recursiveDirty();
            }
        }, {
            key: "editorBottom",
            get: function get() {
                return this._isAbsBottom ? this._bottom : 100 * this._bottom;
            },
            set: function set(value) {
                this._bottom = this._isAbsBottom ? value : value / 100, this._recursiveDirty();
            }
        }, {
            key: "left",
            get: function get() {
                return this._left;
            },
            set: function set(value) {
                this._left = value, this._recursiveDirty();
            }
        }, {
            key: "editorLeft",
            get: function get() {
                return this._isAbsLeft ? this._left : 100 * this._left;
            },
            set: function set(value) {
                this._left = this._isAbsLeft ? value : value / 100, this._recursiveDirty();
            }
        }, {
            key: "right",
            get: function get() {
                return this._right;
            },
            set: function set(value) {
                this._right = value, this._recursiveDirty();
            }
        }, {
            key: "editorRight",
            get: function get() {
                return this._isAbsRight ? this._right : 100 * this._right;
            },
            set: function set(value) {
                this._right = this._isAbsRight ? value : value / 100, this._recursiveDirty();
            }
        }, {
            key: "horizontalCenter",
            get: function get() {
                return this._horizontalCenter;
            },
            set: function set(value) {
                this._horizontalCenter = value, this._recursiveDirty();
            }
        }, {
            key: "editorHorizontalCenter",
            get: function get() {
                return this._isAbsHorizontalCenter ? this._horizontalCenter : 100 * this._horizontalCenter;
            },
            set: function set(value) {
                this._horizontalCenter = this._isAbsHorizontalCenter ? value : value / 100, this._recursiveDirty();
            }
        }, {
            key: "verticalCenter",
            get: function get() {
                return this._verticalCenter;
            },
            set: function set(value) {
                this._verticalCenter = value, this._recursiveDirty();
            }
        }, {
            key: "editorVerticalCenter",
            get: function get() {
                return this._isAbsVerticalCenter ? this._verticalCenter : 100 * this._verticalCenter;
            },
            set: function set(value) {
                this._verticalCenter = this._isAbsVerticalCenter ? value : value / 100, this._recursiveDirty();
            }
        }, {
            key: "isAbsoluteTop",
            get: function get() {
                return this._isAbsTop;
            },
            set: function set(value) {
                this._isAbsTop !== value && (this._isAbsTop = value, this._autoChangedValue(AlignFlags.TOP, this._isAbsTop));
            }
        }, {
            key: "isAbsoluteBottom",
            get: function get() {
                return this._isAbsBottom;
            },
            set: function set(value) {
                this._isAbsBottom !== value && (this._isAbsBottom = value, this._autoChangedValue(AlignFlags.BOT, this._isAbsBottom));
            }
        }, {
            key: "isAbsoluteLeft",
            get: function get() {
                return this._isAbsLeft;
            },
            set: function set(value) {
                this._isAbsLeft !== value && (this._isAbsLeft = value, this._autoChangedValue(AlignFlags.LEFT, this._isAbsLeft));
            }
        }, {
            key: "isAbsoluteRight",
            get: function get() {
                return this._isAbsRight;
            },
            set: function set(value) {
                this._isAbsRight !== value && (this._isAbsRight = value, this._autoChangedValue(AlignFlags.RIGHT, this._isAbsRight));
            }
        }, {
            key: "alignMode",
            get: function get() {
                return this._alignMode;
            },
            set: function set(value) {
                this._alignMode = value, this._recursiveDirty();
            }
        }, {
            key: "isAbsoluteHorizontalCenter",
            get: function get() {
                return this._isAbsHorizontalCenter;
            },
            set: function set(value) {
                this._isAbsHorizontalCenter !== value && (this._isAbsHorizontalCenter = value, this._autoChangedValue(AlignFlags.CENTER, this._isAbsHorizontalCenter));
            }
        }, {
            key: "isAbsoluteVerticalCenter",
            get: function get() {
                return this._isAbsVerticalCenter;
            },
            set: function set(value) {
                this._isAbsVerticalCenter !== value && (this._isAbsVerticalCenter = value, this._autoChangedValue(AlignFlags.MID, this._isAbsVerticalCenter));
            }
        }, {
            key: "alignFlags",
            get: function get() {
                return this._alignFlags;
            },
            set: function set(value) {
                this._alignFlags !== value && (this._alignFlags = value, this._recursiveDirty());
            }
        } ]), WidgetComponent;
    }(Component), _class3$z.AlignMode = AlignMode, _applyDecoratedDescriptor((_class2$1d = _temp$1g).prototype, "target", [ _dec5$A ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "target"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAlignTop", [ _dec6$t ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAlignTop"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAlignBottom", [ _dec7$q ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAlignBottom"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAlignLeft", [ _dec8$j ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAlignLeft"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAlignRight", [ _dec9$d ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAlignRight"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAlignVerticalCenter", [ _dec10$c ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAlignVerticalCenter"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAlignHorizontalCenter", [ _dec11$c ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAlignHorizontalCenter"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isStretchWidth", [ _dec12$a ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isStretchWidth"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isStretchHeight", [ _dec13$9 ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isStretchHeight"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "editorTop", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "editorTop"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "editorBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "editorBottom"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "editorLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "editorLeft"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "editorRight", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "editorRight"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "editorHorizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "editorHorizontalCenter"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "editorVerticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "editorVerticalCenter"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAbsoluteTop", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAbsoluteTop"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAbsoluteBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAbsoluteBottom"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAbsoluteLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAbsoluteLeft"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAbsoluteRight", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAbsoluteRight"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "alignMode", [ _dec14$8 ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "alignMode"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAbsoluteHorizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAbsoluteHorizontalCenter"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "isAbsoluteVerticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "isAbsoluteVerticalCenter"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "alignFlags", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "alignFlags"), _class2$1d.prototype), 
    _descriptor$13 = _applyDecoratedDescriptor(_class2$1d.prototype, "_alignFlags", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor2$U = _applyDecoratedDescriptor(_class2$1d.prototype, "_target", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$I = _applyDecoratedDescriptor(_class2$1d.prototype, "_left", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor4$y = _applyDecoratedDescriptor(_class2$1d.prototype, "_right", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor5$r = _applyDecoratedDescriptor(_class2$1d.prototype, "_top", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$g = _applyDecoratedDescriptor(_class2$1d.prototype, "_bottom", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor7$e = _applyDecoratedDescriptor(_class2$1d.prototype, "_horizontalCenter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor8$d = _applyDecoratedDescriptor(_class2$1d.prototype, "_verticalCenter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor9$b = _applyDecoratedDescriptor(_class2$1d.prototype, "_isAbsLeft", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor10$b = _applyDecoratedDescriptor(_class2$1d.prototype, "_isAbsRight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor11$9 = _applyDecoratedDescriptor(_class2$1d.prototype, "_isAbsTop", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor12$7 = _applyDecoratedDescriptor(_class2$1d.prototype, "_isAbsBottom", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor13$7 = _applyDecoratedDescriptor(_class2$1d.prototype, "_isAbsHorizontalCenter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor14$7 = _applyDecoratedDescriptor(_class2$1d.prototype, "_isAbsVerticalCenter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor15$2 = _applyDecoratedDescriptor(_class2$1d.prototype, "_originalWidth", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor16$2 = _applyDecoratedDescriptor(_class2$1d.prototype, "_originalHeight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor17$1 = _applyDecoratedDescriptor(_class2$1d.prototype, "_alignMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return AlignMode.ALWAYS;
        }
    }), _class$1p = _class2$1d)) || _class$1p) || _class$1p) || _class$1p) || _class$1p) || _class$1p);
    cc.WidgetComponent = WidgetComponent;
    var _dec$1q, _dec2$$, _dec3$K, _dec4$E, _dec5$B, _dec6$u, _dec7$r, _class$1r, _class2$1e, _descriptor$14, _descriptor2$V, _descriptor3$J, _descriptor4$z, _class3$A, _temp$1h, UIReorderComponent = ccclass("cc.UIReorderComponent")(_class$1q = menu("UI/Reorder")(_class$1q = executionOrder(110)(_class$1q = disallowMultiple(_class$1q = executeInEditMode(_class$1q = function(_UIComponent) {
        function UIReorderComponent() {
            return _classCallCheck(this, UIReorderComponent), _possibleConstructorReturn(this, _getPrototypeOf(UIReorderComponent).apply(this, arguments));
        }
        return _inherits(UIReorderComponent, _UIComponent), UIReorderComponent;
    }(UIComponent)) || _class$1q) || _class$1q) || _class$1q) || _class$1q) || _class$1q;
    cc.UIReorderComponent = UIReorderComponent;
    var Direction$2, _color = new Color;
    !function(Direction) {
        Direction[Direction.HORIZONTAL = 0] = "HORIZONTAL", Direction[Direction.VERTICAL = 1] = "VERTICAL";
    }(Direction$2 || (Direction$2 = {})), ccenum(Direction$2);
    var _dec$1r, _dec2$10, _dec3$L, _dec4$F, _dec5$C, _dec6$v, _dec7$s, _dec8$k, _dec9$e, _dec10$d, _dec11$d, _dec12$b, _dec13$a, _dec14$9, _dec15$7, _dec16$7, _class$1s, _class2$1f, _descriptor$15, _descriptor2$W, _descriptor3$K, _descriptor4$A, _descriptor5$s, _descriptor6$h, _descriptor7$f, _descriptor8$e, _descriptor9$c, _descriptor10$c, _descriptor11$a, _descriptor12$8, _class3$B, _temp$1i, PageViewIndicatorComponent = (_dec$1q = ccclass("cc.PageViewIndicatorComponent"), 
    _dec2$$ = executionOrder(110), _dec3$K = menu("UI/PageViewIndicator"), _dec4$E = property({
        type: SpriteFrame,
        tooltip: "每个页面标记显示的图片"
    }), _dec5$B = property({
        type: Direction$2,
        tooltip: "页面标记摆放方向"
    }), _dec6$u = property({
        type: Size,
        tooltip: "每个页面标记的大小"
    }), _dec7$r = property({
        tooltip: "每个页面标记之间的边距"
    }), _dec$1q(_class$1r = _dec2$$(_class$1r = _dec3$K((_temp$1h = _class3$A = function(_Component) {
        function PageViewIndicatorComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, PageViewIndicatorComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PageViewIndicatorComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "spacing", _descriptor$14, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_spriteFrame", _descriptor2$V, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_direction", _descriptor3$J, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_cellSize", _descriptor4$z, _assertThisInitialized(_this)), 
            _this._layout = null, _this._pageView = null, _this._indicators = [], _this;
        }
        return _inherits(PageViewIndicatorComponent, _Component), _createClass(PageViewIndicatorComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this._updateLayout();
            }
        }, {
            key: "setPageView",
            value: function setPageView(target) {
                this._pageView = target, this._refresh();
            }
        }, {
            key: "_updateLayout",
            value: function _updateLayout() {
                this._layout = this.getComponent(LayoutComponent), this._layout || (this._layout = this.addComponent(LayoutComponent));
                var layout = this._layout;
                this.direction === Direction$2.HORIZONTAL ? (layout.type = LayoutComponent.Type.HORIZONTAL, 
                layout.spacingX = this.spacing) : this.direction === Direction$2.VERTICAL && (layout.type = LayoutComponent.Type.VERTICAL, 
                layout.spacingY = this.spacing), layout.resizeMode = LayoutComponent.ResizeMode.CONTAINER;
            }
        }, {
            key: "_createIndicator",
            value: function _createIndicator() {
                var node = new Node$1;
                return node.addComponent(SpriteComponent).spriteFrame = this.spriteFrame, node.parent = this.node, 
                node.width = this.cellSize.width, node.height = this.cellSize.height, node;
            }
        }, {
            key: "_changedState",
            value: function _changedState() {
                var indicators = this._indicators;
                if (0 !== indicators.length && this._pageView) {
                    var idx = this._pageView.curPageIdx;
                    if (!(idx >= indicators.length)) {
                        for (var i = 0; i < indicators.length; ++i) {
                            var node = indicators[i];
                            if (node._uiProps.uiComp) {
                                var uiComp = node._uiProps.uiComp;
                                _color.set(uiComp.color), _color.a = 127.5, uiComp.color = _color;
                            }
                        }
                        if (indicators[idx]._uiProps.uiComp) {
                            var comp = indicators[idx]._uiProps.uiComp;
                            _color.set(comp.color), _color.a = 255, comp.color = _color;
                        }
                    }
                }
            }
        }, {
            key: "_refresh",
            value: function _refresh() {
                if (this._pageView) {
                    var indicators = this._indicators, pages = this._pageView.getPages();
                    if (pages.length !== indicators.length) {
                        var i = 0;
                        if (pages.length > indicators.length) for (i = 0; i < pages.length; ++i) indicators[i] || (indicators[i] = this._createIndicator()); else for (i = indicators.length - pages.length; i > 0; --i) {
                            var node = indicators[i - 1];
                            this.node.removeChild(node), indicators.splice(i - 1, 1);
                        }
                        this._layout && this._layout.enabledInHierarchy && this._layout.updateLayout(), 
                        this._changedState();
                    }
                }
            }
        }, {
            key: "spriteFrame",
            get: function get() {
                return this._spriteFrame;
            },
            set: function set(value) {
                this._spriteFrame !== value && (this._spriteFrame = value);
            }
        }, {
            key: "direction",
            get: function get() {
                return this._direction;
            },
            set: function set(value) {
                this._direction !== value && (this._direction = value);
            }
        }, {
            key: "cellSize",
            get: function get() {
                return this._cellSize;
            },
            set: function set(value) {
                this._cellSize !== value && (this._cellSize = value);
            }
        } ]), PageViewIndicatorComponent;
    }(Component), _class3$A.Direction = Direction$2, _applyDecoratedDescriptor((_class2$1e = _temp$1h).prototype, "spriteFrame", [ _dec4$E ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "spriteFrame"), _class2$1e.prototype), 
    _applyDecoratedDescriptor(_class2$1e.prototype, "direction", [ _dec5$B ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "direction"), _class2$1e.prototype), 
    _applyDecoratedDescriptor(_class2$1e.prototype, "cellSize", [ _dec6$u ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "cellSize"), _class2$1e.prototype), 
    _descriptor$14 = _applyDecoratedDescriptor(_class2$1e.prototype, "spacing", [ _dec7$r ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor2$V = _applyDecoratedDescriptor(_class2$1e.prototype, "_spriteFrame", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$J = _applyDecoratedDescriptor(_class2$1e.prototype, "_direction", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Direction$2.HORIZONTAL;
        }
    }), _descriptor4$z = _applyDecoratedDescriptor(_class2$1e.prototype, "_cellSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Size(20, 20);
        }
    }), _class$1r = _class2$1e)) || _class$1r) || _class$1r) || _class$1r);
    cc.PageViewIndicatorComponent = PageViewIndicatorComponent;
    var SizeMode$1, Direction$3, EventType$6, _temp_vec2 = new Vec2;
    !function(SizeMode) {
        SizeMode[SizeMode.Unified = 0] = "Unified", SizeMode[SizeMode.Free = 1] = "Free";
    }(SizeMode$1 || (SizeMode$1 = {})), ccenum(SizeMode$1), function(Direction) {
        Direction[Direction.Horizontal = 0] = "Horizontal", Direction[Direction.Vertical = 1] = "Vertical";
    }(Direction$3 || (Direction$3 = {})), ccenum(Direction$3), function(EventType) {
        EventType.PAGE_TURNING = "page-turning";
    }(EventType$6 || (EventType$6 = {}));
    var _dec$1s, _dec2$11, _dec3$M, _dec4$G, _dec5$D, _dec6$w, _dec7$t, _class$1t, _class2$1g, PageViewComponent = (_dec$1r = ccclass("cc.PageViewComponent"), 
    _dec2$10 = executionOrder(110), _dec3$L = menu("UI/PageView"), _dec4$F = property({
        type: SizeMode$1,
        tooltip: "页面视图中每个页面大小类型"
    }), _dec5$C = property({
        type: Direction$3,
        tooltip: "页面视图滚动类型"
    }), _dec6$v = property({
        slide: !0,
        range: [ 0, 1, .01 ],
        tooltip: "滚动临界值，默认单位百分比，当拖拽超出该数值时，松开会自动滚动下一页，小于时则还原"
    }), _dec7$s = property({
        slide: !0,
        range: [ 0, 1, .01 ],
        tooltip: "设置 PageView PageTurning 事件的发送时机"
    }), _dec8$k = property({
        type: PageViewIndicatorComponent,
        tooltip: "页面视图指示器组件"
    }), _dec9$e = property({
        tooltip: "快速滑动翻页临界值\n当用户快速滑动时，会根据滑动开始和结束的距离与时间计算出一个速度值\n该值与此临界值相比较，如果大于临界值，则进行自动翻页"
    }), _dec10$d = property({
        type: ScrollBarComponent,
        visible: !1,
        override: !0
    }), _dec11$d = property({
        type: ScrollBarComponent,
        visible: !1,
        override: !0
    }), _dec12$b = property({
        visible: !1,
        override: !0
    }), _dec13$a = property({
        visible: !1,
        override: !0
    }), _dec14$9 = property({
        visible: !1,
        override: !0
    }), _dec15$7 = property({
        visible: !1,
        override: !0,
        type: [ EventHandler ]
    }), _dec16$7 = property({
        type: [ EventHandler ],
        tooltip: "滚动视图的事件回调函数"
    }), _dec$1r(_class$1s = _dec2$10(_class$1s = _dec3$L((_temp$1i = _class3$B = function(_ScrollViewComponent) {
        function PageViewComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, PageViewComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PageViewComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "autoPageTurningThreshold", _descriptor$15, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "horizontal", _descriptor2$W, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "vertical", _descriptor3$K, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor4$A, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "scrollEvents", _descriptor5$s, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "pageTurningSpeed", _descriptor6$h, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "pageEvents", _descriptor7$f, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_sizeMode", _descriptor8$e, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_direction", _descriptor9$c, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_scrollThreshold", _descriptor10$c, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_pageTurningEventTiming", _descriptor11$a, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_indicator", _descriptor12$8, _assertThisInitialized(_this)), 
            _this._curPageIdx = 0, _this._lastPageIdx = 0, _this._pages = [], _this._initContentPos = new Vec3, 
            _this._scrollCenterOffsetX = [], _this._scrollCenterOffsetY = [], _this._touchBeganPosition = new Vec3, 
            _this._touchEndPosition = new Vec3, _this;
        }
        return _inherits(PageViewComponent, _ScrollViewComponent), _createClass(PageViewComponent, [ {
            key: "__preload",
            value: function __preload() {
                this.node.on(exports.SystemEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(PageViewComponent.prototype), "onEnable", this).call(this), 
                this.node.on(PageViewComponent.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(PageViewComponent.prototype), "onDisable", this).call(this), 
                this.node.off(PageViewComponent.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
            }
        }, {
            key: "onLoad",
            value: function onLoad() {
                this._initPages(), this.indicator && this.indicator.setPageView(this);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this.node.off(exports.SystemEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
            }
        }, {
            key: "getCurrentPageIndex",
            value: function getCurrentPageIndex() {
                return this._curPageIdx;
            }
        }, {
            key: "setCurrentPageIndex",
            value: function setCurrentPageIndex(index) {
                this.scrollToPage(index, 1);
            }
        }, {
            key: "getPages",
            value: function getPages() {
                return this._pages;
            }
        }, {
            key: "addPage",
            value: function addPage(page) {
                page && -1 === this._pages.indexOf(page) && this.content && (this.content.addChild(page), 
                this._pages.push(page), this._updatePageView());
            }
        }, {
            key: "insertPage",
            value: function insertPage(page, index) {
                index < 0 || !page || -1 !== this._pages.indexOf(page) || !this.content || (index >= this._pages.length ? this.addPage(page) : (this._pages.splice(index, 0, page), 
                this.content.insertChild(page, index), this._updatePageView()));
            }
        }, {
            key: "removePage",
            value: function removePage(page) {
                if (page && this.content) {
                    var index = this._pages.indexOf(page);
                    -1 !== index ? this.removePageAtIndex(index) : warnID(4300, page.name);
                }
            }
        }, {
            key: "removePageAtIndex",
            value: function removePageAtIndex(index) {
                var pageList = this._pages;
                if (!(index < 0 || index >= pageList.length)) {
                    var page = pageList[index];
                    page && this.content && (this.content.removeChild(page), pageList.splice(index, 1), 
                    this._updatePageView());
                }
            }
        }, {
            key: "removeAllPages",
            value: function removeAllPages() {
                if (this.content) {
                    for (var locPages = this._pages, i = 0, len = locPages.length; i < len; i++) this.content.removeChild(locPages[i]);
                    this._pages.length = 0, this._updatePageView();
                }
            }
        }, {
            key: "scrollToPage",
            value: function scrollToPage(idx) {
                var timeInSecond = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                idx < 0 || idx >= this._pages.length || (timeInSecond = void 0 !== timeInSecond ? timeInSecond : .3, 
                this._curPageIdx = idx, this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, !0), 
                this.indicator && this.indicator._changedState());
            }
        }, {
            key: "getScrollEndedEventTiming",
            value: function getScrollEndedEventTiming() {
                return this.pageTurningEventTiming;
            }
        }, {
            key: "_updatePageView",
            value: function _updatePageView() {
                var layout = this.content.getComponent(LayoutComponent);
                layout && layout.enabled && layout.updateLayout();
                var pageCount = this._pages.length;
                this._curPageIdx >= pageCount && (this._curPageIdx = 0 === pageCount ? 0 : pageCount - 1, 
                this._lastPageIdx = this._curPageIdx);
                for (var contentPos = this._initContentPos, i = 0; i < pageCount; ++i) {
                    var pos = this._pages[i].position;
                    this.direction === Direction$3.Horizontal ? this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + pos.x) : this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + pos.y);
                }
                this.indicator && this.indicator._refresh();
            }
        }, {
            key: "_updateAllPagesSize",
            value: function _updateAllPagesSize() {
                if (this.content && this.view && this._sizeMode === SizeMode$1.Unified) for (var locPages = this._pages, selfSize = this.view.getContentSize(), i = 0, len = locPages.length; i < len; i++) locPages[i].setContentSize(selfSize);
            }
        }, {
            key: "_handleReleaseLogic",
            value: function _handleReleaseLogic() {
                this._autoScrollToPage(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent(PageViewComponent.EventType.SCROLL_ENDED));
            }
        }, {
            key: "_onTouchBegan",
            value: function _onTouchBegan(event, captureListeners) {
                event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchBeganPosition, _temp_vec2.x, _temp_vec2.y, 0), 
                _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchBegan", this).call(this, event, captureListeners);
            }
        }, {
            key: "_onTouchMoved",
            value: function _onTouchMoved(event, captureListeners) {
                _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchMoved", this).call(this, event, captureListeners);
            }
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded(event, captureListeners) {
                event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchEndPosition, _temp_vec2.x, _temp_vec2.y, 0), 
                _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchEnded", this).call(this, event, captureListeners);
            }
        }, {
            key: "_onTouchCancelled",
            value: function _onTouchCancelled(event, captureListeners) {
                event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchEndPosition, _temp_vec2.x, _temp_vec2.y, 0), 
                _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchCancelled", this).call(this, event, captureListeners);
            }
        }, {
            key: "_onMouseWheel",
            value: function _onMouseWheel() {}
        }, {
            key: "_syncScrollDirection",
            value: function _syncScrollDirection() {
                this.horizontal = this.direction === Direction$3.Horizontal, this.vertical = this.direction === Direction$3.Vertical;
            }
        }, {
            key: "_syncSizeMode",
            value: function _syncSizeMode() {
                var view = this.view;
                if (this.content && view) {
                    var layout = this.content.getComponent(LayoutComponent);
                    if (layout) {
                        if (this._sizeMode === SizeMode$1.Free && this._pages.length > 0) {
                            var lastPage = this._pages[this._pages.length - 1];
                            this.direction === Direction$3.Horizontal ? (layout.paddingLeft = (view.width - this._pages[0].width) / 2, 
                            layout.paddingRight = (view.width - lastPage.width) / 2) : this.direction === Direction$3.Vertical && (layout.paddingTop = (view.height - this._pages[0].height) / 2, 
                            layout.paddingBottom = (view.height - lastPage.height) / 2);
                        }
                        layout.updateLayout();
                    }
                }
            }
        }, {
            key: "_initPages",
            value: function _initPages() {
                if (this.content) {
                    this._initContentPos = this.content.position;
                    for (var children = this.content.children, i = 0; i < children.length; ++i) {
                        var page = children[i];
                        this._pages.indexOf(page) >= 0 || this._pages.push(page);
                    }
                    this._syncScrollDirection(), this._syncSizeMode(), this._updatePageView();
                }
            }
        }, {
            key: "_dispatchPageTurningEvent",
            value: function _dispatchPageTurningEvent() {
                this._lastPageIdx !== this._curPageIdx && (this._lastPageIdx = this._curPageIdx, 
                EventHandler.emitEvents(this.pageEvents, this), this.node.emit(EventType$6.PAGE_TURNING, this));
            }
        }, {
            key: "_isQuicklyScrollable",
            value: function _isQuicklyScrollable(touchMoveVelocity) {
                if (this.direction === Direction$3.Horizontal) {
                    if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) return !0;
                } else if (this.direction === Direction$3.Vertical && Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) return !0;
                return !1;
            }
        }, {
            key: "_moveOffsetValue",
            value: function _moveOffsetValue(idx) {
                var offset = new Vec3;
                if (this._sizeMode === SizeMode$1.Free) this.direction === Direction$3.Horizontal ? offset.x = this._scrollCenterOffsetX[idx] : this.direction === Direction$3.Vertical && (offset.y = this._scrollCenterOffsetY[idx]); else {
                    var view = this.view;
                    if (!view) return offset;
                    this.direction === Direction$3.Horizontal ? offset.x = idx * view.width : this.direction === Direction$3.Vertical && (offset.y = idx * view.height);
                }
                return offset;
            }
        }, {
            key: "_getDragDirection",
            value: function _getDragDirection(moveOffset) {
                return this._direction === Direction$3.Horizontal ? 0 === moveOffset.x ? 0 : moveOffset.x > 0 ? 1 : -1 : 0 === moveOffset.y ? 0 : moveOffset.y < 0 ? 1 : -1;
            }
        }, {
            key: "_isScrollable",
            value: function _isScrollable(offset, index, nextIndex) {
                if (this._sizeMode === SizeMode$1.Free) {
                    var curPageCenter = 0, nextPageCenter = 0;
                    if (this.direction === Direction$3.Horizontal) return curPageCenter = this._scrollCenterOffsetX[index], 
                    nextPageCenter = this._scrollCenterOffsetX[nextIndex], Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                    if (this.direction === Direction$3.Vertical) return curPageCenter = this._scrollCenterOffsetY[index], 
                    nextPageCenter = this._scrollCenterOffsetY[nextIndex], Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                } else {
                    var view = this.view;
                    if (!view) return;
                    if (this.direction === Direction$3.Horizontal) return Math.abs(offset.x) >= view.width * this.scrollThreshold;
                    if (this.direction === Direction$3.Vertical) return Math.abs(offset.y) >= view.height * this.scrollThreshold;
                }
            }
        }, {
            key: "_autoScrollToPage",
            value: function _autoScrollToPage() {
                var bounceBackStarted = this._startBounceBackIfNeeded(), moveOffset = new Vec3;
                if (Vec3.subtract(moveOffset, this._touchBeganPosition, this._touchEndPosition), 
                bounceBackStarted) {
                    var dragDirection = this._getDragDirection(moveOffset);
                    if (0 === dragDirection) return;
                    this._curPageIdx = dragDirection > 0 ? this._pages.length - 1 : 0, this.indicator && this.indicator._changedState();
                } else {
                    var index = this._curPageIdx, nextIndex = index + this._getDragDirection(moveOffset), timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);
                    if (nextIndex < this._pages.length) {
                        if (this._isScrollable(moveOffset, index, nextIndex)) return void this.scrollToPage(nextIndex, timeInSecond);
                        var touchMoveVelocity = this._calculateTouchMoveVelocity();
                        if (this._isQuicklyScrollable(touchMoveVelocity)) return void this.scrollToPage(nextIndex, timeInSecond);
                    }
                    this.scrollToPage(index, timeInSecond);
                }
            }
        }, {
            key: "sizeMode",
            get: function get() {
                return this._sizeMode;
            },
            set: function set(value) {
                this._sizeMode !== value && (this._sizeMode = value, this._syncSizeMode());
            }
        }, {
            key: "direction",
            get: function get() {
                return this._direction;
            },
            set: function set(value) {
                this._direction !== value && (this._direction = value, this._syncScrollDirection());
            }
        }, {
            key: "scrollThreshold",
            get: function get() {
                return this._scrollThreshold;
            },
            set: function set(value) {
                this._scrollThreshold !== value && (this._scrollThreshold = value);
            }
        }, {
            key: "pageTurningEventTiming",
            get: function get() {
                return this._pageTurningEventTiming;
            },
            set: function set(value) {
                this._pageTurningEventTiming !== value && (this._pageTurningEventTiming = value);
            }
        }, {
            key: "indicator",
            get: function get() {
                return this._indicator;
            },
            set: function set(value) {
                this._indicator !== value && (this._indicator = value, this.indicator && this.indicator.setPageView(this));
            }
        }, {
            key: "curPageIdx",
            get: function get() {
                return this._curPageIdx;
            }
        }, {
            key: "verticalScrollBar",
            get: function get() {
                return this._verticalScrollBar;
            }
        }, {
            key: "horizontalScrollBar",
            get: function get() {
                return this._horizontalScrollBar;
            }
        } ]), PageViewComponent;
    }(ScrollViewComponent), _class3$B.SizeMode = SizeMode$1, _class3$B.Direction = Direction$3, 
    _class3$B.EventType = extendsEnum(EventType$6, EventType$3), _applyDecoratedDescriptor((_class2$1f = _temp$1i).prototype, "sizeMode", [ _dec4$F ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "sizeMode"), _class2$1f.prototype), 
    _applyDecoratedDescriptor(_class2$1f.prototype, "direction", [ _dec5$C ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "direction"), _class2$1f.prototype), 
    _applyDecoratedDescriptor(_class2$1f.prototype, "scrollThreshold", [ _dec6$v ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "scrollThreshold"), _class2$1f.prototype), 
    _applyDecoratedDescriptor(_class2$1f.prototype, "pageTurningEventTiming", [ _dec7$s ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "pageTurningEventTiming"), _class2$1f.prototype), 
    _applyDecoratedDescriptor(_class2$1f.prototype, "indicator", [ _dec8$k ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "indicator"), _class2$1f.prototype), 
    _descriptor$15 = _applyDecoratedDescriptor(_class2$1f.prototype, "autoPageTurningThreshold", [ _dec9$e ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 100;
        }
    }), _applyDecoratedDescriptor(_class2$1f.prototype, "verticalScrollBar", [ _dec10$d ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "verticalScrollBar"), _class2$1f.prototype), 
    _applyDecoratedDescriptor(_class2$1f.prototype, "horizontalScrollBar", [ _dec11$d ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "horizontalScrollBar"), _class2$1f.prototype), 
    _descriptor2$W = _applyDecoratedDescriptor(_class2$1f.prototype, "horizontal", [ _dec12$b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor3$K = _applyDecoratedDescriptor(_class2$1f.prototype, "vertical", [ _dec13$a ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor4$A = _applyDecoratedDescriptor(_class2$1f.prototype, "cancelInnerEvents", [ _dec14$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor5$s = _applyDecoratedDescriptor(_class2$1f.prototype, "scrollEvents", [ _dec15$7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor6$h = _applyDecoratedDescriptor(_class2$1f.prototype, "pageTurningSpeed", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .3;
        }
    }), _descriptor7$f = _applyDecoratedDescriptor(_class2$1f.prototype, "pageEvents", [ _dec16$7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor8$e = _applyDecoratedDescriptor(_class2$1f.prototype, "_sizeMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return SizeMode$1.Unified;
        }
    }), _descriptor9$c = _applyDecoratedDescriptor(_class2$1f.prototype, "_direction", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Direction$3.Horizontal;
        }
    }), _descriptor10$c = _applyDecoratedDescriptor(_class2$1f.prototype, "_scrollThreshold", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .5;
        }
    }), _descriptor11$a = _applyDecoratedDescriptor(_class2$1f.prototype, "_pageTurningEventTiming", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _descriptor12$8 = _applyDecoratedDescriptor(_class2$1f.prototype, "_indicator", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$1s = _class2$1f)) || _class$1s) || _class$1s) || _class$1s);
    cc.PageViewComponent = PageViewComponent;
    var _class$1u, _class2$1h, _descriptor$16, UIStaticBatchComponent = (_dec$1s = ccclass("cc.UIStaticBatchComponent"), 
    _dec2$11 = menu("UI/Render/UIStaticBatch"), _dec3$M = executionOrder(110), _dec4$G = property({
        visible: !1,
        override: !0
    }), _dec5$D = property({
        visible: !1,
        override: !0
    }), _dec6$w = property({
        visible: !1,
        override: !0
    }), _dec7$t = property({
        type: Material,
        displayOrder: 3,
        visible: !1,
        override: !0
    }), _dec$1s(_class$1t = _dec2$11(_class$1t = _dec3$M((_applyDecoratedDescriptor((_class2$1g = function(_UIRenderComponent) {
        function UIStaticBatchComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, UIStaticBatchComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIStaticBatchComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._init = !1, 
            _this._meshBuffer = null, _this._dirty = !0, _this._lastMeshBuffer = null, _this._uiDrawBatchList = [], 
            _this;
        }
        return _inherits(UIStaticBatchComponent, _UIRenderComponent), _createClass(UIStaticBatchComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                var ui = this._getUI();
                if (ui) {
                    var attr = vfmt, buffer = new MeshBuffer(ui);
                    buffer.initialize(attr, this._arrivalMaxBuffer), this._meshBuffer = buffer;
                }
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(UIStaticBatchComponent.prototype), "onDestroy", this).call(this), 
                this._clearData(), this._meshBuffer && (this._meshBuffer.destroy(), this._meshBuffer = null);
            }
        }, {
            key: "updateAssembler",
            value: function updateAssembler(render) {
                this._dirty && (render.finishMergeBatches(), this._lastMeshBuffer = render.currBufferBatch, 
                render.currBufferBatch = this._meshBuffer, render.currStaticRoot = this), this._init && (render.finishMergeBatches(), 
                render.commitStaticBatch(this));
            }
        }, {
            key: "postUpdateAssembler",
            value: function postUpdateAssembler(render) {
                this._dirty && (render.finishMergeBatches(), render.currBufferBatch = this._lastMeshBuffer, 
                render.currStaticRoot = null, this._dirty = !1, this._init = !0, this.node._static = !0, 
                this._meshBuffer.uploadData());
            }
        }, {
            key: "markAsDirty",
            value: function markAsDirty() {
                this._getUI() && (this.node._static = !1, this._dirty = !0, this._init = !1, this._clearData());
            }
        }, {
            key: "_requireDrawBatch",
            value: function _requireDrawBatch() {
                var batch = new UIDrawBatch;
                return batch.isStatic = !0, this._uiDrawBatchList.push(batch), batch;
            }
        }, {
            key: "_clearData",
            value: function _clearData() {
                if (this._meshBuffer) {
                    this._meshBuffer.reset();
                    for (var ui = this._getUI(), i = 0; i < this._uiDrawBatchList.length; i++) {
                        this._uiDrawBatchList[i].destroy(ui);
                    }
                }
                this._uiDrawBatchList.length = 0, this._init = !1;
            }
        }, {
            key: "_getUI",
            value: function _getUI() {
                return director.root && director.root.ui ? director.root.ui : (warnID(9301), null);
            }
        }, {
            key: "_arrivalMaxBuffer",
            value: function _arrivalMaxBuffer() {
                warnID(9300);
            }
        }, {
            key: "dstBlendFactor",
            get: function get() {
                return this._dstBlendFactor;
            },
            set: function set(value) {
                this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
            }
        }, {
            key: "srcBlendFactor",
            get: function get() {
                return this._srcBlendFactor;
            },
            set: function set(value) {
                this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(value) {
                this._color !== value && (this._color.set(value), this._updateColor(), this.markForUpdateRenderData());
            }
        }, {
            key: "sharedMaterial",
            get: function get() {
                return this._sharedMaterial;
            },
            set: function set(value) {
                this._sharedMaterial !== value && (this._sharedMaterial = value, this._instanceMaterial && this._instanceMaterial());
            }
        }, {
            key: "drawBatchList",
            get: function get() {
                return this._uiDrawBatchList;
            }
        } ]), UIStaticBatchComponent;
    }(UIRenderComponent)).prototype, "dstBlendFactor", [ _dec4$G ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "dstBlendFactor"), _class2$1g.prototype), 
    _applyDecoratedDescriptor(_class2$1g.prototype, "srcBlendFactor", [ _dec5$D ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "srcBlendFactor"), _class2$1g.prototype), 
    _applyDecoratedDescriptor(_class2$1g.prototype, "color", [ _dec6$w ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "color"), _class2$1g.prototype), 
    _applyDecoratedDescriptor(_class2$1g.prototype, "sharedMaterial", [ _dec7$t ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "sharedMaterial"), _class2$1g.prototype), 
    _class$1t = _class2$1g)) || _class$1t) || _class$1t) || _class$1t), UIOpacityComponent = ccclass("cc.UIOpacityComponent")(_class$1u = executionOrder(110)(_class$1u = menu("UI/UIOpacity")(_class$1u = executeInEditMode((_applyDecoratedDescriptor((_class2$1h = function(_Component) {
        function UIOpacityComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, UIOpacityComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIOpacityComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_opacity", _descriptor$16, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(UIOpacityComponent, _Component), _createClass(UIOpacityComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                this.node._uiProps.opacity = this._opacity / 255;
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.node._uiProps.opacity = 1;
            }
        }, {
            key: "opacity",
            get: function get() {
                return this._opacity;
            },
            set: function set(value) {
                this._opacity !== value && (this._opacity = value, this.node._uiProps.opacity = value / 255);
            }
        } ]), UIOpacityComponent;
    }(Component)).prototype, "opacity", [ property ], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "opacity"), _class2$1h.prototype), 
    _descriptor$16 = _applyDecoratedDescriptor(_class2$1h.prototype, "_opacity", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 255;
        }
    }), _class$1u = _class2$1h)) || _class$1u) || _class$1u) || _class$1u) || _class$1u, _tempPos$2 = new Vec3, _defaultAnchor = new Vec2, tInverseTranslate = new Vec3, tInverseScale = new Vec3(1, 1, 1);
    function align(node, widget) {
        var target, hasTarget = widget.target, inverseTranslate = tInverseTranslate, inverseScale = tInverseScale;
        if (hasTarget ? computeInverseTransForTarget(node, target = hasTarget, inverseTranslate, inverseScale) : target = node.parent, 
        target.getComponent(UITransformComponent)) {
            var targetSize = getReadonlyNodeSize(target), isScene = target instanceof Scene, targetAnchor = isScene ? _defaultAnchor : target.getAnchorPoint(), isRoot = isScene;
            node.getPosition(_tempPos$2);
            var x = _tempPos$2.x, y = _tempPos$2.y, anchor = node.getAnchorPoint(), scale = node.getScale();
            if (widget.alignFlags & AlignFlags.HORIZONTAL) {
                var localLeft = 0, localRight = 0, targetWidth = targetSize.width;
                isRoot ? (localLeft = visibleRect.left.x, localRight = visibleRect.right.x) : localRight = (localLeft = -targetAnchor.x * targetWidth) + targetWidth, 
                localLeft += widget.isAbsoluteLeft ? widget.left : widget.left * targetWidth, localRight -= widget.isAbsoluteRight ? widget.right : widget.right * targetWidth, 
                hasTarget && (localLeft += inverseTranslate.x, localLeft *= inverseScale.x, localRight += inverseTranslate.x, 
                localRight *= inverseScale.x);
                var width = 0, anchorX = anchor.x, scaleX = scale.x;
                if (scaleX < 0 && (anchorX = 1 - anchorX, scaleX = -scaleX), widget.isStretchWidth) width = localRight - localLeft, 
                0 !== scaleX && (node.width = width / scaleX), x = localLeft + anchorX * width; else if (width = node.width * scaleX, 
                widget.isAlignHorizontalCenter) {
                    var localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter * targetWidth, targetCenter = (.5 - targetAnchor.x) * targetSize.width;
                    hasTarget && (localHorizontalCenter *= inverseScale.x, targetCenter += inverseTranslate.x, 
                    targetCenter *= inverseScale.x), x = targetCenter + (anchorX - .5) * width + localHorizontalCenter;
                } else x = widget.isAlignLeft ? localLeft + anchorX * width : localRight + (anchorX - 1) * width;
                widget._lastSize.width = width;
            }
            if (widget.alignFlags & AlignFlags.VERTICAL) {
                var localTop = 0, localBottom = 0, targetHeight = targetSize.height;
                isRoot ? (localBottom = visibleRect.bottom.y, localTop = visibleRect.top.y) : localTop = (localBottom = -targetAnchor.y * targetHeight) + targetHeight, 
                localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom * targetHeight, 
                localTop -= widget.isAbsoluteTop ? widget.top : widget.top * targetHeight, hasTarget && (localBottom += inverseTranslate.y, 
                localBottom *= inverseScale.y, localTop += inverseTranslate.y, localTop *= inverseScale.y);
                var height = 0, anchorY = anchor.y, scaleY = scale.y;
                if (scaleY < 0 && (anchorY = 1 - anchorY, scaleY = -scaleY), widget.isStretchHeight) height = localTop - localBottom, 
                0 !== scaleY && (node.height = height / scaleY), y = localBottom + anchorY * height; else if (height = node.height * scaleY, 
                widget.isAlignVerticalCenter) {
                    var localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter * targetHeight, targetMiddle = (.5 - targetAnchor.y) * targetSize.height;
                    hasTarget && (localVerticalCenter *= inverseScale.y, targetMiddle += inverseTranslate.y, 
                    targetMiddle *= inverseScale.y), y = targetMiddle + (anchorY - .5) * height + localVerticalCenter;
                } else y = widget.isAlignBottom ? localBottom + anchorY * height : localTop + (anchorY - 1) * height;
                widget._lastSize.height = height;
            }
            node.setPosition(x, y, _tempPos$2.z), Vec3.set(widget._lastPos, x, y, _tempPos$2.z);
        }
    }
    function refreshScene() {
        var scene = director.getScene();
        if (scene) {
            if (widgetManager.isAligning = !0, widgetManager._nodesOrderDirty) activeWidgets.length = 0, 
            function visitNode$1(node) {
                var widget = node.getComponent(WidgetComponent);
                if (widget) if (align(node, widget), widget.alignMode !== AlignMode.ALWAYS) widget.enabled = !1; else {
                    if (!cc.isValid(node, !0)) return;
                    activeWidgets.push(widget);
                }
                var _iterator = node.children, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var child = _ref;
                    child.active && visitNode$1(child);
                }
            }(scene), widgetManager._nodesOrderDirty = !1; else {
                var widget = null, iterator = widgetManager._activeWidgetsIterator;
                for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) (widget = activeWidgets[iterator.i])._dirty && (align(widget.node, widget), 
                widget._dirty = !1);
            }
            widgetManager.isAligning = !1;
        }
    }
    var activeWidgets = [];
    var canvasList = [], widgetManager = cc._widgetManager = {
        isAligning: !1,
        _nodesOrderDirty: !1,
        _activeWidgetsIterator: new array.MutableForwardIterator(activeWidgets),
        animationState: null,
        init: function init(director) {
            director.on(Director.EVENT_AFTER_UPDATE, refreshScene), sys.isMobile ? window.addEventListener("resize", this.onResized.bind(this)) : View.instance.on("design-resolution-changed", this.onResized, this);
        },
        add: function add(widget) {
            this._nodesOrderDirty = !0;
            var canvasComp = director.root.ui.getScreen(widget.node._uiProps.uiTransformComp.visibility);
            canvasComp && -1 === canvasList.indexOf(canvasComp) && (canvasList.push(canvasComp), 
            canvasComp.node.on("design-resolution-changed", this.onResized, this));
        },
        remove: function remove(widget) {
            this._activeWidgetsIterator.remove(widget);
        },
        onResized: function onResized() {
            var scene = director.getScene();
            scene && this.refreshWidgetOnResized(scene);
        },
        refreshWidgetOnResized: function refreshWidgetOnResized(node) {
            if (Node$1.isNode(node)) {
                var widget = node.getComponent(WidgetComponent);
                if (widget && widget.alignFlags === AlignMode.ALWAYS) return;
            }
            var _iterator2 = node.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var child = _ref2;
                this.refreshWidgetOnResized(child);
            }
        },
        updateOffsetsToStayPut: function updateOffsetsToStayPut(widget, e) {
            function i(t, c) {
                return Math.abs(t - c) > 1e-10 ? c : t;
            }
            var widgetNode = widget.node, widgetParent = widgetNode.parent;
            if (widgetParent) {
                var zero = new Vec3, one = new Vec3(1, 1, 1);
                if (widget.target && computeInverseTransForTarget(widgetNode, widgetParent = widget.target, zero, one), 
                !e) return;
                if (!widgetParent.getComponent(UITransformComponent)) return void cc.warnID(6501, widget.node.name);
                var parentAP = widgetParent.getAnchorPoint(), matchSize = getReadonlyNodeSize(widgetParent), myAP = widgetNode.getAnchorPoint(), pos = widgetNode.getPosition(), alignFlags = AlignFlags, widgetNodeScale = widgetNode.getScale(), temp = 0;
                if (e & alignFlags.LEFT) {
                    var l = -parentAP.x * matchSize.width;
                    l += zero.x, l *= one.x, temp = pos.x - myAP.x * widgetNode.width * widgetNodeScale.x - l, 
                    widget.isAbsoluteLeft || (temp /= matchSize.width), temp /= one.x, widget.left = i(widget.left, temp);
                }
                if (e & alignFlags.RIGHT) {
                    var r = (1 - parentAP.x) * matchSize.width;
                    r += zero.x, temp = (r *= one.x) - (pos.x + (1 - myAP.x) * widgetNode.width * widgetNodeScale.x), 
                    widget.isAbsoluteRight || (temp /= matchSize.width), temp /= one.x, widget.right = i(widget.right, temp);
                }
                if (e & alignFlags.TOP) {
                    var t = (1 - parentAP.y) * matchSize.height;
                    t += zero.y, temp = (t *= one.y) - (pos.y + (1 - myAP.y) * widgetNode.height * widgetNodeScale.y), 
                    widget.isAbsoluteTop || (temp /= matchSize.height), temp /= one.y, widget.top = i(widget.top, temp);
                }
                if (e & alignFlags.BOT) {
                    var b = -parentAP.y * matchSize.height;
                    b += zero.y, b *= one.y, temp = pos.y - myAP.y * widgetNode.height * widgetNodeScale.y - b, 
                    widget.isAbsoluteBottom || (temp /= matchSize.height), temp /= one.y, widget.bottom = i(widget.bottom, temp);
                }
            }
        },
        updateAlignment: function updateAlignment(node) {
            var parent = node.parent;
            parent && Node$1.isNode(parent) && updateAlignment(parent);
            var widget = node.getComponent(WidgetComponent);
            widget && parent && align(node, widget);
        },
        AlignMode: AlignMode,
        AlignFlags: AlignFlags
    };
    director.on(Director.EVENT_INIT, (function() {
        widgetManager.init(director);
    }));
    var Aim = function Aim(i, x, y) {
        _classCallCheck(this, Aim), this.prev = null, this.next = null, this.z = 0, this.prevZ = null, 
        this.nextZ = null, this.steiner = !1, this.i = i, this.x = x, this.y = y;
    };
    function linkedList(datas, start, end, dim, clockwise) {
        var i = 0, last = null;
        if (clockwise === function signedArea(datas, start, end, dim) {
            for (var sum = 0, i = start, j = end - dim; i < end; i += dim) sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]), 
            j = i;
            return sum;
        }(datas, start, end, dim) > 0) for (i = start; i < end; i += dim) last = insertNode(i, datas[i], datas[i + 1], last); else for (i = end - dim; i >= start; i -= dim) last = insertNode(i, datas[i], datas[i + 1], last);
        return last && equals$1(last, last.next) && (removeNode(last), last = last.next), 
        last;
    }
    function filterPoints(start) {
        var end = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        if (!start) return start;
        end || (end = start);
        var p = start, again = !1;
        do {
            if (again = !1, p.steiner || !equals$1(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next; else {
                if (removeNode(p), (p = end = p.prev) === p.next) return null;
                again = !0;
            }
        } while (again || p !== end);
        return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, size) {
        var pass = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0;
        if (ear) {
            !pass && size && indexCurve(ear, minX, minY, size);
            for (var stop = ear, prev = null, next = null; ear.prev !== ear.next; ) if (prev = ear.prev, 
            next = ear.next, size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) triangles.push(prev.i / dim), 
            triangles.push(ear.i / dim), triangles.push(next.i / dim), removeNode(ear), ear = next.next, 
            stop = next.next; else if ((ear = next) === stop) {
                pass ? 1 === pass ? earcutLinked(ear = cureLocalIntersections(ear, triangles, dim), triangles, dim, minX, minY, size, 2) : 2 === pass && splitEarcut(ear, triangles, dim, minX, minY, size) : earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
                break;
            }
        }
    }
    function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0) return !1;
        for (var p = ear.next.next; p !== ear.prev; ) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
            p = p.next;
        }
        return !0;
    }
    function isEarHashed(ear, minX, minY, size) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0) return !1;
        for (var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y, minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size), p = ear.nextZ; p && p.z <= maxZ; ) {
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
            p = p.nextZ;
        }
        for (p = ear.prevZ; p && p.z >= minZ; ) {
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
            p = p.prevZ;
        }
        return !0;
    }
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev, b = p.next.next;
            !equals$1(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a) && (triangles.push(a.i / dim), 
            triangles.push(p.i / dim), triangles.push(b.i / dim), removeNode(p), removeNode(p.next), 
            p = start = b), p = p.next;
        } while (p !== start);
        return p;
    }
    function splitEarcut(start, triangles, dim, minX, minY, size) {
        var a = start;
        do {
            for (var b = a.next.next; b !== a.prev; ) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    var c = splitPolygon(a, b);
                    return a = filterPoints(a, a.next), c = filterPoints(c, c.next), earcutLinked(a, triangles, dim, minX, minY, size), 
                    void earcutLinked(c, triangles, dim, minX, minY, size);
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    function compareX(a, b) {
        return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
        if (outerNode = function findHoleBridge(hole, outerNode) {
            var p = outerNode, hx = hole.x, hy = hole.y, qx = -1 / 0, m = null;
            do {
                if (hy <= p.y && hy >= p.next.y) {
                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                    if (x <= hx && x > qx) {
                        if (qx = x, x === hx) {
                            if (hy === p.y) return p;
                            if (hy === p.next.y) return p.next;
                        }
                        m = p.x < p.next.x ? p : p.next;
                    }
                }
                p = p.next;
            } while (p !== outerNode);
            if (!m) return null;
            if (hx === qx) return m.prev;
            var tan, stop = m, mx = m.x, my = m.y, tanMin = 1 / 0;
            p = m.next;
            for (;p !== stop; ) hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y) && ((tan = Math.abs(hy - p.y) / (hx - p.x)) < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole) && (m = p, 
            tanMin = tan), p = p.next;
            return m;
        }(hole, outerNode)) {
            var b = splitPolygon(outerNode, hole);
            filterPoints(b, b.next);
        }
    }
    function indexCurve(start, minX, minY, size) {
        var p = start;
        do {
            null === p.z && (p.z = zOrder(p.x, p.y, minX, minY, size)), p.prevZ = p.prev, p.nextZ = p.next, 
            p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null, p.prevZ = null, function sortLinked(list) {
            var i = 0, p = null, q = null, e = null, tail = null, numMerges = 0, pSize = 0, qSize = 0, inSize = 1;
            do {
                for (p = list, list = null, tail = null, numMerges = 0; p; ) {
                    for (numMerges++, q = p, pSize = 0, i = 0; i < inSize && (pSize++, q = q.nextZ); i++) ;
                    for (qSize = inSize; pSize > 0 || qSize > 0 && q; ) 0 === pSize ? (e = q, q = q.nextZ, 
                    qSize--) : 0 !== qSize && q ? p.z <= q.z ? (e = p, p = p.nextZ, pSize--) : (e = q, 
                    q = q.nextZ, qSize--) : (e = p, p = p.nextZ, pSize--), tail ? tail.nextZ = e : list = e, 
                    e.prevZ = tail, tail = e;
                    p = q;
                }
                tail.nextZ = null, inSize *= 2;
            } while (numMerges > 1);
            return list;
        }(p);
    }
    function zOrder(x, y, minX, minY, size) {
        return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x = 32767 * (x - minX) / size) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y = 32767 * (y - minY) / size) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1;
    }
    function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
            p.x < leftmost.x && (leftmost = p), p = p.next;
        } while (p !== start);
        return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !function intersectsPolygon(a, b) {
            var p = a;
            do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return !0;
                p = p.next;
            } while (p !== a);
            return !1;
        }(a, b) && locallyInside(a, b) && locallyInside(b, a) && function middleInside(a, b) {
            var p = a, inside = !1, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
            do {
                p.y > py != p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside), 
                p = p.next;
            } while (p !== a);
            return inside;
        }(a, b);
    }
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals$1(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
        return !!(equals$1(p1, q1) && equals$1(p2, q2) || equals$1(p1, q2) && equals$1(p2, q1)) || area(p1, q1, p2) > 0 != area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 != area(p2, q2, q1) > 0;
    }
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function splitPolygon(a, b) {
        var a2 = new Aim(a.i, a.x, a.y), b2 = new Aim(b.i, b.x, b.y), an = a.next, bp = b.prev;
        return a.next = b, b.prev = a, a2.next = an, an.prev = a2, b2.next = a2, a2.prev = b2, 
        bp.next = b2, b2.prev = bp, b2;
    }
    function insertNode(i, x, y, last) {
        var p = new Aim(i, x, y);
        return last ? (p.next = last.next, p.prev = last, last.next.prev = p, last.next = p) : (p.prev = p, 
        p.next = p), p;
    }
    function removeNode(p) {
        p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), 
        p.nextZ && (p.nextZ.prevZ = p.prevZ);
    }
    function earcut(datas, holeIndices, dim) {
        dim = dim || 3;
        var hasHoles = holeIndices ? holeIndices.length : 0, outerLen = hasHoles ? holeIndices[0] * dim : datas.length, outerNode = linkedList(datas, 0, outerLen, dim, !0), triangles = [];
        if (!outerNode) return triangles;
        var minX = 0, minY = 0, maxX = 0, maxY = 0, x = 0, y = 0, size = 0;
        if (hasHoles && (outerNode = function eliminateHoles(datas, holeIndices, outerNode, dim) {
            var len, queue = [], i = 0, list = null;
            for (i = 0, len = holeIndices.length; i < len; i++) (list = linkedList(datas, holeIndices[i] * dim, i < len - 1 ? holeIndices[i + 1] * dim : datas.length, dim, !1)) && (list === list.next && (list.steiner = !0), 
            queue.push(getLeftmost(list)));
            if (queue.sort(compareX), !outerNode) return outerNode;
            for (i = 0; i < queue.length; i++) eliminateHole(queue[i], outerNode), outerNode = filterPoints(outerNode, outerNode.next);
            return outerNode;
        }(datas, holeIndices, outerNode, dim)), datas.length > 80 * dim) {
            minX = maxX = datas[0], minY = maxY = datas[1];
            for (var i = dim; i < outerLen; i += dim) (x = datas[i]) < minX && (minX = x), (y = datas[i + 1]) < minY && (minY = y), 
            x > maxX && (maxX = x), y > maxY && (maxY = y);
            size = Math.max(maxX - minX, maxY - minY);
        }
        return earcutLinked(outerNode, triangles, dim, minX, minY, size), triangles;
    }
    var PI = Math.PI, min$2 = Math.min, max$3 = Math.max, cos$1 = Math.cos, sin = Math.sin, abs$1 = Math.abs, sign$1 = Math.sign, KAPPA90 = .5522847493;
    function ellipse(ctx, cx, cy, rx, ry) {
        ctx.moveTo(cx - rx, cy), ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry), 
        ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy), 
        ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry), 
        ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy), 
        ctx.close();
    }
    for (var Point = function(_Vec) {
        function Point(x, y) {
            var _this;
            return _classCallCheck(this, Point), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Point).call(this, x, y))).dx = 0, 
            _this.dy = 0, _this.dmx = 0, _this.dmy = 0, _this.flags = 0, _this.len = 0, _this.reset(), 
            _this;
        }
        return _inherits(Point, _Vec), _createClass(Point, [ {
            key: "reset",
            value: function reset() {
                this.dx = 0, this.dy = 0, this.dmx = 0, this.dmy = 0, this.flags = 0, this.len = 0;
            }
        } ]), Point;
    }(Vec2), Path = function() {
        function Path() {
            _classCallCheck(this, Path), this.closed = !1, this.nbevel = 0, this.complex = !0, 
            this.points = [], this.reset();
        }
        return _createClass(Path, [ {
            key: "reset",
            value: function reset() {
                this.closed = !1, this.nbevel = 0, this.complex = !0, this.points ? this.points.length = 0 : this.points = [];
            }
        } ]), Path;
    }(), Impl = function() {
        function Impl() {
            _classCallCheck(this, Impl), this.dataOffset = 0, this.updatePathOffset = !1, this.pathLength = 0, 
            this.pathOffset = 0, this.paths = [], this.tessTol = .25, this.distTol = .01, this.fillColor = Color.WHITE.clone(), 
            this.lineCap = LineCap.BUTT, this.strokeColor = Color.BLACK.clone(), this.lineJoin = LineJoin.MITER, 
            this.lineWidth = 0, this.pointsOffset = 0, this._commandx = 0, this._commandy = 0, 
            this._points = [], this._renderDatasPool = new RecyclePool((function() {
                return new MeshRenderData;
            }), 16), this._renderDatas = [], this._curPath = null;
        }
        return _createClass(Impl, [ {
            key: "moveTo",
            value: function moveTo(x, y) {
                this.updatePathOffset && (this.pathOffset = this.pathLength, this.updatePathOffset = !1), 
                this._addPath(), this.addPoint(x, y, PointFlags.PT_CORNER), this._commandx = x, 
                this._commandy = y;
            }
        }, {
            key: "lineTo",
            value: function lineTo(x, y) {
                this.addPoint(x, y, PointFlags.PT_CORNER), this._commandx = x, this._commandy = y;
            }
        }, {
            key: "bezierCurveTo",
            value: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                var path = this._curPath, last = path.points[path.points.length - 1];
                last && (last.x !== c1x || last.y !== c1y || c2x !== x || c2y !== y ? (!function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
                    var x12, y12, x23, y23, x34, y34, x123, y123, x234, y234, x1234, y1234, dx, dy, d2, d3;
                    level > 10 || (x34 = .5 * (x3 + x4), y34 = .5 * (y3 + y4), x123 = .5 * ((x12 = .5 * (x1 + x2)) + (x23 = .5 * (x2 + x3))), 
                    y123 = .5 * ((y12 = .5 * (y1 + y2)) + (y23 = .5 * (y2 + y3))), ((d2 = abs$1((x2 - x4) * (dy = y4 - y1) - (y2 - y4) * (dx = x4 - x1))) + (d3 = abs$1((x3 - x4) * dy - (y3 - y4) * dx))) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy) ? ctx.addPoint(x4, y4, 0 === type ? type | PointFlags.PT_BEVEL : type) : (tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234 = .5 * (x123 + (x234 = .5 * (x23 + x34))), y1234 = .5 * (y123 + (y234 = .5 * (y23 + y34))), level + 1, 0), 
                    tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type)));
                }(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER), this._commandx = x, 
                this._commandy = y) : this.lineTo(x, y));
            }
        }, {
            key: "quadraticCurveTo",
            value: function quadraticCurveTo(cx, cy, x, y) {
                var x0 = this._commandx, y0 = this._commandy;
                this.bezierCurveTo(x0 + 2 / 3 * (cx - x0), y0 + 2 / 3 * (cy - y0), x + 2 / 3 * (cx - x), y + 2 / 3 * (cy - y), x, y);
            }
        }, {
            key: "arc",
            value: function arc$1(cx, cy, r, startAngle, endAngle, counterclockwise) {
                !function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
                    var hda, ndivs, a = 0, da = 0, kappa = 0, dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0, px = 0, py = 0, ptanx = 0, ptany = 0, i = 0;
                    if (da = endAngle - startAngle, counterclockwise = counterclockwise || !1) if (abs$1(da) >= 2 * PI) da = 2 * PI; else for (;da < 0; ) da += 2 * PI; else if (abs$1(da) >= 2 * PI) da = 2 * -PI; else for (;da > 0; ) da -= 2 * PI;
                    for (ndivs = 0 | max$3(1, min$2(abs$1(da) / (.5 * PI) + .5, 5)), kappa = abs$1(4 / 3 * (1 - cos$1(hda = da / ndivs / 2)) / sin(hda)), 
                    counterclockwise || (kappa = -kappa), i = 0; i <= ndivs; i++) x = cx + (dx = cos$1(a = startAngle + da * (i / ndivs))) * r, 
                    y = cy + (dy = sin(a)) * r, tanx = -dy * r * kappa, tany = dx * r * kappa, 0 === i ? ctx.moveTo(x, y) : ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y), 
                    px = x, py = y, ptanx = tanx, ptany = tany;
                }(this, cx, cy, r, startAngle, endAngle, counterclockwise);
            }
        }, {
            key: "ellipse",
            value: function ellipse$1(cx, cy, rx, ry) {
                ellipse(this, cx, cy, rx, ry), this._curPath.complex = !1;
            }
        }, {
            key: "circle",
            value: function circle(cx, cy, r) {
                ellipse(this, cx, cy, r, r), this._curPath.complex = !1;
            }
        }, {
            key: "rect",
            value: function rect(x, y, w, h) {
                this.moveTo(x, y), this.lineTo(x + w, y), this.lineTo(x + w, y + h), this.lineTo(x, y + h), 
                this.close(), this._curPath.complex = !1;
            }
        }, {
            key: "roundRect",
            value: function roundRect$1(x, y, w, h, r) {
                !function roundRect(ctx, x, y, w, h, r) {
                    if (r < .1) ctx.rect(x, y, w, h); else {
                        var rx = min$2(r, .5 * abs$1(w)) * sign$1(w), ry = min$2(r, .5 * abs$1(h)) * sign$1(h);
                        ctx.moveTo(x, y + ry), ctx.lineTo(x, y + h - ry), ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h), 
                        ctx.lineTo(x + w - rx, y + h), ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry), 
                        ctx.lineTo(x + w, y + ry), ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y), 
                        ctx.lineTo(x + rx, y), ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry), 
                        ctx.close();
                    }
                }(this, x, y, w, h, r), this._curPath.complex = !1;
            }
        }, {
            key: "clear",
            value: function clear() {
                var clean = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                this.pathLength = 0, this.pathOffset = 0, this.pointsOffset = 0, this.dataOffset = 0, 
                this._curPath = null, this.paths.length = 0, this._points.length = 0;
                for (var datas = this._renderDatas, i = 0, l = datas.length; i < l; i++) {
                    var data = datas[i];
                    data && data.reset();
                }
                this._renderDatas.length = 0, clean && this._renderDatasPool.reset();
            }
        }, {
            key: "close",
            value: function close() {
                this._curPath.closed = !0;
            }
        }, {
            key: "requestRenderData",
            value: function requestRenderData() {
                var renderData = this._renderDatasPool.add();
                return this._renderDatas.push(renderData), renderData;
            }
        }, {
            key: "getRenderDatas",
            value: function getRenderDatas() {
                return 0 === this._renderDatas.length && this.requestRenderData(), this._renderDatas;
            }
        }, {
            key: "addPoint",
            value: function addPoint(x, y, flags) {
                var path = this._curPath;
                if (path) {
                    var points = this._points, pathPoints = path.points, pt = points[this.pointsOffset++];
                    pt ? (pt.x = x, pt.y = y) : (pt = new Point(x, y), points.push(pt)), pt.flags = flags, 
                    pathPoints.push(pt);
                }
            }
        }, {
            key: "_addPath",
            value: function _addPath() {
                var offset = this.pathLength, path = this.paths[offset];
                return path ? path.reset() : (path = new Path, this.paths.push(path)), this.pathLength++, 
                this._curPath = path, path;
            }
        } ]), Impl;
    }(), PI$1 = Math.PI, min$3 = Math.min, max$4 = Math.max, ceil = Math.ceil, acos$1 = Math.acos, cos$2 = Math.cos, sin$1 = Math.sin, atan2 = Math.atan2, attrs = vfmt, positions = [], uvs = [], colors$2 = [], indices = [], _renderData = null, _impl = null, _curColor = new Color, vec3_temps = [], i$1 = 0; i$1 < 4; i$1++) vec3_temps.push(new Vec3);
    function clamp$1(v, minNum, maxNum) {
        return v < minNum ? minNum : v > maxNum ? maxNum : v;
    }
    var graphicsAssembler = {
        useModel: !0,
        createImpl: function createImpl(graphics) {
            return new Impl;
        },
        updateRenderData: function updateRenderData(graphics) {
            for (var datas = graphics.impl ? graphics.impl.getRenderDatas() : [], _i = 0, l = datas.length; _i < l; _i++) datas[_i].material = graphics.material;
        },
        fillBuffers: function fillBuffers(graphics, renderer) {},
        renderIA: function renderIA(graphics, renderer) {},
        getRenderData: function getRenderData(graphics, cverts) {
            if (!_impl) return null;
            var renderDatas = _impl.getRenderDatas(), renderData = renderDatas[_impl.dataOffset];
            if (!renderData) return null;
            var meshbuffer = renderData, maxVertsCount = meshbuffer ? meshbuffer.vertexCount + cverts : 0;
            return (maxVertsCount > 65535 || 3 * maxVertsCount > 131070) && (++_impl.dataOffset, 
            _impl.dataOffset < renderDatas.length ? renderData = renderDatas[_impl.dataOffset] : (renderData = _impl.requestRenderData(), 
            renderDatas[_impl.dataOffset] = renderData), renderData.material = graphics.material, 
            meshbuffer = renderData), meshbuffer && meshbuffer.vertexCount < maxVertsCount && meshbuffer.request(cverts, 3 * cverts), 
            renderData;
        },
        stroke: function stroke(graphics) {
            Color.copy(_curColor, graphics.strokeColor), graphics.impl && (this._flattenPaths(graphics.impl), 
            this._expandStroke(graphics), graphics.impl.updatePathOffset = !0, this.end(graphics));
        },
        fill: function fill(graphics) {
            Color.copy(_curColor, graphics.fillColor), this._expandFill(graphics), graphics.impl && (graphics.impl.updatePathOffset = !0), 
            this.end(graphics);
        },
        end: function end(graphics) {
            graphics.model && graphics.model.destroy();
            var impl = graphics.impl, primitiveMode = exports.GFXPrimitiveMode.TRIANGLE_LIST, renderDatas = impl && impl.getRenderDatas();
            if (renderDatas) {
                var i = 0;
                positions.length = 0, uvs.length = 0, colors$2.length = 0, indices.length = 0;
                var _iterator = renderDatas, _isArray = Array.isArray(_iterator), _i2 = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i2 >= _iterator.length) break;
                        _ref = _iterator[_i2++];
                    } else {
                        if ((_i2 = _iterator.next()).done) break;
                        _ref = _i2.value;
                    }
                    var renderData = _ref, len = renderData.byteCount >> 2, vData = renderData.vData;
                    for (i = 0; i < len; ) positions.push(vData[i++]), positions.push(vData[i++]), positions.push(vData[i++]), 
                    uvs.push(vData[i++]), uvs.push(vData[i++]), colors$2.push(vData[i++]), colors$2.push(vData[i++]), 
                    colors$2.push(vData[i++]), colors$2.push(vData[i++]);
                    len = renderData.indiceCount;
                    var iData = renderData.iData;
                    for (i = 0; i < len; ) indices.push(iData[i++]);
                }
                var mesh = createMesh({
                    primitiveMode: primitiveMode,
                    positions: positions,
                    uvs: uvs,
                    colors: colors$2,
                    attributes: attrs,
                    indices: indices
                }, void 0, {
                    calculateBounds: !1
                });
                graphics.model.initialize(graphics.node), graphics.model.initSubModel(0, mesh.getSubMesh(0), graphics.material), 
                graphics.markForUpdateRenderData();
            }
        },
        _expandStroke: function _expandStroke(graphics) {
            var w = .5 * graphics.lineWidth, lineCap = graphics.lineCap, lineJoin = graphics.lineJoin, miterLimit = graphics.miterLimit;
            if (_impl = graphics.impl) {
                var ncap = function curveDivs(r, arc, tol) {
                    var da = 2 * acos$1(r / (r + tol));
                    return max$4(2, ceil(arc / da));
                }(w, PI$1, _impl.tessTol);
                this._calculateJoins(_impl, w, lineJoin, miterLimit);
                for (var paths = _impl.paths, cverts = 0, _i3 = _impl.pathOffset, l = _impl.pathLength; _i3 < l; _i3++) {
                    var path = paths[_i3], pointsLength = path.points.length;
                    lineJoin === LineJoin.ROUND ? cverts += 2 * (pointsLength + path.nbevel * (ncap + 2) + 1) : cverts += 2 * (pointsLength + 5 * path.nbevel + 1), 
                    path.closed || (lineCap === LineCap.ROUND ? cverts += 2 * (2 * ncap + 2) : cverts += 12);
                }
                var meshbuffer = _renderData = this.getRenderData(graphics, cverts);
                if (meshbuffer) {
                    for (var vData = meshbuffer.vData, iData = meshbuffer.iData, _i4 = _impl.pathOffset, _l = _impl.pathLength; _i4 < _l; _i4++) {
                        var _path = paths[_i4], pts = _path.points, _pointsLength = pts.length, offset = meshbuffer.vertexStart, p0 = void 0, p1 = void 0, start = 0, end = 0, loop = _path.closed;
                        if (loop ? (p0 = pts[_pointsLength - 1], p1 = pts[0], start = 0, end = _pointsLength) : (p0 = pts[0], 
                        p1 = pts[1], start = 1, end = _pointsLength - 1), !loop) {
                            var dPos = new Point(p1.x, p1.y);
                            dPos.subtract(p0), dPos.normalize();
                            var dx = dPos.x, dy = dPos.y;
                            lineCap === LineCap.BUTT ? this._buttCap(p0, dx, dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p0, dx, dy, w, w) : lineCap === LineCap.ROUND && this._roundCapStart(p0, dx, dy, w, ncap);
                        }
                        for (var j = start; j < end; ++j) lineJoin === LineJoin.ROUND ? this._roundJoin(p0, p1, w, w, ncap) : 0 != (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) ? this._bevelJoin(p0, p1, w, w) : (this._vset(p1.x + p1.dmx * w, p1.y + p1.dmy * w), 
                        this._vset(p1.x - p1.dmx * w, p1.y - p1.dmy * w)), p0 = p1, p1 = pts[j + 1];
                        if (loop) {
                            var vDataoOfset = 9 * offset, data = vData.slice(vDataoOfset, vDataoOfset + 9);
                            vData.set(data, 9 * meshbuffer.vertexStart), vDataoOfset += 9, meshbuffer.vertexStart++, 
                            data = vData.slice(vDataoOfset, vDataoOfset + 9), vData.set(data, 9 * meshbuffer.vertexStart), 
                            meshbuffer.vertexStart++;
                        } else {
                            var _dPos = new Point(p1.x, p1.y);
                            _dPos.subtract(p0), _dPos.normalize();
                            var _dx = _dPos.x, _dy = _dPos.y;
                            lineCap === LineCap.BUTT ? this._buttCap(p1, _dx, _dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p1, _dx, _dy, w, w) : lineCap === LineCap.ROUND && this._roundCapEnd(p1, _dx, _dy, w, ncap);
                        }
                        for (var indicesOffset = meshbuffer.indiceStart, begin = offset + 2, over = meshbuffer.vertexStart; begin < over; begin++) iData[indicesOffset++] = begin - 2, 
                        iData[indicesOffset++] = begin - 1, iData[indicesOffset++] = begin;
                        if (meshbuffer.indiceStart = indicesOffset, indicesOffset !== meshbuffer.indiceCount) {
                            var arr = new Array(meshbuffer.indiceCount - indicesOffset);
                            meshbuffer.iData.set(arr, indicesOffset);
                        }
                    }
                    _renderData = null, _impl = null;
                }
            }
        },
        _expandFill: function _expandFill(graphics) {
            if (_impl = graphics.impl) {
                for (var paths = _impl.paths, cverts = 0, _i5 = _impl.pathOffset, l = _impl.pathLength; _i5 < l; _i5++) {
                    cverts += paths[_i5].points.length;
                }
                var renderData = _renderData = this.getRenderData(graphics, cverts);
                if (renderData) {
                    for (var meshbuffer = renderData, vData = meshbuffer.vData, iData = meshbuffer.iData, _i6 = _impl.pathOffset, _l2 = _impl.pathLength; _i6 < _l2; _i6++) {
                        var _path2 = paths[_i6], pts = _path2.points, _pointsLength2 = pts.length;
                        if (0 !== _pointsLength2) {
                            for (var vertexOffset = renderData.vertexStart, j = 0; j < _pointsLength2; ++j) this._vset(pts[j].x, pts[j].y);
                            var indicesOffset = renderData.indiceStart;
                            if (_path2.complex) {
                                for (var earcutData = [], _j = vertexOffset, end = renderData.vertexStart; _j < end; _j++) {
                                    var vDataOffset = 9 * _j;
                                    earcutData.push(vData[vDataOffset++]), earcutData.push(vData[vDataOffset++]), earcutData.push(vData[vDataOffset++]);
                                }
                                var newIndices = earcut(earcutData, null, 3);
                                if (!newIndices || 0 === newIndices.length) continue;
                                for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) iData[indicesOffset++] = newIndices[_j2] + vertexOffset;
                            } else for (var first = vertexOffset, start = vertexOffset + 2, _end = meshbuffer.vertexStart; start < _end; start++) iData[indicesOffset++] = first, 
                            iData[indicesOffset++] = start - 1, iData[indicesOffset++] = start;
                            if (meshbuffer.indiceStart = indicesOffset, indicesOffset !== meshbuffer.indiceCount) {
                                var arr = new Array(meshbuffer.indiceCount - indicesOffset);
                                meshbuffer.iData.set(arr, indicesOffset);
                            }
                        }
                    }
                    _renderData = null, _impl = null;
                }
            }
        },
        _calculateJoins: function _calculateJoins(impl, w, lineJoin, miterLimit) {
            var iw = 0;
            w > 0 && (iw = 1 / w);
            for (var paths = impl.paths, _i7 = impl.pathOffset, l = impl.pathLength; _i7 < l; _i7++) {
                var path = paths[_i7], pts = path.points, ptsLength = pts.length, p0 = pts[ptsLength - 1], p1 = pts[0];
                path.nbevel = 0;
                for (var j = 0; j < ptsLength; j++) {
                    var dmr2, limit, dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx;
                    if (p1.dmx = .5 * (dlx0 + dlx1), p1.dmy = .5 * (dly0 + dly1), (dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy) > 1e-6) {
                        var scale = 1 / dmr2;
                        scale > 600 && (scale = 600), p1.dmx *= scale, p1.dmy *= scale;
                    }
                    p1.dx * p0.dy - p0.dx * p1.dy > 0 && (p1.flags |= PointFlags.PT_LEFT), dmr2 * (limit = max$4(11, min$3(p0.len, p1.len) * iw)) * limit < 1 && (p1.flags |= PointFlags.PT_INNERBEVEL), 
                    p1.flags & PointFlags.PT_CORNER && (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) && (p1.flags |= PointFlags.PT_BEVEL), 
                    0 != (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) && path.nbevel++, 
                    p0 = p1, p1 = pts[j + 1];
                }
            }
        },
        _flattenPaths: function _flattenPaths(impl) {
            for (var paths = impl.paths, _i8 = impl.pathOffset, l = impl.pathLength; _i8 < l; _i8++) {
                var path = paths[_i8], pts = path.points, p0 = pts[pts.length - 1], p1 = pts[0];
                p0.equals(p1) && (path.closed = !0, pts.pop(), p0 = pts[pts.length - 1]);
                for (var j = 0, size = pts.length; j < size; j++) {
                    var dPos = new Point(p1.x, p1.y);
                    dPos.subtract(p0), p0.len = dPos.length(), (dPos.x || dPos.y) && dPos.normalize(), 
                    p0.dx = dPos.x, p0.dy = dPos.y, p0 = p1, p1 = pts[j + 1];
                }
            }
        },
        _chooseBevel: function _chooseBevel(bevel, p0, p1, w) {
            var x = p1.x, y = p1.y, x0 = 0, y0 = 0, x1 = 0, y1 = 0;
            return 0 !== bevel ? (x0 = x + p0.dy * w, y0 = y - p0.dx * w, x1 = x + p1.dy * w, 
            y1 = y - p1.dx * w) : (x0 = x1 = x + p1.dmx * w, y0 = y1 = y + p1.dmy * w), [ x0, y0, x1, y1 ];
        },
        _buttCap: function _buttCap(p, dx, dy, w, d) {
            var px = p.x - dx * d, py = p.y - dy * d, dlx = dy, dly = -dx;
            this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
        },
        _roundCapStart: function _roundCapStart(p, dx, dy, w, ncap) {
            for (var px = p.x, py = p.y, dlx = dy, dly = -dx, _i9 = 0; _i9 < ncap; _i9++) {
                var a = _i9 / (ncap - 1) * PI$1, ax = cos$2(a) * w, ay = sin$1(a) * w;
                this._vset(px - dlx * ax - dx * ay, py - dly * ax - dy * ay), this._vset(px, py);
            }
            this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
        },
        _roundCapEnd: function _roundCapEnd(p, dx, dy, w, ncap) {
            var px = p.x, py = p.y, dlx = dy, dly = -dx;
            this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
            for (var _i10 = 0; _i10 < ncap; _i10++) {
                var a = _i10 / (ncap - 1) * PI$1, ax = cos$2(a) * w, ay = sin$1(a) * w;
                this._vset(px, py), this._vset(px - dlx * ax + dx * ay, py - dly * ax + dy * ay);
            }
        },
        _roundJoin: function _roundJoin(p0, p1, lw, rw, ncap) {
            var dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx, p1x = p1.x, p1y = p1.y;
            if (0 != (p1.flags & PointFlags.PT_LEFT)) {
                var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw), lx0 = out[0], ly0 = out[1], lx1 = out[2], ly1 = out[3], a0 = atan2(-dly0, -dlx0), a1 = atan2(-dly1, -dlx1);
                a1 > a0 && (a1 -= 2 * PI$1), this._vset(lx0, ly0), this._vset(p1x - dlx0 * rw, p1.y - dly0 * rw);
                for (var n = clamp$1(ceil((a0 - a1) / PI$1) * ncap, 2, ncap), _i11 = 0; _i11 < n; _i11++) {
                    var a = a0 + _i11 / (n - 1) * (a1 - a0), rx = p1x + cos$2(a) * rw, ry = p1y + sin$1(a) * rw;
                    this._vset(p1x, p1y), this._vset(rx, ry);
                }
                this._vset(lx1, ly1), this._vset(p1x - dlx1 * rw, p1y - dly1 * rw);
            } else {
                var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw), rx0 = _out[0], ry0 = _out[1], rx1 = _out[2], ry1 = _out[3], _a = atan2(dly0, dlx0), _a2 = atan2(dly1, dlx1);
                _a2 < _a && (_a2 += 2 * PI$1), this._vset(p1x + dlx0 * rw, p1y + dly0 * rw, 0), 
                this._vset(rx0, ry0, 0);
                for (var _n = clamp$1(ceil((_a2 - _a) / PI$1) * ncap, 2, ncap), _i12 = 0; _i12 < _n; _i12++) {
                    var _a3 = _a + _i12 / (_n - 1) * (_a2 - _a), lx = p1x + cos$2(_a3) * lw, ly = p1y + sin$1(_a3) * lw;
                    this._vset(lx, ly, 0), this._vset(p1x, p1y, 0);
                }
                this._vset(p1x + dlx1 * rw, p1y + dly1 * rw), this._vset(rx1, ry1);
            }
        },
        _bevelJoin: function _bevelJoin(p0, p1, lw, rw) {
            var rx0 = 0, ry0 = 0, rx1 = 0, ry1 = 0, lx0 = 0, ly0 = 0, lx1 = 0, ly1 = 0, dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx;
            if (p1.flags & PointFlags.PT_LEFT) {
                var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
                lx0 = out[0], ly0 = out[1], lx1 = out[2], ly1 = out[3], this._vset(lx0, ly0, 0), 
                this._vset(p1.x - dlx0 * rw, p1.y - dly0 * rw, 0), this._vset(lx1, ly1, 0), this._vset(p1.x - dlx1 * rw, p1.y - dly1 * rw, 0);
            } else {
                var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
                rx0 = _out2[0], ry0 = _out2[1], rx1 = _out2[2], ry1 = _out2[3], this._vset(p1.x + dlx0 * lw, p1.y + dly0 * lw, 0), 
                this._vset(rx0, ry0), this._vset(p1.x + dlx1 * lw, p1.y + dly1 * lw, 0), this._vset(rx1, ry1);
            }
        },
        _vset: function _vset(x, y) {
            if (_renderData) {
                var meshbuffer = _renderData, dataOffset = 9 * meshbuffer.vertexStart, vData = meshbuffer.vData;
                vData[dataOffset++] = x, vData[dataOffset++] = y, vData[dataOffset++] = 0, vData[dataOffset++] = 1, 
                vData[dataOffset++] = 1, Color.toArray(vData, _curColor, dataOffset), meshbuffer.vertexStart++;
            }
        }
    }, graphicsAssemblerManager = {
        getAssembler: function getAssembler(sprite) {
            return graphicsAssembler;
        }
    };
    GraphicsComponent.Assembler = graphicsAssemblerManager;
    var FontLetterDefinition = function FontLetterDefinition() {
        _classCallCheck(this, FontLetterDefinition), this.u = 0, this.v = 0, this.width = 0, 
        this.height = 0, this.offsetX = 0, this.offsetY = 0, this.textureID = 0, this.validDefinition = !1, 
        this.xAdvance = 0;
    }, FontAtlas = function() {
        function FontAtlas() {
            _classCallCheck(this, FontAtlas), this._letterDefinitions = {};
        }
        return _createClass(FontAtlas, [ {
            key: "addLetterDefinitions",
            value: function addLetterDefinitions(letter, letterDefinition) {
                this._letterDefinitions[letter] = letterDefinition;
            }
        }, {
            key: "cloneLetterDefinition",
            value: function cloneLetterDefinition() {
                for (var copyLetterDefinitions = {}, _i = 0, _Object$keys = Object.keys(this._letterDefinitions); _i < _Object$keys.length; _i++) {
                    var _key = _Object$keys[_i], value = new FontLetterDefinition;
                    mixin(value, this._letterDefinitions[_key]), copyLetterDefinitions[_key] = value;
                }
                return copyLetterDefinitions;
            }
        }, {
            key: "assignLetterDefinitions",
            value: function assignLetterDefinitions(letterDefinition) {
                for (var _i2 = 0, _Object$keys2 = Object.keys(this._letterDefinitions); _i2 < _Object$keys2.length; _i2++) {
                    var _key2 = _Object$keys2[_i2], newValue = letterDefinition[_key2];
                    mixin(this._letterDefinitions[_key2], newValue);
                }
            }
        }, {
            key: "scaleFontLetterDefinition",
            value: function scaleFontLetterDefinition(scaleFactor) {
                for (var _i3 = 0, _Object$keys3 = Object.keys(this._letterDefinitions); _i3 < _Object$keys3.length; _i3++) {
                    var fontDefinition = _Object$keys3[_i3], letterDefinitions = this._letterDefinitions[fontDefinition];
                    letterDefinitions.width *= scaleFactor, letterDefinitions.height *= scaleFactor, 
                    letterDefinitions.offsetX *= scaleFactor, letterDefinitions.offsetY *= scaleFactor, 
                    letterDefinitions.xAdvance *= scaleFactor;
                }
            }
        }, {
            key: "getLetterDefinitionForChar",
            value: function getLetterDefinitionForChar(_char) {
                return this._letterDefinitions[_char.charCodeAt(0)];
            }
        }, {
            key: "letterDefinitions",
            get: function get() {
                return this._letterDefinitions;
            }
        } ]), FontAtlas;
    }();
    cc.FontAtlas = FontAtlas;
    var LetterInfo = function LetterInfo() {
        _classCallCheck(this, LetterInfo), this.char = "", this.valid = !0, this.positionX = 0, 
        this.positionY = 0, this.lineIndex = 0;
    }, _tmpRect = new Rect, _comp = null, _horizontalKerning = [], _lettersInfo = [], _linesWidth = [], _linesOffsetX = [], _labelDimensions = new Size, _fontAtlas = null, _fntConfig = null, _numberOfLines = 0, _textDesiredHeight = 0, _letterOffsetY = 0, _tailoredTopY = 0, _tailoredBottomY = 0, _bmfontScale = 1, _spriteFrame = null, _string = "", _fontSize = 0, _originFontSize = 0, _contentSize = new Size, _hAlign = 0, _vAlign = 0, _spacingX = 0, _lineHeight = 0, _overflow = 0, _isWrapText = !1, _labelWidth = 0, _labelHeight = 0, _maxLineWidth = 0, bmfont = {
        createData: function createData(comp) {
            return comp.requestRenderData();
        },
        fillBuffers: function fillBuffers(comp, renderer) {
            fillMeshVertices3D(comp.node, renderer, comp.renderData, comp.color);
        },
        appendQuad: function appendQuad(comp, spriteframe, rect, rotated, x, y, scale) {
            var renderData = comp.renderData;
            if (renderData) {
                var dataOffset = renderData.dataLength;
                renderData.dataLength += 4, renderData.vertexCount = renderData.dataLength, renderData.indiceCount = renderData.dataLength / 2 * 3;
                var datas = renderData.datas, texw = spriteframe.width, texh = spriteframe.height, rectWidth = rect.width, rectHeight = rect.height, l = 0, b = 0, t = 0, r = 0;
                rotated ? (l = rect.x / texw, r = (rect.x + rectHeight) / texw, b = (rect.y + rectWidth) / texh, 
                t = rect.y / texh, datas[dataOffset].u = l, datas[dataOffset].v = t, datas[dataOffset + 1].u = l, 
                datas[dataOffset + 1].v = b, datas[dataOffset + 2].u = r, datas[dataOffset + 2].v = t, 
                datas[dataOffset + 3].u = r, datas[dataOffset + 3].v = b) : (l = rect.x / texw, 
                r = (rect.x + rectWidth) / texw, b = (rect.y + rectHeight) / texh, t = rect.y / texh, 
                datas[dataOffset].u = l, datas[dataOffset].v = b, datas[dataOffset + 1].u = r, datas[dataOffset + 1].v = b, 
                datas[dataOffset + 2].u = l, datas[dataOffset + 2].v = t, datas[dataOffset + 3].u = r, 
                datas[dataOffset + 3].v = t), datas[dataOffset].x = x, datas[dataOffset].y = y - rectHeight * scale, 
                datas[dataOffset + 1].x = x + rectWidth * scale, datas[dataOffset + 1].y = y - rectHeight * scale, 
                datas[dataOffset + 2].x = x, datas[dataOffset + 2].y = y, datas[dataOffset + 3].x = x + rectWidth * scale, 
                datas[dataOffset + 3].y = y;
            }
        }
    };
    addon(bmfont, {
        updateRenderData: function updateRenderData(comp) {
            comp.renderData && comp.renderData.vertDirty && _comp !== comp && (_comp = comp, 
            this._updateProperties(), this._updateContent(), _comp.actualFontSize = _fontSize, 
            _comp.node.setContentSize(_contentSize), _comp.renderData.vertDirty = _comp.renderData.uvDirty = !1, 
            _comp = null, this._resetProperties());
        },
        _updateFontScale: function _updateFontScale() {
            _bmfontScale = _fontSize / _originFontSize;
        },
        _updateProperties: function _updateProperties() {
            if (_comp) {
                var fontAsset = _comp.font;
                if (fontAsset) {
                    if (_spriteFrame = fontAsset.spriteFrame, _fntConfig = fontAsset.fntConfig, !(_fontAtlas = _comp.fontAtlas)) {
                        _fontAtlas = new FontAtlas;
                        for (var fontDict = _fntConfig.fontDefDictionary, _i4 = 0, _Object$keys4 = Object.keys(fontDict); _i4 < _Object$keys4.length; _i4++) {
                            var fontDef = _Object$keys4[_i4], letterDefinition = new FontLetterDefinition, rect = fontDict[fontDef].rect;
                            letterDefinition.offsetX = fontDict[fontDef].xOffset, letterDefinition.offsetY = fontDict[fontDef].yOffset, 
                            letterDefinition.width = rect.width, letterDefinition.height = rect.height, letterDefinition.u = rect.x, 
                            letterDefinition.v = rect.y, letterDefinition.textureID = 0, letterDefinition.validDefinition = !0, 
                            letterDefinition.xAdvance = fontDict[fontDef].xAdvance, _fontAtlas.addLetterDefinitions(fontDef, letterDefinition);
                        }
                        _comp.fontAtlas = _fontAtlas;
                    }
                    _string = _comp.string.toString(), _fontSize = _comp.fontSize, _originFontSize = _fntConfig.fontSize;
                    var contentSize = _comp.node.getContentSize();
                    _contentSize.width = contentSize.width, _contentSize.height = contentSize.height, 
                    _hAlign = _comp.horizontalAlign, _vAlign = _comp.verticalAlign, _spacingX = _comp.spacingX, 
                    _overflow = _comp.overflow, _lineHeight = _comp.lineHeight, _isWrapText = _overflow !== exports.Overflow.NONE && (_overflow === exports.Overflow.RESIZE_HEIGHT || _comp.enableWrapText), 
                    this._setupBMFontOverflowMetrics();
                }
            }
        },
        _resetProperties: function _resetProperties() {
            _fontAtlas = null, _fntConfig = null, _spriteFrame = null;
        },
        _updateContent: function _updateContent() {
            this._updateFontScale(), this._computeHorizontalKerningForText(), this._alignText();
        },
        _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
            for (var string = _string, stringLen = string.length, kerningDict = _fntConfig.kerningDict, horizontalKerning = _horizontalKerning, prev = -1, i = 0; i < stringLen; ++i) {
                var _key3 = string.charCodeAt(i), kerningAmount = kerningDict[prev << 16 | 65535 & _key3] || 0;
                horizontalKerning[i] = i < stringLen - 1 ? kerningAmount : 0, prev = _key3;
            }
        },
        _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
            var textLen = _string.length, lineIndex = 0, nextTokenX = 0, nextTokenY = 0, longestLine = 0, letterRight = 0, highestY = 0, lowestY = 0, letterDef = null, letterPosition = new Vec2;
            this._updateFontScale();
            for (var letterDefinitions = _fontAtlas.letterDefinitions, index = 0; index < textLen; ) {
                var character = _string.charAt(index);
                if ("\n" !== character) {
                    for (var tokenLen = nextTokenFunc(_string, index, textLen), tokenHighestY = highestY, tokenLowestY = lowestY, tokenRight = letterRight, nextLetterX = nextTokenX, newLine = !1, tmp = 0; tmp < tokenLen; ++tmp) {
                        var letterIndex = index + tmp;
                        if ("\r" !== (character = _string.charAt(letterIndex))) if (letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character)) {
                            var letterX = nextLetterX + letterDef.offsetX * _bmfontScale;
                            if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.width * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character)) {
                                _linesWidth.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, nextTokenY -= _lineHeight * _bmfontScale + 0, 
                                newLine = !0;
                                break;
                            }
                            letterPosition.x = letterX, letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale, 
                            this._recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex), 
                            letterIndex + 1 < _horizontalKerning.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKerning[letterIndex + 1]), 
                            nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX, tokenRight = letterPosition.x + letterDef.width * _bmfontScale, 
                            tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y), tokenLowestY > letterPosition.y - letterDef.height * _bmfontScale && (tokenLowestY = letterPosition.y - letterDef.height * _bmfontScale);
                        } else this._recordPlaceholderInfo(letterIndex, character), console.log("Can't find letter definition in texture atlas " + _fntConfig.atlasName + " for letter:" + character); else this._recordPlaceholderInfo(letterIndex, character);
                    }
                    newLine || (nextTokenX = nextLetterX, highestY < tokenHighestY && (highestY = tokenHighestY), 
                    lowestY > tokenLowestY && (lowestY = tokenLowestY), longestLine < (letterRight = tokenRight) && (longestLine = letterRight), 
                    index += tokenLen);
                } else _linesWidth.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, 
                nextTokenY -= _lineHeight * _bmfontScale + 0, this._recordPlaceholderInfo(index, character), 
                index++;
            }
            return _linesWidth.push(letterRight), _textDesiredHeight = (_numberOfLines = lineIndex + 1) * _lineHeight * _bmfontScale, 
            _numberOfLines > 1 && (_textDesiredHeight += 0 * (_numberOfLines - 1)), _contentSize.width = _labelWidth, 
            _contentSize.height = _labelHeight, _labelWidth <= 0 && (_contentSize.width = parseFloat(longestLine.toFixed(2))), 
            _labelHeight <= 0 && (_contentSize.height = parseFloat(_textDesiredHeight.toFixed(2))), 
            _tailoredTopY = _contentSize.height, _tailoredBottomY = 0, highestY > 0 && (_tailoredTopY = _contentSize.height + highestY), 
            lowestY < -_textDesiredHeight && (_tailoredBottomY = _textDesiredHeight + lowestY), 
            !0;
        },
        _getFirstCharLen: function _getFirstCharLen() {
            return 1;
        },
        _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
            var character = text.charAt(startIndex);
            if (isUnicodeCJK(character) || "\n" === character || isUnicodeSpace(character)) return 1;
            var len = 1, letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character);
            if (!letterDef) return len;
            for (var nextLetterX = letterDef.xAdvance * _bmfontScale + _spacingX, index = startIndex + 1; index < textLen && (character = text.charAt(index), 
            letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character)); ++index) {
                if (nextLetterX + letterDef.offsetX * _bmfontScale + letterDef.width * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character) && _maxLineWidth > 0) return len;
                if (nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX, "\n" === character || isUnicodeSpace(character) || isUnicodeCJK(character)) break;
                len++;
            }
            return len;
        },
        _multilineTextWrapByWord: function _multilineTextWrapByWord() {
            return this._multilineTextWrap(this._getFirstWordLen);
        },
        _multilineTextWrapByChar: function _multilineTextWrapByChar() {
            return this._multilineTextWrap(this._getFirstCharLen);
        },
        _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char2) {
            if (letterIndex >= _lettersInfo.length) {
                var tmpInfo = new LetterInfo;
                _lettersInfo.push(tmpInfo);
            }
            _lettersInfo[letterIndex].char = _char2, _lettersInfo[letterIndex].valid = !1;
        },
        _recordLetterInfo: function _recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex) {
            if (letterIndex >= _lettersInfo.length) {
                var tmpInfo = new LetterInfo;
                _lettersInfo.push(tmpInfo);
            }
            var cIndex = character.charCodeAt(0);
            _lettersInfo[letterIndex].lineIndex = lineIndex, _lettersInfo[letterIndex].char = character, 
            _lettersInfo[letterIndex].valid = letterDefinitions[cIndex].validDefinition, _lettersInfo[letterIndex].positionX = letterPosition.x, 
            _lettersInfo[letterIndex].positionY = letterPosition.y;
        },
        _alignText: function _alignText() {
            _textDesiredHeight = 0, _linesWidth.length = 0, this._multilineTextWrapByWord(), 
            this._computeAlignmentOffset(), _overflow === exports.Overflow.SHRINK && _fontSize > 0 && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp), 
            this._updateQuads() || _overflow === exports.Overflow.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp);
        },
        _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
            var shouldUpdateContent = !0;
            fontSize || (fontSize = .1, shouldUpdateContent = !1), _fontSize = fontSize, shouldUpdateContent && this._updateContent();
        },
        _shrinkLabelToContentSize: function _shrinkLabelToContentSize(lambda) {
            for (var fontSize = _fontSize, originalLineHeight = _lineHeight, fontAtlas = _fontAtlas, i = 0, tempLetterDefinition = fontAtlas ? fontAtlas.cloneLetterDefinition() : {}, flag = !0; lambda(); ) {
                var newFontSize = fontSize - ++i;
                if (flag = !1, newFontSize <= 0) break;
                var scale = newFontSize / fontSize;
                fontAtlas && (fontAtlas.assignLetterDefinitions(tempLetterDefinition), fontAtlas.scaleFontLetterDefinition(scale)), 
                _lineHeight = originalLineHeight * scale, this._multilineTextWrapByWord(), this._computeAlignmentOffset();
            }
            _lineHeight = originalLineHeight, fontAtlas && fontAtlas.assignLetterDefinitions(tempLetterDefinition), 
            flag || fontSize - i >= 0 && this._scaleFontSizeDown(fontSize - i);
        },
        _isVerticalClamp: function _isVerticalClamp() {
            return _textDesiredHeight > _contentSize.height;
        },
        _isHorizontalClamp: function _isHorizontalClamp() {
            if (_fontAtlas) {
                for (var letterClamp = !1, ctr = 0, l = _string.length; ctr < l; ++ctr) {
                    var letterInfo = _lettersInfo[ctr];
                    if (letterInfo.valid) {
                        var letterDef = _fontAtlas.getLetterDefinitionForChar(letterInfo.char);
                        if (!letterDef) continue;
                        var px = letterInfo.positionX + letterDef.width / 2 * _bmfontScale, lineIndex = letterInfo.lineIndex;
                        if (_labelWidth > 0) if (_isWrapText) {
                            if (_linesWidth[lineIndex] > _contentSize.width && (px > _contentSize.width || px < 0)) {
                                letterClamp = !0;
                                break;
                            }
                        } else if (px > _contentSize.width) {
                            letterClamp = !0;
                            break;
                        }
                    }
                }
                return letterClamp;
            }
        },
        _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
            var wordWidth = _linesWidth[lineIndex], letterOverClamp = px > _contentSize.width || px < 0;
            return _isWrapText ? wordWidth > _contentSize.width && letterOverClamp : letterOverClamp;
        },
        _updateQuads: function _updateQuads() {
            if (!_comp) return !1;
            var letterDefinitions = _fontAtlas ? _fontAtlas.letterDefinitions : {}, texture = _spriteFrame, node = _comp.node, renderData = _comp.renderData;
            renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
            for (var anchorPoint = node.getAnchorPoint(), contentSize = _contentSize, appX = anchorPoint.x * contentSize.width, appY = anchorPoint.y * contentSize.height, ret = !0, ctr = 0, l = _string.length; ctr < l; ++ctr) {
                var letterInfo = _lettersInfo[ctr];
                if (letterInfo.valid) {
                    var letterDef = letterDefinitions[letterInfo.char.charCodeAt(0)];
                    if (letterDef) {
                        _tmpRect.height = letterDef.height, _tmpRect.width = letterDef.width, _tmpRect.x = letterDef.u, 
                        _tmpRect.y = letterDef.v;
                        var py = letterInfo.positionY + _letterOffsetY;
                        if (_labelHeight > 0) {
                            if (py > _tailoredTopY) {
                                var clipTop = py - _tailoredTopY;
                                _tmpRect.y += clipTop, _tmpRect.height -= clipTop, py -= clipTop;
                            }
                            py - letterDef.height * _bmfontScale < _tailoredBottomY && (_tmpRect.height = py < _tailoredBottomY ? 0 : py - _tailoredBottomY);
                        }
                        var lineIndex = letterInfo.lineIndex, px = letterInfo.positionX + letterDef.width / 2 * _bmfontScale + _linesOffsetX[lineIndex];
                        if (_labelWidth > 0 && this._isHorizontalClamped(px, lineIndex)) if (_overflow === exports.Overflow.CLAMP) _tmpRect.width = 0; else if (_overflow === exports.Overflow.SHRINK) {
                            if (_contentSize.width > letterDef.width) {
                                ret = !1;
                                break;
                            }
                            _tmpRect.width = 0;
                        }
                        if (_spriteFrame && _tmpRect.height > 0 && _tmpRect.width > 0) {
                            var isRotated = _spriteFrame.isRotated(), originalSize = _spriteFrame.getOriginalSize(), rect = _spriteFrame.getRect(), offset = _spriteFrame.getOffset(), trimmedLeft = offset.x + (originalSize.width - rect.width) / 2, trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
                            if (isRotated) {
                                var originalX = _tmpRect.x;
                                _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop, _tmpRect.y = originalX + rect.y - trimmedLeft, 
                                _tmpRect.y < 0 && (_tmpRect.height = _tmpRect.height + trimmedTop);
                            } else _tmpRect.x += rect.x - trimmedLeft, _tmpRect.y += rect.y + trimmedTop;
                            var letterPositionX = letterInfo.positionX + _linesOffsetX[letterInfo.lineIndex];
                            this.appendQuad(_comp, texture, _tmpRect, isRotated, letterPositionX - appX, py - appY, _bmfontScale);
                        }
                    } else console.warn("Can't find letter in this bitmap-font");
                }
            }
            return ret;
        },
        appendQuad: function appendQuad(comp, texture, rect, rotated, x, y, scale) {},
        _computeAlignmentOffset: function _computeAlignmentOffset() {
            switch (_linesOffsetX.length = 0, _hAlign) {
              case exports.HorizontalTextAlignment.LEFT:
                for (var i = 0; i < _numberOfLines; ++i) _linesOffsetX.push(0);
                break;

              case exports.HorizontalTextAlignment.CENTER:
                for (var _i5 = 0, l = _linesWidth.length; _i5 < l; _i5++) _linesOffsetX.push((_contentSize.width - _linesWidth[_i5]) / 2);
                break;

              case exports.HorizontalTextAlignment.RIGHT:
                for (var _i6 = 0, _l = _linesWidth.length; _i6 < _l; _i6++) _linesOffsetX.push(_contentSize.width - _linesWidth[_i6]);
            }
            switch (_vAlign) {
              case exports.VerticalTextAlignment.TOP:
                _letterOffsetY = _contentSize.height;
                break;

              case exports.VerticalTextAlignment.CENTER:
                _letterOffsetY = (_contentSize.height + _textDesiredHeight) / 2;
                break;

              case exports.VerticalTextAlignment.BOTTOM:
                _letterOffsetY = _textDesiredHeight;
            }
        },
        _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
            var newWidth = _contentSize.width, newHeight = _contentSize.height;
            _overflow === exports.Overflow.RESIZE_HEIGHT && (newHeight = 0), _overflow === exports.Overflow.NONE && (newWidth = 0, 
            newHeight = 0), _labelWidth = newWidth, _labelHeight = newHeight, _labelDimensions.width = newWidth, 
            _labelDimensions.height = newHeight, _maxLineWidth = newWidth;
        }
    });
    var Overflow = LabelComponent.Overflow, WHITE = Color.WHITE.clone(), TextAlignment = LabelComponent.HorizontalAlign, VerticalTextAlignment = LabelComponent.VerticalAlign, LetterInfo$1 = function LetterInfo() {
        _classCallCheck(this, LetterInfo), this.char = "", this.valid = !0, this.x = 0, 
        this.y = 0, this.line = 0, this.hash = "";
    }, FontLetterDefinition$1 = function FontLetterDefinition() {
        _classCallCheck(this, FontLetterDefinition), this.u = 0, this.v = 0, this.w = 0, 
        this.h = 0, this.texture = null, this.offsetX = 0, this.offsetY = 0, this.valid = !1, 
        this.xAdvance = 0;
    }, LetterTexture = function() {
        function LetterTexture(_char, labelInfo) {
            _classCallCheck(this, LetterTexture), this.image = null, this.data = null, this.canvas = null, 
            this.context = null, this.width = 0, this.height = 0, this.char = _char, this.labelInfo = labelInfo, 
            this.hash = _char.charCodeAt(0) + labelInfo.hash;
        }
        return _createClass(LetterTexture, [ {
            key: "updateRenderData",
            value: function updateRenderData() {
                this._updateProperties(), this._updateTexture();
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.image = null;
            }
        }, {
            key: "_updateProperties",
            value: function _updateProperties() {
                if (this.data = LabelComponent._canvasPool.get(), this.canvas = this.data.canvas, 
                this.context = this.data.context, this.context) {
                    this.context.font = this.labelInfo.fontDesc;
                    var width = safeMeasureText(this.context, this.char);
                    this.width = parseFloat(width.toFixed(2)), this.height = this.labelInfo.fontSize;
                }
                this.canvas.width !== this.width && (this.canvas.width = this.width), this.canvas.height !== this.height && (this.canvas.height = this.height), 
                this.image || (this.image = new ImageAsset), this.image.reset(this.canvas);
            }
        }, {
            key: "_updateTexture",
            value: function _updateTexture() {
                if (this.context && this.canvas) {
                    var context = this.context, labelInfo = this.labelInfo, width = this.canvas.width, height = this.canvas.height;
                    context.textAlign = "center", context.textBaseline = "middle", context.clearRect(0, 0, width, height), 
                    context.fillStyle = "rgba(255, 255, 255, 0.005)", context.fillRect(0, 0, width, height), 
                    context.font = labelInfo.fontDesc;
                    var startX = width / 2, startY = height / 2, color = labelInfo.color;
                    if (context.lineJoin = "round", context.fillStyle = "rgba(".concat(color.r, ", ").concat(color.g, ", ").concat(color.b, ", ", 1, ")"), 
                    labelInfo.isOutlined) {
                        var strokeColor = labelInfo.out || WHITE;
                        context.strokeStyle = "rgba(".concat(strokeColor.r, ", ").concat(strokeColor.g, ", ").concat(strokeColor.b, ", ").concat(strokeColor.a / 255, ")"), 
                        context.lineWidth = 2 * labelInfo.margin, context.strokeText(this.char, startX, startY);
                    }
                    context.fillText(this.char, startX, startY);
                }
            }
        } ]), LetterTexture;
    }(), LetterRenderTexture = function(_Texture2D) {
        function LetterRenderTexture() {
            return _classCallCheck(this, LetterRenderTexture), _possibleConstructorReturn(this, _getPrototypeOf(LetterRenderTexture).apply(this, arguments));
        }
        return _inherits(LetterRenderTexture, _Texture2D), _createClass(LetterRenderTexture, [ {
            key: "initWithSize",
            value: function initWithSize(width, height) {
                var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : PixelFormat.RGBA8888;
                this.reset({
                    width: width,
                    height: height,
                    format: format
                }), this.loaded = !0, this.emit("load");
            }
        }, {
            key: "drawTextureAt",
            value: function drawTextureAt(image, x, y) {
                var gfxTexture = this.getGFXTexture();
                if (image && gfxTexture) {
                    var gfxDevice = this._getGFXDevice();
                    if (gfxDevice) {
                        var region = {
                            buffOffset: 0,
                            buffStride: 0,
                            buffTexHeight: 0,
                            texOffset: {
                                x: x,
                                y: y,
                                z: 0
                            },
                            texExtent: {
                                width: image.width,
                                height: image.height,
                                depth: 1
                            },
                            texSubres: {
                                baseMipLevel: 0,
                                levelCount: 1,
                                baseArrayLayer: 0,
                                layerCount: 1
                            }
                        };
                        gfxDevice.copyTexImagesToTexture([ image.data ], gfxTexture, [ region ]);
                    } else console.warn("Unable to get device");
                }
            }
        } ]), LetterRenderTexture;
    }(Texture2D), LetterAtlas = function() {
        function LetterAtlas(width, height) {
            _classCallCheck(this, LetterAtlas), this._x = 2, this._y = 2, this._nextY = 2, this._width = 0, 
            this._height = 0, this._letterDefinitions = new Map, this._dirty = !1, this.texture = new LetterRenderTexture, 
            this.texture.initWithSize(width, height), this._width = width, this._height = height, 
            director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
        }
        return _createClass(LetterAtlas, [ {
            key: "width",
            get: function get() {
                return this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        } ]), _createClass(LetterAtlas, [ {
            key: "insertLetterTexture",
            value: function insertLetterTexture(letterTexture) {
                var texture = letterTexture.image, device = director.root.device;
                if (!texture || !this.texture || !device) return null;
                var width = texture.width, height = texture.height;
                if (this._x + width + 2 > this._width && (this._x = 2, this._y = this._nextY), this._y + height > this._nextY && (this._nextY = this._y + height + 2), 
                this._nextY > this._height) return null;
                this.texture.drawTextureAt(texture, this._x, this._y), this._dirty = !0;
                var letterDefinition = new FontLetterDefinition$1;
                return letterDefinition.u = this._x, letterDefinition.v = this._y, letterDefinition.texture = this.texture, 
                letterDefinition.valid = !0, letterDefinition.w = letterTexture.width, letterDefinition.h = letterTexture.height, 
                letterDefinition.xAdvance = letterTexture.width, this._x += width + 2, this._letterDefinitions.set(letterTexture.hash, letterDefinition), 
                letterDefinition;
            }
        }, {
            key: "update",
            value: function update() {
                this._dirty && (this._dirty = !1);
            }
        }, {
            key: "reset",
            value: function reset() {
                this._x = 2, this._y = 2, this._nextY = 2, this._letterDefinitions.clear();
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.reset(), this.texture && this.texture.destroy();
            }
        }, {
            key: "beforeSceneLoad",
            value: function beforeSceneLoad() {
                this.destroy();
                var texture = new LetterRenderTexture;
                texture.initWithSize(this._width, this._height), this.texture = texture;
            }
        }, {
            key: "getLetter",
            value: function getLetter(key) {
                return this._letterDefinitions.get(key);
            }
        }, {
            key: "addLetterDefinitions",
            value: function addLetterDefinitions(key, letterDefinition) {
                this._letterDefinitions[key] = letterDefinition;
            }
        }, {
            key: "cloneLetterDefinition",
            value: function cloneLetterDefinition() {
                for (var copyLetterDefinitions = {}, _i = 0, _Object$keys = Object.keys(this._letterDefinitions); _i < _Object$keys.length; _i++) {
                    var key = _Object$keys[_i], value = new FontLetterDefinition$1;
                    mixin(value, this._letterDefinitions[key]), copyLetterDefinitions[key] = value;
                }
                return copyLetterDefinitions;
            }
        }, {
            key: "assignLetterDefinitions",
            value: function assignLetterDefinitions(letterDefinitions) {
                var _this = this;
                letterDefinitions.forEach((function(value, key) {
                    mixin(_this._letterDefinitions[key], value);
                }));
            }
        }, {
            key: "scaleFontLetterDefinition",
            value: function scaleFontLetterDefinition(scaleFactor) {
                for (var _i2 = 0, _Object$keys2 = Object.keys(this._letterDefinitions); _i2 < _Object$keys2.length; _i2++) {
                    var fontDefinition = _Object$keys2[_i2], letterDefinitions = this._letterDefinitions[fontDefinition];
                    letterDefinitions.w *= scaleFactor, letterDefinitions.h *= scaleFactor, letterDefinitions.offsetX *= scaleFactor, 
                    letterDefinitions.offsetY *= scaleFactor, letterDefinitions.xAdvance *= scaleFactor;
                }
            }
        }, {
            key: "getLetterDefinitionForChar",
            value: function getLetterDefinitionForChar(_char2, labelInfo) {
                var hash = _char2.charCodeAt(0) + labelInfo.hash, letterDefinition = this._letterDefinitions.get(hash);
                if (!letterDefinition) {
                    var temp = new LetterTexture(_char2, labelInfo);
                    temp.updateRenderData(), letterDefinition = this.insertLetterTexture(temp), temp.destroy();
                }
                return letterDefinition;
            }
        } ]), LetterAtlas;
    }(), _tmpRect$1 = new Rect, _comp$1 = null, _horizontalKernings = [], _lettersInfo$1 = [], _linesWidth$1 = [], _linesOffsetX$1 = [], _labelDimensions$1 = new Size, _fontAtlas$1 = null, _numberOfLines$1 = 0, _textDesiredHeight$1 = 0, _letterOffsetY$1 = 0, _tailoredTopY$1 = 0, _tailoredBottomY$1 = 0, _bmfontScale$1 = 1, _string$1 = "", _fontSize$1 = 0, _originFontSize$1 = 0, _contentSize$1 = new Size, _hAlign$1 = 0, _vAlign$1 = 0, _spacingX$1 = 0, _lineHeight$1 = 0, _overflow$1 = 0, _isWrapText$1 = !1, _labelWidth$1 = 0, _labelHeight$1 = 0, _maxLineWidth$1 = 0, _fontFamily = "", _isBold = !1, _labelInfo = {
        fontSize: 0,
        lineHeight: 0,
        hash: "",
        fontFamily: "",
        fontDesc: "Arial",
        hAlign: 0,
        vAlign: 0,
        color: WHITE,
        isOutlined: !1,
        out: WHITE,
        margin: 0
    }, letterFont = {
        getAssemblerData: function getAssemblerData() {
            return _fontAtlas$1 || (_fontAtlas$1 = new LetterAtlas(1024, 1024)), _fontAtlas$1.texture;
        },
        updateRenderData: function updateRenderData(comp) {
            comp.renderData && comp.renderData.vertDirty && _comp$1 !== comp && (_comp$1 = comp, 
            this._updateFontFamily(comp), _labelInfo.fontFamily = _fontFamily, this._updateProperties(), 
            _labelInfo.fontDesc = this._getFontDesc(), this._updateContent(), _comp$1.actualFontSize = _fontSize$1, 
            _comp$1.node.setContentSize(_contentSize$1), _comp$1.renderData.vertDirty = _comp$1.renderData.uvDirty = !1, 
            _comp$1 = null, this._resetProperties());
        },
        _updateFontScale: function _updateFontScale() {
            _bmfontScale$1 = _fontSize$1 / _originFontSize$1;
        },
        _updateProperties: function _updateProperties() {
            if (_comp$1) {
                _string$1 = _comp$1.string.toString(), _fontSize$1 = _comp$1.fontSize, _originFontSize$1 = _fontSize$1;
                var contentSize = _comp$1.node.getContentSize();
                _contentSize$1.width = contentSize.width, _contentSize$1.height = contentSize.height, 
                _hAlign$1 = _comp$1.horizontalAlign, _vAlign$1 = _comp$1.verticalAlign, _spacingX$1 = _comp$1.spacingX, 
                _overflow$1 = _comp$1.overflow, _lineHeight$1 = _comp$1.lineHeight, _isBold = _comp$1.isBold, 
                _isWrapText$1 = _overflow$1 !== Overflow.NONE && (_overflow$1 === Overflow.RESIZE_HEIGHT || _comp$1.enableWrapText);
                var outline = _comp$1.getComponent(LabelOutlineComponent);
                outline && outline.enabled ? (_labelInfo.isOutlined = !0, _labelInfo.margin = outline.width, 
                _labelInfo.out = outline.color, _labelInfo.out.a = outline.color.a * _comp$1.color.a / 255) : (_labelInfo.isOutlined = !1, 
                _labelInfo.margin = 0), _labelInfo.lineHeight = _lineHeight$1, _labelInfo.fontSize = _fontSize$1, 
                _labelInfo.fontFamily = _fontFamily, _labelInfo.color = _comp$1.color, _labelInfo.hash = this._computeHash(_labelInfo), 
                this._setupBMFontOverflowMetrics();
            }
        },
        _updateFontFamily: function _updateFontFamily(comp) {
            comp.useSystemFont ? _fontFamily = comp.fontFamily : comp.font ? comp.font._nativeAsset ? _fontFamily = comp.font._nativeAsset : (_fontFamily = loader.getRes(comp.font.nativeUrl) || "") || loader.load(comp.font.nativeUrl, (function(err, fontFamily) {
                _fontFamily = fontFamily || "Arial", comp.font && (comp.font._nativeAsset = fontFamily), 
                comp.updateRenderData(!0);
            })) : _fontFamily = "Arial";
        },
        _computeHash: function _computeHash(labelInfo) {
            var color = labelInfo.color.toHEX("#rrggbb"), out = "";
            return labelInfo.isOutlined && (out = labelInfo.out.toHEX("#rrggbb")), "" + labelInfo.fontSize + labelInfo.fontFamily + color + out;
        },
        _getFontDesc: function _getFontDesc() {
            var fontDesc = _fontSize$1.toString() + "px ";
            return fontDesc += _fontFamily, _isBold && (fontDesc = "bold " + fontDesc), fontDesc;
        },
        _resetProperties: function _resetProperties() {},
        _updateContent: function _updateContent() {
            this._updateFontScale(), this._alignText();
        },
        _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {},
        _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
            var textLen = _string$1.length, lineIndex = 0, nextTokenX = 0, nextTokenY = 0, longestLine = 0, letterRight = 0, highestY = 0, lowestY = 0, letterDef = null, letterPosition = new Vec2(0, 0);
            this._updateFontScale();
            for (var index = 0; index < textLen; ) {
                var character = _string$1.charAt(index);
                if ("\n" !== character) {
                    for (var tokenLen = nextTokenFunc(_string$1, index, textLen), tokenHighestY = highestY, tokenLowestY = lowestY, tokenRight = letterRight, nextLetterX = nextTokenX, newLine = !1, tmp = 0; tmp < tokenLen; ++tmp) {
                        var letterIndex = index + tmp;
                        if ("\r" !== (character = _string$1.charAt(letterIndex))) if (letterDef = _fontAtlas$1 && _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo)) {
                            var letterX = nextLetterX + letterDef.offsetX * _bmfontScale$1;
                            if (_isWrapText$1 && _maxLineWidth$1 > 0 && nextTokenX > 0 && letterX + letterDef.w * _bmfontScale$1 > _maxLineWidth$1 && !isUnicodeSpace(character)) {
                                _linesWidth$1.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, nextTokenY -= _lineHeight$1 * _bmfontScale$1 + 0, 
                                newLine = !0;
                                break;
                            }
                            letterPosition.x = letterX, letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale$1, 
                            this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex), letterIndex + 1 < _horizontalKernings.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings[letterIndex + 1]), 
                            nextLetterX += letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, tokenRight = letterPosition.x + letterDef.w * _bmfontScale$1, 
                            tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y), tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale$1 && (tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale$1);
                        } else this._recordPlaceholderInfo(letterIndex, character); else this._recordPlaceholderInfo(letterIndex, character);
                    }
                    newLine || (nextTokenX = nextLetterX, highestY < tokenHighestY && (highestY = tokenHighestY), 
                    lowestY > tokenLowestY && (lowestY = tokenLowestY), longestLine < (letterRight = tokenRight) && (longestLine = letterRight), 
                    index += tokenLen);
                } else _linesWidth$1.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, 
                nextTokenY -= _lineHeight$1 * _bmfontScale$1 + 0, this._recordPlaceholderInfo(index, character), 
                index++;
            }
            return _linesWidth$1.push(letterRight), _textDesiredHeight$1 = (_numberOfLines$1 = lineIndex + 1) * _lineHeight$1 * _bmfontScale$1, 
            _numberOfLines$1 > 1 && (_textDesiredHeight$1 += 0 * (_numberOfLines$1 - 1)), _contentSize$1.width = _labelWidth$1, 
            _contentSize$1.height = _labelHeight$1, _labelWidth$1 <= 0 && (_contentSize$1.width = parseFloat(longestLine.toFixed(2))), 
            _labelHeight$1 <= 0 && (_contentSize$1.height = parseFloat(_textDesiredHeight$1.toFixed(2))), 
            _tailoredTopY$1 = _contentSize$1.height, _tailoredBottomY$1 = 0, highestY > 0 && (_tailoredTopY$1 = _contentSize$1.height + highestY), 
            lowestY < -_textDesiredHeight$1 && (_tailoredBottomY$1 = _textDesiredHeight$1 + lowestY), 
            !0;
        },
        _getFirstCharLen: function _getFirstCharLen() {
            return 1;
        },
        _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
            var character = text.charAt(startIndex);
            if (isUnicodeCJK(character) || "\n" === character || isUnicodeSpace(character)) return 1;
            if (_fontAtlas$1) {
                var len = 1, letterDef = _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo);
                if (!letterDef) return len;
                for (var nextLetterX = letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, index = startIndex + 1; index < textLen && (character = text.charAt(index), 
                letterDef = _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo)); ++index) {
                    if (nextLetterX + letterDef.offsetX * _bmfontScale$1 + letterDef.w * _bmfontScale$1 > _maxLineWidth$1 && !isUnicodeSpace(character) && _maxLineWidth$1 > 0) return len;
                    if (nextLetterX += letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, "\n" === character || isUnicodeSpace(character) || isUnicodeCJK(character)) break;
                    len++;
                }
                return len;
            }
        },
        _multilineTextWrapByWord: function _multilineTextWrapByWord() {
            return this._multilineTextWrap(this._getFirstWordLen);
        },
        _multilineTextWrapByChar: function _multilineTextWrapByChar() {
            return this._multilineTextWrap(this._getFirstCharLen);
        },
        _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char3) {
            if (letterIndex >= _lettersInfo$1.length) {
                var tmpInfo = new LetterInfo$1;
                _lettersInfo$1.push(tmpInfo);
            }
            _lettersInfo$1[letterIndex].char = _char3, _lettersInfo$1[letterIndex].hash = _char3.charCodeAt(0) + _labelInfo.hash, 
            _lettersInfo$1[letterIndex].valid = !1;
        },
        _recordLetterInfo: function _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
            if (letterIndex >= _lettersInfo$1.length) {
                var tmpInfo = new LetterInfo$1;
                _lettersInfo$1.push(tmpInfo);
            }
            var key = character.charCodeAt(0) + _labelInfo.hash;
            _lettersInfo$1[letterIndex].line = lineIndex, _lettersInfo$1[letterIndex].char = character, 
            _lettersInfo$1[letterIndex].hash = key;
            var fontLetter = _fontAtlas$1 && _fontAtlas$1.getLetter(key);
            _lettersInfo$1[letterIndex].valid = !!fontLetter && !!fontLetter.valid, _lettersInfo$1[letterIndex].x = letterPosition.x, 
            _lettersInfo$1[letterIndex].y = letterPosition.y;
        },
        _alignText: function _alignText() {
            _textDesiredHeight$1 = 0, _linesWidth$1.length = 0, this._multilineTextWrapByWord(), 
            this._computeAlignmentOffset(), this._updateQuads();
        },
        _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
            var shouldUpdateContent = !0;
            fontSize || (fontSize = .1, shouldUpdateContent = !1), _fontSize$1 = fontSize, shouldUpdateContent && this._updateContent();
        },
        _isVerticalClamp: function _isVerticalClamp() {
            return _textDesiredHeight$1 > _contentSize$1.height;
        },
        _isHorizontalClamp: function _isHorizontalClamp() {
            for (var letterClamp = !1, ctr = 0, l = _string$1.length; ctr < l; ++ctr) {
                var letterInfo = _lettersInfo$1[ctr];
                if (letterInfo.valid) {
                    var letterDef = _fontAtlas$1.getLetter(letterInfo.hash);
                    if (!letterDef) continue;
                    var px = letterInfo.x + letterDef.w * _bmfontScale$1, lineIndex = letterInfo.line;
                    if (_labelWidth$1 > 0) if (_isWrapText$1) {
                        if (_linesWidth$1[lineIndex] > _contentSize$1.width && (px > _contentSize$1.width || px < 0)) {
                            letterClamp = !0;
                            break;
                        }
                    } else if (px > _contentSize$1.width) {
                        letterClamp = !0;
                        break;
                    }
                }
            }
            return letterClamp;
        },
        _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
            var wordWidth = _linesWidth$1[lineIndex], letterOverClamp = px > _contentSize$1.width || px < 0;
            return _isWrapText$1 ? wordWidth > _contentSize$1.width && letterOverClamp : letterOverClamp;
        },
        _updateQuads: function _updateQuads() {
            if (_comp$1 && _fontAtlas$1) {
                var texture = _fontAtlas$1.texture, node = _comp$1.node, renderData = _comp$1.renderData;
                renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
                for (var contentSize = _contentSize$1, ap = node.getAnchorPoint(), appx = ap.x * contentSize.width, appy = ap.y * contentSize.height, ret = !0, ctr = 0, l = _string$1.length; ctr < l; ++ctr) {
                    var letterInfo = _lettersInfo$1[ctr];
                    if (letterInfo.valid) {
                        var letterDef = _fontAtlas$1.getLetter(letterInfo.hash);
                        if (letterDef) {
                            _tmpRect$1.height = letterDef.h, _tmpRect$1.width = letterDef.w, _tmpRect$1.x = letterDef.u, 
                            _tmpRect$1.y = letterDef.v;
                            var py = letterInfo.y + _letterOffsetY$1;
                            if (_labelHeight$1 > 0) {
                                if (py > _tailoredTopY$1) {
                                    var clipTop = py - _tailoredTopY$1;
                                    _tmpRect$1.y += clipTop, _tmpRect$1.height -= clipTop, py -= clipTop;
                                }
                                py - letterDef.h * _bmfontScale$1 < _tailoredBottomY$1 && (_tmpRect$1.height = py < _tailoredBottomY$1 ? 0 : py - _tailoredBottomY$1);
                            }
                            var lineIndex = letterInfo.line, px = letterInfo.x + letterDef.w / 2 * _bmfontScale$1 + _linesOffsetX$1[lineIndex];
                            if (_labelWidth$1 > 0 && this._isHorizontalClamped(px, lineIndex)) if (_overflow$1 === Overflow.CLAMP) _tmpRect$1.width = 0; else if (_overflow$1 === Overflow.SHRINK) {
                                if (_contentSize$1.width > letterDef.w) {
                                    ret = !1;
                                    break;
                                }
                                _tmpRect$1.width = 0;
                            }
                            if (_tmpRect$1.height > 0 && _tmpRect$1.width > 0) {
                                var letterPositionX = letterInfo.x + _linesOffsetX$1[letterInfo.line];
                                this.appendQuad(_comp$1, texture, _tmpRect$1, !1, letterPositionX - appx, py - appy, _bmfontScale$1);
                            }
                        }
                    }
                }
                return ret;
            }
        },
        appendQuad: function appendQuad(renderData, texture, rect, rotated, x, y, scale) {},
        _computeAlignmentOffset: function _computeAlignmentOffset() {
            switch (_linesOffsetX$1.length = 0, _hAlign$1) {
              case TextAlignment.LEFT:
                for (var i = 0; i < _numberOfLines$1; ++i) _linesOffsetX$1.push(0);
                break;

              case TextAlignment.CENTER:
                for (var _i3 = 0, l = _linesWidth$1.length; _i3 < l; _i3++) _linesOffsetX$1.push((_contentSize$1.width - _linesWidth$1[_i3]) / 2);
                break;

              case TextAlignment.RIGHT:
                for (var _i4 = 0, _l = _linesWidth$1.length; _i4 < _l; _i4++) _linesOffsetX$1.push(_contentSize$1.width - _linesWidth$1[_i4]);
            }
            switch (_vAlign$1) {
              case VerticalTextAlignment.TOP:
                _letterOffsetY$1 = _contentSize$1.height;
                break;

              case VerticalTextAlignment.CENTER:
                _letterOffsetY$1 = (_contentSize$1.height + _textDesiredHeight$1) / 2 - (_lineHeight$1 - _fontSize$1) / 2;
                break;

              case VerticalTextAlignment.BOTTOM:
                _letterOffsetY$1 = (_contentSize$1.height + _textDesiredHeight$1) / 2 - (_lineHeight$1 - _fontSize$1);
            }
        },
        _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
            var newWidth = _contentSize$1.width, newHeight = _contentSize$1.height;
            _overflow$1 === Overflow.RESIZE_HEIGHT && (newHeight = 0), _overflow$1 === Overflow.NONE && (newWidth = 0, 
            newHeight = 0), _labelWidth$1 = newWidth, _labelHeight$1 = newHeight, _labelDimensions$1.width = newWidth, 
            _labelDimensions$1.height = newHeight, _maxLineWidth$1 = newWidth;
        }
    }, WHITE$1 = new Color(255, 255, 255, 255), letter = {
        createData: function createData(comp) {
            return comp.requestRenderData();
        },
        fillBuffers: function fillBuffers(comp, renderer) {
            if (comp.renderData) {
                var node = comp.node;
                WHITE$1.a = comp.color.a, fillMeshVertices3D(node, renderer, comp.renderData, WHITE$1);
            }
        },
        appendQuad: bmfont.appendQuad
    };
    addon(letter, letterFont);
    var Overflow$1 = LabelComponent.Overflow, WHITE$2 = Color.WHITE.clone(), OUTLINE_SUPPORTED = isChildClassOf(LabelOutlineComponent, Component), _context = null, _canvas = null, _texture = null, _fontDesc = "", _string$2 = "", _fontSize$2 = 0, _drawFontsize = 0, _splitedStrings = [], _canvasSize = new Size, _lineHeight$2 = 0, _hAlign$2 = 0, _vAlign$2 = 0, _color$1 = new Color, _fontFamily$1 = "", _overflow$2 = Overflow$1.NONE, _isWrapText$2 = !1, _isOutlined = !1, _outlineColor = new Color, _outlineWidth = 0, _margin = 0, _isBold$1 = !1, _isItalic = !1, _isUnderline = !1, ttfUtils = {
        getAssemblerData: function getAssemblerData() {
            var sharedLabelData = LabelComponent._canvasPool.get();
            return sharedLabelData.canvas.width = sharedLabelData.canvas.height = 1, sharedLabelData;
        },
        resetAssemblerData: function resetAssemblerData(assemblerData) {
            assemblerData && LabelComponent._canvasPool.put(assemblerData);
        },
        updateRenderData: function updateRenderData(comp) {
            comp.renderData && comp.renderData.vertDirty && (this._updateFontFamly(comp), this._updateProperties(comp), 
            this._calculateLabelFont(), this._calculateSplitedStrings(), this._updateLabelDimensions(), 
            this._calculateTextBaseline(), this._updateTexture(), comp.actualFontSize = _fontSize$2, 
            comp.node.setContentSize(_canvasSize), this.updateVerts(comp), comp.markForUpdateRenderData(!1), 
            _context = null, _canvas = null, _texture = null);
        },
        updateVerts: function updateVerts(comp) {},
        _updateFontFamly: function _updateFontFamly(comp) {
            comp.useSystemFont ? _fontFamily$1 = comp.fontFamily : comp.font ? comp.font._nativeAsset ? _fontFamily$1 = comp.font._nativeAsset : loader.load(comp.font.nativeUrl, (function(err, fontFamily) {
                _fontFamily$1 = fontFamily || "Arial", comp.updateRenderData(!0);
            })) : _fontFamily$1 = "Arial";
        },
        _updateProperties: function _updateProperties(comp) {
            var assemblerData = comp.assemblerData;
            if (assemblerData) {
                _context = assemblerData.context, _canvas = assemblerData.canvas, _texture = comp.spriteFrame, 
                _string$2 = comp.string.toString(), _fontSize$2 = comp.fontSize, _drawFontsize = _fontSize$2, 
                _overflow$2 = comp.overflow, _canvasSize.width = comp.node.width, _canvasSize.height = comp.node.height, 
                _lineHeight$2 = comp.lineHeight, _hAlign$2 = comp.horizontalAlign, _vAlign$2 = comp.verticalAlign, 
                _color$1 = comp.color, _isBold$1 = comp.isBold, _isItalic = comp.isItalic, _isUnderline = comp.isUnderline, 
                _isWrapText$2 = _overflow$2 !== Overflow$1.NONE && (_overflow$2 === Overflow$1.RESIZE_HEIGHT || comp.enableWrapText);
                var outline = OUTLINE_SUPPORTED && comp.getComponent(LabelOutlineComponent);
                outline && outline.enabled ? (_isOutlined = !0, _margin = _outlineWidth = outline.width, 
                (_outlineColor = outline.color.clone()).a = _outlineColor.a * comp.color.a / 255) : (_isOutlined = !1, 
                _margin = 0);
            }
        },
        _calculateFillTextStartPosition: function _calculateFillTextStartPosition() {
            var labelX, firstLinelabelY, lineHeight = this._getLineHeight(), lineCount = _splitedStrings.length;
            return labelX = _hAlign$2 === exports.HorizontalTextAlignment.RIGHT ? _canvasSize.width - _margin : _hAlign$2 === exports.HorizontalTextAlignment.CENTER ? _canvasSize.width / 2 : 0 + _margin, 
            firstLinelabelY = _vAlign$2 === exports.VerticalTextAlignment.TOP ? 0 : _vAlign$2 === exports.VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 : _canvasSize.height - lineHeight * (lineCount - 1), 
            new Vec2(labelX, firstLinelabelY);
        },
        _updateTexture: function _updateTexture() {
            if (_context && _canvas) {
                _context.clearRect(0, 0, _canvas.width, _canvas.height), _context.font = _fontDesc;
                var underlineStartPosition, startPosition = this._calculateFillTextStartPosition(), lineHeight = this._getLineHeight();
                _context.lineJoin = "round", _context.fillStyle = "rgba(".concat(_color$1.r, ", ").concat(_color$1.g, ", ").concat(_color$1.b, ", ").concat(_color$1.a / 255, ")");
                for (var i = 0; i < _splitedStrings.length; ++i) {
                    if (_isOutlined) {
                        var strokeColor = _outlineColor || WHITE$2;
                        _context.strokeStyle = "rgba(".concat(strokeColor.r, ", ").concat(strokeColor.g, ", ").concat(strokeColor.b, ", ").concat(strokeColor.a / 255, ")"), 
                        _context.lineWidth = 2 * _outlineWidth, _context.strokeText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight);
                    }
                    _context.fillText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight), 
                    _isUnderline && (underlineStartPosition = this._calculateUnderlineStartPosition(), 
                    _context.save(), _context.beginPath(), _context.lineWidth = _fontSize$2 / 8, _context.strokeStyle = "rgba(".concat(_color$1.r, ", ").concat(_color$1.g, ", ").concat(_color$1.b, ", ").concat(_color$1.a / 255, ")"), 
                    _context.moveTo(underlineStartPosition.x, underlineStartPosition.y + i * lineHeight - 1), 
                    _context.lineTo(underlineStartPosition.x + _canvas.width, underlineStartPosition.y + i * lineHeight - 1), 
                    _context.stroke(), _context.restore());
                }
                if (_texture) {
                    var tex;
                    tex = _texture instanceof SpriteFrame ? _texture.texture : _texture;
                    var uploadAgain = 0 === _canvas.width || 0 === _canvas.height;
                    tex.reset({
                        width: _canvas.width,
                        height: _canvas.height,
                        mipmapLevel: uploadAgain ? 0 : 1
                    }), uploadAgain || tex.uploadData(_canvas);
                }
            }
        },
        _calculateUnderlineStartPosition: function _calculateUnderlineStartPosition() {
            var labelX, firstLinelabelY, lineHeight = this._getLineHeight(), lineCount = _splitedStrings.length;
            return labelX = 0 + _margin, firstLinelabelY = _vAlign$2 === exports.VerticalTextAlignment.TOP ? _fontSize$2 : _vAlign$2 === exports.VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 + _fontSize$2 / 2 : _canvasSize.height - lineHeight * (lineCount - 1), 
            new Vec2(labelX, firstLinelabelY);
        },
        _updateLabelDimensions: function _updateLabelDimensions() {
            if (_context) {
                var paragraphedStrings = _string$2.split("\n");
                if (_overflow$2 === Overflow$1.RESIZE_HEIGHT) _canvasSize.height = _splitedStrings.length * this._getLineHeight(); else if (_overflow$2 === Overflow$1.NONE) {
                    _splitedStrings = paragraphedStrings;
                    var canvasSizeX = 0, canvasSizeY = 0, _iterator = paragraphedStrings, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var paraLength = safeMeasureText(_context, _ref);
                        canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
                    }
                    canvasSizeY = _splitedStrings.length * this._getLineHeight(), _canvasSize.width = parseFloat(canvasSizeX.toFixed(2)) + 2 * _margin, 
                    _canvasSize.height = parseFloat(canvasSizeY.toFixed(2)), _isItalic && (_canvasSize.width += _drawFontsize * Math.tan(.20943951));
                }
                _canvas && (_canvas.width = _canvasSize.width, _canvas.height = _canvasSize.height);
            }
        },
        _calculateTextBaseline: function _calculateTextBaseline() {
            var hAlign, vAlign;
            hAlign = _hAlign$2 === exports.HorizontalTextAlignment.RIGHT ? "right" : _hAlign$2 === exports.HorizontalTextAlignment.CENTER ? "center" : "left", 
            vAlign = _vAlign$2 === exports.VerticalTextAlignment.TOP ? "top" : _vAlign$2 === exports.VerticalTextAlignment.CENTER ? "middle" : "bottom", 
            _context && (_context.textAlign = hAlign, _context.textBaseline = vAlign);
        },
        _calculateSplitedStrings: function _calculateSplitedStrings() {
            if (_context) {
                var paragraphedStrings = _string$2.split("\n");
                if (_isWrapText$2) {
                    _splitedStrings = [];
                    var canvasWidthNoMargin = _canvasSize.width - 2 * _margin, _iterator2 = paragraphedStrings, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var textFragment = fragmentText(_ref2, safeMeasureText(_context, _ref2), canvasWidthNoMargin, this._measureText(_context));
                        _splitedStrings = _splitedStrings.concat(textFragment);
                    }
                } else _splitedStrings = paragraphedStrings;
            }
        },
        _getFontDesc: function _getFontDesc() {
            var fontDesc = _fontSize$2.toString() + "px ";
            return fontDesc += _fontFamily$1, _isBold$1 && (fontDesc = "bold " + fontDesc), 
            _isItalic && (fontDesc = "italic " + fontDesc), fontDesc;
        },
        _getLineHeight: function _getLineHeight() {
            var nodeSpacingY = _lineHeight$2;
            return 0 | (nodeSpacingY = 0 === nodeSpacingY ? _fontSize$2 : nodeSpacingY * _fontSize$2 / _drawFontsize);
        },
        _calculateParagraphLength: function _calculateParagraphLength(paragraphedStrings, ctx) {
            var paragraphLength = [], _iterator3 = paragraphedStrings, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var width = safeMeasureText(ctx, _ref3);
                paragraphLength.push(width);
            }
            return paragraphLength;
        },
        _measureText: function _measureText(ctx) {
            return function(string) {
                return safeMeasureText(ctx, string);
            };
        },
        _calculateLabelFont: function _calculateLabelFont() {
            if (_context && (_fontDesc = this._getFontDesc(), _context.font = _fontDesc, _overflow$2 === Overflow$1.SHRINK)) {
                var paragraphedStrings = _string$2.split("\n"), paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);
                _splitedStrings = paragraphedStrings;
                var i = 0, totalHeight = 0, maxLength = 0;
                if (_isWrapText$2) {
                    var canvasWidthNoMargin = _canvasSize.width - 2 * _margin, canvasHeightNoMargin = _canvasSize.height - 2 * _margin;
                    if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) return _fontDesc = this._getFontDesc(), 
                    void (_context.font = _fontDesc);
                    totalHeight = canvasHeightNoMargin + 1, maxLength = canvasWidthNoMargin + 1;
                    for (var actualFontSize = _fontSize$2 + 1, textFragment = [], tryDivideByTwo = !0, startShrinkFontSize = 0 | actualFontSize; totalHeight > canvasHeightNoMargin || maxLength > canvasWidthNoMargin; ) {
                        if (tryDivideByTwo ? actualFontSize = startShrinkFontSize / 2 | 0 : startShrinkFontSize = actualFontSize = startShrinkFontSize - 1, 
                        actualFontSize <= 0) {
                            logID(4003);
                            break;
                        }
                        for (_fontSize$2 = actualFontSize, _fontDesc = this._getFontDesc(), _context.font = _fontDesc, 
                        _splitedStrings = [], totalHeight = 0, i = 0; i < paragraphedStrings.length; ++i) {
                            var j = 0, allWidth = safeMeasureText(_context, paragraphedStrings[i]);
                            for (textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context)); j < textFragment.length; ) {
                                maxLength = safeMeasureText(_context, textFragment[j]), totalHeight += this._getLineHeight(), 
                                ++j;
                            }
                            _splitedStrings = _splitedStrings.concat(textFragment);
                        }
                        tryDivideByTwo && (totalHeight > canvasHeightNoMargin ? startShrinkFontSize = 0 | actualFontSize : (tryDivideByTwo = !1, 
                        totalHeight = canvasHeightNoMargin + 1));
                    }
                } else {
                    for (totalHeight = paragraphedStrings.length * this._getLineHeight(), i = 0; i < paragraphedStrings.length; ++i) maxLength < paragraphLength[i] && (maxLength = paragraphLength[i]);
                    var scaleX = (_canvasSize.width - 2 * _margin) / maxLength, scaleY = _canvasSize.height / totalHeight;
                    _fontSize$2 = _drawFontsize * Math.min(1, scaleX, scaleY) | 0, _fontDesc = this._getFontDesc(), 
                    _context.font = _fontDesc;
                }
            }
        }
    }, WHITE$3 = Color.WHITE.clone(), ttf = {
        createData: function createData(comp) {
            var renderData = comp.requestRenderData();
            renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6;
            var vData = renderData.vData = new Float32Array(36);
            vData[3] = vData[21] = vData[22] = vData[31] = 0, vData[4] = vData[12] = vData[13] = vData[30] = 1;
            for (var offset = 5, i = 0; i < 4; i++) Color.toArray(vData, WHITE$3, offset), offset += 9;
            return renderData;
        },
        fillBuffers: function fillBuffers(comp, renderer) {
            var renderData = comp.renderData, datas = renderData.datas, node = comp.node, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
            buffer.request() || (buffer = renderer.currBufferBatch, indiceOffset = 0, vertexId = 0);
            var vbuf = buffer.vData, ibuf = buffer.iData, vData = renderData.vData, data0 = datas[0], data3 = datas[3];
            node.updateWorldTransform();
            var pos = node._pos, rot = node._rot, scale = node._scale, ax = data0.x * scale.x, bx = data3.x * scale.x, ay = data0.y * scale.y, by = data3.y * scale.y, qx = rot.x, qy = rot.y, qz = rot.z, qw = rot.w, qxy = qx * qy, qzw = qz * qw, qxy2 = qx * qx - qy * qy, qzw2 = qw * qw - qz * qz, cx1 = qzw2 + qxy2, cx2 = 2 * (qxy - qzw), cy1 = qzw2 - qxy2, cy2 = 2 * (qxy + qzw), x = pos.x, y = pos.y;
            vData[0] = cx1 * ax + cx2 * ay + x, vData[1] = cy1 * ay + cy2 * ax + y, vData[9] = cx1 * bx + cx2 * ay + x, 
            vData[10] = cy1 * ay + cy2 * bx + y, vData[18] = cx1 * ax + cx2 * by + x, vData[19] = cy1 * by + cy2 * ax + y, 
            vData[27] = cx1 * bx + cx2 * by + x, vData[28] = cy1 * by + cy2 * bx + y, vbuf.set(vData, vertexOffset), 
            ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, 
            ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 3;
        },
        updateVerts: function updateVerts(comp) {
            var renderData = comp.renderData;
            if (renderData) {
                var node = comp.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, datas = renderData.datas;
                datas[0].x = -appx, datas[0].y = -appy, datas[3].x = width - appx, datas[3].y = height - appy;
            }
        }
    };
    addon(ttf, ttfUtils);
    var labelAssembler = {
        getAssembler: function getAssembler(comp) {
            var assembler = ttf;
            return comp.font instanceof BitmapFont ? assembler = bmfont : comp.cacheMode === LabelComponent.CacheMode.CHAR && (sys.browserType === sys.BROWSER_TYPE_WECHAT_GAME_SUB ? warn("sorry, subdomain does not support CHAR mode currently!") : assembler = letter), 
            assembler;
        }
    };
    LabelComponent.Assembler = labelAssembler;
    var _stencilManager = StencilManager.sharedManager, maskAssembler = {
        createData: function createData(mask) {
            var renderData = mask.requestRenderData();
            return renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6, 
            renderData;
        },
        updateRenderData: function updateRenderData(mask) {
            var renderData = mask.renderData;
            renderData && renderData.vertDirty && this.updateVerts && this.updateVerts(mask);
        },
        updateVerts: function updateVerts(mask) {
            var renderData = mask.renderData;
            if (renderData) {
                var l, b, r, t, node = mask.node, datas = renderData.datas, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch;
                l = -appx, b = -appy, r = cw - appx, t = ch - appy, datas[0].x = l, datas[0].y = b, 
                datas[3].x = r, datas[3].y = t, renderData.vertDirty = !1;
            }
        },
        fillBuffers: function fillBuffers(mask, renderer) {
            _stencilManager.pushMask(mask), _stencilManager.clear(), mask.clearGraphics.updateAssembler(renderer), 
            _stencilManager.enterLevel(), mask.graphics.updateAssembler(renderer), _stencilManager.enableMask();
        }
    }, maskEndAssembler = {
        fillBuffers: function fillBuffers(mask, ui) {
            _stencilManager.exitMask();
        }
    }, StartAssembler = {
        getAssembler: function getAssembler() {
            return maskAssembler;
        }
    }, PostAssembler = {
        getAssembler: function getAssembler() {
            return maskEndAssembler;
        }
    };
    MaskComponent.Assembler = StartAssembler, MaskComponent.PostAssembler = PostAssembler;
    var FillType$1 = SpriteComponent.FillType, matrix = new Mat4, barFilled = {
        useModel: !1,
        updateRenderData: function updateRenderData(sprite) {
            var frame = sprite.spriteFrame, renderData = sprite.renderData;
            if (renderData && frame) {
                var uvDirty = renderData.uvDirty, vertDirty = renderData.vertDirty;
                if (!uvDirty && !vertDirty) return;
                var fillStart = sprite.fillStart, fillRange = sprite.fillRange;
                fillRange < 0 && (fillStart += fillRange, fillRange = -fillRange), fillRange = (fillRange = (fillRange = fillStart + fillRange) > 1 ? 1 : fillRange) < 0 ? 0 : fillRange;
                var fillEnd = (fillStart = (fillStart = fillStart > 1 ? 1 : fillStart) < 0 ? 0 : fillStart) + (fillRange = (fillRange -= fillStart) < 0 ? 0 : fillRange);
                fillEnd = fillEnd > 1 ? 1 : fillEnd, uvDirty && this.updateUVs(sprite, fillStart, fillEnd), 
                vertDirty && (this.updateVerts && this.updateVerts(sprite, fillStart, fillEnd), 
                this.updateWorldVerts(sprite));
            }
        },
        updateUVs: function updateUVs(sprite, fillStart, fillEnd) {
            var spriteFrame = sprite.spriteFrame, renderData = sprite.renderData, datas = renderData.datas, atlasWidth = spriteFrame.width, atlasHeight = spriteFrame.height, textureRect = spriteFrame.getRect(), ul = 0, vb = 0, quadUV0 = 0, quadUV1 = 0, quadUV2 = 0, quadUV3 = 0, quadUV4 = 0, quadUV5 = 0, quadUV6 = 0, quadUV7 = 0;
            switch (spriteFrame.isRotated() ? (ul = textureRect.x / atlasWidth, vb = (textureRect.y + textureRect.width) / atlasHeight, 
            quadUV0 = quadUV2 = ul, quadUV4 = quadUV6 = (textureRect.x + textureRect.height) / atlasWidth, 
            quadUV3 = quadUV7 = vb, quadUV1 = quadUV5 = textureRect.y / atlasHeight) : (ul = textureRect.x / atlasWidth, 
            vb = (textureRect.y + textureRect.height) / atlasHeight, quadUV0 = quadUV4 = ul, 
            quadUV2 = quadUV6 = (textureRect.x + textureRect.width) / atlasWidth, quadUV1 = quadUV3 = vb, 
            quadUV5 = quadUV7 = textureRect.y / atlasHeight), sprite.fillType) {
              case FillType$1.HORIZONTAL:
                datas[0].u = quadUV0 + (quadUV2 - quadUV0) * fillStart, datas[0].v = quadUV1 + (quadUV3 - quadUV1) * fillStart, 
                datas[1].u = quadUV0 + (quadUV2 - quadUV0) * fillEnd, datas[1].v = quadUV1 + (quadUV3 - quadUV1) * fillEnd, 
                datas[2].u = quadUV4 + (quadUV6 - quadUV4) * fillStart, datas[2].v = quadUV5 + (quadUV7 - quadUV5) * fillStart, 
                datas[3].u = quadUV4 + (quadUV6 - quadUV4) * fillEnd, datas[3].v = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
                break;

              case FillType$1.VERTICAL:
                datas[0].u = quadUV0 + (quadUV4 - quadUV0) * fillStart, datas[0].v = quadUV1 + (quadUV5 - quadUV1) * fillStart, 
                datas[1].u = quadUV2 + (quadUV6 - quadUV2) * fillStart, datas[1].v = quadUV3 + (quadUV7 - quadUV3) * fillStart, 
                datas[2].u = quadUV0 + (quadUV4 - quadUV0) * fillEnd, datas[2].v = quadUV1 + (quadUV5 - quadUV1) * fillEnd, 
                datas[3].u = quadUV2 + (quadUV6 - quadUV2) * fillEnd, datas[3].v = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
                break;

              default:
                errorID(2626);
            }
            renderData.uvDirty = !1;
        },
        updateVerts: function updateVerts(sprite, fillStart, fillEnd) {
            var renderData = sprite.renderData, datas = renderData.datas, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, l = -appx, b = -appy, r = width - appx, t = height - appy, progressEnd = 0;
            switch (sprite.fillType) {
              case FillType$1.HORIZONTAL:
                progressEnd = l + (r - l) * fillEnd, l = l + (r - l) * fillStart, r = progressEnd;
                break;

              case FillType$1.VERTICAL:
                progressEnd = b + (t - b) * fillEnd, b = b + (t - b) * fillStart, t = progressEnd;
                break;

              default:
                errorID(2626);
            }
            datas[4].x = l, datas[4].y = b, datas[5].x = r, datas[5].y = b, datas[6].x = l, 
            datas[6].y = t, datas[7].x = r, datas[7].y = t, renderData.vertDirty = !1;
        },
        createData: function createData(sprite) {
            var renderData = sprite.requestRenderData();
            renderData.dataLength = 8, renderData.vertexCount = 4, renderData.indiceCount = 6;
            var _iterator = renderData.datas, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.z = 0;
            }
            return renderData;
        },
        updateWorldVerts: function updateWorldVerts(sprite) {
            var node = sprite.node, datas = sprite.renderData.datas;
            node.getWorldMatrix(matrix);
            for (var i = 0; i < 4; i++) {
                var local = datas[i + 4], world = datas[i];
                Vec3.transformMat4(world, local, matrix);
            }
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
            sprite.node.hasChangedFlags && this.updateWorldVerts(sprite);
            sprite.node;
            !function fillVerticesWithoutCalc3D(node, renderer, renderData, color) {
                var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
                buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
                vertexCount = 0, indiceOffset = 0, vertexId = 0);
                for (var vbuf = buffer.vData, i = 0; i < vertexCount; i++) {
                    var vert = datas[i];
                    vbuf[vertexOffset++] = vert.x, vbuf[vertexOffset++] = vert.y, vbuf[vertexOffset++] = vert.z, 
                    vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.toArray(vbuf, color, vertexOffset), 
                    vertexOffset += 4;
                }
                var ibuf = buffer.iData;
                ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, 
                ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 3, ibuf[indiceOffset++] = vertexId + 2;
            }(0, renderer, sprite.renderData, sprite.color);
        }
    }, PI_2 = 2 * Math.PI, _vertPos = [ new Vec2, new Vec2, new Vec2, new Vec2 ], _vertices = new Array(4), _uvs = new Array(8), _intersectPoint_1 = [ new Vec2, new Vec2, new Vec2, new Vec2 ], _intersectPoint_2 = [ new Vec2, new Vec2, new Vec2, new Vec2 ], _center = new Vec2, _triangles = [ new Vec2, new Vec2, new Vec2, new Vec2 ];
    function _calcIntersectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
        var sinAngle = Math.sin(angle);
        sinAngle = Math.abs(sinAngle) > 1e-6 ? sinAngle : 0;
        var cosAngle = Math.cos(angle), tanAngle = 0, cotAngle = 0;
        if (0 !== (cosAngle = Math.abs(cosAngle) > 1e-6 ? cosAngle : 0)) {
            if (tanAngle = sinAngle / cosAngle, (left - center.x) * cosAngle > 0) {
                var yleft = center.y + tanAngle * (left - center.x);
                intersectPoints[0].x = left, intersectPoints[0].y = yleft;
            }
            if ((right - center.x) * cosAngle > 0) {
                var yright = center.y + tanAngle * (right - center.x);
                intersectPoints[2].x = right, intersectPoints[2].y = yright;
            }
        }
        if (0 !== sinAngle) {
            if (cotAngle = cosAngle / sinAngle, (top - center.y) * sinAngle > 0) {
                var xtop = center.x + cotAngle * (top - center.y);
                intersectPoints[3].x = xtop, intersectPoints[3].y = top;
            }
            if ((bottom - center.y) * sinAngle > 0) {
                var xbottom = center.x + cotAngle * (bottom - center.y);
                intersectPoints[1].x = xbottom, intersectPoints[1].y = bottom;
            }
        }
    }
    function _getVertAngle(start, end) {
        var placementX = end.x - start.x, placementY = end.y - start.y;
        if (0 === placementX && 0 === placementY) return 0;
        if (0 === placementX) return placementY > 0 ? .5 * Math.PI : 1.5 * Math.PI;
        var angle = Math.atan(placementY / placementX);
        return placementX < 0 && (angle += Math.PI), angle;
    }
    function _generateTriangle(datas, offset, vert0, vert1, vert2) {
        var vertices = _vertices, v0x = vertices[0], v0y = vertices[1], v1x = vertices[2], v1y = vertices[3];
        datas[offset].x = vert0.x, datas[offset].y = vert0.y, datas[offset + 1].x = vert1.x, 
        datas[offset + 1].y = vert1.y, datas[offset + 2].x = vert2.x, datas[offset + 2].y = vert2.y;
        _generateUV((vert0.x - v0x) / (v1x - v0x), (vert0.y - v0y) / (v1y - v0y), datas, offset), 
        _generateUV((vert1.x - v0x) / (v1x - v0x), (vert1.y - v0y) / (v1y - v0y), datas, offset + 1), 
        _generateUV((vert2.x - v0x) / (v1x - v0x), (vert2.y - v0y) / (v1y - v0y), datas, offset + 2);
    }
    function _generateUV(progressX, progressY, data, offset) {
        var uvs = _uvs, px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX, px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX, py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX, py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX, uv = data[offset];
        uv.u = px1 + (px2 - px1) * progressY, uv.v = py1 + (py2 - py1) * progressY;
    }
    for (var radialFilled = {
        useModel: !1,
        createData: function createData(sprite) {
            return sprite.requestRenderData();
        },
        updateRenderData: function updateRenderData(sprite) {
            var frame = sprite.spriteFrame, renderData = sprite.renderData;
            if (renderData && frame && (renderData.vertDirty || renderData.uvDirty)) {
                var datas = renderData.datas, fillStart = sprite.fillStart, fillRange = sprite.fillRange;
                for (fillRange < 0 && (fillStart += fillRange, fillRange = -fillRange); fillStart >= 1; ) fillStart -= 1;
                for (;fillStart < 0; ) fillStart += 1;
                var fillEnd = (fillStart *= PI_2) + (fillRange *= PI_2);
                !function _calculateVertices(sprite) {
                    var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, l = -appx, b = -appy, r = width - appx, t = height - appy, vertices = _vertices;
                    vertices[0] = l, vertices[1] = b, vertices[2] = r, vertices[3] = t;
                    var fillCenter = sprite.fillCenter, cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l, cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
                    _vertPos[0].x = _vertPos[3].x = l, _vertPos[1].x = _vertPos[2].x = r, _vertPos[0].y = _vertPos[1].y = b, 
                    _vertPos[2].y = _vertPos[3].y = t;
                    var _iterator = _triangles, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var num = _ref;
                        Vec2.set(num, 0, 0);
                    }
                    cx !== vertices[0] && Vec2.set(_triangles[0], 3, 0), cx !== vertices[2] && Vec2.set(_triangles[2], 1, 2), 
                    cy !== vertices[1] && Vec2.set(_triangles[1], 0, 1), cy !== vertices[3] && Vec2.set(_triangles[3], 2, 3);
                }(sprite), function _calculateUVs(spriteFrame) {
                    var atlasWidth = spriteFrame.width, atlasHeight = spriteFrame.height, textureRect = spriteFrame.getRect(), u0 = 0, u1 = 0, v0 = 0, v1 = 0, uvs = _uvs;
                    spriteFrame.isRotated() ? (u0 = textureRect.x / atlasWidth, u1 = (textureRect.x + textureRect.height) / atlasWidth, 
                    v0 = textureRect.y / atlasHeight, v1 = (textureRect.y + textureRect.width) / atlasHeight, 
                    uvs[0] = uvs[2] = u0, uvs[4] = uvs[6] = u1, uvs[3] = uvs[7] = v1, uvs[1] = uvs[5] = v0) : (u0 = textureRect.x / atlasWidth, 
                    u1 = (textureRect.x + textureRect.width) / atlasWidth, v0 = textureRect.y / atlasHeight, 
                    v1 = (textureRect.y + textureRect.height) / atlasHeight, uvs[0] = uvs[4] = u0, uvs[2] = uvs[6] = u1, 
                    uvs[1] = uvs[3] = v1, uvs[5] = uvs[7] = v0);
                }(frame), _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1), 
                _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);
                for (var offset = 0, triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
                    var triangle = _triangles[triangleIndex];
                    if (triangle) if (fillRange >= PI_2) renderData.dataLength = offset + 3, _generateTriangle(datas, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]), 
                    offset += 3; else {
                        var startAngle = _getVertAngle(_center, _vertPos[triangle.x]), endAngle = _getVertAngle(_center, _vertPos[triangle.y]);
                        endAngle < startAngle && (endAngle += PI_2), startAngle -= PI_2, endAngle -= PI_2;
                        for (var testIndex = 0; testIndex < 3; ++testIndex) startAngle >= fillEnd || (startAngle >= fillStart ? (renderData.dataLength = offset + 3, 
                        _generateTriangle(datas, offset, _center, _vertPos[triangle.x], endAngle >= fillEnd ? _intersectPoint_2[triangleIndex] : _vertPos[triangle.y]), 
                        offset += 3) : endAngle <= fillStart || (endAngle <= fillEnd ? (renderData.dataLength = offset + 3, 
                        _generateTriangle(datas, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y]), 
                        offset += 3) : (renderData.dataLength = offset + 3, _generateTriangle(datas, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]), 
                        offset += 3))), startAngle += PI_2, endAngle += PI_2;
                    }
                }
                renderData.indiceCount = renderData.vertexCount = offset, renderData.vertDirty = renderData.uvDirty = !1;
            }
        },
        fillBuffers: function fillBuffers(comp, renderer) {
            !function fillVertices3D(node, renderer, renderData, color) {
                var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
                buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
                vertexCount = 0, indiceOffset = 0, vertexId = 0);
                var vbuf = buffer.vData;
                node.getWorldMatrix(_worldMatrix$1);
                for (var i = 0; i < vertexCount; i++) {
                    var vert = datas[i];
                    Vec3.set(vec3_temp, vert.x, vert.y, 0), Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix$1), 
                    vbuf[vertexOffset++] = vec3_temp.x, vbuf[vertexOffset++] = vec3_temp.y, vbuf[vertexOffset++] = vec3_temp.z, 
                    vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.toArray(vbuf, color, vertexOffset), 
                    vertexOffset += 4;
                }
                for (var ibuf = buffer.iData, _i = 0; _i < renderData.dataLength; _i++) ibuf[indiceOffset + _i] = vertexId + _i;
            }(comp.node, renderer, comp.renderData, comp.color);
        }
    }, vec3_temps$1 = [], i$2 = 0; i$2 < 4; i$2++) vec3_temps$1.push(new Vec3);
    for (var simple = {
        createData: function createData(sprite) {
            var renderData = sprite.requestRenderData();
            return renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6, 
            renderData.vData = new Float32Array(36), renderData;
        },
        updateRenderData: function updateRenderData(sprite) {
            var frame = sprite.spriteFrame, renderData = sprite.renderData;
            renderData && frame && (renderData.vertDirty && this.updateVerts(sprite), renderData.uvDirty && this.updateUvs(sprite));
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
            if (null !== sprite) {
                var datas = sprite.renderData.datas, node = sprite.node, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
                buffer.request() || (buffer = renderer.currBufferBatch, vertexOffset = 0, indiceOffset = 0, 
                vertexId = 0);
                var vbuf = buffer.vData, ibuf = buffer.iData, vData = sprite.renderData.vData, data0 = datas[0], data3 = datas[3], matrix = node.worldMatrix, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13, vl = data0.x, vr = data3.x, vb = data0.y, vt = data3.y, al = a * vl, ar = a * vr, bl = b * vl, br = b * vr, cb = c * vb, ct = c * vt, db = d * vb, dt = d * vt;
                vData[0] = al + cb + tx, vData[1] = bl + db + ty, vData[9] = ar + cb + tx, vData[10] = br + db + ty, 
                vData[18] = al + ct + tx, vData[19] = bl + dt + ty, vData[27] = ar + ct + tx, vData[28] = br + dt + ty, 
                vbuf.set(vData, vertexOffset), ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, 
                ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 1, 
                ibuf[indiceOffset++] = vertexId + 3;
            }
        },
        updateVerts: function updateVerts(sprite) {
            var renderData = sprite.renderData;
            if (renderData) {
                var node = sprite.node, datas = renderData.datas, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l = 0, b = 0, r = 0, t = 0;
                if (sprite.trim) l = -appx, b = -appy, r = cw - appx, t = ch - appy; else {
                    var frame = sprite.spriteFrame, originSize = frame.getOriginalSize(), rect = frame.getRect(), ow = originSize.width, oh = originSize.height, rw = rect.width, rh = rect.height, offset = frame.getOffset(), scaleX = cw / ow, scaleY = ch / oh, trimLeft = offset.x + (ow - rw) / 2, trimRight = offset.x - (ow - rw) / 2;
                    l = trimLeft * scaleX - appx, b = (offset.y + (oh - rh) / 2) * scaleY - appy, r = cw + trimRight * scaleX - appx, 
                    t = ch + (offset.y - (oh - rh) / 2) * scaleY - appy;
                }
                datas[0].x = l, datas[0].y = b, datas[0].z = 0, datas[3].x = r, datas[3].y = t, 
                datas[3].z = 0, renderData.vertDirty = !1;
            }
        },
        updateUvs: function updateUvs(sprite) {
            var renderData = sprite.renderData, vData = renderData.vData, uv = sprite.spriteFrame.uv;
            vData[3] = uv[0], vData[4] = uv[1], vData[12] = uv[2], vData[13] = uv[3], vData[21] = uv[4], 
            vData[22] = uv[5], vData[30] = uv[6], vData[31] = uv[7], renderData.uvDirty = !1;
        },
        updateColor: function updateColor(sprite) {
            for (var vData = sprite.renderData.vData, colorOffset = 5, color = sprite.color, colorr = color.r / 255, colorg = color.g / 255, colorb = color.b / 255, colora = color.a / 255, _i = 0; _i < 4; _i++) vData[colorOffset] = colorr, 
            vData[colorOffset + 1] = colorg, vData[colorOffset + 2] = colorb, vData[colorOffset + 3] = colora, 
            colorOffset += 9;
        }
    }, vec3_temp$1 = new Vec3, matrix$1 = new Mat4, sliced = {
        useModel: !1,
        createData: function createData(sprite) {
            var renderData = sprite.requestRenderData();
            return renderData.dataLength = 20, renderData.vertexCount = 16, renderData.indiceCount = 54, 
            renderData;
        },
        updateRenderData: function updateRenderData(sprite) {
            var frame = sprite.spriteFrame, renderData = sprite.renderData;
            renderData && frame && (renderData.vertDirty && (this.updateVerts(sprite), this.updateWorldVerts(sprite)));
        },
        updateVerts: function updateVerts(sprite) {
            var renderData = sprite.renderData, datas = renderData.datas, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, frame = sprite.spriteFrame, leftWidth = frame.insetLeft, rightWidth = frame.insetRight, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, sizableWidth = width - leftWidth - rightWidth, sizableHeight = height - topHeight - bottomHeight, xScale = width / (leftWidth + rightWidth), yScale = height / (topHeight + bottomHeight);
            xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale, yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale, 
            sizableWidth = sizableWidth < 0 ? 0 : sizableWidth, sizableHeight = sizableHeight < 0 ? 0 : sizableHeight, 
            datas[0].x = -appx, datas[0].y = -appy, datas[1].x = leftWidth * xScale - appx, 
            datas[1].y = bottomHeight * yScale - appy, datas[2].x = datas[1].x + sizableWidth, 
            datas[2].y = datas[1].y + sizableHeight, datas[3].x = width - appx, datas[3].y = height - appy, 
            renderData.vertDirty = !1;
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
            sprite.node.hasChangedFlags && this.updateWorldVerts(sprite);
            var buffer = renderer.currBufferBatch, renderData = sprite.renderData, datas = renderData.datas, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset, uvSliced = sprite.spriteFrame.uvSliced;
            buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
            vertexOffset = 0, indiceOffset = 0, vertexId = 0);
            for (var vbuf = buffer.vData, ibuf = buffer.iData, i = 4; i < 20; ++i) {
                var vert = datas[i], uvs = uvSliced[i - 4];
                vbuf[vertexOffset++] = vert.x, vbuf[vertexOffset++] = vert.y, vbuf[vertexOffset++] = vert.z, 
                vbuf[vertexOffset++] = uvs.u, vbuf[vertexOffset++] = uvs.v, Color.toArray(vbuf, sprite.color, vertexOffset), 
                vertexOffset += 4;
            }
            for (var r = 0; r < 3; ++r) for (var c = 0; c < 3; ++c) {
                var start = vertexId + 4 * r + c;
                ibuf[indiceOffset++] = start, ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 4, 
                ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 5, ibuf[indiceOffset++] = start + 4;
            }
        },
        updateWorldVerts: function updateWorldVerts(sprite) {
            var node = sprite.node, datas = sprite.renderData.datas;
            node.getWorldMatrix(matrix$1);
            for (var row = 0; row < 4; ++row) for (var rowD = datas[row], col = 0; col < 4; ++col) {
                var colD = datas[col], world = datas[4 + 4 * row + col];
                Vec3.set(vec3_temp$1, colD.x, rowD.y, 0), Vec3.transformMat4(world, vec3_temp$1, matrix$1);
            }
        }
    }, vec3_temps$2 = [], i$3 = 0; i$3 < 4; i$3++) vec3_temps$2.push(new Vec3);
    var _dec$1u, _dec2$13, _dec3$O, _dec4$H, _dec5$E, _dec6$x, _dec7$u, _class$1v, _class2$1i, _descriptor$17, _descriptor2$X, _descriptor3$L, _descriptor4$B, tilled = {
        useModel: !1,
        createData: function createData(sprite) {
            return sprite.requestRenderData();
        },
        updateRenderData: function updateRenderData(sprite) {
            var renderData = sprite.renderData, frame = sprite.spriteFrame;
            if (frame && renderData && (renderData.uvDirty || renderData.vertDirty)) {
                var node = sprite.node, contentWidth = Math.abs(node.width), contentHeight = Math.abs(node.height), appx = node.anchorX * contentWidth, appy = node.anchorY * contentHeight, rect = frame.getRect(), rectWidth = rect.width, rectHeight = rect.height, hRepeat = contentWidth / rectWidth, vRepeat = contentHeight / rectHeight, row = Math.ceil(vRepeat), col = Math.ceil(hRepeat), datas = renderData.datas;
                renderData.dataLength = Math.max(8, row + 1, col + 1);
                for (var _i = 0; _i <= col; ++_i) datas[_i].x = Math.min(rectWidth * _i, contentWidth) - appx;
                for (var _i2 = 0; _i2 <= row; ++_i2) datas[_i2].y = Math.min(rectHeight * _i2, contentHeight) - appy;
                renderData.vertexCount = row * col * 4, renderData.indiceCount = row * col * 6, 
                renderData.uvDirty = !1, renderData.vertDirty = !1;
            }
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
            var node = sprite.node, renderData = sprite.renderData, buffer = renderer.currBufferBatch, indiceOffset = buffer.indiceOffset, vertexOffset = buffer.byteOffset >> 2, vertexId = buffer.vertexOffset, vertexCount = renderData.vertexCount, indiceCount = renderData.indiceCount, vbuf = buffer.vData, ibuf = buffer.iData;
            buffer.request(vertexCount, indiceCount) || (buffer = renderer.currBufferBatch, 
            vertexOffset = 0, indiceOffset = 0, vertexId = 0);
            var frame = sprite.spriteFrame, rotated = frame.isRotated(), uv = frame.uv, rect = frame.getRect(), contentWidth = Math.abs(node.width), contentHeight = Math.abs(node.height), hRepeat = contentWidth / rect.width, vRepeat = contentHeight / rect.height, row = Math.ceil(vRepeat), col = Math.ceil(hRepeat), matrix = node.worldMatrix;
            this.fillVertices(vbuf, vertexOffset, matrix, row, col, renderData.datas);
            for (var coefu = 0, coefv = 0, yindex = 0, ylength = row; yindex < ylength; ++yindex) {
                coefv = Math.min(1, vRepeat - yindex);
                for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
                    coefu = Math.min(1, hRepeat - xindex);
                    var vertexOffsetU = vertexOffset + 3, vertexOffsetV = vertexOffsetU + 1;
                    rotated ? (vbuf[vertexOffsetU] = uv[0], vbuf[vertexOffsetV] = uv[1], vbuf[vertexOffsetU + 9] = uv[0], 
                    vbuf[vertexOffsetV + 9] = uv[1] + (uv[7] - uv[1]) * coefu, vbuf[vertexOffsetU + 18] = uv[0] + (uv[6] - uv[0]) * coefv, 
                    vbuf[vertexOffsetV + 18] = uv[1], vbuf[vertexOffsetU + 27] = vbuf[vertexOffsetU + 18], 
                    vbuf[vertexOffsetV + 27] = vbuf[vertexOffsetV + 9]) : (vbuf[vertexOffsetU] = uv[0], 
                    vbuf[vertexOffsetV] = uv[1], vbuf[vertexOffsetU + 9] = uv[0] + (uv[6] - uv[0]) * coefu, 
                    vbuf[vertexOffsetV + 9] = uv[1], vbuf[vertexOffsetU + 18] = uv[0], vbuf[vertexOffsetV + 18] = uv[1] + (uv[7] - uv[1]) * coefv, 
                    vbuf[vertexOffsetU + 27] = vbuf[vertexOffsetU + 9], vbuf[vertexOffsetV + 27] = vbuf[vertexOffsetV + 18]), 
                    Color.toArray(vbuf, sprite.color, vertexOffsetV + 1), Color.toArray(vbuf, sprite.color, vertexOffsetV + 9 + 1), 
                    Color.toArray(vbuf, sprite.color, vertexOffsetV + 18 + 1), Color.toArray(vbuf, sprite.color, vertexOffsetV + 27 + 1), 
                    vertexOffset += 36;
                }
            }
            for (var _i3 = 0; _i3 < indiceCount; _i3 += 6) ibuf[indiceOffset++] = vertexId, 
            ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 1, 
            ibuf[indiceOffset++] = vertexId + 3, ibuf[indiceOffset++] = vertexId + 2, vertexId += 4;
        },
        fillVertices: function fillVertices(vbuf, vertexOffset, matrix, row, col, datas) {
            for (var x = 0, x1 = 0, y = 0, y1 = 0, yindex = 0, ylength = row; yindex < ylength; ++yindex) {
                y = datas[yindex].y, y1 = datas[yindex + 1].y;
                for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
                    x = datas[xindex].x, x1 = datas[xindex + 1].x, Vec3.set(vec3_temps$2[0], x, y, 0), 
                    Vec3.set(vec3_temps$2[1], x1, y, 0), Vec3.set(vec3_temps$2[2], x, y1, 0), Vec3.set(vec3_temps$2[3], x1, y1, 0);
                    for (var _i4 = 0; _i4 < 4; _i4++) {
                        var vec3_temp = vec3_temps$2[_i4];
                        Vec3.transformMat4(vec3_temp, vec3_temp, matrix);
                        var offset = 9 * _i4;
                        vbuf[vertexOffset + offset] = vec3_temp.x, vbuf[vertexOffset + offset + 1] = vec3_temp.y, 
                        vbuf[vertexOffset + offset + 2] = vec3_temp.z;
                    }
                    vertexOffset += 36;
                }
            }
        }
    }, SpriteType$1 = SpriteComponent.Type, FillType$2 = SpriteComponent.FillType, spriteAssembler = {
        getAssembler: function getAssembler(spriteComp) {
            var util = simple, comp = spriteComp;
            switch (comp.type) {
              case SpriteType$1.SLICED:
                util = sliced;
                break;

              case SpriteType$1.TILED:
                util = tilled;
                break;

              case SpriteType$1.FILLED:
                util = comp.fillType === FillType$2.RADIAL ? radialFilled : barFilled;
            }
            return util;
        }
    };
    SpriteComponent.Assembler = spriteAssembler, cc.UI = {
        MeshBuffer: MeshBuffer,
        UIVertexFormat: UIVertexFormat,
        barFilled: barFilled,
        radialFilled: radialFilled,
        simple: simple,
        sliced: sliced,
        ttf: ttf,
        bmfont: bmfont,
        letter: letter,
        mask: maskAssembler,
        maskEnd: maskEndAssembler,
        graphics: graphicsAssembler,
        spriteAssembler: spriteAssembler,
        graphicsAssembler: graphicsAssemblerManager,
        labelAssembler: labelAssembler
    };
    var _dec$1v, _dec2$14, _dec3$P, _dec4$I, _dec5$F, _class$1w, _class2$1j, _descriptor$18, _descriptor2$Y, _descriptor3$M, _descriptor4$C, _descriptor5$t, _descriptor6$i, _descriptor7$g, _descriptor8$f, _class3$C, _temp$1m, _class$1x, _class2$1k, _descriptor$19, _descriptor2$Z, _class4$9, _class5$8, _descriptor3$N, _descriptor4$D, _class7$2, _class8$2, _descriptor5$u, _descriptor6$j, _descriptor7$h, _class9, _temp3$2, _dec$1x, _dec2$16, _dec3$R, _dec4$J, _dec5$G, _dec6$y, _class$1y, _class2$1l, _descriptor$1a, _descriptor2$_, _descriptor3$O, _descriptor4$E, _descriptor5$v, _descriptor6$k, _descriptor7$i, _class3$D, _temp$1o, _dec$1y, _dec2$17, _dec3$S, _dec4$K, _dec5$H, _dec6$z, _dec7$v, _dec8$l, _dec9$f, _dec10$e, _dec11$e, _dec12$c, _dec13$b, _class$1z, _class2$1m, _descriptor$1b, _descriptor2$$, _descriptor3$P, _descriptor4$F, _descriptor5$w, _descriptor6$l, _descriptor7$j, _dec$1z, _dec2$18, _dec3$T, _class$1A, _class2$1n, _descriptor$1c, _descriptor2$10, _dec$1A, _dec2$19, _dec3$U, _dec4$L, _dec5$I, _dec6$A, _class$1B, _class2$1o, _descriptor$1d, _descriptor2$11, _descriptor3$Q, _descriptor4$G, _descriptor5$x, BillboardComponent = (_dec$1u = ccclass("cc.BillboardComponent"), 
    _dec2$13 = menu("Components/Billboard"), _dec3$O = property({
        type: Texture2D
    }), _dec4$H = property({
        type: Texture2D,
        tooltip: "billboard显示的贴图"
    }), _dec5$E = property({
        tooltip: "billboard的高度"
    }), _dec6$x = property({
        tooltip: "billboard的宽度"
    }), _dec7$u = property({
        tooltip: "billboard绕中心点旋转的角度"
    }), _dec$1u(_class$1v = _dec2$13(_class$1v = executeInEditMode((_descriptor$17 = _applyDecoratedDescriptor((_class2$1i = function(_Component) {
        function BillboardComponent() {
            var _this;
            return _classCallCheck(this, BillboardComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BillboardComponent).call(this)), "_texture", _descriptor$17, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_height", _descriptor2$X, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_width", _descriptor3$L, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_rotation", _descriptor4$B, _assertThisInitialized(_this)), 
            _this._model = null, _this._mesh = null, _this._material = null, _this._uniform = new Vec4(1, 1, 0, 0), 
            _this;
        }
        return _inherits(BillboardComponent, _Component), _createClass(BillboardComponent, [ {
            key: "texture",
            get: function get() {
                return this._texture;
            },
            set: function set(val) {
                this._texture = val, this._material && this._material.setProperty("mainTexture", val);
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            },
            set: function set(val) {
                this._height = val, this._material && (this._uniform.y = val, this._material.setProperty("cc_size_rotation", this._uniform));
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            },
            set: function set(val) {
                this._width = val, this._material && (this._uniform.x = val, this._material.setProperty("cc_size_rotation", this._uniform));
            }
        }, {
            key: "rotation",
            get: function get() {
                return Math.round(100 * toDegree(this._rotation)) / 100;
            },
            set: function set(val) {
                this._rotation = toRadian(val), this._material && (this._uniform.z = this._rotation, 
                this._material.setProperty("cc_size_rotation", this._uniform));
            }
        } ]), _createClass(BillboardComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this.createModel();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this.attachToScene(), this._model.enabled = !0, this.width = this._width, this.height = this._height, 
                this.rotation = this.rotation, this.texture = this.texture;
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.detachFromScene();
            }
        }, {
            key: "attachToScene",
            value: function attachToScene() {
                this._model && this.node && this.node.scene && (this._model.scene && this.detachFromScene(), 
                this._getRenderScene().addModel(this._model));
            }
        }, {
            key: "detachFromScene",
            value: function detachFromScene() {
                this._model && this._model.scene && this._model.scene.removeModel(this._model);
            }
        }, {
            key: "createModel",
            value: function createModel() {
                this._mesh = createMesh({
                    primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_LIST,
                    positions: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
                    uvs: [ 0, 0, 1, 0, 0, 1, 1, 1 ],
                    colors: [ Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a ],
                    attributes: [ {
                        name: exports.GFXAttributeName.ATTR_POSITION,
                        format: exports.GFXFormat.RGB32F
                    }, {
                        name: exports.GFXAttributeName.ATTR_TEX_COORD,
                        format: exports.GFXFormat.RG32F
                    }, {
                        name: exports.GFXAttributeName.ATTR_COLOR,
                        format: exports.GFXFormat.RGBA8UI,
                        isNormalized: !0
                    } ],
                    indices: [ 0, 1, 2, 1, 2, 3 ]
                }, void 0, {
                    calculateBounds: !1
                }), this._model = cc.director.root.createModel(Model, this.node), this._model.initialize(this.node), 
                null == this._material && (this._material = new Material, this._material.copy(builtinResMgr.get("default-billboard-material"))), 
                this._model.initSubModel(0, this._mesh.getSubMesh(0), this._material);
            }
        } ]), BillboardComponent;
    }(Component)).prototype, "_texture", [ _dec3$O ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _applyDecoratedDescriptor(_class2$1i.prototype, "texture", [ _dec4$H ], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "texture"), _class2$1i.prototype), 
    _descriptor2$X = _applyDecoratedDescriptor(_class2$1i.prototype, "_height", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _applyDecoratedDescriptor(_class2$1i.prototype, "height", [ _dec5$E ], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "height"), _class2$1i.prototype), 
    _descriptor3$L = _applyDecoratedDescriptor(_class2$1i.prototype, "_width", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _applyDecoratedDescriptor(_class2$1i.prototype, "width", [ _dec6$x ], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "width"), _class2$1i.prototype), 
    _descriptor4$B = _applyDecoratedDescriptor(_class2$1i.prototype, "_rotation", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _applyDecoratedDescriptor(_class2$1i.prototype, "rotation", [ _dec7$u ], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "rotation"), _class2$1i.prototype), 
    _class$1v = _class2$1i)) || _class$1v) || _class$1v) || _class$1v), _vertex_attrs = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RGBA32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD1,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA8,
        isNormalized: !0
    } ], _temp_v1 = new Vec3, _temp_v2 = new Vec3, LineModel = function(_Model) {
        function LineModel() {
            var _this;
            return _classCallCheck(this, LineModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(LineModel).call(this)))._vertSize = 0, 
            _this._vBuffer = null, _this._vertAttrsFloatCount = 0, _this._vdataF32 = null, _this._vdataUint32 = null, 
            _this._subMeshData = null, _this._vertCount = 0, _this._indexCount = 0, _this._capacity = 100, 
            _this._iaInfo = {
                drawInfos: [ {
                    vertexCount: 0,
                    firstVertex: 0,
                    indexCount: 0,
                    firstIndex: 0,
                    vertexOffset: 0,
                    instanceCount: 0,
                    firstInstance: 0
                } ]
            }, _this._iaInfoBuffer = _this._device.createBuffer({
                usage: exports.GFXBufferUsageBit.INDIRECT,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: 56,
                stride: 1
            }), _this;
        }
        return _inherits(LineModel, _Model), _createClass(LineModel, [ {
            key: "setCapacity",
            value: function setCapacity(capacity) {
                this._capacity = capacity, this.createBuffer();
            }
        }, {
            key: "createBuffer",
            value: function createBuffer() {
                this._vertSize = 0;
                var _iterator = _vertex_attrs, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var a = _ref;
                    a.offset = this._vertSize, this._vertSize += GFXFormatInfos[a.format].size;
                }
                this._vertAttrsFloatCount = this._vertSize / 4, this._vBuffer = this._createSubMeshData(), 
                this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
            }
        }, {
            key: "_createSubMeshData",
            value: function _createSubMeshData() {
                this._subMeshData && this.destroySubMeshData(), this._vertCount = 2, this._indexCount = 6;
                var vertexBuffer = this._device.createBuffer({
                    usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: this._vertSize * this._capacity * this._vertCount,
                    stride: this._vertSize
                }), vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
                vertexBuffer.update(vBuffer);
                for (var indices = new Uint16Array((this._capacity - 1) * this._indexCount), dst = 0, i = 0; i < this._capacity - 1; ++i) {
                    var baseIdx = 2 * i;
                    indices[dst++] = baseIdx, indices[dst++] = baseIdx + 1, indices[dst++] = baseIdx + 2, 
                    indices[dst++] = baseIdx + 3, indices[dst++] = baseIdx + 2, indices[dst++] = baseIdx + 1;
                }
                var indexBuffer = this._device.createBuffer({
                    usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: (this._capacity - 1) * this._indexCount * Uint16Array.BYTES_PER_ELEMENT,
                    stride: Uint16Array.BYTES_PER_ELEMENT
                });
                return indexBuffer.update(indices), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, 
                this._iaInfo.drawInfos[0].indexCount = (this._capacity - 1) * this._indexCount, 
                this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = {
                    vertexBuffers: [ vertexBuffer ],
                    indexBuffer: indexBuffer,
                    indirectBuffer: this._iaInfoBuffer,
                    attributes: _vertex_attrs,
                    primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_LIST,
                    flatBuffers: []
                }, this.setSubModelMesh(0, this._subMeshData), vBuffer;
            }
        }, {
            key: "addLineVertexData",
            value: function addLineVertexData(positions, width, color) {
                if (positions.length > 1) {
                    var offset = 0;
                    Vec3.subtract(_temp_v1, positions[1], positions[0]), this._vdataF32[offset++] = positions[0].x, 
                    this._vdataF32[offset++] = positions[0].y, this._vdataF32[offset++] = positions[0].z, 
                    this._vdataF32[offset++] = 0, this._vdataF32[offset++] = width.evaluate(0, 1), this._vdataF32[offset++] = 0, 
                    this._vdataF32[offset++] = 0, this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, 
                    this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(0, 1)._val, 
                    this._vdataF32[offset++] = positions[0].x, this._vdataF32[offset++] = positions[0].y, 
                    this._vdataF32[offset++] = positions[0].z, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(0, 1), 
                    this._vdataF32[offset++] = 0, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v1.x, 
                    this._vdataF32[offset++] = _temp_v1.y, this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(0, 1)._val;
                    for (var i = 1; i < positions.length - 1; i++) {
                        Vec3.subtract(_temp_v1, positions[i - 1], positions[i]), Vec3.subtract(_temp_v2, positions[i + 1], positions[i]), 
                        Vec3.subtract(_temp_v2, _temp_v2, _temp_v1);
                        var seg = i / positions.length;
                        this._vdataF32[offset++] = positions[i].x, this._vdataF32[offset++] = positions[i].y, 
                        this._vdataF32[offset++] = positions[i].z, this._vdataF32[offset++] = 0, this._vdataF32[offset++] = width.evaluate(seg, 1), 
                        this._vdataF32[offset++] = seg, this._vdataF32[offset++] = 0, this._vdataF32[offset++] = _temp_v2.x, 
                        this._vdataF32[offset++] = _temp_v2.y, this._vdataF32[offset++] = _temp_v2.z, this._vdataUint32[offset++] = color.evaluate(seg, 1)._val, 
                        this._vdataF32[offset++] = positions[i].x, this._vdataF32[offset++] = positions[i].y, 
                        this._vdataF32[offset++] = positions[i].z, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(seg, 1), 
                        this._vdataF32[offset++] = seg, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v2.x, 
                        this._vdataF32[offset++] = _temp_v2.y, this._vdataF32[offset++] = _temp_v2.z, this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
                    }
                    Vec3.subtract(_temp_v1, positions[positions.length - 1], positions[positions.length - 2]), 
                    this._vdataF32[offset++] = positions[positions.length - 1].x, this._vdataF32[offset++] = positions[positions.length - 1].y, 
                    this._vdataF32[offset++] = positions[positions.length - 1].z, this._vdataF32[offset++] = 0, 
                    this._vdataF32[offset++] = width.evaluate(1, 1), this._vdataF32[offset++] = 1, this._vdataF32[offset++] = 0, 
                    this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, this._vdataF32[offset++] = _temp_v1.z, 
                    this._vdataUint32[offset++] = color.evaluate(1, 1)._val, this._vdataF32[offset++] = positions[positions.length - 1].x, 
                    this._vdataF32[offset++] = positions[positions.length - 1].y, this._vdataF32[offset++] = positions[positions.length - 1].z, 
                    this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(1, 1), this._vdataF32[offset++] = 1, 
                    this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, 
                    this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
                }
                this.updateIA(Math.max(0, positions.length - 1));
            }
        }, {
            key: "updateIA",
            value: function updateIA(count) {
                this.getSubModel(0).inputAssembler.vertexBuffers[0].update(this._vdataF32), this.getSubModel(0).inputAssembler.indexCount = this._indexCount * count, 
                this.getSubModel(0).inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), this._iaInfoBuffer.update(this._iaInfo);
            }
        }, {
            key: "destroySubMeshData",
            value: function destroySubMeshData() {
                var _iterator2 = this._subMeshData.vertexBuffers, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2.destroy();
                }
                this._subMeshData.indexBuffer.destroy();
            }
        } ]), LineModel;
    }(Model), Mode$1 = Enum({
        Constant: 0,
        Curve: 1,
        TwoCurves: 2,
        TwoConstants: 3
    }), CurveRange = (_dec$1v = ccclass("cc.CurveRange"), _dec2$14 = property({
        type: Mode$1
    }), _dec3$P = property({
        type: AnimationCurve
    }), _dec4$I = property({
        type: AnimationCurve
    }), _dec5$F = property({
        type: AnimationCurve
    }), _dec$1v((_temp$1m = _class3$C = function() {
        function CurveRange() {
            _classCallCheck(this, CurveRange), _initializerDefineProperty(this, "mode", _descriptor$18, this), 
            _initializerDefineProperty(this, "curve", _descriptor2$Y, this), _initializerDefineProperty(this, "curveMin", _descriptor3$M, this), 
            _initializerDefineProperty(this, "curveMax", _descriptor4$C, this), _initializerDefineProperty(this, "constant", _descriptor5$t, this), 
            _initializerDefineProperty(this, "constantMin", _descriptor6$i, this), _initializerDefineProperty(this, "constantMax", _descriptor7$g, this), 
            _initializerDefineProperty(this, "multiplier", _descriptor8$f, this);
        }
        return _createClass(CurveRange, [ {
            key: "evaluate",
            value: function evaluate(time, rndRatio) {
                switch (this.mode) {
                  case Mode$1.Constant:
                    return this.constant;

                  case Mode$1.Curve:
                    return this.curve.evaluate(time) * this.multiplier;

                  case Mode$1.TwoCurves:
                    return lerp(this.curveMin.evaluate(time), this.curveMax.evaluate(time), rndRatio) * this.multiplier;

                  case Mode$1.TwoConstants:
                    return lerp(this.constantMin, this.constantMax, rndRatio);
                }
            }
        }, {
            key: "getMax",
            value: function getMax() {
                switch (this.mode) {
                  case Mode$1.Constant:
                    return this.constant;

                  case Mode$1.Curve:
                    return this.multiplier;

                  case Mode$1.TwoConstants:
                    return this.constantMax;

                  case Mode$1.TwoCurves:
                    return this.multiplier;
                }
                return 0;
            }
        } ]), CurveRange;
    }(), _class3$C.Mode = Mode$1, _descriptor$18 = _applyDecoratedDescriptor((_class2$1j = _temp$1m).prototype, "mode", [ _dec2$14 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Mode$1.Constant;
        }
    }), _descriptor2$Y = _applyDecoratedDescriptor(_class2$1j.prototype, "curve", [ _dec3$P ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new AnimationCurve;
        }
    }), _descriptor3$M = _applyDecoratedDescriptor(_class2$1j.prototype, "curveMin", [ _dec4$I ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new AnimationCurve;
        }
    }), _descriptor4$C = _applyDecoratedDescriptor(_class2$1j.prototype, "curveMax", [ _dec5$F ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new AnimationCurve;
        }
    }), _descriptor5$t = _applyDecoratedDescriptor(_class2$1j.prototype, "constant", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$i = _applyDecoratedDescriptor(_class2$1j.prototype, "constantMin", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor7$g = _applyDecoratedDescriptor(_class2$1j.prototype, "constantMax", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor8$f = _applyDecoratedDescriptor(_class2$1j.prototype, "multiplier", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _class$1w = _class2$1j)) || _class$1w), Mode$2 = Enum({
        Blend: 0,
        Fixed: 1
    }), Gradient = (ccclass("cc.ColorKey")((_descriptor$19 = _applyDecoratedDescriptor((_class2$1k = function ColorKey() {
        _classCallCheck(this, ColorKey), _initializerDefineProperty(this, "color", _descriptor$19, this), 
        _initializerDefineProperty(this, "time", _descriptor2$Z, this);
    }).prototype, "color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE.clone();
        }
    }), _descriptor2$Z = _applyDecoratedDescriptor(_class2$1k.prototype, "time", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$1x = _class2$1k)), ccclass("cc.AlphaKey")((_descriptor3$N = _applyDecoratedDescriptor((_class5$8 = function AlphaKey() {
        _classCallCheck(this, AlphaKey), _initializerDefineProperty(this, "alpha", _descriptor3$N, this), 
        _initializerDefineProperty(this, "time", _descriptor4$D, this);
    }).prototype, "alpha", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor4$D = _applyDecoratedDescriptor(_class5$8.prototype, "time", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class4$9 = _class5$8)), ccclass("cc.Gradient")((_temp3$2 = _class9 = function() {
        function Gradient() {
            _classCallCheck(this, Gradient), _initializerDefineProperty(this, "colorKeys", _descriptor5$u, this), 
            _initializerDefineProperty(this, "alphaKeys", _descriptor6$j, this), _initializerDefineProperty(this, "mode", _descriptor7$h, this), 
            this._color = Color.WHITE.clone();
        }
        return _createClass(Gradient, [ {
            key: "setKeys",
            value: function setKeys(colorKeys, alphaKeys) {
                this.colorKeys = colorKeys, this.alphaKeys = alphaKeys;
            }
        }, {
            key: "sortKeys",
            value: function sortKeys() {
                this.colorKeys.length > 1 && this.colorKeys.sort((function(a, b) {
                    return a.time - b.time;
                })), this.alphaKeys.length > 1 && this.alphaKeys.sort((function(a, b) {
                    return a.time - b.time;
                }));
            }
        }, {
            key: "evaluate",
            value: function evaluate(time) {
                return this.getRGB(time), this._color._set_a_unsafe(this.getAlpha(time)), this._color;
            }
        }, {
            key: "randomColor",
            value: function randomColor() {
                var c = this.colorKeys[Math.trunc(Math.random() * this.colorKeys.length)], a = this.alphaKeys[Math.trunc(Math.random() * this.alphaKeys.length)];
                return this._color.set(c.color), this._color._set_a_unsafe(a.alpha), this._color;
            }
        }, {
            key: "getRGB",
            value: function getRGB(time) {
                if (!(this.colorKeys.length > 1)) return 1 === this.colorKeys.length ? (this._color.set(this.colorKeys[0].color), 
                this._color) : (this._color.set(Color.WHITE), this._color);
                time = repeat(time, 1);
                for (var i = 1; i < this.colorKeys.length; ++i) {
                    var preTime = this.colorKeys[i - 1].time, curTime = this.colorKeys[i].time;
                    if (time >= preTime && time < curTime) {
                        if (this.mode === Mode$2.Fixed) return this.colorKeys[i].color;
                        var factor = (time - preTime) / (curTime - preTime);
                        return Color.lerp(this._color, this.colorKeys[i - 1].color, this.colorKeys[i].color, factor), 
                        this._color;
                    }
                }
                var lastIndex = this.colorKeys.length - 1;
                time < this.colorKeys[0].time ? Color.lerp(this._color, Color.BLACK, this.colorKeys[0].color, time / this.colorKeys[0].time) : time > this.colorKeys[lastIndex].time && Color.lerp(this._color, this.colorKeys[lastIndex].color, Color.BLACK, (time - this.colorKeys[lastIndex].time) / (1 - this.colorKeys[lastIndex].time));
            }
        }, {
            key: "getAlpha",
            value: function getAlpha(time) {
                if (!(this.alphaKeys.length > 1)) return 1 === this.alphaKeys.length ? this.alphaKeys[0].alpha : 255;
                time = repeat(time, 1);
                for (var i = 1; i < this.alphaKeys.length; ++i) {
                    var preTime = this.alphaKeys[i - 1].time, curTime = this.alphaKeys[i].time;
                    if (time >= preTime && time < curTime) {
                        if (this.mode === Mode$2.Fixed) return this.alphaKeys[i].alpha;
                        var factor = (time - preTime) / (curTime - preTime);
                        return lerp(this.alphaKeys[i - 1].alpha, this.alphaKeys[i].alpha, factor);
                    }
                }
                var lastIndex = this.alphaKeys.length - 1;
                return time < this.alphaKeys[0].time ? lerp(255, this.alphaKeys[0].alpha, time / this.alphaKeys[0].time) : time > this.alphaKeys[lastIndex].time ? lerp(this.alphaKeys[lastIndex].alpha, 255, (time - this.alphaKeys[lastIndex].time) / (1 - this.alphaKeys[lastIndex].time)) : void 0;
            }
        } ]), Gradient;
    }(), _class9.Mode = Mode$2, _descriptor5$u = _applyDecoratedDescriptor((_class8$2 = _temp3$2).prototype, "colorKeys", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Array;
        }
    }), _descriptor6$j = _applyDecoratedDescriptor(_class8$2.prototype, "alphaKeys", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Array;
        }
    }), _descriptor7$h = _applyDecoratedDescriptor(_class8$2.prototype, "mode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Mode$2.Blend;
        }
    }), _class7$2 = _class8$2)) || _class7$2), Mode$3 = Enum({
        Color: 0,
        Gradient: 1,
        TwoColors: 2,
        TwoGradients: 3,
        RandomColor: 4
    }), GradientRange = (_dec$1x = ccclass("cc.GradientRange"), _dec2$16 = property({
        type: Mode$3
    }), _dec3$R = property({
        type: Gradient
    }), _dec4$J = property({
        type: Gradient
    }), _dec5$G = property({
        type: Gradient
    }), _dec6$y = property({
        type: Mode$3
    }), _dec$1x((_temp$1o = _class3$D = function() {
        function GradientRange() {
            _classCallCheck(this, GradientRange), _initializerDefineProperty(this, "color", _descriptor$1a, this), 
            _initializerDefineProperty(this, "colorMin", _descriptor2$_, this), _initializerDefineProperty(this, "colorMax", _descriptor3$O, this), 
            _initializerDefineProperty(this, "gradient", _descriptor4$E, this), _initializerDefineProperty(this, "gradientMin", _descriptor5$v, this), 
            _initializerDefineProperty(this, "gradientMax", _descriptor6$k, this), _initializerDefineProperty(this, "_mode", _descriptor7$i, this), 
            this._color = Color.WHITE.clone();
        }
        return _createClass(GradientRange, [ {
            key: "evaluate",
            value: function evaluate(time, rndRatio) {
                switch (this.mode) {
                  case Mode$3.Color:
                    return this.color;

                  case Mode$3.TwoColors:
                    return Color.lerp(this._color, this.colorMin, this.colorMax, rndRatio), this._color;

                  case Mode$3.RandomColor:
                    return this.gradient.randomColor();

                  case Mode$3.Gradient:
                    return this.gradient.evaluate(time);

                  case Mode$3.TwoGradients:
                    return Color.lerp(this._color, this.gradientMin.evaluate(time), this.gradientMax.evaluate(time), rndRatio), 
                    this._color;

                  default:
                    return this.color;
                }
            }
        }, {
            key: "mode",
            get: function get() {
                return this._mode;
            },
            set: function set(m) {
                this._mode = m;
            }
        } ]), GradientRange;
    }(), _class3$D.Mode = Mode$3, _applyDecoratedDescriptor((_class2$1l = _temp$1o).prototype, "mode", [ _dec2$16 ], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "mode"), _class2$1l.prototype), 
    _descriptor$1a = _applyDecoratedDescriptor(_class2$1l.prototype, "color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE.clone();
        }
    }), _descriptor2$_ = _applyDecoratedDescriptor(_class2$1l.prototype, "colorMin", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE.clone();
        }
    }), _descriptor3$O = _applyDecoratedDescriptor(_class2$1l.prototype, "colorMax", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE.clone();
        }
    }), _descriptor4$E = _applyDecoratedDescriptor(_class2$1l.prototype, "gradient", [ _dec3$R ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Gradient;
        }
    }), _descriptor5$v = _applyDecoratedDescriptor(_class2$1l.prototype, "gradientMin", [ _dec4$J ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Gradient;
        }
    }), _descriptor6$k = _applyDecoratedDescriptor(_class2$1l.prototype, "gradientMax", [ _dec5$G ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Gradient;
        }
    }), _descriptor7$i = _applyDecoratedDescriptor(_class2$1l.prototype, "_mode", [ _dec6$y ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Mode$3.Color;
        }
    }), _class$1y = _class2$1l)) || _class$1y), define$1 = {
        CC_USE_WORLD_SPACE: !1
    }, LineComponent = (_dec$1y = ccclass("cc.LineComponent"), _dec2$17 = menu("Components/Line"), 
    _dec3$S = property({
        type: Texture2D
    }), _dec4$K = property({
        type: Texture2D,
        displayOrder: 0,
        tooltip: "线段中显示的贴图"
    }), _dec5$H = property({
        displayOrder: 1,
        tooltip: "线段中各个点的坐标采用哪个坐标系，勾选使用世界坐标系，不选使用本地坐标系"
    }), _dec6$z = property({
        type: [ Vec3 ]
    }), _dec7$v = property({
        type: [ Vec3 ],
        displayOrder: 2,
        tooltip: "每个线段端点的坐标"
    }), _dec8$l = property({
        type: CurveRange
    }), _dec9$f = property({
        type: CurveRange,
        displayOrder: 3,
        tooltip: "线段宽度，如果采用曲线，则表示沿着线段方向上的曲线变化"
    }), _dec10$e = property({
        type: Vec2,
        displayOrder: 4,
        tooltip: "贴图平铺次数"
    }), _dec11$e = property({
        type: Vec2,
        displayOrder: 5,
        tooltip: "贴图坐标的偏移"
    }), _dec12$c = property({
        type: GradientRange
    }), _dec13$b = property({
        type: GradientRange,
        displayOrder: 6,
        tooltip: "线段颜色，如果采用渐变色，则表示沿着线段方向上的颜色渐变"
    }), _dec$1y(_class$1z = _dec2$17(_class$1z = executeInEditMode((_descriptor$1b = _applyDecoratedDescriptor((_class2$1m = function(_Component) {
        function LineComponent() {
            var _this;
            return _classCallCheck(this, LineComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LineComponent).call(this)), "_texture", _descriptor$1b, _assertThisInitialized(_this)), 
            _this._material = null, _initializerDefineProperty(_this, "_worldSpace", _descriptor2$$, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_positions", _descriptor3$P, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_width", _descriptor4$F, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_tile", _descriptor5$w, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_offset", _descriptor6$l, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_color", _descriptor7$j, _assertThisInitialized(_this)), 
            _this._model = null, _this._tile_offset = new Vec4, _this;
        }
        return _inherits(LineComponent, _Component), _createClass(LineComponent, [ {
            key: "texture",
            get: function get() {
                return this._texture;
            },
            set: function set(val) {
                this._texture = val, this._material && this._material.setProperty("mainTexture", val);
            }
        }, {
            key: "worldSpace",
            get: function get() {
                return this._worldSpace;
            },
            set: function set(val) {
                this._worldSpace = val, this._material && (define$1.CC_USE_WORLD_SPACE = this.worldSpace, 
                this._material.recompileShaders(define$1), this._model && this._model.setSubModelMaterial(0, this._material));
            }
        }, {
            key: "positions",
            get: function get() {
                return this._positions;
            },
            set: function set(val) {
                this._positions = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            },
            set: function set(val) {
                this._width = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
            }
        }, {
            key: "tile",
            get: function get() {
                return this._tile;
            },
            set: function set(val) {
                this._tile.set(val), this._material && (this._tile_offset.x = this._tile.x, this._tile_offset.y = this._tile.y, 
                this._material.setProperty("mainTiling_Offset", this._tile_offset));
            }
        }, {
            key: "offset",
            get: function get() {
                return this._offset;
            },
            set: function set(val) {
                this._offset.set(val), this._material && (this._tile_offset.z = this._offset.x, 
                this._tile_offset.w = this._offset.y, this._material.setProperty("mainTiling_Offset", this._tile_offset));
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(val) {
                this._color = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
            }
        } ]), _createClass(LineComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this._model = cc.director.root.createModel(LineModel), this._model.initialize(this.node), 
                this._model.setCapacity(100), null == this._material && (this._material = new Material, 
                this._material.copy(builtinResMgr.get("default-trail-material")), define$1.CC_USE_WORLD_SPACE = this.worldSpace, 
                this._material.recompileShaders(define$1)), this._model.setSubModelMaterial(0, this._material);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._model && (this.attachToScene(), this.texture = this.texture, this.tile = this._tile, 
                this.offset = this._offset, this._model.addLineVertexData(this._positions, this._width, this._color));
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._model && this.detachFromScene();
            }
        }, {
            key: "attachToScene",
            value: function attachToScene() {
                this._model && this.node && this.node.scene && (this._model.scene && this.detachFromScene(), 
                this._getRenderScene().addModel(this._model));
            }
        }, {
            key: "detachFromScene",
            value: function detachFromScene() {
                this._model && this._model.scene && this._model.scene.removeModel(this._model);
            }
        } ]), LineComponent;
    }(Component)).prototype, "_texture", [ _dec3$S ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _applyDecoratedDescriptor(_class2$1m.prototype, "texture", [ _dec4$K ], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "texture"), _class2$1m.prototype), 
    _descriptor2$$ = _applyDecoratedDescriptor(_class2$1m.prototype, "_worldSpace", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _applyDecoratedDescriptor(_class2$1m.prototype, "worldSpace", [ _dec5$H ], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "worldSpace"), _class2$1m.prototype), 
    _descriptor3$P = _applyDecoratedDescriptor(_class2$1m.prototype, "_positions", [ _dec6$z ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _applyDecoratedDescriptor(_class2$1m.prototype, "positions", [ _dec7$v ], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "positions"), _class2$1m.prototype), 
    _descriptor4$F = _applyDecoratedDescriptor(_class2$1m.prototype, "_width", [ _dec8$l ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _applyDecoratedDescriptor(_class2$1m.prototype, "width", [ _dec9$f ], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "width"), _class2$1m.prototype), 
    _descriptor5$w = _applyDecoratedDescriptor(_class2$1m.prototype, "_tile", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(1, 1);
        }
    }), _applyDecoratedDescriptor(_class2$1m.prototype, "tile", [ _dec10$e ], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "tile"), _class2$1m.prototype), 
    _descriptor6$l = _applyDecoratedDescriptor(_class2$1m.prototype, "_offset", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(0, 0);
        }
    }), _applyDecoratedDescriptor(_class2$1m.prototype, "offset", [ _dec11$e ], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "offset"), _class2$1m.prototype), 
    _descriptor7$j = _applyDecoratedDescriptor(_class2$1m.prototype, "_color", [ _dec12$c ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new GradientRange;
        }
    }), _applyDecoratedDescriptor(_class2$1m.prototype, "color", [ _dec13$b ], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "color"), _class2$1m.prototype), 
    _class$1z = _class2$1m)) || _class$1z) || _class$1z) || _class$1z), ColorOvertimeModule = (_dec$1z = ccclass("cc.ColorOvertimeModule"), 
    _dec2$18 = property({
        displayOrder: 0
    }), _dec3$T = property({
        type: GradientRange,
        displayOrder: 1
    }), _dec$1z((_descriptor$1c = _applyDecoratedDescriptor((_class2$1n = function() {
        function ColorOvertimeModule() {
            _classCallCheck(this, ColorOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$1c, this), 
            _initializerDefineProperty(this, "color", _descriptor2$10, this);
        }
        return _createClass(ColorOvertimeModule, [ {
            key: "animate",
            value: function animate(particle) {
                this.enable && (particle.color.set(particle.startColor), particle.color.multiply(this.color.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + 91041))));
            }
        } ]), ColorOvertimeModule;
    }()).prototype, "enable", [ _dec2$18 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$10 = _applyDecoratedDescriptor(_class2$1n.prototype, "color", [ _dec3$T ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new GradientRange;
        }
    }), _class$1A = _class2$1n)) || _class$1A), Space = Enum({
        World: 0,
        Local: 1,
        Custom: 2
    }), RenderMode$1 = Enum({
        Billboard: 0,
        StrecthedBillboard: 1,
        HorizontalBillboard: 2,
        VerticalBillboard: 3,
        Mesh: 4
    }), ShapeType = Enum({
        Box: 0,
        Circle: 1,
        Cone: 2,
        Sphere: 3,
        Hemisphere: 4
    }), EmitLocation = Enum({
        Base: 0,
        Edge: 1,
        Shell: 2,
        Volume: 3
    }), ArcMode = Enum({
        Random: 0,
        Loop: 1,
        PingPong: 2
    }), TrailMode = Enum({
        Particles: 0,
        Ribbon: 1
    }), TextureMode = Enum({
        Stretch: 0,
        Repeat: 1
    }), particleEmitZAxis = new Vec3(0, 0, -1);
    function calculateTransform(systemSpace, moduleSpace, worldTransform, outQuat) {
        return moduleSpace !== systemSpace ? (systemSpace === Space.World ? Mat4.getRotation(outQuat, worldTransform) : (Mat4.invert(worldTransform, worldTransform), 
        Mat4.getRotation(outQuat, worldTransform)), !0) : (Quat.set(outQuat, 0, 0, 0, 1), 
        !1);
    }
    function fixedAngleUnitVector2(out, theta) {
        Vec2.set(out, Math.cos(theta), Math.sin(theta));
    }
    function randomUnitVector(out) {
        var z = randomRange(-1, 1), a = randomRange(0, 2 * Math.PI), r = Math.sqrt(1 - z * z), x = r * Math.cos(a), y = r * Math.sin(a);
        Vec3.set(out, x, y, z);
    }
    function randomPointBetweenSphere(out, minRadius, maxRadius) {
        randomUnitVector(out), Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
    }
    function randomPointBetweenCircleAtFixedAngle(out, minRadius, maxRadius, theta) {
        fixedAngleUnitVector2(out, theta), out.z = 0, Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
    }
    function randomSortArray(arr) {
        for (var i = 0; i < arr.length; i++) {
            var transpose = i + randomRangeInt(0, arr.length - i), val = arr[transpose];
            arr[transpose] = arr[i], arr[i] = val;
        }
    }
    function randomSign() {
        var sgn = randomRange(-1, 1);
        return 0 === sgn && sgn++, sign(sgn);
    }
    var _dec$1B, _dec2$1a, _dec3$V, _dec4$M, _dec5$J, _dec6$B, _dec7$w, _dec8$m, _dec9$g, _class$1C, _class2$1p, _descriptor$1e, _descriptor2$12, _descriptor3$R, _descriptor4$H, _descriptor5$y, _descriptor6$m, _descriptor7$k, _descriptor8$g, _dec$1C, _dec2$1b, _dec3$W, _dec4$N, _dec5$K, _dec6$C, _class$1D, _class2$1q, _descriptor$1f, _descriptor2$13, _descriptor3$S, _descriptor4$I, _descriptor5$z, _temp_v3 = new Vec3, ForceOvertimeModule = (_dec$1A = ccclass("cc.ForceOvertimeModule"), 
    _dec2$19 = property({
        displayOrder: 0
    }), _dec3$U = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 2,
        tooltip: "X 轴方向上的加速度分量"
    }), _dec4$L = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 3,
        tooltip: "Y 轴方向上的加速度分量"
    }), _dec5$I = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 4,
        tooltip: "Z 轴方向上的加速度分量"
    }), _dec6$A = property({
        type: Space,
        displayOrder: 1,
        tooltip: "加速度计算时采用的坐标"
    }), _dec$1A((_descriptor$1d = _applyDecoratedDescriptor((_class2$1o = function() {
        function ForceOvertimeModule() {
            _classCallCheck(this, ForceOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$1d, this), 
            _initializerDefineProperty(this, "x", _descriptor2$11, this), _initializerDefineProperty(this, "y", _descriptor3$Q, this), 
            _initializerDefineProperty(this, "z", _descriptor4$G, this), _initializerDefineProperty(this, "space", _descriptor5$x, this), 
            this.randomized = !1, this.rotation = new Quat, this.needTransform = !1;
        }
        return _createClass(ForceOvertimeModule, [ {
            key: "update",
            value: function update(space, worldTransform) {
                this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
            }
        }, {
            key: "animate",
            value: function animate(p, dt) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, force = Vec3.set(_temp_v3, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)));
                this.needTransform && Vec3.transformQuat(force, force, this.rotation), Vec3.scaleAndAdd(p.velocity, p.velocity, force, dt);
            }
        } ]), ForceOvertimeModule;
    }()).prototype, "enable", [ _dec2$19 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$11 = _applyDecoratedDescriptor(_class2$1o.prototype, "x", [ _dec3$U ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor3$Q = _applyDecoratedDescriptor(_class2$1o.prototype, "y", [ _dec4$L ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor4$G = _applyDecoratedDescriptor(_class2$1o.prototype, "z", [ _dec5$I ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor5$x = _applyDecoratedDescriptor(_class2$1o.prototype, "space", [ _dec6$A ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.Local;
        }
    }), _class$1B = _class2$1o)) || _class$1B), _temp_v3$1 = new Vec3, _temp_v3_1 = new Vec3, LimitVelocityOvertimeModule = (_dec$1B = ccclass("cc.LimitVelocityOvertimeModule"), 
    _dec2$1a = property({
        displayOrder: 0
    }), _dec3$V = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 4,
        tooltip: "X 轴方向上的速度下限"
    }), _dec4$M = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 5,
        tooltip: "Y 轴方向上的速度下限"
    }), _dec5$J = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 6,
        tooltip: "Z 轴方向上的速度下限"
    }), _dec6$B = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 3,
        tooltip: "速度下限"
    }), _dec7$w = property({
        displayOrder: 7,
        tooltip: "当前速度与速度下限的插值"
    }), _dec8$m = property({
        displayOrder: 2,
        tooltip: "是否三个轴分开限制"
    }), _dec9$g = property({
        type: Space,
        displayOrder: 1,
        tooltip: "计算速度下限时采用的坐标系"
    }), _dec$1B((_descriptor$1e = _applyDecoratedDescriptor((_class2$1p = function() {
        function LimitVelocityOvertimeModule() {
            _classCallCheck(this, LimitVelocityOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$1e, this), 
            _initializerDefineProperty(this, "limitX", _descriptor2$12, this), _initializerDefineProperty(this, "limitY", _descriptor3$R, this), 
            _initializerDefineProperty(this, "limitZ", _descriptor4$H, this), _initializerDefineProperty(this, "limit", _descriptor5$y, this), 
            _initializerDefineProperty(this, "dampen", _descriptor6$m, this), _initializerDefineProperty(this, "separateAxes", _descriptor7$k, this), 
            _initializerDefineProperty(this, "space", _descriptor8$g, this), this.drag = null, 
            this.multiplyDragByParticleSize = !1, this.multiplyDragByParticleVelocity = !1, 
            this.rotation = new Quat, this.needTransform = !1;
        }
        return _createClass(LimitVelocityOvertimeModule, [ {
            key: "update",
            value: function update(space, worldTransform) {
                this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
            }
        }, {
            key: "animate",
            value: function animate(p) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, dampedVel = _temp_v3$1;
                this.separateAxes ? (Vec3.set(_temp_v3_1, this.limitX.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.limitY.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.limitZ.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541))), 
                this.needTransform && Vec3.transformQuat(_temp_v3_1, _temp_v3_1, this.rotation), 
                Vec3.set(dampedVel, dampenBeyondLimit(p.ultimateVelocity.x, _temp_v3_1.x, this.dampen), dampenBeyondLimit(p.ultimateVelocity.y, _temp_v3_1.y, this.dampen), dampenBeyondLimit(p.ultimateVelocity.z, _temp_v3_1.z, this.dampen))) : (Vec3.normalize(dampedVel, p.ultimateVelocity), 
                Vec3.multiplyScalar(dampedVel, dampedVel, dampenBeyondLimit(p.ultimateVelocity.length(), this.limit.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen))), 
                Vec3.copy(p.ultimateVelocity, dampedVel);
            }
        } ]), LimitVelocityOvertimeModule;
    }()).prototype, "enable", [ _dec2$1a ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$12 = _applyDecoratedDescriptor(_class2$1p.prototype, "limitX", [ _dec3$V ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor3$R = _applyDecoratedDescriptor(_class2$1p.prototype, "limitY", [ _dec4$M ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor4$H = _applyDecoratedDescriptor(_class2$1p.prototype, "limitZ", [ _dec5$J ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor5$y = _applyDecoratedDescriptor(_class2$1p.prototype, "limit", [ _dec6$B ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor6$m = _applyDecoratedDescriptor(_class2$1p.prototype, "dampen", [ _dec7$w ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 3;
        }
    }), _descriptor7$k = _applyDecoratedDescriptor(_class2$1p.prototype, "separateAxes", [ _dec8$m ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor8$g = _applyDecoratedDescriptor(_class2$1p.prototype, "space", [ _dec9$g ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.Local;
        }
    }), _class$1C = _class2$1p)) || _class$1C);
    function dampenBeyondLimit(vel, limit, dampen) {
        var sgn = Math.sign(vel), abs = Math.abs(vel);
        return abs > limit && (abs = lerp(abs, limit, dampen)), abs * sgn;
    }
    var _dec$1D, _dec2$1c, _dec3$X, _dec4$O, _dec5$L, _dec6$D, _dec7$x, _class$1E, _class2$1r, _descriptor$1g, _descriptor2$14, _descriptor3$T, _descriptor4$J, _descriptor5$A, _descriptor6$n, _dec$1E, _dec2$1d, _dec3$Y, _dec4$P, _dec5$M, _dec6$E, _dec7$y, _dec8$n, _dec9$h, _dec10$f, _dec11$f, _dec12$d, _dec13$c, _dec14$a, _class$1F, _class2$1s, _descriptor$1h, _descriptor2$15, _descriptor3$U, _descriptor4$K, _descriptor5$B, _descriptor6$o, _descriptor7$l, _descriptor8$h, _descriptor9$d, _descriptor10$d, _descriptor11$b, _descriptor12$9, _descriptor13$8, _dec$1F, _dec2$1e, _dec3$Z, _dec4$Q, _dec5$N, _dec6$F, _dec7$z, _class$1G, _class2$1t, _descriptor$1i, _descriptor2$16, _descriptor3$V, _descriptor4$L, _descriptor5$C, _descriptor6$p, _dec$1G, _dec2$1f, _class$1H, _class2$1u, _descriptor$1j, _descriptor2$17, _descriptor3$W, _descriptor4$M, _descriptor5$D, _descriptor6$q, _dec$1H, _dec2$1g, _dec3$_, _dec4$R, _dec5$O, _dec6$G, _dec7$A, _dec8$o, _dec9$i, _dec10$g, _dec11$g, _dec12$e, _dec13$d, _dec14$b, _dec15$8, _dec16$8, _dec17$5, _dec18$5, _dec19$2, _dec20$2, _dec21$2, _class$1I, _class2$1v, _descriptor$1k, _descriptor2$18, _descriptor3$X, _descriptor4$N, _descriptor5$E, _descriptor6$r, _descriptor7$m, _descriptor8$i, _descriptor9$e, _descriptor10$e, _descriptor11$c, _descriptor12$a, _descriptor13$9, _descriptor14$8, _descriptor15$3, _descriptor16$3, _descriptor17$2, _descriptor18$1, _descriptor19$1, RotationOvertimeModule = (_dec$1C = ccclass("cc.RotationOvertimeModule"), 
    _dec2$1b = property({
        displayOrder: 0
    }), _dec3$W = property({
        displayOrder: 1,
        tooltip: "是否三个轴分开设定旋转（暂不支持）"
    }), _dec4$N = property({
        type: CurveRange,
        range: [ -1, 1 ],
        radian: !0,
        displayOrder: 2,
        tooltip: "绕 X 轴设定旋转"
    }), _dec5$K = property({
        type: CurveRange,
        range: [ -1, 1 ],
        radian: !0,
        displayOrder: 3,
        tooltip: "绕 Y 轴设定旋转"
    }), _dec6$C = property({
        type: CurveRange,
        range: [ -1, 1 ],
        radian: !0,
        displayOrder: 4,
        tooltip: "绕 Z 轴设定旋转"
    }), _dec$1C((_descriptor$1f = _applyDecoratedDescriptor((_class2$1q = function() {
        function RotationOvertimeModule() {
            _classCallCheck(this, RotationOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$1f, this), 
            _initializerDefineProperty(this, "_separateAxes", _descriptor2$13, this), _initializerDefineProperty(this, "x", _descriptor3$S, this), 
            _initializerDefineProperty(this, "y", _descriptor4$I, this), _initializerDefineProperty(this, "z", _descriptor5$z, this);
        }
        return _createClass(RotationOvertimeModule, [ {
            key: "separateAxes",
            get: function get() {
                return this._separateAxes;
            },
            set: function set(val) {
                this._separateAxes = val;
            }
        } ]), _createClass(RotationOvertimeModule, [ {
            key: "animate",
            value: function animate(p, dt) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                if (this._separateAxes) {
                    var rotationRand = pseudoRandom(p.randomSeed + 125292);
                    p.rotation.x += this.x.evaluate(normalizedTime, rotationRand) * dt, p.rotation.y += this.y.evaluate(normalizedTime, rotationRand) * dt, 
                    p.rotation.z += this.z.evaluate(normalizedTime, rotationRand) * dt;
                } else p.rotation.z += this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 125292)) * dt;
            }
        } ]), RotationOvertimeModule;
    }()).prototype, "enable", [ _dec2$1b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$13 = _applyDecoratedDescriptor(_class2$1q.prototype, "_separateAxes", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _applyDecoratedDescriptor(_class2$1q.prototype, "separateAxes", [ _dec3$W ], Object.getOwnPropertyDescriptor(_class2$1q.prototype, "separateAxes"), _class2$1q.prototype), 
    _descriptor3$S = _applyDecoratedDescriptor(_class2$1q.prototype, "x", [ _dec4$N ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor4$I = _applyDecoratedDescriptor(_class2$1q.prototype, "y", [ _dec5$K ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor5$z = _applyDecoratedDescriptor(_class2$1q.prototype, "z", [ _dec6$C ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _class$1D = _class2$1q)) || _class$1D), SizeOvertimeModule = (_dec$1D = ccclass("cc.SizeOvertimeModule"), 
    _dec2$1c = property({
        displayOrder: 0
    }), _dec3$X = property({
        displayOrder: 1,
        tooltip: "决定是否在每个轴上独立控制粒子大小"
    }), _dec4$O = property({
        type: CurveRange,
        displayOrder: 2,
        tooltip: "定义一条曲线来决定粒子在其生命周期中的大小变化"
    }), _dec5$L = property({
        type: CurveRange,
        displayOrder: 3,
        tooltip: "定义一条曲线来决定粒子在其生命周期中 X 轴方向上的大小变化"
    }), _dec6$D = property({
        type: CurveRange,
        displayOrder: 4,
        tooltip: "定义一条曲线来决定粒子在其生命周期中 Y 轴方向上的大小变化"
    }), _dec7$x = property({
        type: CurveRange,
        displayOrder: 5,
        tooltip: "定义一条曲线来决定粒子在其生命周期中 Z 轴方向上的大小变化"
    }), _dec$1D((_descriptor$1g = _applyDecoratedDescriptor((_class2$1r = function() {
        function SizeOvertimeModule() {
            _classCallCheck(this, SizeOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$1g, this), 
            _initializerDefineProperty(this, "separateAxes", _descriptor2$14, this), _initializerDefineProperty(this, "size", _descriptor3$T, this), 
            _initializerDefineProperty(this, "x", _descriptor4$J, this), _initializerDefineProperty(this, "y", _descriptor5$A, this), 
            _initializerDefineProperty(this, "z", _descriptor6$n, this);
        }
        return _createClass(SizeOvertimeModule, [ {
            key: "animate",
            value: function animate(particle) {
                if (this.separateAxes) {
                    var currLifetime = 1 - particle.remainingLifetime / particle.startLifetime, sizeRand = pseudoRandom(particle.randomSeed + 39825);
                    particle.size.x = particle.startSize.x * this.x.evaluate(currLifetime, sizeRand), 
                    particle.size.y = particle.startSize.y * this.y.evaluate(currLifetime, sizeRand), 
                    particle.size.z = particle.startSize.z * this.z.evaluate(currLifetime, sizeRand);
                } else Vec3.multiplyScalar(particle.size, particle.startSize, this.size.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + 39825)));
            }
        } ]), SizeOvertimeModule;
    }()).prototype, "enable", [ _dec2$1c ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$14 = _applyDecoratedDescriptor(_class2$1r.prototype, "separateAxes", [ _dec3$X ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$T = _applyDecoratedDescriptor(_class2$1r.prototype, "size", [ _dec4$O ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor4$J = _applyDecoratedDescriptor(_class2$1r.prototype, "x", [ _dec5$L ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor5$A = _applyDecoratedDescriptor(_class2$1r.prototype, "y", [ _dec6$D ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor6$n = _applyDecoratedDescriptor(_class2$1r.prototype, "z", [ _dec7$x ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _class$1E = _class2$1r)) || _class$1E), Mode$4 = Enum({
        Grid: 0
    }), Animation = Enum({
        WholeSheet: 0,
        SingleRow: 1
    }), TextureAnimationModule = (_dec$1E = ccclass("cc.TextureAnimationModule"), _dec2$1d = property({
        formerlySerializedAs: "numTilesX"
    }), _dec3$Y = property({
        formerlySerializedAs: "numTilesY"
    }), _dec4$P = property({
        displayOrder: 0
    }), _dec5$M = property({
        type: Mode$4
    }), _dec6$E = property({
        type: Mode$4,
        displayOrder: 1,
        tooltip: "设定粒子贴图动画的类型（暂只支持 Grid 模式）"
    }), _dec7$y = property({
        displayOrder: 2,
        tooltip: "X 方向动画帧数"
    }), _dec8$n = property({
        displayOrder: 3,
        tooltip: "Y 方向动画帧数"
    }), _dec9$h = property({
        type: Animation,
        displayOrder: 4,
        tooltip: "动画播放方式"
    }), _dec10$f = property({
        type: CurveRange,
        displayOrder: 7,
        tooltip: "一个周期内动画播放的帧与时间变化曲线"
    }), _dec11$f = property({
        type: CurveRange,
        displayOrder: 8,
        tooltip: "从第几帧开始播放，时间为整个粒子系统的生命周期"
    }), _dec12$d = property({
        displayOrder: 9,
        tooltip: "一个生命周期内播放循环的次数"
    }), _dec13$c = property({
        displayOrder: 5,
        tooltip: "随机从动画贴图中选择一行以生成动画。\n此选项仅在动画播放方式为 SingleRow 时生效"
    }), _dec14$a = property({
        displayOrder: 6,
        tooltip: "从动画贴图中选择特定行以生成动画。\n此选项仅在动画播放方式为 SingleRow 时且禁用 randomRow 时可用"
    }), _dec$1E((_descriptor$1h = _applyDecoratedDescriptor((_class2$1s = function() {
        function TextureAnimationModule() {
            _classCallCheck(this, TextureAnimationModule), _initializerDefineProperty(this, "_enable", _descriptor$1h, this), 
            _initializerDefineProperty(this, "_numTilesX", _descriptor2$15, this), _initializerDefineProperty(this, "_numTilesY", _descriptor3$U, this), 
            _initializerDefineProperty(this, "_mode", _descriptor4$K, this), _initializerDefineProperty(this, "animation", _descriptor5$B, this), 
            _initializerDefineProperty(this, "frameOverTime", _descriptor6$o, this), _initializerDefineProperty(this, "startFrame", _descriptor7$l, this), 
            _initializerDefineProperty(this, "cycleCount", _descriptor8$h, this), _initializerDefineProperty(this, "_flipU", _descriptor9$d, this), 
            _initializerDefineProperty(this, "_flipV", _descriptor10$d, this), _initializerDefineProperty(this, "_uvChannelMask", _descriptor11$b, this), 
            _initializerDefineProperty(this, "randomRow", _descriptor12$9, this), _initializerDefineProperty(this, "rowIndex", _descriptor13$8, this), 
            this.ps = null;
        }
        return _createClass(TextureAnimationModule, [ {
            key: "onInit",
            value: function onInit(ps) {
                this.ps = ps;
            }
        }, {
            key: "init",
            value: function init(p) {
                p.startRow = Math.floor(Math.random() * this.numTilesY);
            }
        }, {
            key: "animate",
            value: function animate(p) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, startFrame = this.startFrame.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) / (this.numTilesX * this.numTilesY);
                if (this.animation === Animation.WholeSheet) p.frameIndex = repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1); else if (this.animation === Animation.SingleRow) {
                    var rowLength = 1 / this.numTilesY;
                    if (this.randomRow) {
                        var f = repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1), from = p.startRow * rowLength, to = from + rowLength;
                        p.frameIndex = lerp(from, to, f);
                    } else {
                        var _from = this.rowIndex * rowLength, _to = _from + rowLength;
                        p.frameIndex = lerp(_from, _to, repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1));
                    }
                }
            }
        }, {
            key: "enable",
            get: function get() {
                return this._enable;
            },
            set: function set(val) {
                this._enable = val, this.ps && this.ps.renderer._updateMaterialParams();
            }
        }, {
            key: "mode",
            get: function get() {
                return this._mode;
            },
            set: function set(val) {
                val === Mode$4.Grid || console.error("particle texture animation's sprites is not supported!");
            }
        }, {
            key: "numTilesX",
            get: function get() {
                return this._numTilesX;
            },
            set: function set(val) {
                this._numTilesX !== val && (this._numTilesX = val, this.ps && this.ps.renderer._updateMaterialParams());
            }
        }, {
            key: "numTilesY",
            get: function get() {
                return this._numTilesY;
            },
            set: function set(val) {
                this._numTilesY !== val && (this._numTilesY = val, this.ps && this.ps.renderer._updateMaterialParams());
            }
        }, {
            key: "flipU",
            get: function get() {
                return this._flipU;
            },
            set: function set(val) {
                console.error("particle texture animation's flipU is not supported!");
            }
        }, {
            key: "flipV",
            get: function get() {
                return this._flipV;
            },
            set: function set(val) {
                console.error("particle texture animation's flipV is not supported!");
            }
        }, {
            key: "uvChannelMask",
            get: function get() {
                return this._uvChannelMask;
            },
            set: function set(val) {
                console.error("particle texture animation's uvChannelMask is not supported!");
            }
        } ]), TextureAnimationModule;
    }()).prototype, "_enable", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$15 = _applyDecoratedDescriptor(_class2$1s.prototype, "_numTilesX", [ _dec2$1d ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor3$U = _applyDecoratedDescriptor(_class2$1s.prototype, "_numTilesY", [ _dec3$Y ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _applyDecoratedDescriptor(_class2$1s.prototype, "enable", [ _dec4$P ], Object.getOwnPropertyDescriptor(_class2$1s.prototype, "enable"), _class2$1s.prototype), 
    _descriptor4$K = _applyDecoratedDescriptor(_class2$1s.prototype, "_mode", [ _dec5$M ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Mode$4.Grid;
        }
    }), _applyDecoratedDescriptor(_class2$1s.prototype, "mode", [ _dec6$E ], Object.getOwnPropertyDescriptor(_class2$1s.prototype, "mode"), _class2$1s.prototype), 
    _applyDecoratedDescriptor(_class2$1s.prototype, "numTilesX", [ _dec7$y ], Object.getOwnPropertyDescriptor(_class2$1s.prototype, "numTilesX"), _class2$1s.prototype), 
    _applyDecoratedDescriptor(_class2$1s.prototype, "numTilesY", [ _dec8$n ], Object.getOwnPropertyDescriptor(_class2$1s.prototype, "numTilesY"), _class2$1s.prototype), 
    _descriptor5$B = _applyDecoratedDescriptor(_class2$1s.prototype, "animation", [ _dec9$h ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Animation.WholeSheet;
        }
    }), _descriptor6$o = _applyDecoratedDescriptor(_class2$1s.prototype, "frameOverTime", [ _dec10$f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor7$l = _applyDecoratedDescriptor(_class2$1s.prototype, "startFrame", [ _dec11$f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor8$h = _applyDecoratedDescriptor(_class2$1s.prototype, "cycleCount", [ _dec12$d ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor9$d = _applyDecoratedDescriptor(_class2$1s.prototype, "_flipU", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor10$d = _applyDecoratedDescriptor(_class2$1s.prototype, "_flipV", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor11$b = _applyDecoratedDescriptor(_class2$1s.prototype, "_uvChannelMask", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return -1;
        }
    }), _descriptor12$9 = _applyDecoratedDescriptor(_class2$1s.prototype, "randomRow", [ _dec13$c ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor13$8 = _applyDecoratedDescriptor(_class2$1s.prototype, "rowIndex", [ _dec14$a ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$1F = _class2$1s)) || _class$1F), _temp_v3$2 = new Vec3, VelocityOvertimeModule = (_dec$1F = ccclass("cc.VelocityOvertimeModule"), 
    _dec2$1e = property({
        displayOrder: 0
    }), _dec3$Z = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 2,
        tooltip: "X 轴方向上的速度分量"
    }), _dec4$Q = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 3,
        tooltip: "Y 轴方向上的速度分量"
    }), _dec5$N = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 4,
        tooltip: "Z 轴方向上的速度分量"
    }), _dec6$F = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 5,
        tooltip: "速度修正系数（只支持 CPU 粒子）"
    }), _dec7$z = property({
        type: Space,
        displayOrder: 1,
        tooltip: "速度计算时采用的坐标系"
    }), _dec$1F((_descriptor$1i = _applyDecoratedDescriptor((_class2$1t = function() {
        function VelocityOvertimeModule() {
            _classCallCheck(this, VelocityOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$1i, this), 
            _initializerDefineProperty(this, "x", _descriptor2$16, this), _initializerDefineProperty(this, "y", _descriptor3$V, this), 
            _initializerDefineProperty(this, "z", _descriptor4$L, this), _initializerDefineProperty(this, "speedModifier", _descriptor5$C, this), 
            _initializerDefineProperty(this, "space", _descriptor6$p, this), this.rotation = new Quat, 
            this.speedModifier.constant = 1, this.needTransform = !1;
        }
        return _createClass(VelocityOvertimeModule, [ {
            key: "update",
            value: function update(space, worldTransform) {
                this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
            }
        }, {
            key: "animate",
            value: function animate(p) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, vel = Vec3.set(_temp_v3$2, this.x.evaluate(normalizedTime, pseudoRandom(197866 ^ p.randomSeed)), this.y.evaluate(normalizedTime, pseudoRandom(156497 ^ p.randomSeed)), this.z.evaluate(normalizedTime, pseudoRandom(984136 ^ p.randomSeed)));
                this.needTransform && Vec3.transformQuat(vel, vel, this.rotation), Vec3.add(p.animatedVelocity, p.animatedVelocity, vel), 
                Vec3.add(p.ultimateVelocity, p.velocity, p.animatedVelocity), Vec3.multiplyScalar(p.ultimateVelocity, p.ultimateVelocity, this.speedModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed + 197866)));
            }
        } ]), VelocityOvertimeModule;
    }()).prototype, "enable", [ _dec2$1e ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$16 = _applyDecoratedDescriptor(_class2$1t.prototype, "x", [ _dec3$Z ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor3$V = _applyDecoratedDescriptor(_class2$1t.prototype, "y", [ _dec4$Q ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor4$L = _applyDecoratedDescriptor(_class2$1t.prototype, "z", [ _dec5$N ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor5$C = _applyDecoratedDescriptor(_class2$1t.prototype, "speedModifier", [ _dec6$F ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor6$p = _applyDecoratedDescriptor(_class2$1t.prototype, "space", [ _dec7$z ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.Local;
        }
    }), _class$1G = _class2$1t)) || _class$1G), Burst = (_dec$1G = ccclass("cc.Burst"), 
    _dec2$1f = property({
        type: CurveRange
    }), _dec$1G((_descriptor$1j = _applyDecoratedDescriptor((_class2$1u = function() {
        function Burst() {
            _classCallCheck(this, Burst), _initializerDefineProperty(this, "_time", _descriptor$1j, this), 
            _initializerDefineProperty(this, "minCount", _descriptor2$17, this), _initializerDefineProperty(this, "maxCount", _descriptor3$W, this), 
            _initializerDefineProperty(this, "_repeatCount", _descriptor4$M, this), _initializerDefineProperty(this, "repeatInterval", _descriptor5$D, this), 
            _initializerDefineProperty(this, "count", _descriptor6$q, this), this._remainingCount = 1, 
            this._curTime = 0;
        }
        return _createClass(Burst, [ {
            key: "time",
            get: function get() {
                return this._time;
            },
            set: function set(val) {
                this._time = val, this._curTime = val;
            }
        }, {
            key: "repeatCount",
            get: function get() {
                return this._repeatCount;
            },
            set: function set(val) {
                this._repeatCount = val, this._remainingCount = val;
            }
        } ]), _createClass(Burst, [ {
            key: "update",
            value: function update(psys, dt) {
                if (0 === this._remainingCount && (this._remainingCount = this._repeatCount, this._curTime = this._time), 
                this._remainingCount > 0) {
                    var preFrameTime = repeat(psys._time - psys.startDelay.evaluate(0, 1), psys.duration) - dt;
                    preFrameTime = preFrameTime > 0 ? preFrameTime : 0;
                    var curFrameTime = repeat(psys.time - psys.startDelay.evaluate(0, 1), psys.duration);
                    this._curTime >= preFrameTime && this._curTime < curFrameTime && (psys.emit(this.count.evaluate(this._curTime / psys.duration, 1), dt - (curFrameTime - this._curTime)), 
                    this._curTime += this.repeatInterval, --this._remainingCount);
                }
            }
        }, {
            key: "getMaxCount",
            value: function getMaxCount(psys) {
                return this.count.getMax() * Math.min(Math.ceil(psys.duration / this.repeatInterval), this.repeatCount);
            }
        } ]), Burst;
    }()).prototype, "_time", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _applyDecoratedDescriptor(_class2$1u.prototype, "time", [ property ], Object.getOwnPropertyDescriptor(_class2$1u.prototype, "time"), _class2$1u.prototype), 
    _descriptor2$17 = _applyDecoratedDescriptor(_class2$1u.prototype, "minCount", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 30;
        }
    }), _descriptor3$W = _applyDecoratedDescriptor(_class2$1u.prototype, "maxCount", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 30;
        }
    }), _descriptor4$M = _applyDecoratedDescriptor(_class2$1u.prototype, "_repeatCount", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _applyDecoratedDescriptor(_class2$1u.prototype, "repeatCount", [ property ], Object.getOwnPropertyDescriptor(_class2$1u.prototype, "repeatCount"), _class2$1u.prototype), 
    _descriptor5$D = _applyDecoratedDescriptor(_class2$1u.prototype, "repeatInterval", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor6$q = _applyDecoratedDescriptor(_class2$1u.prototype, "count", [ _dec2$1f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _class$1H = _class2$1u)) || _class$1H), _intermediVec = new Vec3(0, 0, 0), _intermediArr = new Array, _unitBoxExtent = new Vec3(.5, .5, .5), ShapeModule = (_dec$1H = ccclass("cc.ShapeModule"), 
    _dec2$1g = property({
        displayOrder: 13,
        tooltip: "粒子发射器位置"
    }), _dec3$_ = property({
        displayOrder: 14,
        tooltip: "粒子发射器旋转角度"
    }), _dec4$R = property({
        displayOrder: 15,
        tooltip: "粒子发射器缩放比例"
    }), _dec5$O = property({
        displayOrder: 6,
        tooltip: "粒子发射器在一个扇形范围内发射"
    }), _dec6$G = property({
        displayOrder: 5,
        tooltip: "圆锥的轴与母线的夹角\n决定圆锥发射器的开合程度"
    }), _dec7$A = property({
        displayOrder: 0
    }), _dec8$o = property({
        type: ShapeType,
        displayOrder: 1,
        formerlySerializedAs: "shapeType"
    }), _dec9$i = property({
        type: ShapeType,
        tooltip: "粒子发射器类型"
    }), _dec10$g = property({
        type: EmitLocation,
        displayOrder: 2,
        tooltip: "粒子从发射器哪个部位发射"
    }), _dec11$g = property({
        displayOrder: 16,
        tooltip: "根据粒子的初始方向决定粒子的移动方向"
    }), _dec12$e = property({
        displayOrder: 17,
        tooltip: "粒子生成方向随机设定"
    }), _dec13$d = property({
        displayOrder: 18,
        tooltip: "表示当前发射方向与当前位置到结点中心连线方向的插值"
    }), _dec14$b = property({
        displayOrder: 19,
        tooltip: "粒子生成位置随机设定（设定此值为非 0 会使粒子生成位置超出生成器大小范围）"
    }), _dec15$8 = property({
        displayOrder: 3,
        tooltip: "粒子发射器半径"
    }), _dec16$8 = property({
        displayOrder: 4,
        tooltip: "粒子发射器发射位置（对 Box 类型的发射器无效）:\n - 0 表示从表面发射；\n - 1 表示从中心发射；\n - 0 ~ 1 之间表示在中心到表面之间发射。"
    }), _dec17$5 = property({
        type: ArcMode,
        displayOrder: 7,
        tooltip: "粒子在扇形范围内的发射方式"
    }), _dec18$5 = property({
        displayOrder: 9,
        tooltip: "控制可能产生粒子的弧周围的离散间隔"
    }), _dec19$2 = property({
        type: CurveRange,
        displayOrder: 10,
        tooltip: "粒子沿圆周发射的速度"
    }), _dec20$2 = property({
        displayOrder: 11,
        tooltip: "圆锥顶部截面距离底部的轴长\n决定圆锥发射器的高度"
    }), _dec21$2 = property({
        displayOrder: 12,
        tooltip: "粒子发射器发射位置（针对 Box 类型的粒子发射器）"
    }), _dec$1H((_applyDecoratedDescriptor((_class2$1v = function() {
        function ShapeModule() {
            _classCallCheck(this, ShapeModule), _initializerDefineProperty(this, "enable", _descriptor$1k, this), 
            _initializerDefineProperty(this, "_shapeType", _descriptor2$18, this), _initializerDefineProperty(this, "emitFrom", _descriptor3$X, this), 
            _initializerDefineProperty(this, "alignToDirection", _descriptor4$N, this), _initializerDefineProperty(this, "randomDirectionAmount", _descriptor5$E, this), 
            _initializerDefineProperty(this, "sphericalDirectionAmount", _descriptor6$r, this), 
            _initializerDefineProperty(this, "randomPositionAmount", _descriptor7$m, this), 
            _initializerDefineProperty(this, "radius", _descriptor8$i, this), _initializerDefineProperty(this, "radiusThickness", _descriptor9$e, this), 
            _initializerDefineProperty(this, "arcMode", _descriptor10$e, this), _initializerDefineProperty(this, "arcSpread", _descriptor11$c, this), 
            _initializerDefineProperty(this, "arcSpeed", _descriptor12$a, this), _initializerDefineProperty(this, "length", _descriptor13$9, this), 
            _initializerDefineProperty(this, "boxThickness", _descriptor14$8, this), _initializerDefineProperty(this, "_position", _descriptor15$3, this), 
            _initializerDefineProperty(this, "_rotation", _descriptor16$3, this), _initializerDefineProperty(this, "_scale", _descriptor17$2, this), 
            _initializerDefineProperty(this, "_arc", _descriptor18$1, this), _initializerDefineProperty(this, "_angle", _descriptor19$1, this), 
            this.mat = new Mat4, this.quat = new Quat, this.particleSystem = null, this.lastTime = 0, 
            this.totalAngle = 0;
        }
        return _createClass(ShapeModule, [ {
            key: "position",
            get: function get() {
                return this._position;
            },
            set: function set(val) {
                this._position = val, this.constructMat();
            }
        }, {
            key: "rotation",
            get: function get() {
                return this._rotation;
            },
            set: function set(val) {
                this._rotation = val, this.constructMat();
            }
        }, {
            key: "scale",
            get: function get() {
                return this._scale;
            },
            set: function set(val) {
                this._scale = val, this.constructMat();
            }
        }, {
            key: "arc",
            get: function get() {
                return toDegree(this._arc);
            },
            set: function set(val) {
                this._arc = toRadian(val);
            }
        }, {
            key: "angle",
            get: function get() {
                return Math.round(100 * toDegree(this._angle)) / 100;
            },
            set: function set(val) {
                this._angle = toRadian(val);
            }
        }, {
            key: "shapeType",
            get: function get() {
                return this._shapeType;
            },
            set: function set(val) {
                switch (this._shapeType = val, this._shapeType) {
                  case ShapeType.Box:
                    this.emitFrom === EmitLocation.Base && (this.emitFrom = EmitLocation.Volume);
                    break;

                  case ShapeType.Cone:
                    this.emitFrom === EmitLocation.Edge && (this.emitFrom = EmitLocation.Base);
                    break;

                  case ShapeType.Sphere:
                  case ShapeType.Hemisphere:
                    this.emitFrom !== EmitLocation.Base && this.emitFrom !== EmitLocation.Edge || (this.emitFrom = EmitLocation.Volume);
                }
            }
        } ]), _createClass(ShapeModule, [ {
            key: "onInit",
            value: function onInit(ps) {
                this.particleSystem = ps, this.constructMat(), this.lastTime = this.particleSystem._time;
            }
        }, {
            key: "emit",
            value: function emit(p) {
                switch (this.shapeType) {
                  case ShapeType.Box:
                    !function boxEmit(emitFrom, boxThickness, pos, dir) {
                        switch (emitFrom) {
                          case EmitLocation.Volume:
                            !function randomPointInCube(out, extents) {
                                Vec3.set(out, randomRange(-extents.x, extents.x), randomRange(-extents.y, extents.y), randomRange(-extents.z, extents.z));
                            }(pos, _unitBoxExtent);
                            break;

                          case EmitLocation.Shell:
                            _intermediArr.splice(0, _intermediArr.length), _intermediArr.push(randomRange(-.5, .5)), 
                            _intermediArr.push(randomRange(-.5, .5)), _intermediArr.push(.5 * randomSign()), 
                            randomSortArray(_intermediArr), applyBoxThickness(_intermediArr, boxThickness), 
                            Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                            break;

                          case EmitLocation.Edge:
                            _intermediArr.splice(0, _intermediArr.length), _intermediArr.push(randomRange(-.5, .5)), 
                            _intermediArr.push(.5 * randomSign()), _intermediArr.push(.5 * randomSign()), randomSortArray(_intermediArr), 
                            applyBoxThickness(_intermediArr, boxThickness), Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                            break;

                          default:
                            console.warn(emitFrom + " is not supported for box emitter.");
                        }
                        Vec3.copy(dir, particleEmitZAxis);
                    }(this.emitFrom, this.boxThickness, p.position, p.velocity);
                    break;

                  case ShapeType.Circle:
                    !function circleEmit(radius, radiusThickness, theta, pos, dir) {
                        randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                        Vec3.normalize(dir, pos);
                    }(this.radius, this.radiusThickness, this.generateArcAngle(), p.position, p.velocity);
                    break;

                  case ShapeType.Cone:
                    !function coneEmit(emitFrom, radius, radiusThickness, theta, angle, length, pos, dir) {
                        switch (emitFrom) {
                          case EmitLocation.Base:
                            randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                            Vec2.multiplyScalar(dir, pos, Math.sin(angle)), dir.z = -Math.cos(angle) * radius, 
                            Vec3.normalize(dir, dir), pos.z = 0;
                            break;

                          case EmitLocation.Shell:
                            fixedAngleUnitVector2(pos, theta), Vec2.multiplyScalar(dir, pos, Math.sin(angle)), 
                            dir.z = -Math.cos(angle), Vec3.normalize(dir, dir), Vec2.multiplyScalar(pos, pos, radius), 
                            pos.z = 0;
                            break;

                          case EmitLocation.Volume:
                            randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                            Vec2.multiplyScalar(dir, pos, Math.sin(angle)), dir.z = -Math.cos(angle) * radius, 
                            Vec3.normalize(dir, dir), pos.z = 0, Vec3.add(pos, pos, Vec3.multiplyScalar(_intermediVec, dir, length * random() / -dir.z));
                            break;

                          default:
                            console.warn(emitFrom + " is not supported for cone emitter.");
                        }
                    }(this.emitFrom, this.radius, this.radiusThickness, this.generateArcAngle(), this._angle, this.length, p.position, p.velocity);
                    break;

                  case ShapeType.Sphere:
                    !function sphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
                        switch (emitFrom) {
                          case EmitLocation.Volume:
                            randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius), Vec3.copy(dir, pos), 
                            Vec3.normalize(dir, dir);
                            break;

                          case EmitLocation.Shell:
                            randomUnitVector(pos), Vec3.multiplyScalar(pos, pos, radius), Vec3.copy(dir, pos);
                            break;

                          default:
                            console.warn(emitFrom + " is not supported for sphere emitter.");
                        }
                    }(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                    break;

                  case ShapeType.Hemisphere:
                    !function hemisphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
                        switch (emitFrom) {
                          case EmitLocation.Volume:
                            randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius), pos.z > 0 && (pos.z *= -1), 
                            Vec3.copy(dir, pos), Vec3.normalize(dir, dir);
                            break;

                          case EmitLocation.Shell:
                            randomUnitVector(pos), Vec3.multiplyScalar(pos, pos, radius), pos.z > 0 && (pos.z *= -1), 
                            Vec3.copy(dir, pos);
                            break;

                          default:
                            console.warn(emitFrom + " is not supported for hemisphere emitter.");
                        }
                    }(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                    break;

                  default:
                    console.warn(this.shapeType + " shapeType is not supported by ShapeModule.");
                }
                if (this.randomPositionAmount > 0 && (p.position.x += randomRange(-this.randomPositionAmount, this.randomPositionAmount), 
                p.position.y += randomRange(-this.randomPositionAmount, this.randomPositionAmount), 
                p.position.z += randomRange(-this.randomPositionAmount, this.randomPositionAmount)), 
                Vec3.transformQuat(p.velocity, p.velocity, this.quat), Vec3.transformMat4(p.position, p.position, this.mat), 
                this.sphericalDirectionAmount > 0) {
                    var sphericalVel = Vec3.normalize(_intermediVec, p.position);
                    Vec3.lerp(p.velocity, p.velocity, sphericalVel, this.sphericalDirectionAmount);
                }
                this.lastTime = this.particleSystem._time;
            }
        }, {
            key: "constructMat",
            value: function constructMat() {
                Quat.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z), 
                Mat4.fromRTS(this.mat, this.quat, this._position, this._scale);
            }
        }, {
            key: "generateArcAngle",
            value: function generateArcAngle() {
                if (this.arcMode === ArcMode.Random) return randomRange(0, this._arc);
                var angle = this.totalAngle + 2 * Math.PI * this.arcSpeed.evaluate(this.particleSystem._time, 1) * (this.particleSystem._time - this.lastTime);
                switch (this.totalAngle = angle, 0 !== this.arcSpread && (angle = Math.floor(angle / (this._arc * this.arcSpread)) * this._arc * this.arcSpread), 
                this.arcMode) {
                  case ArcMode.Loop:
                    return repeat(angle, this._arc);

                  case ArcMode.PingPong:
                    return pingPong(angle, this._arc);
                }
            }
        } ]), ShapeModule;
    }()).prototype, "position", [ _dec2$1g ], Object.getOwnPropertyDescriptor(_class2$1v.prototype, "position"), _class2$1v.prototype), 
    _applyDecoratedDescriptor(_class2$1v.prototype, "rotation", [ _dec3$_ ], Object.getOwnPropertyDescriptor(_class2$1v.prototype, "rotation"), _class2$1v.prototype), 
    _applyDecoratedDescriptor(_class2$1v.prototype, "scale", [ _dec4$R ], Object.getOwnPropertyDescriptor(_class2$1v.prototype, "scale"), _class2$1v.prototype), 
    _applyDecoratedDescriptor(_class2$1v.prototype, "arc", [ _dec5$O ], Object.getOwnPropertyDescriptor(_class2$1v.prototype, "arc"), _class2$1v.prototype), 
    _applyDecoratedDescriptor(_class2$1v.prototype, "angle", [ _dec6$G ], Object.getOwnPropertyDescriptor(_class2$1v.prototype, "angle"), _class2$1v.prototype), 
    _descriptor$1k = _applyDecoratedDescriptor(_class2$1v.prototype, "enable", [ _dec7$A ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor2$18 = _applyDecoratedDescriptor(_class2$1v.prototype, "_shapeType", [ _dec8$o ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return ShapeType.Cone;
        }
    }), _applyDecoratedDescriptor(_class2$1v.prototype, "shapeType", [ _dec9$i ], Object.getOwnPropertyDescriptor(_class2$1v.prototype, "shapeType"), _class2$1v.prototype), 
    _descriptor3$X = _applyDecoratedDescriptor(_class2$1v.prototype, "emitFrom", [ _dec10$g ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return EmitLocation.Volume;
        }
    }), _descriptor4$N = _applyDecoratedDescriptor(_class2$1v.prototype, "alignToDirection", [ _dec11$g ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor5$E = _applyDecoratedDescriptor(_class2$1v.prototype, "randomDirectionAmount", [ _dec12$e ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$r = _applyDecoratedDescriptor(_class2$1v.prototype, "sphericalDirectionAmount", [ _dec13$d ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor7$m = _applyDecoratedDescriptor(_class2$1v.prototype, "randomPositionAmount", [ _dec14$b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor8$i = _applyDecoratedDescriptor(_class2$1v.prototype, "radius", [ _dec15$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor9$e = _applyDecoratedDescriptor(_class2$1v.prototype, "radiusThickness", [ _dec16$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor10$e = _applyDecoratedDescriptor(_class2$1v.prototype, "arcMode", [ _dec17$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return ArcMode.Random;
        }
    }), _descriptor11$c = _applyDecoratedDescriptor(_class2$1v.prototype, "arcSpread", [ _dec18$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor12$a = _applyDecoratedDescriptor(_class2$1v.prototype, "arcSpeed", [ _dec19$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor13$9 = _applyDecoratedDescriptor(_class2$1v.prototype, "length", [ _dec20$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 5;
        }
    }), _descriptor14$8 = _applyDecoratedDescriptor(_class2$1v.prototype, "boxThickness", [ _dec21$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(0, 0, 0);
        }
    }), _descriptor15$3 = _applyDecoratedDescriptor(_class2$1v.prototype, "_position", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(0, 0, 0);
        }
    }), _descriptor16$3 = _applyDecoratedDescriptor(_class2$1v.prototype, "_rotation", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(0, 0, 0);
        }
    }), _descriptor17$2 = _applyDecoratedDescriptor(_class2$1v.prototype, "_scale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(1, 1, 1);
        }
    }), _descriptor18$1 = _applyDecoratedDescriptor(_class2$1v.prototype, "_arc", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return toRadian(360);
        }
    }), _descriptor19$1 = _applyDecoratedDescriptor(_class2$1v.prototype, "_angle", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return toRadian(25);
        }
    }), _class$1I = _class2$1v)) || _class$1I);
    function applyBoxThickness(pos, thickness) {
        thickness.x > 0 && (pos[0] += .5 * randomRange(-thickness.x, thickness.x), pos[0] = clamp(pos[0], -.5, .5)), 
        thickness.y > 0 && (pos[1] += .5 * randomRange(-thickness.y, thickness.y), pos[1] = clamp(pos[1], -.5, .5)), 
        thickness.z > 0 && (pos[2] += .5 * randomRange(-thickness.z, thickness.z), pos[2] = clamp(pos[2], -.5, .5));
    }
    var _dec$1I, _dec2$1h, _dec3$$, _dec4$S, _dec5$P, _dec6$H, _dec7$B, _dec8$p, _dec9$j, _dec10$h, _dec11$h, _class$1J, _class2$1w, _descriptor$1l, _descriptor2$19, _descriptor3$Y, _descriptor4$O, _descriptor5$F, _dec$1J, _dec2$1i, _dec3$10, _dec4$T, _dec5$Q, _dec6$I, _dec7$C, _dec8$q, _dec9$k, _dec10$i, _dec11$i, _dec12$f, _dec13$e, _dec14$c, _class$1K, _class2$1x, _descriptor$1m, _descriptor2$1a, _descriptor3$Z, _descriptor4$P, _descriptor5$G, _descriptor6$s, _descriptor7$n, _descriptor8$j, _descriptor9$f, _descriptor10$f, _descriptor11$d, _descriptor12$b, _descriptor13$a, ParticleBatchModel = function(_Model) {
        function ParticleBatchModel() {
            var _this;
            return _classCallCheck(this, ParticleBatchModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleBatchModel).call(this)))._vertCount = 0, 
            _this._indexCount = 0, _this._type = "particle-batch", _this._capacity = 0, _this._vertAttrs = null, 
            _this._vertSize = 0, _this._vBuffer = null, _this._vertAttrsFloatCount = 0, _this._vdataF32 = null, 
            _this._vdataUint32 = null, _this._iaInfo = {
                drawInfos: [ {
                    vertexCount: 0,
                    firstVertex: 0,
                    indexCount: 0,
                    firstIndex: 0,
                    vertexOffset: 0,
                    instanceCount: 0,
                    firstInstance: 0
                } ]
            }, _this._iaInfoBuffer = _this._device.createBuffer({
                usage: exports.GFXBufferUsageBit.INDIRECT,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: 56,
                stride: 1
            }), _this._subMeshData = null, _this._mesh = null, _this;
        }
        return _inherits(ParticleBatchModel, _Model), _createClass(ParticleBatchModel, [ {
            key: "setCapacity",
            value: function setCapacity(capacity) {
                var capChanged = this._capacity !== capacity;
                this._capacity = capacity, this._inited && capChanged && this._recreateBuffer();
            }
        }, {
            key: "setVertexAttributes",
            value: function setVertexAttributes(mesh, attrs) {
                if (this._mesh !== mesh || this._vertAttrs !== attrs) {
                    this._mesh = mesh, this._vertAttrs = attrs, this._vertSize = 0;
                    var _iterator = this._vertAttrs, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var a = _ref;
                        a.offset = this._vertSize, this._vertSize += GFXFormatInfos[a.format].size;
                    }
                    this._vertAttrsFloatCount = this._vertSize / 4, this._vBuffer = this._createSubMeshData(), 
                    this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer), 
                    this._inited = !0;
                }
            }
        }, {
            key: "_createSubMeshData",
            value: function _createSubMeshData() {
                this._subMeshData && this.destroySubMeshData(), this._vertCount = 4, this._indexCount = 6, 
                this._mesh && (this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count, 
                this._indexCount = this._mesh.struct.primitives[0].indexView.count);
                var vertexBuffer = this._device.createBuffer({
                    usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: this._vertSize * this._capacity * this._vertCount,
                    stride: this._vertSize
                }), vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
                if (this._mesh) {
                    var vIdx = this._vertAttrs.findIndex((function(val) {
                        return val.name === exports.GFXAttributeName.ATTR_TEX_COORD3;
                    })), vOffset = this._vertAttrs[vIdx++].offset;
                    if (this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_POSITION, vBuffer, this._vertSize, vOffset), 
                    vOffset = this._vertAttrs[vIdx++].offset, this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_NORMAL, vBuffer, this._vertSize, vOffset), 
                    vOffset = this._vertAttrs[this._vertAttrs.findIndex((function(val) {
                        return val.name === exports.GFXAttributeName.ATTR_TEX_COORD;
                    }))].offset, this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_TEX_COORD, vBuffer, this._vertSize, vOffset), 
                    vOffset = this._vertAttrs[vIdx++].offset, !this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_COLOR, vBuffer, this._vertSize, vOffset)) for (var vb = new Uint32Array(vBuffer), iVertex = 0; iVertex < this._vertCount; ++iVertex) vb[iVertex * this._vertAttrsFloatCount + vOffset / 4] = Color.WHITE._val;
                    for (var vbFloatArray = new Float32Array(vBuffer), i = 1; i < this._capacity; i++) vbFloatArray.copyWithin(i * this._vertSize * this._vertCount / 4, 0, this._vertSize * this._vertCount / 4);
                }
                vertexBuffer.update(vBuffer);
                var indices = new Uint16Array(this._capacity * this._indexCount);
                if (this._mesh) {
                    this._mesh.copyIndices(0, indices);
                    for (var _i2 = 1; _i2 < this._capacity; _i2++) for (var j = 0; j < this._indexCount; j++) indices[_i2 * this._indexCount + j] = indices[j] + _i2 * this._vertCount;
                } else for (var dst = 0, _i3 = 0; _i3 < this._capacity; ++_i3) {
                    var baseIdx = 4 * _i3;
                    indices[dst++] = baseIdx, indices[dst++] = baseIdx + 1, indices[dst++] = baseIdx + 2, 
                    indices[dst++] = baseIdx + 3, indices[dst++] = baseIdx + 2, indices[dst++] = baseIdx + 1;
                }
                var indexBuffer = this._device.createBuffer({
                    usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: this._capacity * this._indexCount * Uint16Array.BYTES_PER_ELEMENT,
                    stride: Uint16Array.BYTES_PER_ELEMENT
                });
                return indexBuffer.update(indices), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, 
                this._iaInfo.drawInfos[0].indexCount = this._capacity * this._indexCount, this._iaInfoBuffer.status === exports.GFXStatus.UNREADY && this._iaInfoBuffer.initialize({
                    usage: exports.GFXBufferUsageBit.INDIRECT,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: 56,
                    stride: 1
                }), this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = {
                    vertexBuffers: [ vertexBuffer ],
                    indexBuffer: indexBuffer,
                    indirectBuffer: this._iaInfoBuffer,
                    attributes: this._vertAttrs,
                    primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_LIST,
                    flatBuffers: []
                }, this.setSubModelMesh(0, this._subMeshData), vBuffer;
            }
        }, {
            key: "setSubModelMaterial",
            value: function setSubModelMaterial(idx, mat) {
                this.initLocalBindings(mat), _get(_getPrototypeOf(ParticleBatchModel.prototype), "setSubModelMaterial", this).call(this, idx, mat);
            }
        }, {
            key: "addParticleVertexData",
            value: function addParticleVertexData(index, pvdata) {
                if (this._mesh) for (var i = 0; i < this._vertCount; i++) {
                    var _offset = (index * this._vertCount + i) * this._vertAttrsFloatCount;
                    this._vdataF32[_offset++] = pvdata[0].x, this._vdataF32[_offset++] = pvdata[0].y, 
                    this._vdataF32[_offset++] = pvdata[0].z, _offset += 2, this._vdataF32[_offset++] = pvdata[1].z, 
                    this._vdataF32[_offset++] = pvdata[2].x, this._vdataF32[_offset++] = pvdata[2].y, 
                    this._vdataF32[_offset++] = pvdata[2].z, this._vdataF32[_offset++] = pvdata[3].x, 
                    this._vdataF32[_offset++] = pvdata[3].y, this._vdataF32[_offset++] = pvdata[3].z, 
                    this._vdataUint32[_offset++] = pvdata[4];
                } else {
                    var offset = index * this._vertAttrsFloatCount;
                    this._vdataF32[offset++] = pvdata[0].x, this._vdataF32[offset++] = pvdata[0].y, 
                    this._vdataF32[offset++] = pvdata[0].z, this._vdataF32[offset++] = pvdata[1].x, 
                    this._vdataF32[offset++] = pvdata[1].y, this._vdataF32[offset++] = pvdata[1].z, 
                    this._vdataF32[offset++] = pvdata[2].x, this._vdataF32[offset++] = pvdata[2].y, 
                    this._vdataF32[offset++] = pvdata[2].z, this._vdataF32[offset++] = pvdata[3].x, 
                    this._vdataF32[offset++] = pvdata[3].y, this._vdataF32[offset++] = pvdata[3].z, 
                    this._vdataUint32[offset++] = pvdata[4], pvdata[5] && (this._vdataF32[offset++] = pvdata[5].x, 
                    this._vdataF32[offset++] = pvdata[5].y, this._vdataF32[offset++] = pvdata[5].z);
                }
            }
        }, {
            key: "updateIA",
            value: function updateIA(count) {
                this.getSubModel(0).inputAssembler.vertexBuffers[0].update(this._vdataF32), this.getSubModel(0).inputAssembler.indexCount = this._indexCount * count, 
                this.getSubModel(0).inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), this._iaInfoBuffer.update(this._iaInfo);
            }
        }, {
            key: "clear",
            value: function clear() {
                this.getSubModel(0).inputAssembler.indexCount = 0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(ParticleBatchModel.prototype), "destroy", this).call(this), 
                this._vBuffer = null, this._vdataF32 = null, this._subMeshData && this.destroySubMeshData(), 
                this._iaInfoBuffer.destroy(), this._subMeshData = null;
            }
        }, {
            key: "_recreateBuffer",
            value: function _recreateBuffer() {
                this._vBuffer = this._createSubMeshData(), this.getSubModel(0).updateCommandBuffer(), 
                this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
            }
        }, {
            key: "destroySubMeshData",
            value: function destroySubMeshData() {
                var _iterator2 = this._subMeshData.vertexBuffers, _isArray2 = Array.isArray(_iterator2), _i4 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i4 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i4++];
                    } else {
                        if ((_i4 = _iterator2.next()).done) break;
                        _ref2 = _i4.value;
                    }
                    _ref2.destroy();
                }
                this._subMeshData.indexBuffer.destroy();
            }
        } ]), ParticleBatchModel;
    }(Model), Particle = function Particle(particleSystem) {
        _classCallCheck(this, Particle), this.particleSystem = particleSystem, this.position = new Vec3(0, 0, 0), 
        this.velocity = new Vec3(0, 0, 0), this.animatedVelocity = new Vec3(0, 0, 0), this.ultimateVelocity = new Vec3(0, 0, 0), 
        this.angularVelocity = new Vec3(0, 0, 0), this.axisOfRotation = new Vec3(0, 0, 0), 
        this.rotation = new Vec3(0, 0, 0), this.startSize = new Vec3(0, 0, 0), this.size = new Vec3(0, 0, 0), 
        this.startColor = Color.WHITE.clone(), this.color = Color.WHITE.clone(), this.randomSeed = 0, 
        this.remainingLifetime = 0, this.startLifetime = 0, this.emitAccumulator0 = 0, this.emitAccumulator1 = 0, 
        this.frameIndex = 0, this.startRow = 0;
    }, _tempAttribUV = new Vec3, _tempWorldTrans = (new Vec2, new Mat4), _uvs$1 = [ 0, 0, 1, 0, 0, 1, 1, 1 ], _vertex_attrs$1 = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD1,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD2,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA8,
        isNormalized: !0
    } ], _vertex_attrs_stretch = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD1,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD2,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA8,
        isNormalized: !0
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR1,
        format: exports.GFXFormat.RGB32F
    } ], _vertex_attrs_mesh = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD1,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD2,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA8,
        isNormalized: !0
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD3,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_NORMAL,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR1,
        format: exports.GFXFormat.RGBA8,
        isNormalized: !0
    } ], _matInsInfo$3 = {
        parent: null,
        owner: null,
        subModelIdx: 0
    }, ParticleSystemRenderer = (_dec$1I = ccclass("cc.ParticleSystemRenderer"), _dec2$1h = property({
        type: RenderMode$1,
        displayOrder: 0,
        tooltip: "设定粒子生成模式"
    }), _dec3$$ = property({
        displayOrder: 1,
        tooltip: "在粒子生成方式为 StrecthedBillboard 时,对粒子在运动方向上按速度大小进行拉伸"
    }), _dec4$S = property({
        displayOrder: 2,
        tooltip: "在粒子生成方式为 StrecthedBillboard 时,对粒子在运动方向上按粒子大小进行拉伸"
    }), _dec5$P = property({
        type: RenderMode$1,
        displayOrder: 3
    }), _dec6$H = property({
        displayOrder: 4
    }), _dec7$B = property({
        displayOrder: 5
    }), _dec8$p = property({
        displayOrder: 6
    }), _dec9$j = property({
        type: Mesh,
        displayOrder: 7,
        tooltip: "粒子发射的模型"
    }), _dec10$h = property({
        type: Material,
        displayOrder: 8,
        tooltip: "粒子使用的材质"
    }), _dec11$h = property({
        type: Material,
        displayOrder: 9,
        tooltip: "拖尾使用的材质"
    }), _dec$1I((_applyDecoratedDescriptor((_class2$1w = function() {
        function ParticleSystemRenderer() {
            _classCallCheck(this, ParticleSystemRenderer), _initializerDefineProperty(this, "_renderMode", _descriptor$1l, this), 
            _initializerDefineProperty(this, "_velocityScale", _descriptor2$19, this), _initializerDefineProperty(this, "_lengthScale", _descriptor3$Y, this), 
            _initializerDefineProperty(this, "_mesh", _descriptor4$O, this), _initializerDefineProperty(this, "_particleSystem", _descriptor5$F, this), 
            this._vertAttrs = [], this._particles = null, this._defaultMat = null, this._defaultTrailMat = null, 
            this._model = null, this.frameTile_velLenScale = new Vec4(1, 1, 0, 0), this._node_scale = new Vec4, 
            this.attrs = new Array(5), this._defines = {
                CC_USE_WORLD_SPACE: !0,
                CC_USE_BILLBOARD: !0,
                CC_USE_STRETCHED_BILLBOARD: !1,
                CC_USE_HORIZONTAL_BILLBOARD: !1,
                CC_USE_VERTICAL_BILLBOARD: !1
            }, this._trailDefines = {
                CC_USE_WORLD_SPACE: !0
            };
        }
        return _createClass(ParticleSystemRenderer, [ {
            key: "renderMode",
            get: function get() {
                return this._renderMode;
            },
            set: function set(val) {
                this._renderMode !== val && (this._renderMode = val, this._setVertexAttrib(), this._updateModel(), 
                this._updateMaterialParams());
            }
        }, {
            key: "velocityScale",
            get: function get() {
                return this._velocityScale;
            },
            set: function set(val) {
                this._velocityScale = val, this._updateMaterialParams();
            }
        }, {
            key: "lengthScale",
            get: function get() {
                return this._lengthScale;
            },
            set: function set(val) {
                this._lengthScale = val, this._updateMaterialParams();
            }
        }, {
            key: "mesh",
            get: function get() {
                return this._mesh;
            },
            set: function set(val) {
                this._mesh = val, this._model && this._model.setVertexAttributes(this._renderMode === RenderMode$1.Mesh ? this._mesh : null, this._vertAttrs);
            }
        }, {
            key: "particleMaterial",
            get: function get() {
                return this._particleSystem ? this._particleSystem.getMaterial(0) : null;
            },
            set: function set(val) {
                this._particleSystem.setMaterial(val, 0);
            }
        }, {
            key: "trailMaterial",
            get: function get() {
                return this._particleSystem ? this._particleSystem.getMaterial(1) : null;
            },
            set: function set(val) {
                this._particleSystem.setMaterial(val, 1);
            }
        } ]), _createClass(ParticleSystemRenderer, [ {
            key: "onInit",
            value: function onInit(ps) {
                var _this = this;
                this._particleSystem = ps, this._particles = new RecyclePool((function() {
                    return new Particle(_this);
                }), 16), this._setVertexAttrib(), this._updateModel(), this._updateMaterialParams(), 
                this._updateTrailMaterial();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._particleSystem && (this._attachToScene(), this._model.initialize(this._particleSystem.node), 
                this._model.enabled = this._particleSystem.enabledInHierarchy);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._detachFromScene();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._model && (cc.director.root.destroyModel(this._model), this._model = null);
            }
        }, {
            key: "_attachToScene",
            value: function _attachToScene() {
                this._model && (this._model.scene && this._detachFromScene(), this._particleSystem._getRenderScene().addModel(this._model));
            }
        }, {
            key: "_detachFromScene",
            value: function _detachFromScene() {
                this._model && this._model.scene && this._model.scene.removeModel(this._model);
            }
        }, {
            key: "clear",
            value: function clear() {
                this._particles.reset(), this._updateRenderData();
            }
        }, {
            key: "_getFreeParticle",
            value: function _getFreeParticle() {
                return this._particles.length >= this._particleSystem.capacity ? null : this._particles.add();
            }
        }, {
            key: "_setNewParticle",
            value: function _setNewParticle(p) {}
        }, {
            key: "_updateParticles",
            value: function _updateParticles(dt) {
                switch (this._particleSystem.node.getWorldMatrix(_tempWorldTrans), this._particleSystem.scaleSpace) {
                  case Space.Local:
                    this._particleSystem.node.getScale(this._node_scale);
                    break;

                  case Space.World:
                    this._particleSystem.node.getWorldScale(this._node_scale);
                }
                (this._particleSystem.getMaterialInstance(0) || this._defaultMat).setProperty("scale", this._node_scale), 
                this._particleSystem.velocityOvertimeModule.enable && this._particleSystem.velocityOvertimeModule.update(this._particleSystem._simulationSpace, _tempWorldTrans), 
                this._particleSystem.limitVelocityOvertimeModule.enable && this._particleSystem.limitVelocityOvertimeModule.update(this._particleSystem._simulationSpace, _tempWorldTrans), 
                this._particleSystem.forceOvertimeModule.enable && this._particleSystem.forceOvertimeModule.update(this._particleSystem._simulationSpace, _tempWorldTrans), 
                this._particleSystem.trailModule.enable && this._particleSystem.trailModule.update();
                for (var i = 0; i < this._particles.length; ++i) {
                    var p = this._particles.data[i];
                    p.remainingLifetime -= dt, Vec3.set(p.animatedVelocity, 0, 0, 0), p.remainingLifetime < 0 ? (this._particleSystem.trailModule.enable && this._particleSystem.trailModule.removeParticle(p), 
                    this._particles.removeAt(i), --i) : (p.velocity.y -= 9.8 * this._particleSystem.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, p.randomSeed) * dt, 
                    this._particleSystem.sizeOvertimeModule.enable && this._particleSystem.sizeOvertimeModule.animate(p), 
                    this._particleSystem.colorOverLifetimeModule.enable && this._particleSystem.colorOverLifetimeModule.animate(p), 
                    this._particleSystem.forceOvertimeModule.enable && this._particleSystem.forceOvertimeModule.animate(p, dt), 
                    this._particleSystem.velocityOvertimeModule.enable ? this._particleSystem.velocityOvertimeModule.animate(p) : Vec3.copy(p.ultimateVelocity, p.velocity), 
                    this._particleSystem.limitVelocityOvertimeModule.enable && this._particleSystem.limitVelocityOvertimeModule.animate(p), 
                    this._particleSystem.rotationOvertimeModule.enable && this._particleSystem.rotationOvertimeModule.animate(p, dt), 
                    this._particleSystem.textureAnimationModule.enable && this._particleSystem.textureAnimationModule.animate(p), 
                    Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt), this._particleSystem.trailModule.enable && this._particleSystem.trailModule.animate(p, dt));
                }
                return this._particles.length;
            }
        }, {
            key: "_updateRenderData",
            value: function _updateRenderData() {
                for (var idx = 0, uploadVel = this._renderMode === RenderMode$1.StrecthedBillboard, i = 0; i < this._particles.length; ++i) {
                    var p = this._particles.data[i], fi = 0;
                    this._particleSystem.textureAnimationModule.enable && (fi = p.frameIndex), idx = 4 * i;
                    var attrNum = 0;
                    if (this._renderMode !== RenderMode$1.Mesh) for (var j = 0; j < 4; ++j) attrNum = 0, 
                    this.attrs[attrNum++] = p.position, _tempAttribUV.x = _uvs$1[2 * j], _tempAttribUV.y = _uvs$1[2 * j + 1], 
                    _tempAttribUV.z = fi, this.attrs[attrNum++] = _tempAttribUV, this.attrs[attrNum++] = p.size, 
                    this.attrs[attrNum++] = p.rotation, this.attrs[attrNum++] = p.color._val, this.attrs[attrNum++] = uploadVel ? p.ultimateVelocity : null, 
                    this._model.addParticleVertexData(idx++, this.attrs); else attrNum = 0, this.attrs[attrNum++] = p.position, 
                    _tempAttribUV.z = fi, this.attrs[attrNum++] = _tempAttribUV, this.attrs[attrNum++] = p.size, 
                    this.attrs[attrNum++] = p.rotation, this.attrs[attrNum++] = p.color._val, this._model.addParticleVertexData(i, this.attrs);
                }
                this._model.updateIA(this._particles.length);
            }
        }, {
            key: "updateShaderUniform",
            value: function updateShaderUniform() {}
        }, {
            key: "getParticleCount",
            value: function getParticleCount() {
                return this._particles.length;
            }
        }, {
            key: "_onMaterialModified",
            value: function _onMaterialModified(index, material) {
                0 === index ? (this._updateModel(), this._updateMaterialParams()) : this._updateTrailMaterial();
            }
        }, {
            key: "_onRebuildPSO",
            value: function _onRebuildPSO(index, material) {
                this._model && 0 === index && this._model.setSubModelMaterial(0, material), this._particleSystem.trailModule._trailModel && 1 === index && this._particleSystem.trailModule._trailModel.setSubModelMaterial(0, material);
            }
        }, {
            key: "_setVertexAttrib",
            value: function _setVertexAttrib() {
                switch (this._renderMode) {
                  case RenderMode$1.StrecthedBillboard:
                    this._vertAttrs = _vertex_attrs_stretch.slice();
                    break;

                  case RenderMode$1.Mesh:
                    this._vertAttrs = _vertex_attrs_mesh.slice();
                    break;

                  default:
                    this._vertAttrs = _vertex_attrs$1.slice();
                }
            }
        }, {
            key: "_updateMaterialParams",
            value: function _updateMaterialParams() {
                if (this._particleSystem) {
                    null != this._particleSystem.sharedMaterial && -1 === this._particleSystem.sharedMaterial._effectAsset._name.indexOf("particle") && this._particleSystem.setMaterial(null, 0), 
                    null == this._particleSystem.sharedMaterial && null == this._defaultMat && (_matInsInfo$3.parent = builtinResMgr.get("default-particle-material"), 
                    _matInsInfo$3.owner = this._particleSystem, _matInsInfo$3.subModelIdx = 0, this._defaultMat = new MaterialInstance(_matInsInfo$3));
                    var mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;
                    this._particleSystem._simulationSpace === Space.World ? this._defines.CC_USE_WORLD_SPACE = !0 : this._defines.CC_USE_WORLD_SPACE = !1, 
                    this._renderMode === RenderMode$1.Billboard ? this._defines.CC_RENDER_MODE = 0 : this._renderMode === RenderMode$1.StrecthedBillboard ? (this._defines.CC_RENDER_MODE = 1, 
                    this.frameTile_velLenScale.z = this._velocityScale, this.frameTile_velLenScale.w = this._lengthScale) : this._renderMode === RenderMode$1.HorizontalBillboard ? this._defines.CC_RENDER_MODE = 2 : this._renderMode === RenderMode$1.VerticalBillboard ? this._defines.CC_RENDER_MODE = 3 : this._renderMode === RenderMode$1.Mesh ? this._defines.CC_RENDER_MODE = 4 : console.warn("particle system renderMode ".concat(this._renderMode, " not support.")), 
                    this._particleSystem.textureAnimationModule.enable ? (Vec2.set(this.frameTile_velLenScale, this._particleSystem.textureAnimationModule.numTilesX, this._particleSystem.textureAnimationModule.numTilesY), 
                    mat.setProperty("frameTile_velLenScale", this.frameTile_velLenScale)) : mat.setProperty("frameTile_velLenScale", this.frameTile_velLenScale), 
                    mat.recompileShaders(this._defines), this._model && this._model.setSubModelMaterial(0, mat);
                }
            }
        }, {
            key: "_updateTrailMaterial",
            value: function _updateTrailMaterial() {
                if (this._particleSystem.trailModule.enable) {
                    this._particleSystem._simulationSpace === Space.World || this._particleSystem.trailModule.space === Space.World ? this._trailDefines.CC_USE_WORLD_SPACE = !0 : this._trailDefines.CC_USE_WORLD_SPACE = !1;
                    var mat = this._particleSystem.getMaterialInstance(1);
                    null === mat && null === this._defaultTrailMat && (_matInsInfo$3.parent = builtinResMgr.get("default-trail-material"), 
                    _matInsInfo$3.owner = this._particleSystem, _matInsInfo$3.subModelIdx = 1, this._defaultTrailMat = new MaterialInstance(_matInsInfo$3)), 
                    null === mat && (mat = this._defaultTrailMat), mat.recompileShaders(this._trailDefines), 
                    this._particleSystem.trailModule._updateMaterial();
                }
            }
        }, {
            key: "_updateModel",
            value: function _updateModel() {
                this._model || (this._model = cc.director.root.createModel(ParticleBatchModel), 
                this._model.setCapacity(this._particleSystem.capacity), this._model.visFlags = this._particleSystem.visibility), 
                this._model.setVertexAttributes(this._renderMode === RenderMode$1.Mesh ? this._mesh : null, this._vertAttrs);
            }
        } ]), ParticleSystemRenderer;
    }()).prototype, "renderMode", [ _dec2$1h ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "renderMode"), _class2$1w.prototype), 
    _applyDecoratedDescriptor(_class2$1w.prototype, "velocityScale", [ _dec3$$ ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "velocityScale"), _class2$1w.prototype), 
    _applyDecoratedDescriptor(_class2$1w.prototype, "lengthScale", [ _dec4$S ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "lengthScale"), _class2$1w.prototype), 
    _descriptor$1l = _applyDecoratedDescriptor(_class2$1w.prototype, "_renderMode", [ _dec5$P ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return RenderMode$1.Billboard;
        }
    }), _descriptor2$19 = _applyDecoratedDescriptor(_class2$1w.prototype, "_velocityScale", [ _dec6$H ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor3$Y = _applyDecoratedDescriptor(_class2$1w.prototype, "_lengthScale", [ _dec7$B ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor4$O = _applyDecoratedDescriptor(_class2$1w.prototype, "_mesh", [ _dec8$p ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor5$F = _applyDecoratedDescriptor(_class2$1w.prototype, "_particleSystem", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _applyDecoratedDescriptor(_class2$1w.prototype, "mesh", [ _dec9$j ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "mesh"), _class2$1w.prototype), 
    _applyDecoratedDescriptor(_class2$1w.prototype, "particleMaterial", [ _dec10$h ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "particleMaterial"), _class2$1w.prototype), 
    _applyDecoratedDescriptor(_class2$1w.prototype, "trailMaterial", [ _dec11$h ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "trailMaterial"), _class2$1w.prototype), 
    _class$1J = _class2$1w)) || _class$1J);
    Object.assign(ParticleSystemRenderer, {
        uv: _uvs$1
    });
    var _dec$1K, _dec2$1j, _dec3$11, _dec4$U, _dec5$R, _dec6$J, _dec7$D, _dec8$r, _dec9$l, _dec10$j, _dec11$j, _dec12$g, _dec13$f, _dec14$d, _dec15$9, _dec16$9, _dec17$6, _dec18$6, _dec19$3, _dec20$3, _dec21$3, _dec22$2, _dec23$2, _dec24$1, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _class$1L, _class2$1y, _descriptor$1n, _descriptor2$1b, _descriptor3$_, _descriptor4$Q, _descriptor5$H, _descriptor6$t, _descriptor7$o, _descriptor8$k, _descriptor9$g, _descriptor10$g, _descriptor11$e, _descriptor12$c, _descriptor13$b, _descriptor14$9, _descriptor15$4, _descriptor16$4, _descriptor17$3, _descriptor18$2, _descriptor19$2, _descriptor20$1, _descriptor21$1, _descriptor22$1, _descriptor23$1, _descriptor24$1, _descriptor25$1, _descriptor26$1, _descriptor27$1, _descriptor28$1, _descriptor29, _descriptor30, _descriptor31, _descriptor32, _descriptor33, _descriptor34, BoxShape, SphereShape, RigidBody, PhysicsWorld, DIRECTION_THRESHOLD = Math.cos(toRadian(100)), _temp_trailEle = {
        position: new Vec3,
        velocity: new Vec3
    }, _temp_quat = new Quat, _temp_xform = new Mat4, _temp_vec3 = new Vec3, _temp_vec3_1$1 = new Vec3, _temp_color = new Color, TrailSegment = function() {
        function TrailSegment(maxTrailElementNum) {
            for (_classCallCheck(this, TrailSegment), this.start = -1, this.end = -1, this.trailElements = []; maxTrailElementNum--; ) this.trailElements.push({
                position: new Vec3,
                lifetime: 0,
                width: 0,
                velocity: new Vec3,
                direction: 0,
                color: new Color
            });
        }
        return _createClass(TrailSegment, [ {
            key: "getElement",
            value: function getElement(idx) {
                return -1 === this.start ? null : (idx < 0 && (idx = (idx + this.trailElements.length) % this.trailElements.length), 
                idx >= this.trailElements.length && (idx %= this.trailElements.length), this.trailElements[idx]);
            }
        }, {
            key: "addElement",
            value: function addElement() {
                if (0 === this.trailElements.length) return null;
                if (-1 === this.start) return this.start = 0, this.end = 1, this.trailElements[0];
                this.start === this.end && (this.trailElements.splice(this.end, 0, {
                    position: new Vec3,
                    lifetime: 0,
                    width: 0,
                    velocity: new Vec3,
                    direction: 0,
                    color: new Color
                }), this.start++, this.start %= this.trailElements.length);
                var newEleLoc = this.end++;
                return this.end %= this.trailElements.length, this.trailElements[newEleLoc];
            }
        }, {
            key: "iterateElement",
            value: function iterateElement(target, f, p, dt) {
                for (var end = this.start >= this.end ? this.end + this.trailElements.length : this.end, i = this.start; i < end; i++) f(target, this.trailElements[i % this.trailElements.length], p, dt) && (this.start++, 
                this.start %= this.trailElements.length);
                this.start === end && (this.start = -1, this.end = -1);
            }
        }, {
            key: "count",
            value: function count() {
                return this.start < this.end ? this.end - this.start : this.trailElements.length + this.end - this.start;
            }
        }, {
            key: "clear",
            value: function clear() {
                this.start = -1, this.end = -1;
            }
        } ]), TrailSegment;
    }(), TrailModule = (_dec$1J = ccclass("cc.TrailModule"), _dec2$1i = property({
        displayOrder: 0
    }), _dec3$10 = property({
        type: TrailMode,
        displayOrder: 1,
        tooltip: "Particle在每个粒子的运动轨迹上形成拖尾效果"
    }), _dec4$T = property({
        type: CurveRange,
        displayOrder: 3,
        tooltip: "拖尾的生命周期"
    }), _dec5$Q = property({
        displayOrder: 5,
        tooltip: "粒子每生成一个拖尾节点所运行的最短距离"
    }), _dec6$I = property({
        type: Space,
        displayOrder: 6,
        tooltip: "拖尾所在的坐标系，World在世界坐标系中运行，Local在本地坐标系中运行"
    }), _dec7$C = property({
        displayOrder: 7,
        tooltip: "拖尾是否跟随粒子一起消失"
    }), _dec8$q = property({
        type: TextureMode,
        displayOrder: 8,
        tooltip: "贴图在拖尾上的展开形式，Stretch贴图覆盖在整条拖尾上，Repeat贴图覆盖在一段拖尾上"
    }), _dec9$k = property({
        displayOrder: 9,
        tooltip: "拖尾宽度继承自粒子大小"
    }), _dec10$i = property({
        type: CurveRange,
        displayOrder: 10,
        tooltip: "拖尾宽度，如果继承自粒子则是粒子大小的比例"
    }), _dec11$i = property({
        displayOrder: 11,
        tooltip: "拖尾颜色是否继承自粒子"
    }), _dec12$f = property({
        type: GradientRange,
        displayOrder: 12,
        tooltip: "拖尾颜色随拖尾自身长度的颜色渐变"
    }), _dec13$e = property({
        type: GradientRange,
        displayOrder: 13,
        tooltip: "拖尾颜色随时间的颜色渐变"
    }), _dec14$c = property({
        type: Space
    }), _dec$1J((_applyDecoratedDescriptor((_class2$1x = function() {
        function TrailModule() {
            _classCallCheck(this, TrailModule), _initializerDefineProperty(this, "_enable", _descriptor$1m, this), 
            _initializerDefineProperty(this, "mode", _descriptor2$1a, this), _initializerDefineProperty(this, "lifeTime", _descriptor3$Z, this), 
            _initializerDefineProperty(this, "_minParticleDistance", _descriptor4$P, this), 
            _initializerDefineProperty(this, "existWithParticles", _descriptor5$G, this), _initializerDefineProperty(this, "textureMode", _descriptor6$s, this), 
            _initializerDefineProperty(this, "widthFromParticle", _descriptor7$n, this), _initializerDefineProperty(this, "widthRatio", _descriptor8$j, this), 
            _initializerDefineProperty(this, "colorFromParticle", _descriptor9$f, this), _initializerDefineProperty(this, "colorOverTrail", _descriptor10$f, this), 
            _initializerDefineProperty(this, "colorOvertime", _descriptor11$d, this), _initializerDefineProperty(this, "_space", _descriptor12$b, this), 
            _initializerDefineProperty(this, "_particleSystem", _descriptor13$a, this), this._minSquaredDistance = 0, 
            this._trailNum = 0, this._trailLifetime = 0, this.vbOffset = 0, this.ibOffset = 0, 
            this._trailSegments = null, this._trailModel = null, this._iaInfoBuffer = null, 
            this._subMeshData = null, this._vbF32 = null, this._vbUint32 = null, this._iBuffer = null, 
            this._needTransform = !1, this._defaultMat = null, this._iaInfo = {
                drawInfos: [ {
                    vertexCount: 0,
                    firstVertex: 0,
                    indexCount: 0,
                    firstIndex: 0,
                    vertexOffset: 0,
                    instanceCount: 0,
                    firstInstance: 0
                } ]
            }, this._vertAttrs = [ {
                name: exports.GFXAttributeName.ATTR_POSITION,
                format: exports.GFXFormat.RGB32F
            }, {
                name: exports.GFXAttributeName.ATTR_TEX_COORD,
                format: exports.GFXFormat.RGBA32F
            }, {
                name: exports.GFXAttributeName.ATTR_TEX_COORD1,
                format: exports.GFXFormat.RGB32F
            }, {
                name: exports.GFXAttributeName.ATTR_COLOR,
                format: exports.GFXFormat.RGBA8,
                isNormalized: !0
            } ], this._vertSize = 0;
            var _iterator = this._vertAttrs, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var a = _ref;
                this._vertSize += GFXFormatInfos[a.format].size;
            }
            this._particleTrail = new Map;
        }
        return _createClass(TrailModule, [ {
            key: "enable",
            get: function get() {
                return this._enable;
            },
            set: function set(val) {
                val && !this._trailModel && this._createModel(), val && !this._enable && (this._enable = val, 
                this._particleSystem.renderer._updateTrailMaterial()), this._enable = val, this._trailModel && (this._trailModel.enabled = val);
            }
        }, {
            key: "minParticleDistance",
            get: function get() {
                return this._minParticleDistance;
            },
            set: function set(val) {
                this._minParticleDistance = val, this._minSquaredDistance = val * val;
            }
        }, {
            key: "space",
            get: function get() {
                return this._space;
            },
            set: function set(val) {
                this._space = val, this._particleSystem && this._particleSystem.renderer._updateTrailMaterial();
            }
        } ]), _createClass(TrailModule, [ {
            key: "onInit",
            value: function onInit(ps) {
                this._particleSystem = ps, this.minParticleDistance = this._minParticleDistance;
                var burstCount = 0, _iterator2 = this._particleSystem.bursts, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    burstCount += _ref2.getMaxCount(this._particleSystem);
                }
                this._trailNum = Math.ceil(this._particleSystem.startLifetime.getMax() * this.lifeTime.getMax() * 60 * (this._particleSystem.rateOverTime.getMax() * this._particleSystem.duration + burstCount)), 
                this._trailSegments = new Pool$1((function() {
                    return new TrailSegment(10);
                }), Math.ceil(this._particleSystem.rateOverTime.getMax() * this._particleSystem.duration)), 
                this._enable && (this.enable = this._enable, this._updateMaterial());
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._attachToScene();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._detachFromScene();
            }
        }, {
            key: "_attachToScene",
            value: function _attachToScene() {
                this._trailModel && (this._trailModel.scene && this._detachFromScene(), this._particleSystem._getRenderScene().addModel(this._trailModel));
            }
        }, {
            key: "_detachFromScene",
            value: function _detachFromScene() {
                this._trailModel && this._trailModel.scene && this._trailModel.scene.removeModel(this._trailModel);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._trailModel && (cc.director.root.destroyModel(this._trailModel), this._trailModel = null), 
                this._trailSegments && (this._trailSegments.clear((function(obj) {
                    obj.trailElements.length = 0;
                })), this._trailSegments = null);
            }
        }, {
            key: "clear",
            value: function clear() {
                if (this.enable) {
                    for (var trailIter = this._particleTrail.values(), trail = trailIter.next(); !trail.done; ) trail.value.clear(), 
                    trail = trailIter.next();
                    this._particleTrail.clear(), this.updateRenderData();
                }
            }
        }, {
            key: "_updateMaterial",
            value: function _updateMaterial() {
                if (this._particleSystem && this._trailModel) {
                    var mat = this._particleSystem.getMaterialInstance(1);
                    mat ? this._trailModel.setSubModelMaterial(0, mat) : this._trailModel.setSubModelMaterial(0, this._particleSystem.renderer._defaultTrailMat);
                }
            }
        }, {
            key: "update",
            value: function update() {
                this._trailLifetime = this.lifeTime.evaluate(this._particleSystem._time, 1), this.space === Space.World && this._particleSystem._simulationSpace === Space.Local ? (this._needTransform = !0, 
                this._particleSystem.node.getWorldMatrix(_temp_xform), this._particleSystem.node.getWorldRotation(_temp_quat)) : this._needTransform = !1;
            }
        }, {
            key: "animate",
            value: function animate(p, scaledDt) {
                if (this._trailSegments) {
                    var trail = this._particleTrail.get(p);
                    if (!trail) return trail = this._trailSegments.alloc(), void this._particleTrail.set(p, trail);
                    var lastSeg = trail.getElement(trail.end - 1);
                    if (this._needTransform ? Vec3.transformMat4(_temp_vec3, p.position, _temp_xform) : Vec3.copy(_temp_vec3, p.position), 
                    !(lastSeg && (trail.iterateElement(this, this._updateTrailElement, p, scaledDt), 
                    Vec3.squaredDistance(lastSeg.position, _temp_vec3) < this._minSquaredDistance)) && (lastSeg = trail.addElement())) {
                        Vec3.copy(lastSeg.position, _temp_vec3), lastSeg.lifetime = 0, this.widthFromParticle ? lastSeg.width = p.size.x * this.widthRatio.evaluate(0, 1) : lastSeg.width = this.widthRatio.evaluate(0, 1);
                        var trailNum = trail.count();
                        if (2 === trailNum) {
                            var lastSecondTrail = trail.getElement(trail.end - 2);
                            Vec3.subtract(lastSecondTrail.velocity, lastSeg.position, lastSecondTrail.position);
                        } else if (trailNum > 2) {
                            var _lastSecondTrail = trail.getElement(trail.end - 2), lastThirdTrail = trail.getElement(trail.end - 3);
                            Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail.position), Vec3.subtract(_temp_vec3_1$1, lastSeg.position, _lastSecondTrail.position), 
                            Vec3.subtract(_lastSecondTrail.velocity, _temp_vec3_1$1, _temp_vec3), Vec3.equals(Vec3.ZERO, _lastSecondTrail.velocity) && Vec3.copy(_lastSecondTrail.velocity, _temp_vec3), 
                            Vec3.normalize(_lastSecondTrail.velocity, _lastSecondTrail.velocity), this._checkDirectionReverse(_lastSecondTrail, lastThirdTrail);
                        }
                        this.colorFromParticle ? lastSeg.color.set(p.color) : lastSeg.color.set(this.colorOvertime.evaluate(0, 1));
                    }
                }
            }
        }, {
            key: "removeParticle",
            value: function removeParticle(p) {
                var trail = this._particleTrail.get(p);
                trail && this._trailSegments && (trail.clear(), this._trailSegments.free(trail), 
                this._particleTrail.delete(p));
            }
        }, {
            key: "updateRenderData",
            value: function updateRenderData() {
                this.vbOffset = 0, this.ibOffset = 0;
                var _iterator3 = this._particleTrail.keys(), _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var p = _ref3, trailSeg = this._particleTrail.get(p);
                    if (-1 !== trailSeg.start) {
                        var indexOffset = 4 * this.vbOffset / this._vertSize, end = trailSeg.start >= trailSeg.end ? trailSeg.end + trailSeg.trailElements.length : trailSeg.end, trailNum = end - trailSeg.start, textCoordSeg = 1 / trailNum, startSegEle = trailSeg.trailElements[trailSeg.start];
                        this._fillVertexBuffer(startSegEle, this.colorOverTrail.evaluate(1, 1), indexOffset, 1, 0, 4);
                        for (var i = trailSeg.start + 1; i < end; i++) {
                            var segEle = trailSeg.trailElements[i % trailSeg.trailElements.length], j = i - trailSeg.start;
                            this._fillVertexBuffer(segEle, this.colorOverTrail.evaluate(1 - j / trailNum, 1), indexOffset, 1 - j * textCoordSeg, j, 5);
                        }
                        if (this._needTransform ? Vec3.transformMat4(_temp_trailEle.position, p.position, _temp_xform) : Vec3.copy(_temp_trailEle.position, p.position), 
                        1 === trailNum || 2 === trailNum) {
                            var lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
                            Vec3.subtract(lastSecondTrail.velocity, _temp_trailEle.position, lastSecondTrail.position), 
                            this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = lastSecondTrail.velocity.x, 
                            this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = lastSecondTrail.velocity.y, 
                            this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = lastSecondTrail.velocity.z, 
                            this._vbF32[this.vbOffset - 4] = lastSecondTrail.velocity.x, this._vbF32[this.vbOffset - 3] = lastSecondTrail.velocity.y, 
                            this._vbF32[this.vbOffset - 2] = lastSecondTrail.velocity.z, Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position), 
                            this._checkDirectionReverse(_temp_trailEle, lastSecondTrail);
                        } else if (trailNum > 2) {
                            var _lastSecondTrail2 = trailSeg.getElement(trailSeg.end - 1), lastThirdTrail = trailSeg.getElement(trailSeg.end - 2);
                            Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail2.position), 
                            Vec3.subtract(_temp_vec3_1$1, _temp_trailEle.position, _lastSecondTrail2.position), 
                            Vec3.normalize(_temp_vec3, _temp_vec3), Vec3.normalize(_temp_vec3_1$1, _temp_vec3_1$1), 
                            Vec3.subtract(_lastSecondTrail2.velocity, _temp_vec3_1$1, _temp_vec3), Vec3.normalize(_lastSecondTrail2.velocity, _lastSecondTrail2.velocity), 
                            this._checkDirectionReverse(_lastSecondTrail2, lastThirdTrail), this.vbOffset -= this._vertSize / 4 * 2, 
                            this.ibOffset -= 6, this._fillVertexBuffer(_lastSecondTrail2, this.colorOverTrail.evaluate(textCoordSeg, 1), indexOffset, textCoordSeg, trailNum - 1, 5), 
                            Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, _lastSecondTrail2.position), 
                            Vec3.normalize(_temp_trailEle.velocity, _temp_trailEle.velocity), this._checkDirectionReverse(_temp_trailEle, _lastSecondTrail2);
                        }
                        this.widthFromParticle ? _temp_trailEle.width = p.size.x * this.widthRatio.evaluate(0, 1) : _temp_trailEle.width = this.widthRatio.evaluate(0, 1), 
                        _temp_trailEle.color = p.color, Vec3.equals(_temp_trailEle.velocity, Vec3.ZERO) ? this.ibOffset -= 3 : this._fillVertexBuffer(_temp_trailEle, this.colorOverTrail.evaluate(0, 1), indexOffset, 0, trailNum, 1);
                    }
                }
                this.updateIA(this.ibOffset);
            }
        }, {
            key: "updateIA",
            value: function updateIA(count) {
                if (this._trailModel && this._trailModel.subModelNum > 0) {
                    var subModel = this._trailModel.getSubModel(0);
                    subModel.inputAssembler.vertexBuffers[0].update(this._vbF32), subModel.inputAssembler.indexBuffer.update(this._iBuffer), 
                    subModel.inputAssembler.indexCount = count, subModel.inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), 
                    this._iaInfoBuffer.update(this._iaInfo);
                }
            }
        }, {
            key: "_createModel",
            value: function _createModel() {
                if (!this._trailModel) {
                    var device = director.root.device, vertexBuffer = device.createBuffer({
                        usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                        size: this._vertSize * (this._trailNum + 1) * 2,
                        stride: this._vertSize
                    }), vBuffer = new ArrayBuffer(this._vertSize * (this._trailNum + 1) * 2);
                    this._vbF32 = new Float32Array(vBuffer), this._vbUint32 = new Uint32Array(vBuffer), 
                    vertexBuffer.update(vBuffer);
                    var indexBuffer = device.createBuffer({
                        usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                        size: 6 * this._trailNum * Uint16Array.BYTES_PER_ELEMENT,
                        stride: Uint16Array.BYTES_PER_ELEMENT
                    });
                    this._iBuffer = new Uint16Array(6 * this._trailNum), indexBuffer.update(this._iBuffer), 
                    this._iaInfoBuffer = device.createBuffer({
                        usage: exports.GFXBufferUsageBit.INDIRECT,
                        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                        size: 56,
                        stride: 1
                    }), this._iaInfo.drawInfos[0].vertexCount = 2 * (this._trailNum + 1), this._iaInfo.drawInfos[0].indexCount = 6 * this._trailNum, 
                    this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = {
                        vertexBuffers: [ vertexBuffer ],
                        indexBuffer: indexBuffer,
                        indirectBuffer: this._iaInfoBuffer,
                        attributes: this._vertAttrs,
                        primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_LIST,
                        flatBuffers: []
                    }, this._trailModel = cc.director.root.createModel(Model), this._trailModel.initialize(this._particleSystem.node), 
                    this._trailModel.visFlags = this._particleSystem.visibility, this._trailModel.setSubModelMesh(0, this._subMeshData), 
                    this._trailModel.enabled = !0;
                }
            }
        }, {
            key: "_updateTrailElement",
            value: function _updateTrailElement(module, trailEle, p, dt) {
                return trailEle.lifetime += dt, module.colorFromParticle ? (trailEle.color.set(p.color), 
                trailEle.color.multiply(module.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1))) : trailEle.color.set(module.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1)), 
                module.widthFromParticle ? trailEle.width = p.size.x * module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1) : trailEle.width = module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1), 
                trailEle.lifetime > module._trailLifetime;
            }
        }, {
            key: "_fillVertexBuffer",
            value: function _fillVertexBuffer(trailSeg, colorModifer, indexOffset, xTexCoord, trailEleIdx, indexSet) {
                this._vbF32[this.vbOffset++] = trailSeg.position.x, this._vbF32[this.vbOffset++] = trailSeg.position.y, 
                this._vbF32[this.vbOffset++] = trailSeg.position.z, this._vbF32[this.vbOffset++] = trailSeg.direction, 
                this._vbF32[this.vbOffset++] = trailSeg.width, this._vbF32[this.vbOffset++] = xTexCoord, 
                this._vbF32[this.vbOffset++] = 0, this._vbF32[this.vbOffset++] = trailSeg.velocity.x, 
                this._vbF32[this.vbOffset++] = trailSeg.velocity.y, this._vbF32[this.vbOffset++] = trailSeg.velocity.z, 
                _temp_color.set(trailSeg.color), _temp_color.multiply(colorModifer), this._vbUint32[this.vbOffset++] = _temp_color._val, 
                this._vbF32[this.vbOffset++] = trailSeg.position.x, this._vbF32[this.vbOffset++] = trailSeg.position.y, 
                this._vbF32[this.vbOffset++] = trailSeg.position.z, this._vbF32[this.vbOffset++] = 1 - trailSeg.direction, 
                this._vbF32[this.vbOffset++] = trailSeg.width, this._vbF32[this.vbOffset++] = xTexCoord, 
                this._vbF32[this.vbOffset++] = 1, this._vbF32[this.vbOffset++] = trailSeg.velocity.x, 
                this._vbF32[this.vbOffset++] = trailSeg.velocity.y, this._vbF32[this.vbOffset++] = trailSeg.velocity.z, 
                this._vbUint32[this.vbOffset++] = _temp_color._val, 1 & indexSet && (this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx, 
                this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx - 1, this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1), 
                4 & indexSet && (this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx, 
                this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1, this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 2);
            }
        }, {
            key: "_checkDirectionReverse",
            value: function _checkDirectionReverse(currElement, prevElement) {
                Vec3.dot(currElement.velocity, prevElement.velocity) < DIRECTION_THRESHOLD ? currElement.direction = 1 - prevElement.direction : currElement.direction = prevElement.direction;
            }
        } ]), TrailModule;
    }()).prototype, "enable", [ _dec2$1i ], Object.getOwnPropertyDescriptor(_class2$1x.prototype, "enable"), _class2$1x.prototype), 
    _descriptor$1m = _applyDecoratedDescriptor(_class2$1x.prototype, "_enable", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$1a = _applyDecoratedDescriptor(_class2$1x.prototype, "mode", [ _dec3$10 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return TrailMode.Particles;
        }
    }), _descriptor3$Z = _applyDecoratedDescriptor(_class2$1x.prototype, "lifeTime", [ _dec4$T ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor4$P = _applyDecoratedDescriptor(_class2$1x.prototype, "_minParticleDistance", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _applyDecoratedDescriptor(_class2$1x.prototype, "minParticleDistance", [ _dec5$Q ], Object.getOwnPropertyDescriptor(_class2$1x.prototype, "minParticleDistance"), _class2$1x.prototype), 
    _applyDecoratedDescriptor(_class2$1x.prototype, "space", [ _dec6$I ], Object.getOwnPropertyDescriptor(_class2$1x.prototype, "space"), _class2$1x.prototype), 
    _descriptor5$G = _applyDecoratedDescriptor(_class2$1x.prototype, "existWithParticles", [ _dec7$C ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor6$s = _applyDecoratedDescriptor(_class2$1x.prototype, "textureMode", [ _dec8$q ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return TextureMode.Stretch;
        }
    }), _descriptor7$n = _applyDecoratedDescriptor(_class2$1x.prototype, "widthFromParticle", [ _dec9$k ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor8$j = _applyDecoratedDescriptor(_class2$1x.prototype, "widthRatio", [ _dec10$i ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor9$f = _applyDecoratedDescriptor(_class2$1x.prototype, "colorFromParticle", [ _dec11$i ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor10$f = _applyDecoratedDescriptor(_class2$1x.prototype, "colorOverTrail", [ _dec12$f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new GradientRange;
        }
    }), _descriptor11$d = _applyDecoratedDescriptor(_class2$1x.prototype, "colorOvertime", [ _dec13$e ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new GradientRange;
        }
    }), _descriptor12$b = _applyDecoratedDescriptor(_class2$1x.prototype, "_space", [ _dec14$c ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.World;
        }
    }), _descriptor13$a = _applyDecoratedDescriptor(_class2$1x.prototype, "_particleSystem", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$1K = _class2$1x)) || _class$1K), _world_mat = new Mat4, ParticleSystemComponent = (_dec$1K = ccclass("cc.ParticleSystemComponent"), 
    _dec2$1j = menu("Components/ParticleSystem"), _dec3$11 = executionOrder(99), _dec4$U = property({
        displayOrder: 1,
        tooltip: "粒子系统能生成的最大粒子数量"
    }), _dec5$R = property({
        type: GradientRange,
        displayOrder: 8,
        tooltip: "粒子初始颜色"
    }), _dec6$J = property({
        type: Space,
        displayOrder: 9,
        tooltip: "选择缩放坐标系"
    }), _dec7$D = property({
        displayOrder: 10,
        tooltip: "粒子初始大小"
    }), _dec8$r = property({
        type: CurveRange,
        displayOrder: 10,
        formerlySerializedAs: "startSize",
        tooltip: "粒子初始大小"
    }), _dec9$l = property({
        type: CurveRange,
        displayOrder: 10,
        tooltip: "粒子初始大小"
    }), _dec10$j = property({
        type: CurveRange,
        displayOrder: 10,
        tooltip: "粒子初始大小"
    }), _dec11$j = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 11,
        tooltip: "粒子初始速度"
    }), _dec12$g = property({
        displayOrder: 12,
        tooltip: "粒子初始旋转角度"
    }), _dec13$f = property({
        type: CurveRange,
        range: [ -1, 1 ],
        radian: !0,
        displayOrder: 12,
        tooltip: "粒子初始旋转角度"
    }), _dec14$d = property({
        type: CurveRange,
        range: [ -1, 1 ],
        radian: !0,
        displayOrder: 12,
        tooltip: "粒子初始旋转角度"
    }), _dec15$9 = property({
        type: CurveRange,
        range: [ -1, 1 ],
        radian: !0,
        displayOrder: 12,
        formerlySerializedAs: "startRotation",
        tooltip: "粒子初始旋转角度"
    }), _dec16$9 = property({
        type: CurveRange,
        displayOrder: 6,
        tooltip: "粒子系统开始运行后，延迟粒子发射的时间"
    }), _dec17$6 = property({
        type: CurveRange,
        displayOrder: 7,
        tooltip: "粒子生命周期"
    }), _dec18$6 = property({
        displayOrder: 0,
        tooltip: "粒子系统运行时间"
    }), _dec19$3 = property({
        displayOrder: 2,
        tooltip: "粒子系统是否循环播放"
    }), _dec20$3 = property({
        displayOrder: 3,
        tooltip: "选中之后，粒子系统会以已播放完一轮之后的状态开始播放（仅当循环播放启用时有效）"
    }), _dec21$3 = property({
        type: Space,
        displayOrder: 4,
        tooltip: "控制粒子坐标计算所在的坐标系"
    }), _dec22$2 = property({
        displayOrder: 5,
        tooltip: "控制整个粒子系统的更新速度"
    }), _dec23$2 = property({
        displayOrder: 2,
        tooltip: "粒子系统加载后是否自动开始播放"
    }), _dec24$1 = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 13,
        tooltip: "粒子受重力影响的重力系数"
    }), _dec25 = property({
        type: CurveRange,
        displayOrder: 14,
        tooltip: "每秒发射的粒子数"
    }), _dec26 = property({
        type: CurveRange,
        displayOrder: 15,
        tooltip: "每移动单位距离发射的粒子数"
    }), _dec27 = property({
        type: [ Burst ],
        displayOrder: 16,
        tooltip: "在某个时间点发射给定数量的粒子"
    }), _dec28 = property({
        type: Material,
        displayName: "Materials",
        visible: !1,
        override: !0
    }), _dec29 = property({
        type: ColorOvertimeModule,
        displayOrder: 23,
        tooltip: "颜色模块"
    }), _dec30 = property({
        type: ShapeModule,
        displayOrder: 17,
        tooltip: "发射器模块"
    }), _dec31 = property({
        type: SizeOvertimeModule,
        displayOrder: 21,
        tooltip: "大小模块"
    }), _dec32 = property({
        type: VelocityOvertimeModule,
        displayOrder: 18,
        tooltip: "速度模块"
    }), _dec33 = property({
        type: ForceOvertimeModule,
        displayOrder: 19,
        tooltip: "加速度模块"
    }), _dec34 = property({
        type: LimitVelocityOvertimeModule,
        displayOrder: 20,
        tooltip: "限速模块"
    }), _dec35 = property({
        type: RotationOvertimeModule,
        displayOrder: 22,
        tooltip: "旋转模块"
    }), _dec36 = property({
        type: TextureAnimationModule,
        displayOrder: 24,
        tooltip: "贴图动画模块"
    }), _dec37 = property({
        type: TrailModule,
        displayOrder: 25,
        tooltip: "拖尾模块"
    }), _dec38 = property({
        type: ParticleSystemRenderer,
        displayOrder: 26,
        tooltip: "渲染模块"
    }), _dec$1K(_class$1L = _dec2$1j(_class$1L = _dec3$11(_class$1L = executeInEditMode((_applyDecoratedDescriptor((_class2$1y = function(_RenderableComponent) {
        function ParticleSystemComponent() {
            var _this;
            return _classCallCheck(this, ParticleSystemComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleSystemComponent).call(this)), "startColor", _descriptor$1n, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "scaleSpace", _descriptor2$1b, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "startSize3D", _descriptor3$_, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "startSizeX", _descriptor4$Q, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "startSizeY", _descriptor5$H, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "startSizeZ", _descriptor6$t, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "startSpeed", _descriptor7$o, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "startRotation3D", _descriptor8$k, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "startRotationX", _descriptor9$g, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "startRotationY", _descriptor10$g, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "startRotationZ", _descriptor11$e, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "startDelay", _descriptor12$c, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "startLifetime", _descriptor13$b, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "duration", _descriptor14$9, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "loop", _descriptor15$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "simulationSpeed", _descriptor16$4, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "playOnAwake", _descriptor17$3, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "gravityModifier", _descriptor18$2, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "rateOverTime", _descriptor19$2, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "rateOverDistance", _descriptor20$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "bursts", _descriptor21$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "colorOverLifetimeModule", _descriptor22$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "shapeModule", _descriptor23$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "sizeOvertimeModule", _descriptor24$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "velocityOvertimeModule", _descriptor25$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "forceOvertimeModule", _descriptor26$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "limitVelocityOvertimeModule", _descriptor27$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "rotationOvertimeModule", _descriptor28$1, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "textureAnimationModule", _descriptor29, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "trailModule", _descriptor30, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "renderer", _descriptor31, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_prewarm", _descriptor32, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_capacity", _descriptor33, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_simulationSpace", _descriptor34, _assertThisInitialized(_this)), 
            _this.rateOverTime.constant = 10, _this.startLifetime.constant = 5, _this.startSizeX.constant = 1, 
            _this.startSpeed.constant = 5, _this._isPlaying = !1, _this._isPaused = !1, _this._isStopped = !0, 
            _this._isEmitting = !1, _this._time = 0, _this._emitRateTimeCounter = 0, _this._emitRateDistanceCounter = 0, 
            _this._oldWPos = new Vec3, _this._curWPos = new Vec3, _this._customData1 = new Vec2, 
            _this._customData2 = new Vec2, _this._subEmitters = [], _this;
        }
        return _inherits(ParticleSystemComponent, _RenderableComponent), _createClass(ParticleSystemComponent, [ {
            key: "capacity",
            get: function get() {
                return this._capacity;
            },
            set: function set(val) {
                this._capacity = val, this.renderer && this.renderer._model && this.renderer._model.setCapacity(this._capacity);
            }
        }, {
            key: "prewarm",
            get: function get() {
                return this._prewarm;
            },
            set: function set(val) {
                !0 === val && this.loop, this._prewarm = val;
            }
        }, {
            key: "simulationSpace",
            get: function get() {
                return this._simulationSpace;
            },
            set: function set(val) {
                val !== this._simulationSpace && (this._simulationSpace = val, this.renderer._updateMaterialParams(), 
                this.renderer._updateTrailMaterial());
            }
        }, {
            key: "sharedMaterials",
            get: function get() {
                return _get(_getPrototypeOf(ParticleSystemComponent.prototype), "sharedMaterials", this);
            },
            set: function set(val) {
                _set(_getPrototypeOf(ParticleSystemComponent.prototype), "sharedMaterials", val, this, !0);
            }
        } ]), _createClass(ParticleSystemComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this.renderer.onInit(this), this.shapeModule.onInit(this), this.trailModule.onInit(this), 
                this.textureAnimationModule.onInit(this), this._resetPosition();
            }
        }, {
            key: "_onMaterialModified",
            value: function _onMaterialModified(index, material) {
                this.renderer._onMaterialModified(index, material);
            }
        }, {
            key: "_onRebuildPSO",
            value: function _onRebuildPSO(index, material) {
                this.renderer._onRebuildPSO(index, material);
            }
        }, {
            key: "_collectModels",
            value: function _collectModels() {
                return this._models.length = 0, this._models.push(this.renderer._model), this.trailModule.enable && this.trailModule._trailModel && this._models.push(this.trailModule._trailModel), 
                this._models;
            }
        }, {
            key: "_attachToScene",
            value: function _attachToScene() {
                this.renderer._attachToScene(), this.trailModule.enable && this.trailModule._attachToScene();
            }
        }, {
            key: "_detachFromScene",
            value: function _detachFromScene() {
                this.renderer._detachFromScene(), this.trailModule.enable && this.trailModule._detachFromScene();
            }
        }, {
            key: "play",
            value: function play() {
                this._isPaused && (this._isPaused = !1), this._isStopped && (this._isStopped = !1), 
                this._isPlaying = !0, this._isEmitting = !0, this._resetPosition(), this._prewarm && this._prewarmSystem();
            }
        }, {
            key: "pause",
            value: function pause() {
                this._isStopped ? console.warn("pause(): particle system is already stopped.") : (this._isPlaying && (this._isPlaying = !1), 
                this._isPaused = !0);
            }
        }, {
            key: "stop",
            value: function stop() {
                (this._isPlaying || this._isPaused) && this.clear(), this._isPlaying && (this._isPlaying = !1), 
                this._isPaused && (this._isPaused = !1), this._time = 0, this._emitRateTimeCounter = 0, 
                this._emitRateDistanceCounter = 0, this._isStopped = !0;
            }
        }, {
            key: "clear",
            value: function clear() {
                this.enabledInHierarchy && (this.renderer.clear(), this.trailModule.clear());
            }
        }, {
            key: "getParticleCount",
            value: function getParticleCount() {
                return this.renderer.getParticleCount();
            }
        }, {
            key: "setCustomData1",
            value: function setCustomData1(x, y) {
                Vec2.set(this._customData1, x, y);
            }
        }, {
            key: "setCustomData2",
            value: function setCustomData2(x, y) {
                Vec2.set(this._customData2, x, y);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this.renderer.onDestroy(), this.trailModule.destroy();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this.playOnAwake && this.play(), this.renderer.onEnable(), this.trailModule.onEnable();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.renderer.onDisable(), this.trailModule.onDisable();
            }
        }, {
            key: "update",
            value: function update(dt) {
                var scaledDeltaTime = dt * this.simulationSpeed;
                this._isPlaying && (this._time += scaledDeltaTime, this._emit(scaledDeltaTime), 
                0 !== this.renderer._updateParticles(scaledDeltaTime) || this._isEmitting || this.stop(), 
                this.renderer._updateRenderData(), this.trailModule.enable && this.trailModule.updateRenderData());
            }
        }, {
            key: "_onVisiblityChange",
            value: function _onVisiblityChange(val) {
                this.renderer._model && (this.renderer._model.visFlags = val);
            }
        }, {
            key: "emit",
            value: function emit(count, dt) {
                for (var i = 0; i < count; ++i) {
                    var particle = this.renderer._getFreeParticle();
                    if (null === particle) return;
                    var rand = pseudoRandom(randomRangeInt(0, 2147483647));
                    switch (this.shapeModule.enable ? this.shapeModule.emit(particle) : (Vec3.set(particle.position, 0, 0, 0), 
                    Vec3.copy(particle.velocity, particleEmitZAxis)), this.textureAnimationModule.enable && this.textureAnimationModule.init(particle), 
                    Vec3.multiplyScalar(particle.velocity, particle.velocity, this.startSpeed.evaluate(this._time / this.duration, rand)), 
                    this._simulationSpace) {
                      case Space.Local:
                        break;

                      case Space.World:
                        this.node.getWorldMatrix(_world_mat), Vec3.transformMat4(particle.position, particle.position, _world_mat);
                        var worldRot = new Quat;
                        this.node.getWorldRotation(worldRot), Vec3.transformQuat(particle.velocity, particle.velocity, worldRot);
                        break;

                      case Space.Custom:
                    }
                    Vec3.copy(particle.ultimateVelocity, particle.velocity), this.startRotation3D ? Vec3.set(particle.rotation, this.startRotationX.evaluate(this._time / this.duration, rand), this.startRotationY.evaluate(this._time / this.duration, rand), this.startRotationZ.evaluate(this._time / this.duration, rand)) : Vec3.set(particle.rotation, 0, 0, this.startRotationZ.evaluate(this._time / this.duration, rand)), 
                    this.startSize3D ? Vec3.set(particle.startSize, this.startSizeX.evaluate(this._time / this.duration, rand), this.startSizeY.evaluate(this._time / this.duration, rand), this.startSizeZ.evaluate(this._time / this.duration, rand)) : (Vec3.set(particle.startSize, this.startSizeX.evaluate(this._time / this.duration, rand), 1, 1), 
                    particle.startSize.y = particle.startSize.x), Vec3.copy(particle.size, particle.startSize), 
                    particle.startColor.set(this.startColor.evaluate(this._time / this.duration, rand)), 
                    particle.color.set(particle.startColor), particle.startLifetime = this.startLifetime.evaluate(this._time / this.duration, rand) + dt, 
                    particle.remainingLifetime = particle.startLifetime, particle.randomSeed = randomRangeInt(0, 233280), 
                    this.renderer._setNewParticle(particle);
                }
            }
        }, {
            key: "_prewarmSystem",
            value: function _prewarmSystem() {
                this.startDelay.mode = Mode$1.Constant, this.startDelay.constant = 0;
                for (var cnt = this.duration / 1, i = 0; i < cnt; ++i) this._time += 1, this._emit(1), 
                this.renderer._updateParticles(1);
            }
        }, {
            key: "_emit",
            value: function _emit(dt) {
                var startDelay = this.startDelay.evaluate(0, 1);
                if (this._time > startDelay) {
                    if (this._time > this.duration + startDelay && !this.loop) return void (this._isEmitting = !1);
                    if (this._emitRateTimeCounter += this.rateOverTime.evaluate(this._time / this.duration, 1) * dt, 
                    this._emitRateTimeCounter > 1 && this._isEmitting) {
                        var emitNum = Math.floor(this._emitRateTimeCounter);
                        this._emitRateTimeCounter -= emitNum, this.emit(emitNum, dt);
                    }
                    this.node.getWorldPosition(this._curWPos);
                    var distance = Vec3.distance(this._curWPos, this._oldWPos);
                    if (Vec3.copy(this._oldWPos, this._curWPos), this._emitRateDistanceCounter += distance * this.rateOverDistance.evaluate(this._time / this.duration, 1), 
                    this._emitRateDistanceCounter > 1 && this._isEmitting) {
                        var _emitNum = Math.floor(this._emitRateDistanceCounter);
                        this._emitRateDistanceCounter -= _emitNum, this.emit(_emitNum, dt);
                    }
                    var _iterator = this.bursts, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        _ref.update(this, dt);
                    }
                }
            }
        }, {
            key: "_resetPosition",
            value: function _resetPosition() {
                this.node.getWorldPosition(this._oldWPos), Vec3.copy(this._curWPos, this._oldWPos);
            }
        }, {
            key: "addSubEmitter",
            value: function addSubEmitter(subEmitter) {
                this._subEmitters.push(subEmitter);
            }
        }, {
            key: "removeSubEmitter",
            value: function removeSubEmitter(idx) {
                this._subEmitters.splice(this._subEmitters.indexOf(idx), 1);
            }
        }, {
            key: "addBurst",
            value: function addBurst(burst) {
                this.bursts.push(burst);
            }
        }, {
            key: "removeBurst",
            value: function removeBurst(idx) {
                this.bursts.splice(this.bursts.indexOf(idx), 1);
            }
        }, {
            key: "isPlaying",
            get: function get() {
                return this._isPlaying;
            }
        }, {
            key: "isPaused",
            get: function get() {
                return this._isPaused;
            }
        }, {
            key: "isStopped",
            get: function get() {
                return this._isStopped;
            }
        }, {
            key: "isEmitting",
            get: function get() {
                return this._isEmitting;
            }
        }, {
            key: "time",
            get: function get() {
                return this._time;
            }
        } ]), ParticleSystemComponent;
    }(RenderableComponent)).prototype, "capacity", [ _dec4$U ], Object.getOwnPropertyDescriptor(_class2$1y.prototype, "capacity"), _class2$1y.prototype), 
    _descriptor$1n = _applyDecoratedDescriptor(_class2$1y.prototype, "startColor", [ _dec5$R ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new GradientRange;
        }
    }), _descriptor2$1b = _applyDecoratedDescriptor(_class2$1y.prototype, "scaleSpace", [ _dec6$J ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.Local;
        }
    }), _descriptor3$_ = _applyDecoratedDescriptor(_class2$1y.prototype, "startSize3D", [ _dec7$D ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor4$Q = _applyDecoratedDescriptor(_class2$1y.prototype, "startSizeX", [ _dec8$r ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor5$H = _applyDecoratedDescriptor(_class2$1y.prototype, "startSizeY", [ _dec9$l ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor6$t = _applyDecoratedDescriptor(_class2$1y.prototype, "startSizeZ", [ _dec10$j ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor7$o = _applyDecoratedDescriptor(_class2$1y.prototype, "startSpeed", [ _dec11$j ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor8$k = _applyDecoratedDescriptor(_class2$1y.prototype, "startRotation3D", [ _dec12$g ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor9$g = _applyDecoratedDescriptor(_class2$1y.prototype, "startRotationX", [ _dec13$f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor10$g = _applyDecoratedDescriptor(_class2$1y.prototype, "startRotationY", [ _dec14$d ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor11$e = _applyDecoratedDescriptor(_class2$1y.prototype, "startRotationZ", [ _dec15$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor12$c = _applyDecoratedDescriptor(_class2$1y.prototype, "startDelay", [ _dec16$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor13$b = _applyDecoratedDescriptor(_class2$1y.prototype, "startLifetime", [ _dec17$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor14$9 = _applyDecoratedDescriptor(_class2$1y.prototype, "duration", [ _dec18$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 5;
        }
    }), _descriptor15$4 = _applyDecoratedDescriptor(_class2$1y.prototype, "loop", [ _dec19$3 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _applyDecoratedDescriptor(_class2$1y.prototype, "prewarm", [ _dec20$3 ], Object.getOwnPropertyDescriptor(_class2$1y.prototype, "prewarm"), _class2$1y.prototype), 
    _applyDecoratedDescriptor(_class2$1y.prototype, "simulationSpace", [ _dec21$3 ], Object.getOwnPropertyDescriptor(_class2$1y.prototype, "simulationSpace"), _class2$1y.prototype), 
    _descriptor16$4 = _applyDecoratedDescriptor(_class2$1y.prototype, "simulationSpeed", [ _dec22$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor17$3 = _applyDecoratedDescriptor(_class2$1y.prototype, "playOnAwake", [ _dec23$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor18$2 = _applyDecoratedDescriptor(_class2$1y.prototype, "gravityModifier", [ _dec24$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor19$2 = _applyDecoratedDescriptor(_class2$1y.prototype, "rateOverTime", [ _dec25 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor20$1 = _applyDecoratedDescriptor(_class2$1y.prototype, "rateOverDistance", [ _dec26 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange;
        }
    }), _descriptor21$1 = _applyDecoratedDescriptor(_class2$1y.prototype, "bursts", [ _dec27 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Array;
        }
    }), _applyDecoratedDescriptor(_class2$1y.prototype, "sharedMaterials", [ _dec28 ], Object.getOwnPropertyDescriptor(_class2$1y.prototype, "sharedMaterials"), _class2$1y.prototype), 
    _descriptor22$1 = _applyDecoratedDescriptor(_class2$1y.prototype, "colorOverLifetimeModule", [ _dec29 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new ColorOvertimeModule;
        }
    }), _descriptor23$1 = _applyDecoratedDescriptor(_class2$1y.prototype, "shapeModule", [ _dec30 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new ShapeModule;
        }
    }), _descriptor24$1 = _applyDecoratedDescriptor(_class2$1y.prototype, "sizeOvertimeModule", [ _dec31 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new SizeOvertimeModule;
        }
    }), _descriptor25$1 = _applyDecoratedDescriptor(_class2$1y.prototype, "velocityOvertimeModule", [ _dec32 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new VelocityOvertimeModule;
        }
    }), _descriptor26$1 = _applyDecoratedDescriptor(_class2$1y.prototype, "forceOvertimeModule", [ _dec33 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new ForceOvertimeModule;
        }
    }), _descriptor27$1 = _applyDecoratedDescriptor(_class2$1y.prototype, "limitVelocityOvertimeModule", [ _dec34 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new LimitVelocityOvertimeModule;
        }
    }), _descriptor28$1 = _applyDecoratedDescriptor(_class2$1y.prototype, "rotationOvertimeModule", [ _dec35 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new RotationOvertimeModule;
        }
    }), _descriptor29 = _applyDecoratedDescriptor(_class2$1y.prototype, "textureAnimationModule", [ _dec36 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new TextureAnimationModule;
        }
    }), _descriptor30 = _applyDecoratedDescriptor(_class2$1y.prototype, "trailModule", [ _dec37 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new TrailModule;
        }
    }), _descriptor31 = _applyDecoratedDescriptor(_class2$1y.prototype, "renderer", [ _dec38 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new ParticleSystemRenderer;
        }
    }), _descriptor32 = _applyDecoratedDescriptor(_class2$1y.prototype, "_prewarm", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor33 = _applyDecoratedDescriptor(_class2$1y.prototype, "_capacity", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 100;
        }
    }), _descriptor34 = _applyDecoratedDescriptor(_class2$1y.prototype, "_simulationSpace", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.Local;
        }
    }), _class$1L = _class2$1y)) || _class$1L) || _class$1L) || _class$1L) || _class$1L), ParticleUtils = function() {
        function ParticleUtils() {
            _classCallCheck(this, ParticleUtils);
        }
        return _createClass(ParticleUtils, null, [ {
            key: "instantiate",
            value: function instantiate$1(prefab) {
                return this.registeredSceneEvent || (director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.onSceneUnload, this), 
                this.registeredSceneEvent = !0), this.particleSystemPool.has(prefab._uuid) || this.particleSystemPool.set(prefab._uuid, new Pool$1((function() {
                    return instantiate(prefab);
                }), 1)), this.particleSystemPool.get(prefab._uuid).alloc();
            }
        }, {
            key: "destroy",
            value: function destroy(prefab) {
                this.particleSystemPool.has(prefab._prefab.asset._uuid) && (this.stop(prefab), this.particleSystemPool.get(prefab._prefab.asset._uuid).free(prefab));
            }
        }, {
            key: "play",
            value: function play(rootNode) {
                var _iterator = rootNode.getComponentsInChildren(ParticleSystemComponent), _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.play();
                }
            }
        }, {
            key: "stop",
            value: function stop(rootNode) {
                var _iterator2 = rootNode.getComponentsInChildren(ParticleSystemComponent), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2.stop();
                }
            }
        }, {
            key: "onSceneUnload",
            value: function onSceneUnload() {
                this.particleSystemPool.forEach((function(value) {
                    value.clear((function(prefab) {
                        prefab.destroy();
                    }));
                })), this.particleSystemPool.clear();
            }
        } ]), ParticleUtils;
    }();
    function commonjsRequire() {
        throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
    }
    ParticleUtils.particleSystemPool = new Map, ParticleUtils.registeredSceneEvent = !1, 
    cc.ParticleSystemComponent = ParticleSystemComponent, cc.BillboardComponent = BillboardComponent, 
    cc.LineComponent = LineComponent, cc.ParticleUtils = ParticleUtils;
    var _class$1M, _class2$1z, _descriptor$1o, _descriptor2$1c, _class3$E, _temp$1C, cannon_min = function createCommonjsModule(fn, module) {
        return fn(module = {
            exports: {}
        }, module.exports), module.exports;
    }((function(module, exports) {
        module.exports = function n(s, r, a) {
            function h(i, t) {
                if (!r[i]) {
                    if (!s[i]) {
                        if (!t && commonjsRequire) return commonjsRequire();
                        if (l) return l(i, !0);
                        throw new Error("Cannot find module '" + i + "'");
                    }
                    var o = r[i] = {
                        exports: {}
                    };
                    s[i][0].call(o.exports, (function(t) {
                        return h(s[i][1][t] || t);
                    }), o, o.exports, n, s, r, a);
                }
                return r[i].exports;
            }
            for (var l = commonjsRequire, t = 0; t < a.length; t++) h(a[t]);
            return h;
        }({
            1: [ function(t, e, i) {
                e.exports = {
                    name: "@cocos/cannon",
                    version: "1.0.5",
                    description: "A lightweight 3D physics engine written in JavaScript.",
                    homepage: "https://github.com/cocos-creator/cannon.js",
                    author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se), JayceLai",
                    keywords: [ "cannon", "cocos", "creator", "physics", "engine", "3d" ],
                    scripts: {
                        build: "grunt && npm run preprocess && grunt addLicense && grunt addDate",
                        preprocess: "node node_modules/uglify-js/bin/uglifyjs build/cannon.js -o build/cannon.min.js -d doProfiling=false,DEBUG=false -c -m"
                    },
                    main: "./build/cannon.min.js",
                    engines: {
                        node: "*"
                    },
                    repository: {
                        type: "git",
                        url: "https://github.com/cocos-creator/cannon.js.git"
                    },
                    bugs: {
                        url: "https://github.com/cocos-creator/cannon.js/issues"
                    },
                    licenses: [ {
                        type: "MIT"
                    } ],
                    devDependencies: {
                        jshint: "latest",
                        "uglify-js": "latest",
                        nodeunit: "^0.9.0",
                        grunt: "~0.4.0",
                        "grunt-contrib-jshint": "~0.1.1",
                        "grunt-contrib-nodeunit": "^0.4.1",
                        "grunt-contrib-concat": "~0.1.3",
                        "grunt-contrib-uglify": "^0.5.1",
                        "grunt-browserify": "^2.1.4",
                        "grunt-contrib-yuidoc": "^0.5.2",
                        browserify: "*"
                    },
                    dependencies: {}
                };
            }, {} ],
            2: [ function(t, e, i) {
                e.exports = {
                    version: t("../package.json").version,
                    AABB: t("./collision/AABB"),
                    ArrayCollisionMatrix: t("./collision/ArrayCollisionMatrix"),
                    Body: t("./objects/Body"),
                    Box: t("./shapes/Box"),
                    Broadphase: t("./collision/Broadphase"),
                    Constraint: t("./constraints/Constraint"),
                    ContactEquation: t("./equations/ContactEquation"),
                    Narrowphase: t("./world/Narrowphase"),
                    ConeTwistConstraint: t("./constraints/ConeTwistConstraint"),
                    ContactMaterial: t("./material/ContactMaterial"),
                    ConvexPolyhedron: t("./shapes/ConvexPolyhedron"),
                    Cylinder: t("./shapes/Cylinder"),
                    DistanceConstraint: t("./constraints/DistanceConstraint"),
                    Equation: t("./equations/Equation"),
                    EventTarget: t("./utils/EventTarget"),
                    FrictionEquation: t("./equations/FrictionEquation"),
                    GSSolver: t("./solver/GSSolver"),
                    GridBroadphase: t("./collision/GridBroadphase"),
                    Heightfield: t("./shapes/Heightfield"),
                    HingeConstraint: t("./constraints/HingeConstraint"),
                    LockConstraint: t("./constraints/LockConstraint"),
                    Mat3: t("./math/Mat3"),
                    Material: t("./material/Material"),
                    NaiveBroadphase: t("./collision/NaiveBroadphase"),
                    ObjectCollisionMatrix: t("./collision/ObjectCollisionMatrix"),
                    Pool: t("./utils/Pool"),
                    Particle: t("./shapes/Particle"),
                    Plane: t("./shapes/Plane"),
                    PointToPointConstraint: t("./constraints/PointToPointConstraint"),
                    Quaternion: t("./math/Quaternion"),
                    Ray: t("./collision/Ray"),
                    RaycastVehicle: t("./objects/RaycastVehicle"),
                    RaycastResult: t("./collision/RaycastResult"),
                    RigidVehicle: t("./objects/RigidVehicle"),
                    RotationalEquation: t("./equations/RotationalEquation"),
                    RotationalMotorEquation: t("./equations/RotationalMotorEquation"),
                    SAPBroadphase: t("./collision/SAPBroadphase"),
                    SPHSystem: t("./objects/SPHSystem"),
                    Shape: t("./shapes/Shape"),
                    Solver: t("./solver/Solver"),
                    Sphere: t("./shapes/Sphere"),
                    SplitSolver: t("./solver/SplitSolver"),
                    Spring: t("./objects/Spring"),
                    Transform: t("./math/Transform"),
                    Trimesh: t("./shapes/Trimesh"),
                    Vec3: t("./math/Vec3"),
                    Vec3Pool: t("./utils/Vec3Pool"),
                    World: t("./world/World")
                };
            }, {
                "../package.json": 1,
                "./collision/AABB": 3,
                "./collision/ArrayCollisionMatrix": 4,
                "./collision/Broadphase": 5,
                "./collision/GridBroadphase": 6,
                "./collision/NaiveBroadphase": 7,
                "./collision/ObjectCollisionMatrix": 8,
                "./collision/Ray": 10,
                "./collision/RaycastResult": 11,
                "./collision/SAPBroadphase": 12,
                "./constraints/ConeTwistConstraint": 13,
                "./constraints/Constraint": 14,
                "./constraints/DistanceConstraint": 15,
                "./constraints/HingeConstraint": 16,
                "./constraints/LockConstraint": 17,
                "./constraints/PointToPointConstraint": 18,
                "./equations/ContactEquation": 20,
                "./equations/Equation": 21,
                "./equations/FrictionEquation": 22,
                "./equations/RotationalEquation": 23,
                "./equations/RotationalMotorEquation": 24,
                "./material/ContactMaterial": 25,
                "./material/Material": 26,
                "./math/Mat3": 28,
                "./math/Quaternion": 29,
                "./math/Transform": 30,
                "./math/Vec3": 31,
                "./objects/Body": 32,
                "./objects/RaycastVehicle": 33,
                "./objects/RigidVehicle": 34,
                "./objects/SPHSystem": 35,
                "./objects/Spring": 36,
                "./shapes/Box": 38,
                "./shapes/ConvexPolyhedron": 39,
                "./shapes/Cylinder": 40,
                "./shapes/Heightfield": 41,
                "./shapes/Particle": 42,
                "./shapes/Plane": 43,
                "./shapes/Shape": 44,
                "./shapes/Sphere": 45,
                "./shapes/Trimesh": 46,
                "./solver/GSSolver": 47,
                "./solver/Solver": 48,
                "./solver/SplitSolver": 49,
                "./utils/EventTarget": 50,
                "./utils/Pool": 52,
                "./utils/Vec3Pool": 55,
                "./world/Narrowphase": 56,
                "./world/World": 57
            } ],
            3: [ function(t, e, i) {
                var o = t("../math/Vec3");
                function n(t) {
                    t = t || {}, this.lowerBound = new o, t.lowerBound && this.lowerBound.copy(t.lowerBound), 
                    this.upperBound = new o, t.upperBound && this.upperBound.copy(t.upperBound);
                }
                t("../utils/Utils"), e.exports = n;
                var l = new o;
                n.prototype.setFromPoints = function(t, e, i, o) {
                    var n = this.lowerBound, s = this.upperBound, r = i;
                    n.copy(t[0]), r && r.vmult(n, n), s.copy(n);
                    for (var a = 1; a < t.length; a++) {
                        var h = t[a];
                        r && (r.vmult(h, l), h = l), h.x > s.x && (s.x = h.x), h.x < n.x && (n.x = h.x), 
                        h.y > s.y && (s.y = h.y), h.y < n.y && (n.y = h.y), h.z > s.z && (s.z = h.z), h.z < n.z && (n.z = h.z);
                    }
                    return e && (e.vadd(n, n), e.vadd(s, s)), o && (n.x -= o, n.y -= o, n.z -= o, s.x += o, 
                    s.y += o, s.z += o), this;
                }, n.prototype.copy = function(t) {
                    return this.lowerBound.copy(t.lowerBound), this.upperBound.copy(t.upperBound), this;
                }, n.prototype.clone = function() {
                    return (new n).copy(this);
                }, n.prototype.extend = function(t) {
                    this.lowerBound.x = Math.min(this.lowerBound.x, t.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, t.upperBound.x), 
                    this.lowerBound.y = Math.min(this.lowerBound.y, t.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, t.upperBound.y), 
                    this.lowerBound.z = Math.min(this.lowerBound.z, t.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, t.upperBound.z);
                }, n.prototype.overlaps = function(t) {
                    var e = this.lowerBound, i = this.upperBound, o = t.lowerBound, n = t.upperBound, s = o.x <= i.x && i.x <= n.x || e.x <= n.x && n.x <= i.x, r = o.y <= i.y && i.y <= n.y || e.y <= n.y && n.y <= i.y, a = o.z <= i.z && i.z <= n.z || e.z <= n.z && n.z <= i.z;
                    return s && r && a;
                }, n.prototype.volume = function() {
                    var t = this.lowerBound, e = this.upperBound;
                    return (e.x - t.x) * (e.y - t.y) * (e.z - t.z);
                }, n.prototype.contains = function(t) {
                    var e = this.lowerBound, i = this.upperBound, o = t.lowerBound, n = t.upperBound;
                    return e.x <= o.x && i.x >= n.x && e.y <= o.y && i.y >= n.y && e.z <= o.z && i.z >= n.z;
                }, n.prototype.getCorners = function(t, e, i, o, n, s, r, a) {
                    var h = this.lowerBound, l = this.upperBound;
                    t.copy(h), e.set(l.x, h.y, h.z), i.set(l.x, l.y, h.z), o.set(h.x, l.y, l.z), n.set(l.x, h.y, l.z), 
                    s.set(h.x, l.y, h.z), r.set(h.x, h.y, l.z), a.copy(l);
                };
                var d = [ new o, new o, new o, new o, new o, new o, new o, new o ];
                n.prototype.toLocalFrame = function(t, e) {
                    var i = d, o = i[0], n = i[1], s = i[2], r = i[3], a = i[4], h = i[5], l = i[6], c = i[7];
                    this.getCorners(o, n, s, r, a, h, l, c);
                    for (var p = 0; 8 !== p; p++) {
                        var u = i[p];
                        t.pointToLocal(u, u);
                    }
                    return e.setFromPoints(i);
                }, n.prototype.toWorldFrame = function(t, e) {
                    var i = d, o = i[0], n = i[1], s = i[2], r = i[3], a = i[4], h = i[5], l = i[6], c = i[7];
                    this.getCorners(o, n, s, r, a, h, l, c);
                    for (var p = 0; 8 !== p; p++) {
                        var u = i[p];
                        t.pointToWorld(u, u);
                    }
                    return e.setFromPoints(i);
                }, n.prototype.overlapsRay = function(t) {
                    var e = 1 / t._direction.x, i = 1 / t._direction.y, o = 1 / t._direction.z, n = (this.lowerBound.x - t.from.x) * e, s = (this.upperBound.x - t.from.x) * e, r = (this.lowerBound.y - t.from.y) * i, a = (this.upperBound.y - t.from.y) * i, h = (this.lowerBound.z - t.from.z) * o, l = (this.upperBound.z - t.from.z) * o, c = Math.max(Math.max(Math.min(n, s), Math.min(r, a)), Math.min(h, l)), p = Math.min(Math.min(Math.max(n, s), Math.max(r, a)), Math.max(h, l));
                    return !(p < 0 || p < c);
                };
            }, {
                "../math/Vec3": 31,
                "../utils/Utils": 54
            } ],
            4: [ function(t, e, i) {
                function o() {
                    this.matrix = [];
                }
                (e.exports = o).prototype.get = function(t, e) {
                    if ((t = t.index) < (e = e.index)) {
                        var i = e;
                        e = t, t = i;
                    }
                    return this.matrix[(t * (t + 1) >> 1) + e - 1];
                }, o.prototype.set = function(t, e, i) {
                    if ((t = t.index) < (e = e.index)) {
                        var o = e;
                        e = t, t = o;
                    }
                    this.matrix[(t * (t + 1) >> 1) + e - 1] = i ? 1 : 0;
                }, o.prototype.reset = function() {
                    for (var t = 0, e = this.matrix.length; t !== e; t++) this.matrix[t] = 0;
                }, o.prototype.setNumObjects = function(t) {
                    this.matrix.length = t * (t - 1) >> 1;
                };
            }, {} ],
            5: [ function(t, e, i) {
                var o = t("../objects/Body"), n = t("../math/Vec3"), s = t("../math/Quaternion");
                function r() {
                    this.world = null, this.useBoundingBoxes = !1, this.dirty = !0;
                }
                t("../shapes/Shape"), t("../shapes/Plane"), (e.exports = r).prototype.collisionPairs = function(t, e, i) {
                    throw new Error("collisionPairs not implemented for this BroadPhase class!");
                }, r.prototype.needBroadphaseCollision = function(t, e) {
                    return 0 != (t.collisionFilterGroup & e.collisionFilterMask) && 0 != (e.collisionFilterGroup & t.collisionFilterMask) && (!(!t.hasTrigger && !e.hasTrigger) || 0 == (t.type & o.STATIC) && t.sleepState !== o.SLEEPING || 0 == (e.type & o.STATIC) && e.sleepState !== o.SLEEPING);
                }, r.prototype.intersectionTest = function(t, e, i, o) {
                    this.useBoundingBoxes ? this.doBoundingBoxBroadphase(t, e, i, o) : this.doBoundingSphereBroadphase(t, e, i, o);
                };
                var a = new n;
                new n, new s, new n, r.prototype.doBoundingSphereBroadphase = function(t, e, i, o) {
                    var n = a;
                    e.position.vsub(t.position, n);
                    var s = Math.pow(t.boundingRadius + e.boundingRadius, 2);
                    n.norm2() < s && (i.push(t), o.push(e));
                }, r.prototype.doBoundingBoxBroadphase = function(t, e, i, o) {
                    t.aabbNeedsUpdate && t.computeAABB(), e.aabbNeedsUpdate && e.computeAABB(), t.aabb.overlaps(e.aabb) && (i.push(t), 
                    o.push(e));
                };
                var p = {
                    keys: []
                }, u = [], d = [];
                r.prototype.makePairsUnique = function(t, e) {
                    for (var i = p, o = u, n = d, s = t.length, r = 0; r !== s; r++) o[r] = t[r], n[r] = e[r];
                    for (t.length = 0, r = e.length = 0; r !== s; r++) {
                        var a = o[r].id, h = n[r].id;
                        i[l = a < h ? a + "," + h : h + "," + a] = r, i.keys.push(l);
                    }
                    for (r = 0; r !== i.keys.length; r++) {
                        var l = i.keys.pop(), c = i[l];
                        t.push(o[c]), e.push(n[c]), delete i[l];
                    }
                }, r.prototype.setWorld = function(t) {};
                var h = new n;
                r.boundingSphereCheck = function(t, e) {
                    var i = h;
                    return t.position.vsub(e.position, i), Math.pow(t.shape.boundingSphereRadius + e.shape.boundingSphereRadius, 2) > i.norm2();
                }, r.prototype.aabbQuery = function(t, e, i) {
                    return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), 
                    [];
                };
            }, {
                "../math/Quaternion": 29,
                "../math/Vec3": 31,
                "../objects/Body": 32,
                "../shapes/Plane": 43,
                "../shapes/Shape": 44
            } ],
            6: [ function(t, e, i) {
                e.exports = o;
                var a = t("./Broadphase"), h = t("../math/Vec3"), it = t("../shapes/Shape");
                function o(t, e, i, o, n) {
                    a.apply(this), this.nx = i || 10, this.ny = o || 10, this.nz = n || 10, this.aabbMin = t || new h(100, 100, 100), 
                    this.aabbMax = e || new h(-100, -100, -100);
                    var s = this.nx * this.ny * this.nz;
                    if (s <= 0) throw "GridBroadphase: Each dimension's n must be >0";
                    this.bins = [], this.binLengths = [], this.bins.length = s, this.binLengths.length = s;
                    for (var r = 0; r < s; r++) this.bins[r] = [], this.binLengths[r] = 0;
                }
                (o.prototype = new a).constructor = o;
                var ot = new h;
                new h, o.prototype.collisionPairs = function(t, e, i) {
                    for (var o = t.numObjects(), n = t.bodies, s = this.aabbMax, r = this.aabbMin, m = this.nx, w = this.ny, g = this.nz, x = w * g, b = g, a = s.x, h = s.y, l = s.z, E = r.x, A = r.y, S = r.z, z = m / (a - E), M = w / (h - A), C = g / (l - S), c = (a - E) / m, p = (h - A) / w, u = (l - S) / g, d = .5 * Math.sqrt(c * c + p * p + u * u), v = it.types, y = v.SPHERE, f = v.PLANE, q = (v.BOX, 
                    v.COMPOUND, v.CONVEXPOLYHEDRON, this.bins), R = this.binLengths, F = this.bins.length, T = 0; T !== F; T++) R[T] = 0;
                    var P = Math.ceil;
                    function V(t, e, i, o, n, s, r) {
                        var a = (t - E) * z | 0, h = (e - A) * M | 0, l = (i - S) * C | 0, c = P((o - E) * z), p = P((n - A) * M), u = P((s - S) * C);
                        a < 0 ? a = 0 : m <= a && (a = m - 1), h < 0 ? h = 0 : w <= h && (h = w - 1), l < 0 ? l = 0 : g <= l && (l = g - 1), 
                        c < 0 ? c = 0 : m <= c && (c = m - 1), p < 0 ? p = 0 : w <= p && (p = w - 1), u < 0 ? u = 0 : g <= u && (u = g - 1), 
                        h *= b, l *= 1, c *= x, p *= b, u *= 1;
                        for (var d = a *= x; d <= c; d += x) for (var v = h; v <= p; v += b) for (var y = l; y <= u; y += 1) {
                            var f = d + v + y;
                            q[f][R[f]++] = r;
                        }
                    }
                    for (r = Math.min, s = Math.max, T = 0; T !== o; T++) {
                        var I = (tt = n[T]).shape;
                        switch (I.type) {
                          case y:
                            var N = tt.position.x, L = tt.position.y, W = tt.position.z, j = I.radius;
                            V(N - j, L - j, W - j, N + j, L + j, W + j, tt);
                            break;

                          case f:
                            I.worldNormalNeedsUpdate && I.computeWorldNormal(tt.quaternion);
                            var O = I.worldNormal, k = E + .5 * c - tt.position.x, D = A + .5 * p - tt.position.y, _ = S + .5 * u - tt.position.z, U = ot;
                            U.set(k, D, _);
                            for (var H = 0, G = 0; H !== m; H++, G += x, U.y = D, U.x += c) for (var X = 0, Q = 0; X !== w; X++, 
                            Q += b, U.z = _, U.y += p) for (var Y = 0, Z = 0; Y !== g; Y++, Z += 1, U.z += u) if (U.dot(O) < d) {
                                var K = G + Q + Z;
                                q[K][R[K]++] = tt;
                            }
                            break;

                          default:
                            tt.aabbNeedsUpdate && tt.computeAABB(), V(tt.aabb.lowerBound.x, tt.aabb.lowerBound.y, tt.aabb.lowerBound.z, tt.aabb.upperBound.x, tt.aabb.upperBound.y, tt.aabb.upperBound.z, tt);
                        }
                    }
                    for (T = 0; T !== F; T++) {
                        var J = R[T];
                        if (1 < J) {
                            var $ = q[T];
                            for (H = 0; H !== J; H++) {
                                var tt = $[H];
                                for (X = 0; X !== H; X++) {
                                    var et = $[X];
                                    this.needBroadphaseCollision(tt, et) && this.intersectionTest(tt, et, e, i);
                                }
                            }
                        }
                    }
                    this.makePairsUnique(e, i);
                };
            }, {
                "../math/Vec3": 31,
                "../shapes/Shape": 44,
                "./Broadphase": 5
            } ],
            7: [ function(t, e, i) {
                e.exports = s;
                var o = t("./Broadphase"), n = t("./AABB");
                function s() {
                    o.apply(this);
                }
                ((s.prototype = new o).constructor = s).prototype.collisionPairs = function(t, e, i) {
                    var o, n, s, r, a = t.bodies, h = a.length;
                    for (o = 0; o !== h; o++) for (n = 0; n !== o; n++) s = a[o], r = a[n], this.needBroadphaseCollision(s, r) && this.intersectionTest(s, r, e, i);
                }, new n, s.prototype.aabbQuery = function(t, e, i) {
                    i = i || [];
                    for (var o = 0; o < t.bodies.length; o++) {
                        var n = t.bodies[o];
                        n.aabbNeedsUpdate && n.computeAABB(), n.aabb.overlaps(e) && i.push(n);
                    }
                    return i;
                };
            }, {
                "./AABB": 3,
                "./Broadphase": 5
            } ],
            8: [ function(t, e, i) {
                function o() {
                    this.matrix = {};
                }
                (e.exports = o).prototype.get = function(t, e) {
                    if ((t = t.id) < (e = e.id)) {
                        var i = e;
                        e = t, t = i;
                    }
                    return t + "-" + e in this.matrix;
                }, o.prototype.set = function(t, e, i) {
                    if ((t = t.id) < (e = e.id)) {
                        var o = e;
                        e = t, t = o;
                    }
                    i ? this.matrix[t + "-" + e] = !0 : delete this.matrix[t + "-" + e];
                }, o.prototype.reset = function() {
                    this.matrix = {};
                }, o.prototype.setNumObjects = function(t) {};
            }, {} ],
            9: [ function(t, e, i) {
                function o() {
                    this.current = [], this.previous = [];
                }
                function c(t, e) {
                    t.push((4294901760 & e) >> 16, 65535 & e);
                }
                (e.exports = o).prototype.getKey = function(t, e) {
                    if (e < t) {
                        var i = e;
                        e = t, t = i;
                    }
                    return t << 16 | e;
                }, o.prototype.set = function(t, e) {
                    for (var i = this.getKey(t, e), o = this.current, n = 0; i > o[n]; ) n++;
                    if (i !== o[n]) {
                        for (e = o.length - 1; n <= e; e--) o[e + 1] = o[e];
                        o[n] = i;
                    }
                }, o.prototype.tick = function() {
                    var t = this.current;
                    this.current = this.previous, this.previous = t, this.current.length = 0;
                }, o.prototype.reset = function() {
                    this.previous.length = 0, this.current.length = 0;
                }, o.prototype.getDiff = function(t, e) {
                    for (var i = this.current, o = this.previous, n = i.length, s = o.length, r = 0, a = 0; a < n; a++) {
                        for (var h = i[a]; h > o[r]; ) r++;
                        h === o[r] || c(t, h);
                    }
                    for (a = r = 0; a < s; a++) {
                        for (var l = o[a]; l > i[r]; ) r++;
                        i[r] === l || c(e, l);
                    }
                }, o.prototype.copy = function(t) {
                    this.current.length = 0, this.previous.length = 0, this.current = t.current.slice(), 
                    this.previous = t.previous.slice();
                };
            }, {} ],
            10: [ function(t, e, i) {
                e.exports = l;
                var f = t("../math/Vec3"), o = t("../math/Quaternion"), z = t("../math/Transform"), n = (t("../shapes/ConvexPolyhedron"), 
                t("../shapes/Box"), t("../collision/RaycastResult")), s = t("../shapes/Shape"), v = t("../collision/AABB");
                function l(t, e) {
                    this.from = t ? t.clone() : new f, this.to = e ? e.clone() : new f, this._direction = new f, 
                    this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, 
                    this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = l.ANY, 
                    this.result = new n, this.hasHit = !1, this.callback = function(t) {};
                }
                (l.prototype.constructor = l).CLOSEST = 1, l.ANY = 2, l.ALL = 4;
                var r = new v, a = [];
                l.prototype.intersectWorld = function(t, e) {
                    return this.mode = e.mode || l.ANY, this.result = e.result || new n, this.skipBackfaces = !!e.skipBackfaces, 
                    this.collisionFilterMask = void 0 !== e.collisionFilterMask ? e.collisionFilterMask : -1, 
                    this.collisionFilterGroup = void 0 !== e.collisionFilterGroup ? e.collisionFilterGroup : -1, 
                    e.from && this.from.copy(e.from), e.to && this.to.copy(e.to), this.callback = e.callback || function() {}, 
                    this.hasHit = !1, this.result.reset(), this._updateDirection(), this.getAABB(r), 
                    a.length = 0, t.broadphase.aabbQuery(t, r, a), this.intersectBodies(a), this.hasHit;
                };
                var p = new f, u = new f;
                function C(t, e, i, o) {
                    o.vsub(e, d), i.vsub(e, p), t.vsub(e, u);
                    var n, s, r = d.dot(d), a = d.dot(p), h = d.dot(u), l = p.dot(p), c = p.dot(u);
                    return 0 <= (n = l * h - a * c) && 0 <= (s = r * c - a * h) && n + s < r * l - a * a;
                }
                l.pointInTriangle = C;
                var h = new f, c = new o;
                l.prototype.intersectBody = function(t, e) {
                    e && (this.result = e, this._updateDirection());
                    var i = this.checkCollisionResponse;
                    if ((!i || t.collisionResponse) && 0 != (this.collisionFilterGroup & t.collisionFilterMask) && 0 != (t.collisionFilterGroup & this.collisionFilterMask)) for (var o = h, n = c, s = 0, r = t.shapes.length; s < r; s++) {
                        var a = t.shapes[s];
                        if ((!i || a.collisionResponse) && (t.quaternion.mult(t.shapeOrientations[s], n), 
                        t.quaternion.vmult(t.shapeOffsets[s], o), o.vadd(t.position, o), this.intersectShape(a, n, o, t), 
                        this.result._shouldStop)) break;
                    }
                }, l.prototype.intersectBodies = function(t, e) {
                    e && (this.result = e, this._updateDirection());
                    for (var i = 0, o = t.length; !this.result._shouldStop && i < o; i++) this.intersectBody(t[i]);
                }, l.prototype._updateDirection = function() {
                    this.to.vsub(this.from, this._direction), this._direction.normalize();
                }, l.prototype.intersectShape = function(t, e, i, o) {
                    if (!(function(t, e, i) {
                        i.vsub(t, d);
                        var o = d.dot(e);
                        return e.mult(o, B), B.vadd(t, B), i.distanceTo(B);
                    }(this.from, this._direction, i) > t.boundingSphereRadius)) {
                        var n = this[t.type];
                        n && n.call(this, t, e, i, o, t);
                    }
                }, new f, new f;
                var q = new f, R = new f, F = new f, T = new f;
                new f, new n, l.prototype.intersectBox = function(t, e, i, o, n) {
                    return this.intersectConvex(t.convexPolyhedronRepresentation, e, i, o, n);
                }, l.prototype[s.types.BOX] = l.prototype.intersectBox, l.prototype.intersectPlane = function(t, e, i, o, n) {
                    var s = this.from, r = this.to, a = this._direction, h = new f(0, 0, 1);
                    e.vmult(h, h);
                    var l = new f;
                    s.vsub(i, l);
                    var c = l.dot(h);
                    if (r.vsub(i, l), !(0 < c * l.dot(h) || s.distanceTo(r) < c)) {
                        var p = h.dot(a);
                        if (!(Math.abs(p) < this.precision)) {
                            var u = new f, d = new f, v = new f;
                            s.vsub(i, u);
                            var y = -h.dot(u) / p;
                            a.scale(y, d), s.vadd(d, v), this.reportIntersection(h, v, n, o, -1);
                        }
                    }
                }, l.prototype[s.types.PLANE] = l.prototype.intersectPlane, l.prototype.getAABB = function(t) {
                    var e = this.to, i = this.from;
                    t.lowerBound.x = Math.min(e.x, i.x), t.lowerBound.y = Math.min(e.y, i.y), t.lowerBound.z = Math.min(e.z, i.z), 
                    t.upperBound.x = Math.max(e.x, i.x), t.upperBound.y = Math.max(e.y, i.y), t.upperBound.z = Math.max(e.z, i.z);
                };
                var y = {
                    faceList: [ 0 ]
                }, m = new f, w = new l, g = [];
                l.prototype.intersectHeightfield = function(t, e, i, o, n) {
                    t.data, t.elementSize;
                    var s = w;
                    s.from.copy(this.from), s.to.copy(this.to), z.pointToLocalFrame(i, e, s.from, s.from), 
                    z.pointToLocalFrame(i, e, s.to, s.to), s._updateDirection();
                    var r, a, h, l, c = g;
                    r = a = 0, h = l = t.data.length - 1;
                    var p = new v;
                    s.getAABB(p), t.getIndexOfPosition(p.lowerBound.x, p.lowerBound.y, c, !0), r = Math.max(r, c[0]), 
                    a = Math.max(a, c[1]), t.getIndexOfPosition(p.upperBound.x, p.upperBound.y, c, !0), 
                    h = Math.min(h, c[0] + 1), l = Math.min(l, c[1] + 1);
                    for (var u = r; u < h; u++) for (var d = a; d < l; d++) {
                        if (this.result._shouldStop) return;
                        if (t.getAabbAtIndex(u, d, p), p.overlapsRay(s)) {
                            if (t.getConvexTrianglePillar(u, d, !1), z.pointToWorldFrame(i, e, t.pillarOffset, m), 
                            this.intersectConvex(t.pillarConvex, e, m, o, n, y), this.result._shouldStop) return;
                            t.getConvexTrianglePillar(u, d, !0), z.pointToWorldFrame(i, e, t.pillarOffset, m), 
                            this.intersectConvex(t.pillarConvex, e, m, o, n, y);
                        }
                    }
                }, l.prototype[s.types.HEIGHTFIELD] = l.prototype.intersectHeightfield;
                var x = new f, b = new f;
                l.prototype.intersectSphere = function(t, e, i, o, n) {
                    var s = this.from, r = this.to, a = t.radius, h = Math.pow(r.x - s.x, 2) + Math.pow(r.y - s.y, 2) + Math.pow(r.z - s.z, 2), l = 2 * ((r.x - s.x) * (s.x - i.x) + (r.y - s.y) * (s.y - i.y) + (r.z - s.z) * (s.z - i.z)), c = Math.pow(s.x - i.x, 2) + Math.pow(s.y - i.y, 2) + Math.pow(s.z - i.z, 2) - Math.pow(a, 2), p = Math.pow(l, 2) - 4 * h * c, u = x, d = b;
                    if (!(p < 0)) if (0 == p) s.lerp(r, p, u), u.vsub(i, d), d.normalize(), this.reportIntersection(d, u, n, o, -1); else {
                        var v = (-l - Math.sqrt(p)) / (2 * h), y = (-l + Math.sqrt(p)) / (2 * h);
                        if (0 <= v && v <= 1 && (s.lerp(r, v, u), u.vsub(i, d), d.normalize(), this.reportIntersection(d, u, n, o, -1)), 
                        this.result._shouldStop) return;
                        0 <= y && y <= 1 && (s.lerp(r, y, u), u.vsub(i, d), d.normalize(), this.reportIntersection(d, u, n, o, -1));
                    }
                }, l.prototype[s.types.SPHERE] = l.prototype.intersectSphere;
                var P = new f, V = (new f, new f, new f);
                l.prototype.intersectConvex = function(t, e, i, o, n, s) {
                    for (var r = P, a = V, h = s && s.faceList || null, l = t.faces, c = t.vertices, p = t.faceNormals, u = this._direction, d = this.from, v = this.to, y = d.distanceTo(v), f = h ? h.length : l.length, m = this.result, w = 0; !m._shouldStop && w < f; w++) {
                        var g = h ? h[w] : w, x = l[g], b = p[g], B = e, E = i;
                        a.copy(c[x[0]]), B.vmult(a, a), a.vadd(E, a), a.vsub(d, a), B.vmult(b, r);
                        var A = u.dot(r);
                        if (!(Math.abs(A) < this.precision)) {
                            var S = r.dot(a) / A;
                            if (!(S < 0)) {
                                u.mult(S, q), q.vadd(d, q), R.copy(c[x[0]]), B.vmult(R, R), E.vadd(R, R);
                                for (var z = 1; !m._shouldStop && z < x.length - 1; z++) {
                                    F.copy(c[x[z]]), T.copy(c[x[z + 1]]), B.vmult(F, F), B.vmult(T, T), E.vadd(F, F), 
                                    E.vadd(T, T);
                                    var M = q.distanceTo(d);
                                    !C(q, R, F, T) && !C(q, F, R, T) || y < M || this.reportIntersection(r, q, n, o, g);
                                }
                            }
                        }
                    }
                }, l.prototype[s.types.CONVEXPOLYHEDRON] = l.prototype.intersectConvex;
                var M = new f, I = new f, N = new f, L = new f, W = new f, j = new f, O = (new v, 
                []), k = new z;
                l.prototype.intersectTrimesh = function(t, e, i, o, n, s) {
                    var r = M, a = O, h = k, l = V, c = I, p = N, u = L, d = j, v = W, y = (s && s.faceList, 
                    t.indices), f = (t.vertices, t.faceNormals, this.from), m = this.to, w = this._direction;
                    h.position.copy(i), h.quaternion.copy(e), z.vectorToLocalFrame(i, e, w, c), z.pointToLocalFrame(i, e, f, p), 
                    z.pointToLocalFrame(i, e, m, u), u.x *= t.scale.x, u.y *= t.scale.y, u.z *= t.scale.z, 
                    p.x *= t.scale.x, p.y *= t.scale.y, p.z *= t.scale.z, u.vsub(p, c), c.normalize();
                    var g = p.distanceSquared(u);
                    t.tree.rayQuery(this, h, a);
                    for (var x = 0, b = a.length; !this.result._shouldStop && x !== b; x++) {
                        var B = a[x];
                        t.getNormal(B, r), t.getVertex(y[3 * B], R), R.vsub(p, l);
                        var E = c.dot(r), A = r.dot(l) / E;
                        if (!(A < 0)) {
                            c.scale(A, q), q.vadd(p, q), t.getVertex(y[3 * B + 1], F), t.getVertex(y[3 * B + 2], T);
                            var S = q.distanceSquared(p);
                            !C(q, F, R, T) && !C(q, R, F, T) || g < S || (z.vectorToWorldFrame(e, r, v), z.pointToWorldFrame(i, e, q, d), 
                            this.reportIntersection(v, d, n, o, B));
                        }
                    }
                    a.length = 0;
                }, l.prototype[s.types.TRIMESH] = l.prototype.intersectTrimesh, l.prototype.reportIntersection = function(t, e, i, o, n) {
                    var s = this.from, r = this.to, a = s.distanceTo(e), h = this.result;
                    if (!(this.skipBackfaces && 0 < t.dot(this._direction))) switch (h.hitFaceIndex = void 0 !== n ? n : -1, 
                    this.mode) {
                      case l.ALL:
                        this.hasHit = !0, h.set(s, r, t, e, i, o, a), h.hasHit = !0, this.callback(h);
                        break;

                      case l.CLOSEST:
                        (a < h.distance || !h.hasHit) && (this.hasHit = !0, h.hasHit = !0, h.set(s, r, t, e, i, o, a));
                        break;

                      case l.ANY:
                        this.hasHit = !0, h.hasHit = !0, h.set(s, r, t, e, i, o, a), h._shouldStop = !0;
                    }
                };
                var d = new f, B = new f;
            }, {
                "../collision/AABB": 3,
                "../collision/RaycastResult": 11,
                "../math/Quaternion": 29,
                "../math/Transform": 30,
                "../math/Vec3": 31,
                "../shapes/Box": 38,
                "../shapes/ConvexPolyhedron": 39,
                "../shapes/Shape": 44
            } ],
            11: [ function(t, e, i) {
                var o = t("../math/Vec3");
                function n() {
                    this.rayFromWorld = new o, this.rayToWorld = new o, this.hitNormalWorld = new o, 
                    this.hitPointWorld = new o, this.hasHit = !1, this.shape = null, this.body = null, 
                    this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1;
                }
                (e.exports = n).prototype.reset = function() {
                    this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), 
                    this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, 
                    this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1;
                }, n.prototype.abort = function() {
                    this._shouldStop = !0;
                }, n.prototype.set = function(t, e, i, o, n, s, r) {
                    this.rayFromWorld.copy(t), this.rayToWorld.copy(e), this.hitNormalWorld.copy(i), 
                    this.hitPointWorld.copy(o), this.shape = n, this.body = s, this.distance = r;
                };
            }, {
                "../math/Vec3": 31
            } ],
            12: [ function(t, e, i) {
                t("../shapes/Shape");
                var o = t("../collision/Broadphase");
                function c(t) {
                    o.apply(this), this.axisList = [], this.world = null, this.axisIndex = 0;
                    var i = this.axisList;
                    this._addBodyHandler = function(t) {
                        i.push(t.body);
                    }, this._removeBodyHandler = function(t) {
                        var e = i.indexOf(t.body);
                        -1 !== e && i.splice(e, 1);
                    }, t && this.setWorld(t);
                }
                ((e.exports = c).prototype = new o).setWorld = function(t) {
                    for (var e = this.axisList.length = 0; e < t.bodies.length; e++) this.axisList.push(t.bodies[e]);
                    t.removeEventListener("addBody", this._addBodyHandler), t.removeEventListener("removeBody", this._removeBodyHandler), 
                    t.addEventListener("addBody", this._addBodyHandler), t.addEventListener("removeBody", this._removeBodyHandler), 
                    this.world = t, this.dirty = !0;
                }, c.insertionSortX = function(t) {
                    for (var e = 1, i = t.length; e < i; e++) {
                        for (var o = t[e], n = e - 1; 0 <= n && !(t[n].aabb.lowerBound.x <= o.aabb.lowerBound.x); n--) t[n + 1] = t[n];
                        t[n + 1] = o;
                    }
                    return t;
                }, c.insertionSortY = function(t) {
                    for (var e = 1, i = t.length; e < i; e++) {
                        for (var o = t[e], n = e - 1; 0 <= n && !(t[n].aabb.lowerBound.y <= o.aabb.lowerBound.y); n--) t[n + 1] = t[n];
                        t[n + 1] = o;
                    }
                    return t;
                }, c.insertionSortZ = function(t) {
                    for (var e = 1, i = t.length; e < i; e++) {
                        for (var o = t[e], n = e - 1; 0 <= n && !(t[n].aabb.lowerBound.z <= o.aabb.lowerBound.z); n--) t[n + 1] = t[n];
                        t[n + 1] = o;
                    }
                    return t;
                }, c.prototype.collisionPairs = function(t, e, i) {
                    var o, n, s = this.axisList, r = s.length, a = this.axisIndex;
                    for (this.dirty && (this.sortList(), this.dirty = !1), o = 0; o !== r; o++) {
                        var h = s[o];
                        for (n = o + 1; n < r; n++) {
                            var l = s[n];
                            if (this.needBroadphaseCollision(h, l)) {
                                if (!c.checkBounds(h, l, a)) break;
                                this.intersectionTest(h, l, e, i);
                            }
                        }
                    }
                }, c.prototype.sortList = function() {
                    for (var t = this.axisList, e = this.axisIndex, i = t.length, o = 0; o !== i; o++) {
                        var n = t[o];
                        n.aabbNeedsUpdate && n.computeAABB();
                    }
                    0 === e ? c.insertionSortX(t) : 1 === e ? c.insertionSortY(t) : 2 === e && c.insertionSortZ(t);
                }, c.checkBounds = function(t, e, i) {
                    var o, n;
                    0 === i ? (o = t.position.x, n = e.position.x) : 1 === i ? (o = t.position.y, n = e.position.y) : 2 === i && (o = t.position.z, 
                    n = e.position.z);
                    var s = t.boundingRadius;
                    return n - e.boundingRadius < o + s;
                }, c.prototype.autoDetectAxis = function() {
                    for (var t = 0, e = 0, i = 0, o = 0, n = 0, s = 0, r = this.axisList, a = r.length, h = 1 / a, l = 0; l !== a; l++) {
                        var c = r[l], p = c.position.x;
                        t += p, e += p * p;
                        var u = c.position.y;
                        i += u, o += u * u;
                        var d = c.position.z;
                        n += d, s += d * d;
                    }
                    var v = e - t * t * h, y = o - i * i * h, f = s - n * n * h;
                    this.axisIndex = y < v ? f < v ? 0 : 2 : f < y ? 1 : 2;
                }, c.prototype.aabbQuery = function(t, e, i) {
                    i = i || [], this.dirty && (this.sortList(), this.dirty = !1);
                    var o = this.axisIndex, n = "x";
                    1 === o && (n = "y"), 2 === o && (n = "z");
                    for (var s = this.axisList, r = (e.lowerBound[n], e.upperBound[n], 0); r < s.length; r++) {
                        var a = s[r];
                        a.aabbNeedsUpdate && a.computeAABB(), a.aabb.overlaps(e) && i.push(a);
                    }
                    return i;
                };
            }, {
                "../collision/Broadphase": 5,
                "../shapes/Shape": 44
            } ],
            13: [ function(t, e, i) {
                e.exports = o, t("./Constraint");
                var h = t("./PointToPointConstraint"), l = t("../equations/ConeEquation"), c = t("../equations/RotationalEquation"), p = (t("../equations/ContactEquation"), 
                t("../math/Vec3"));
                function o(t, e, i) {
                    var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = i.pivotA ? i.pivotA.clone() : new p, s = i.pivotB ? i.pivotB.clone() : new p;
                    this.axisA = i.axisA ? i.axisA.clone() : new p, this.axisB = i.axisB ? i.axisB.clone() : new p, 
                    h.call(this, t, n, e, s, o), this.collideConnected = !!i.collideConnected, this.angle = void 0 !== i.angle ? i.angle : 0;
                    var r = this.coneEquation = new l(t, e, i), a = this.twistEquation = new c(t, e, i);
                    this.twistAngle = void 0 !== i.twistAngle ? i.twistAngle : 0, r.maxForce = 0, r.minForce = -o, 
                    a.maxForce = 0, a.minForce = -o, this.equations.push(r, a);
                }
                o.prototype = new h, o.constructor = o, new p, new p, o.prototype.update = function() {
                    var t = this.bodyA, e = this.bodyB, i = this.coneEquation, o = this.twistEquation;
                    h.prototype.update.call(this), t.vectorToWorldFrame(this.axisA, i.axisA), e.vectorToWorldFrame(this.axisB, i.axisB), 
                    this.axisA.tangents(o.axisA, o.axisA), t.vectorToWorldFrame(o.axisA, o.axisA), this.axisB.tangents(o.axisB, o.axisB), 
                    e.vectorToWorldFrame(o.axisB, o.axisB), i.angle = this.angle, o.maxAngle = this.twistAngle;
                };
            }, {
                "../equations/ConeEquation": 19,
                "../equations/ContactEquation": 20,
                "../equations/RotationalEquation": 23,
                "../math/Vec3": 31,
                "./Constraint": 14,
                "./PointToPointConstraint": 18
            } ],
            14: [ function(t, e, i) {
                e.exports = n;
                var o = t("../utils/Utils");
                function n(t, e, i) {
                    i = o.defaults(i, {
                        collideConnected: !0,
                        wakeUpBodies: !0
                    }), this.equations = [], this.bodyA = t, this.bodyB = e, this.id = n.idCounter++, 
                    this.collideConnected = i.collideConnected, i.wakeUpBodies && (t && t.wakeUp(), 
                    e && e.wakeUp());
                }
                n.prototype.update = function() {
                    throw new Error("method update() not implmemented in this Constraint subclass!");
                }, n.prototype.enable = function() {
                    for (var t = this.equations, e = 0; e < t.length; e++) t[e].enabled = !0;
                }, n.prototype.disable = function() {
                    for (var t = this.equations, e = 0; e < t.length; e++) t[e].enabled = !1;
                }, n.idCounter = 0;
            }, {
                "../utils/Utils": 54
            } ],
            15: [ function(t, e, i) {
                e.exports = o;
                var s = t("./Constraint"), r = t("../equations/ContactEquation");
                function o(t, e, i, o) {
                    s.call(this, t, e), void 0 === i && (i = t.position.distanceTo(e.position)), void 0 === o && (o = 1e6), 
                    this.distance = i;
                    var n = this.distanceEquation = new r(t, e);
                    this.equations.push(n), n.minForce = -o, n.maxForce = o;
                }
                (o.prototype = new s).update = function() {
                    var t = this.bodyA, e = this.bodyB, i = this.distanceEquation, o = .5 * this.distance, n = i.ni;
                    e.position.vsub(t.position, n), n.normalize(), n.mult(o, i.ri), n.mult(-o, i.rj);
                };
            }, {
                "../equations/ContactEquation": 20,
                "./Constraint": 14
            } ],
            16: [ function(t, e, i) {
                e.exports = o, t("./Constraint");
                var l = t("./PointToPointConstraint"), c = t("../equations/RotationalEquation"), p = t("../equations/RotationalMotorEquation"), u = (t("../equations/ContactEquation"), 
                t("../math/Vec3"));
                function o(t, e, i) {
                    var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = i.pivotA ? i.pivotA.clone() : new u, s = i.pivotB ? i.pivotB.clone() : new u;
                    l.call(this, t, n, e, s, o), (this.axisA = i.axisA ? i.axisA.clone() : new u(1, 0, 0)).normalize(), 
                    (this.axisB = i.axisB ? i.axisB.clone() : new u(1, 0, 0)).normalize();
                    var r = this.rotationalEquation1 = new c(t, e, i), a = this.rotationalEquation2 = new c(t, e, i), h = this.motorEquation = new p(t, e, o);
                    h.enabled = !1, this.equations.push(r, a, h);
                }
                o.prototype = new l, (o.constructor = o).prototype.enableMotor = function() {
                    this.motorEquation.enabled = !0;
                }, o.prototype.disableMotor = function() {
                    this.motorEquation.enabled = !1;
                }, o.prototype.setMotorSpeed = function(t) {
                    this.motorEquation.targetVelocity = t;
                }, o.prototype.setMotorMaxForce = function(t) {
                    this.motorEquation.maxForce = t, this.motorEquation.minForce = -t;
                };
                var d = new u, v = new u;
                o.prototype.update = function() {
                    var t = this.bodyA, e = this.bodyB, i = this.motorEquation, o = this.rotationalEquation1, n = this.rotationalEquation2, s = d, r = v, a = this.axisA, h = this.axisB;
                    l.prototype.update.call(this), t.quaternion.vmult(a, s), e.quaternion.vmult(h, r), 
                    s.tangents(o.axisA, n.axisA), o.axisB.copy(r), n.axisB.copy(r), this.motorEquation.enabled && (t.quaternion.vmult(this.axisA, i.axisA), 
                    e.quaternion.vmult(this.axisB, i.axisB));
                };
            }, {
                "../equations/ContactEquation": 20,
                "../equations/RotationalEquation": 23,
                "../equations/RotationalMotorEquation": 24,
                "../math/Vec3": 31,
                "./Constraint": 14,
                "./PointToPointConstraint": 18
            } ],
            17: [ function(t, e, i) {
                e.exports = o, t("./Constraint");
                var c = t("./PointToPointConstraint"), p = t("../equations/RotationalEquation"), u = (t("../equations/RotationalMotorEquation"), 
                t("../equations/ContactEquation"), t("../math/Vec3"));
                function o(t, e, i) {
                    var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = new u, s = new u, r = new u;
                    t.position.vadd(e.position, r), r.scale(.5, r), e.pointToLocalFrame(r, s), t.pointToLocalFrame(r, n), 
                    c.call(this, t, n, e, s, o), this.xA = t.vectorToLocalFrame(u.UNIT_X), this.xB = e.vectorToLocalFrame(u.UNIT_X), 
                    this.yA = t.vectorToLocalFrame(u.UNIT_Y), this.yB = e.vectorToLocalFrame(u.UNIT_Y), 
                    this.zA = t.vectorToLocalFrame(u.UNIT_Z), this.zB = e.vectorToLocalFrame(u.UNIT_Z);
                    var a = this.rotationalEquation1 = new p(t, e, i), h = this.rotationalEquation2 = new p(t, e, i), l = this.rotationalEquation3 = new p(t, e, i);
                    this.equations.push(a, h, l);
                }
                o.prototype = new c, o.constructor = o, new u, new u, o.prototype.update = function() {
                    var t = this.bodyA, e = this.bodyB, i = (this.motorEquation, this.rotationalEquation1), o = this.rotationalEquation2, n = this.rotationalEquation3;
                    c.prototype.update.call(this), t.vectorToWorldFrame(this.xA, i.axisA), e.vectorToWorldFrame(this.yB, i.axisB), 
                    t.vectorToWorldFrame(this.yA, o.axisA), e.vectorToWorldFrame(this.zB, o.axisB), 
                    t.vectorToWorldFrame(this.zA, n.axisA), e.vectorToWorldFrame(this.xB, n.axisB);
                };
            }, {
                "../equations/ContactEquation": 20,
                "../equations/RotationalEquation": 23,
                "../equations/RotationalMotorEquation": 24,
                "../math/Vec3": 31,
                "./Constraint": 14,
                "./PointToPointConstraint": 18
            } ],
            18: [ function(t, e, i) {
                e.exports = o;
                var h = t("./Constraint"), l = t("../equations/ContactEquation"), c = t("../math/Vec3");
                function o(t, e, i, o, n) {
                    h.call(this, t, i), n = void 0 !== n ? n : 1e6, this.pivotA = e ? e.clone() : new c, 
                    this.pivotB = o ? o.clone() : new c;
                    var s = this.equationX = new l(t, i), r = this.equationY = new l(t, i), a = this.equationZ = new l(t, i);
                    this.equations.push(s, r, a), s.minForce = r.minForce = a.minForce = -n, s.maxForce = r.maxForce = a.maxForce = n, 
                    s.ni.set(1, 0, 0), r.ni.set(0, 1, 0), a.ni.set(0, 0, 1);
                }
                (o.prototype = new h).update = function() {
                    var t = this.bodyA, e = this.bodyB, i = this.equationX, o = this.equationY, n = this.equationZ;
                    t.quaternion.vmult(this.pivotA, i.ri), e.quaternion.vmult(this.pivotB, i.rj), o.ri.copy(i.ri), 
                    o.rj.copy(i.rj), n.ri.copy(i.ri), n.rj.copy(i.rj);
                };
            }, {
                "../equations/ContactEquation": 20,
                "../math/Vec3": 31,
                "./Constraint": 14
            } ],
            19: [ function(t, e, i) {
                e.exports = o;
                var n = t("../math/Vec3"), s = (t("../math/Mat3"), t("./Equation"));
                function o(t, e, i) {
                    var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6;
                    s.call(this, t, e, -o, o), this.axisA = i.axisA ? i.axisA.clone() : new n(1, 0, 0), 
                    this.axisB = i.axisB ? i.axisB.clone() : new n(0, 1, 0), this.angle = void 0 !== i.angle ? i.angle : 0;
                }
                (o.prototype = new s).constructor = o;
                var l = new n, c = new n;
                o.prototype.computeB = function(t) {
                    var e = this.a, i = this.b, o = this.axisA, n = this.axisB, s = l, r = c, a = this.jacobianElementA, h = this.jacobianElementB;
                    return o.cross(n, s), n.cross(o, r), a.rotational.copy(r), h.rotational.copy(s), 
                    -(Math.cos(this.angle) - o.dot(n)) * e - this.computeGW() * i - t * this.computeGiMf();
                };
            }, {
                "../math/Mat3": 28,
                "../math/Vec3": 31,
                "./Equation": 21
            } ],
            20: [ function(t, e, i) {
                e.exports = s;
                var o = t("./Equation"), n = t("../math/Vec3");
                function s(t, e, i) {
                    i = void 0 !== i ? i : 1e6, o.call(this, t, e, 0, i), this.si = null, this.sj = null, 
                    this.restitution = 0, this.ri = new n, this.rj = new n, this.ni = new n;
                }
                t("../math/Mat3"), (s.prototype = new o).constructor = s;
                var g = new n, x = new n, b = new n;
                s.prototype.computeB = function(t) {
                    var e = this.a, i = this.b, o = this.bi, n = this.bj, s = this.ri, r = this.rj, a = g, h = x, l = o.velocity, c = o.angularVelocity, p = (o.force, 
                    o.torque, n.velocity), u = n.angularVelocity, d = (n.force, n.torque, b), v = this.jacobianElementA, y = this.jacobianElementB, f = this.ni;
                    s.cross(f, a), r.cross(f, h), f.negate(v.spatial), a.negate(v.rotational), y.spatial.copy(f), 
                    y.rotational.copy(h), d.copy(n.position), d.vadd(r, d), d.vsub(o.position, d), d.vsub(s, d);
                    var m = f.dot(d), w = this.restitution + 1;
                    return -m * e - (w * p.dot(f) - w * l.dot(f) + u.dot(h) - c.dot(a)) * i - t * this.computeGiMf();
                };
                var r = new n, a = new n, h = new n, l = new n, c = new n;
                s.prototype.getImpactVelocityAlongNormal = function() {
                    var t = r, e = a, i = h, o = l, n = c;
                    return this.bi.position.vadd(this.ri, i), this.bj.position.vadd(this.rj, o), this.bi.getVelocityAtWorldPoint(i, t), 
                    this.bj.getVelocityAtWorldPoint(o, e), t.vsub(e, n), this.ni.dot(n);
                };
            }, {
                "../math/Mat3": 28,
                "../math/Vec3": 31,
                "./Equation": 21
            } ],
            21: [ function(t, e, i) {
                e.exports = s;
                var n = t("../math/JacobianElement"), o = t("../math/Vec3");
                function s(t, e, i, o) {
                    this.id = s.id++, this.minForce = void 0 === i ? -1e6 : i, this.maxForce = void 0 === o ? 1e6 : o, 
                    this.bi = t, this.bj = e, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new n, 
                    this.jacobianElementB = new n, this.enabled = !0, this.multiplier = 0, this.setSpookParams(1e7, 4, 1 / 60);
                }
                (s.prototype.constructor = s).id = 0, s.prototype.setSpookParams = function(t, e, i) {
                    var o = e, n = t, s = i;
                    this.a = 4 / (s * (1 + 4 * o)), this.b = 4 * o / (1 + 4 * o), this.eps = 4 / (s * s * n * (1 + 4 * o));
                }, s.prototype.computeB = function(t, e, i) {
                    var o = this.computeGW();
                    return -this.computeGq() * t - o * e - this.computeGiMf() * i;
                }, s.prototype.computeGq = function() {
                    var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.position, s = o.position;
                    return t.spatial.dot(n) + e.spatial.dot(s);
                }, new o, s.prototype.computeGW = function() {
                    var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.velocity, s = o.velocity, r = i.angularVelocity, a = o.angularVelocity;
                    return t.multiplyVectors(n, r) + e.multiplyVectors(s, a);
                }, s.prototype.computeGWlambda = function() {
                    var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.vlambda, s = o.vlambda, r = i.wlambda, a = o.wlambda;
                    return t.multiplyVectors(n, r) + e.multiplyVectors(s, a);
                };
                var c = new o, p = new o, u = new o, d = new o;
                s.prototype.computeGiMf = function() {
                    var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.force, s = i.torque, r = o.force, a = o.torque, h = i.invMassSolve, l = o.invMassSolve;
                    return n.scale(h, c), r.scale(l, p), i.invInertiaWorldSolve.vmult(s, u), o.invInertiaWorldSolve.vmult(a, d), 
                    t.multiplyVectors(c, u) + e.multiplyVectors(p, d);
                };
                var l = new o;
                s.prototype.computeGiMGt = function() {
                    var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.invMassSolve, s = o.invMassSolve, r = i.invInertiaWorldSolve, a = o.invInertiaWorldSolve, h = n + s;
                    return r.vmult(t.rotational, l), h += l.dot(t.rotational), a.vmult(e.rotational, l), 
                    h + l.dot(e.rotational);
                };
                var r = new o;
                new o, new o, new o, new o, new o, s.prototype.addToWlambda = function(t) {
                    var e = this.jacobianElementA, i = this.jacobianElementB, o = this.bi, n = this.bj, s = r;
                    o.vlambda.addScaledVector(o.invMassSolve * t, e.spatial, o.vlambda), n.vlambda.addScaledVector(n.invMassSolve * t, i.spatial, n.vlambda), 
                    o.invInertiaWorldSolve.vmult(e.rotational, s), o.wlambda.addScaledVector(t, s, o.wlambda), 
                    n.invInertiaWorldSolve.vmult(i.rotational, s), n.wlambda.addScaledVector(t, s, n.wlambda);
                }, s.prototype.computeC = function() {
                    return this.computeGiMGt() + this.eps;
                };
            }, {
                "../math/JacobianElement": 27,
                "../math/Vec3": 31
            } ],
            22: [ function(t, e, i) {
                e.exports = s;
                var o = t("./Equation"), n = t("../math/Vec3");
                function s(t, e, i) {
                    o.call(this, t, e, -i, i), this.ri = new n, this.rj = new n, this.t = new n;
                }
                t("../math/Mat3"), (s.prototype = new o).constructor = s;
                var l = new n, c = new n;
                s.prototype.computeB = function(t) {
                    this.a;
                    var e = this.b, i = (this.bi, this.bj, this.ri), o = this.rj, n = l, s = c, r = this.t;
                    i.cross(r, n), o.cross(r, s);
                    var a = this.jacobianElementA, h = this.jacobianElementB;
                    return r.negate(a.spatial), n.negate(a.rotational), h.spatial.copy(r), h.rotational.copy(s), 
                    -this.computeGW() * e - t * this.computeGiMf();
                };
            }, {
                "../math/Mat3": 28,
                "../math/Vec3": 31,
                "./Equation": 21
            } ],
            23: [ function(t, e, i) {
                e.exports = o;
                var n = t("../math/Vec3"), s = (t("../math/Mat3"), t("./Equation"));
                function o(t, e, i) {
                    var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6;
                    s.call(this, t, e, -o, o), this.axisA = i.axisA ? i.axisA.clone() : new n(1, 0, 0), 
                    this.axisB = i.axisB ? i.axisB.clone() : new n(0, 1, 0), this.maxAngle = Math.PI / 2;
                }
                (o.prototype = new s).constructor = o;
                var l = new n, c = new n;
                o.prototype.computeB = function(t) {
                    var e = this.a, i = this.b, o = this.axisA, n = this.axisB, s = l, r = c, a = this.jacobianElementA, h = this.jacobianElementB;
                    return o.cross(n, s), n.cross(o, r), a.rotational.copy(r), h.rotational.copy(s), 
                    -(Math.cos(this.maxAngle) - o.dot(n)) * e - this.computeGW() * i - t * this.computeGiMf();
                };
            }, {
                "../math/Mat3": 28,
                "../math/Vec3": 31,
                "./Equation": 21
            } ],
            24: [ function(t, e, i) {
                e.exports = s;
                var o = t("../math/Vec3"), n = (t("../math/Mat3"), t("./Equation"));
                function s(t, e, i) {
                    i = void 0 !== i ? i : 1e6, n.call(this, t, e, -i, i), this.axisA = new o, this.axisB = new o, 
                    this.targetVelocity = 0;
                }
                ((s.prototype = new n).constructor = s).prototype.computeB = function(t) {
                    this.a;
                    var e = this.b, i = (this.bi, this.bj, this.axisA), o = this.axisB, n = this.jacobianElementA, s = this.jacobianElementB;
                    return n.rotational.copy(i), o.negate(s.rotational), -(this.computeGW() - this.targetVelocity) * e - t * this.computeGiMf();
                };
            }, {
                "../math/Mat3": 28,
                "../math/Vec3": 31,
                "./Equation": 21
            } ],
            25: [ function(t, e, i) {
                var o = t("../utils/Utils");
                (e.exports = function n(t, e, i) {
                    i = o.defaults(i, {
                        friction: .3,
                        restitution: .3,
                        contactEquationStiffness: 1e7,
                        contactEquationRelaxation: 3,
                        frictionEquationStiffness: 1e7,
                        frictionEquationRelaxation: 3
                    }), this.id = n.idCounter++, this.materials = [ t, e ], this.friction = i.friction, 
                    this.restitution = i.restitution, this.contactEquationStiffness = i.contactEquationStiffness, 
                    this.contactEquationRelaxation = i.contactEquationRelaxation, this.frictionEquationStiffness = i.frictionEquationStiffness, 
                    this.frictionEquationRelaxation = i.frictionEquationRelaxation;
                }).idCounter = 0;
            }, {
                "../utils/Utils": 54
            } ],
            26: [ function(t, e, i) {
                (e.exports = function o(t) {
                    var e = "";
                    "string" == typeof (t = t || {}) ? (e = t, t = {}) : "object" == typeof t && (e = ""), 
                    this.name = e, this.id = o.idCounter++, this.friction = void 0 !== t.friction ? t.friction : -1, 
                    this.restitution = void 0 !== t.restitution ? t.restitution : -1;
                }).idCounter = 0;
            }, {} ],
            27: [ function(t, e, i) {
                e.exports = n;
                var o = t("./Vec3");
                function n() {
                    this.spatial = new o, this.rotational = new o;
                }
                n.prototype.multiplyElement = function(t) {
                    return t.spatial.dot(this.spatial) + t.rotational.dot(this.rotational);
                }, n.prototype.multiplyVectors = function(t, e) {
                    return t.dot(this.spatial) + e.dot(this.rotational);
                };
            }, {
                "./Vec3": 31
            } ],
            28: [ function(t, e, i) {
                e.exports = l;
                var c = t("./Vec3");
                function l(t) {
                    this.elements = t || [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
                }
                l.prototype.identity = function() {
                    var t = this.elements;
                    t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, 
                    t[8] = 1;
                }, l.prototype.setZero = function() {
                    var t = this.elements;
                    t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, 
                    t[8] = 0;
                }, l.prototype.setTrace = function(t) {
                    var e = this.elements;
                    e[0] = t.x, e[4] = t.y, e[8] = t.z;
                }, l.prototype.getTrace = function(t) {
                    t = t || new c;
                    var e = this.elements;
                    t.x = e[0], t.y = e[4], t.z = e[8];
                }, l.prototype.vmult = function(t, e) {
                    e = e || new c;
                    var i = this.elements, o = t.x, n = t.y, s = t.z;
                    return e.x = i[0] * o + i[1] * n + i[2] * s, e.y = i[3] * o + i[4] * n + i[5] * s, 
                    e.z = i[6] * o + i[7] * n + i[8] * s, e;
                }, l.prototype.smult = function(t) {
                    for (var e = 0; e < this.elements.length; e++) this.elements[e] *= t;
                }, l.prototype.mmult = function(t, e) {
                    for (var i = e || new l, o = 0; o < 3; o++) for (var n = 0; n < 3; n++) {
                        for (var s = 0, r = 0; r < 3; r++) s += t.elements[o + 3 * r] * this.elements[r + 3 * n];
                        i.elements[o + 3 * n] = s;
                    }
                    return i;
                }, l.prototype.scale = function(t, e) {
                    e = e || new l;
                    for (var i = this.elements, o = e.elements, n = 0; 3 !== n; n++) o[3 * n + 0] = t.x * i[3 * n + 0], 
                    o[3 * n + 1] = t.y * i[3 * n + 1], o[3 * n + 2] = t.z * i[3 * n + 2];
                    return e;
                }, l.prototype.solve = function(t, e) {
                    e = e || new c;
                    for (var i, o = [], n = 0; n < 12; n++) o.push(0);
                    for (n = 0; n < 3; n++) for (i = 0; i < 3; i++) o[n + 4 * i] = this.elements[n + 3 * i];
                    o[3] = t.x, o[7] = t.y, o[11] = t.z;
                    var s, r, a = 3, h = a;
                    do {
                        if (0 === o[(n = h - a) + 4 * n]) for (i = n + 1; i < h; i++) if (0 !== o[n + 4 * i]) {
                            for (s = 4; o[(r = 4 - s) + 4 * n] += o[r + 4 * i], --s; ) ;
                            break;
                        }
                        if (0 !== o[n + 4 * n]) for (i = n + 1; i < h; i++) {
                            var l = o[n + 4 * i] / o[n + 4 * n];
                            for (s = 4; o[(r = 4 - s) + 4 * i] = r <= n ? 0 : o[r + 4 * i] - o[r + 4 * n] * l, 
                            --s; ) ;
                        }
                    } while (--a);
                    if (e.z = o[11] / o[10], e.y = (o[7] - o[6] * e.z) / o[5], e.x = (o[3] - o[2] * e.z - o[1] * e.y) / o[0], 
                    isNaN(e.x) || isNaN(e.y) || isNaN(e.z) || e.x === 1 / 0 || e.y === 1 / 0 || e.z === 1 / 0) throw "Could not solve equation! Got x=[" + e.toString() + "], b=[" + t.toString() + "], A=[" + this.toString() + "]";
                    return e;
                }, l.prototype.e = function(t, e, i) {
                    if (void 0 === i) return this.elements[e + 3 * t];
                    this.elements[e + 3 * t] = i;
                }, l.prototype.copy = function(t) {
                    for (var e = 0; e < t.elements.length; e++) this.elements[e] = t.elements[e];
                    return this;
                }, l.prototype.toString = function() {
                    for (var t = "", e = 0; e < 9; e++) t += this.elements[e] + ",";
                    return t;
                }, l.prototype.reverse = function(t) {
                    t = t || new l;
                    for (var e, i = [], o = 0; o < 18; o++) i.push(0);
                    for (o = 0; o < 3; o++) for (e = 0; e < 3; e++) i[o + 6 * e] = this.elements[o + 3 * e];
                    i[3] = 1, i[9] = 0, i[15] = 0, i[4] = 0, i[10] = 1, i[16] = 0, i[5] = 0, i[11] = 0, 
                    i[17] = 1;
                    var n, s, r = 3, a = r;
                    do {
                        if (0 === i[(o = a - r) + 6 * o]) for (e = o + 1; e < a; e++) if (0 !== i[o + 6 * e]) {
                            for (n = 6; i[(s = 6 - n) + 6 * o] += i[s + 6 * e], --n; ) ;
                            break;
                        }
                        if (0 !== i[o + 6 * o]) for (e = o + 1; e < a; e++) {
                            var h = i[o + 6 * e] / i[o + 6 * o];
                            for (n = 6; i[(s = 6 - n) + 6 * e] = s <= o ? 0 : i[s + 6 * e] - i[s + 6 * o] * h, 
                            --n; ) ;
                        }
                    } while (--r);
                    o = 2;
                    do {
                        e = o - 1;
                        do {
                            for (h = i[o + 6 * e] / i[o + 6 * o], n = 6; i[(s = 6 - n) + 6 * e] = i[s + 6 * e] - i[s + 6 * o] * h, 
                            --n; ) ;
                        } while (e--);
                    } while (--o);
                    o = 2;
                    do {
                        for (h = 1 / i[o + 6 * o], n = 6; i[(s = 6 - n) + 6 * o] = i[s + 6 * o] * h, --n; ) ;
                    } while (o--);
                    o = 2;
                    do {
                        e = 2;
                        do {
                            if (s = i[3 + e + 6 * o], isNaN(s) || s === 1 / 0) throw "Could not reverse! A=[" + this.toString() + "]";
                            t.e(o, e, s);
                        } while (e--);
                    } while (o--);
                    return t;
                }, l.prototype.setRotationFromQuaternion = function(t) {
                    var e = t.x, i = t.y, o = t.z, n = t.w, s = e + e, r = i + i, a = o + o, h = e * s, l = e * r, c = e * a, p = i * r, u = i * a, d = o * a, v = n * s, y = n * r, f = n * a, m = this.elements;
                    return m[0] = 1 - (p + d), m[1] = l - f, m[2] = c + y, m[3] = l + f, m[4] = 1 - (h + d), 
                    m[5] = u - v, m[6] = c - y, m[7] = u + v, m[8] = 1 - (h + p), this;
                }, l.prototype.transpose = function(t) {
                    for (var e = (t = t || new l).elements, i = this.elements, o = 0; 3 !== o; o++) for (var n = 0; 3 !== n; n++) e[3 * o + n] = i[3 * n + o];
                    return t;
                };
            }, {
                "./Vec3": 31
            } ],
            29: [ function(t, e, i) {
                e.exports = f;
                var d = t("./Vec3");
                function f(t, e, i, o) {
                    this.x = void 0 !== t ? t : 0, this.y = void 0 !== e ? e : 0, this.z = void 0 !== i ? i : 0, 
                    this.w = void 0 !== o ? o : 1;
                }
                f.prototype.set = function(t, e, i, o) {
                    return this.x = t, this.y = e, this.z = i, this.w = o, this;
                }, f.prototype.toString = function() {
                    return this.x + "," + this.y + "," + this.z + "," + this.w;
                }, f.prototype.toArray = function() {
                    return [ this.x, this.y, this.z, this.w ];
                }, f.prototype.setFromAxisAngle = function(t, e) {
                    var i = Math.sin(.5 * e);
                    return this.x = t.x * i, this.y = t.y * i, this.z = t.z * i, this.w = Math.cos(.5 * e), 
                    this;
                }, f.prototype.toAxisAngle = function(t) {
                    t = t || new d, this.normalize();
                    var e = 2 * Math.acos(this.w), i = Math.sqrt(1 - this.w * this.w);
                    return i < .001 ? (t.x = this.x, t.y = this.y, t.z = this.z) : (t.x = this.x / i, 
                    t.y = this.y / i, t.z = this.z / i), [ t, e ];
                };
                var s = new d, r = new d;
                f.prototype.setFromVectors = function(t, e) {
                    if (t.isAntiparallelTo(e)) {
                        var i = s, o = r;
                        t.tangents(i, o), this.setFromAxisAngle(i, Math.PI);
                    } else {
                        var n = t.cross(e);
                        this.x = n.x, this.y = n.y, this.z = n.z, this.w = Math.sqrt(Math.pow(t.norm(), 2) * Math.pow(e.norm(), 2)) + t.dot(e), 
                        this.normalize();
                    }
                    return this;
                }, new d, new d, new d, f.prototype.mult = function(t, e) {
                    e = e || new f;
                    var i = this.x, o = this.y, n = this.z, s = this.w, r = t.x, a = t.y, h = t.z, l = t.w;
                    return e.x = i * l + s * r + o * h - n * a, e.y = o * l + s * a + n * r - i * h, 
                    e.z = n * l + s * h + i * a - o * r, e.w = s * l - i * r - o * a - n * h, e;
                }, f.prototype.inverse = function(t) {
                    var e = this.x, i = this.y, o = this.z, n = this.w;
                    t = t || new f, this.conjugate(t);
                    var s = 1 / (e * e + i * i + o * o + n * n);
                    return t.x *= s, t.y *= s, t.z *= s, t.w *= s, t;
                }, f.prototype.conjugate = function(t) {
                    return (t = t || new f).x = -this.x, t.y = -this.y, t.z = -this.z, t.w = this.w, 
                    t;
                }, f.prototype.normalize = function() {
                    var t = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                    return 0 === t ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (t = 1 / t, 
                    this.x *= t, this.y *= t, this.z *= t, this.w *= t), this;
                }, f.prototype.normalizeFast = function() {
                    var t = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
                    return 0 == t ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= t, 
                    this.y *= t, this.z *= t, this.w *= t), this;
                }, f.prototype.vmult = function(t, e) {
                    e = e || new d;
                    var i = t.x, o = t.y, n = t.z, s = this.x, r = this.y, a = this.z, h = this.w, l = h * i + r * n - a * o, c = h * o + a * i - s * n, p = h * n + s * o - r * i, u = -s * i - r * o - a * n;
                    return e.x = l * h + u * -s + c * -a - p * -r, e.y = c * h + u * -r + p * -s - l * -a, 
                    e.z = p * h + u * -a + l * -r - c * -s, e;
                }, f.prototype.copy = function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this;
                }, f.prototype.toEuler = function(t, e) {
                    var i, o, n;
                    e = e || "YZX";
                    var s = this.x, r = this.y, a = this.z, h = this.w;
                    switch (e) {
                      case "YZX":
                        var l = s * r + a * h;
                        if (.499 < l && (i = 2 * Math.atan2(s, h), o = Math.PI / 2, n = 0), l < -.499 && (i = -2 * Math.atan2(s, h), 
                        o = -Math.PI / 2, n = 0), isNaN(i)) {
                            var c = s * s, p = r * r, u = a * a;
                            i = Math.atan2(2 * r * h - 2 * s * a, 1 - 2 * p - 2 * u), o = Math.asin(2 * l), 
                            n = Math.atan2(2 * s * h - 2 * r * a, 1 - 2 * c - 2 * u);
                        }
                        break;

                      default:
                        throw new Error("Euler order " + e + " not supported yet.");
                    }
                    t.y = i, t.z = o, t.x = n;
                }, f.prototype.setFromEuler = function(t, e, i, o) {
                    o = o || "XYZ";
                    var n = Math.cos(t / 2), s = Math.cos(e / 2), r = Math.cos(i / 2), a = Math.sin(t / 2), h = Math.sin(e / 2), l = Math.sin(i / 2);
                    return "XYZ" === o ? (this.x = a * s * r + n * h * l, this.y = n * h * r - a * s * l, 
                    this.z = n * s * l + a * h * r, this.w = n * s * r - a * h * l) : "YXZ" === o ? (this.x = a * s * r + n * h * l, 
                    this.y = n * h * r - a * s * l, this.z = n * s * l - a * h * r, this.w = n * s * r + a * h * l) : "ZXY" === o ? (this.x = a * s * r - n * h * l, 
                    this.y = n * h * r + a * s * l, this.z = n * s * l + a * h * r, this.w = n * s * r - a * h * l) : "ZYX" === o ? (this.x = a * s * r - n * h * l, 
                    this.y = n * h * r + a * s * l, this.z = n * s * l - a * h * r, this.w = n * s * r + a * h * l) : "YZX" === o ? (this.x = a * s * r + n * h * l, 
                    this.y = n * h * r + a * s * l, this.z = n * s * l - a * h * r, this.w = n * s * r - a * h * l) : "XZY" === o && (this.x = a * s * r - n * h * l, 
                    this.y = n * h * r - a * s * l, this.z = n * s * l + a * h * r, this.w = n * s * r + a * h * l), 
                    this;
                }, f.prototype.clone = function() {
                    return new f(this.x, this.y, this.z, this.w);
                }, f.prototype.slerp = function(t, e, i) {
                    i = i || new f;
                    var o, n, s, r, a, h = this.x, l = this.y, c = this.z, p = this.w, u = t.x, d = t.y, v = t.z, y = t.w;
                    return (n = h * u + l * d + c * v + p * y) < 0 && (n = -n, u = -u, d = -d, v = -v, 
                    y = -y), a = 1e-6 < 1 - n ? (o = Math.acos(n), s = Math.sin(o), r = Math.sin((1 - e) * o) / s, 
                    Math.sin(e * o) / s) : (r = 1 - e, e), i.x = r * h + a * u, i.y = r * l + a * d, 
                    i.z = r * c + a * v, i.w = r * p + a * y, i;
                }, f.prototype.integrate = function(t, e, i, o) {
                    o = o || new f;
                    var n = t.x * i.x, s = t.y * i.y, r = t.z * i.z, a = this.x, h = this.y, l = this.z, c = this.w, p = .5 * e;
                    return o.x += p * (n * c + s * l - r * h), o.y += p * (s * c + r * a - n * l), o.z += p * (r * c + n * h - s * a), 
                    o.w += p * (-n * a - s * h - r * l), o;
                };
            }, {
                "./Vec3": 31
            } ],
            30: [ function(t, e, i) {
                var n = t("./Vec3"), o = t("./Quaternion");
                function s(t) {
                    t = t || {}, this.position = new n, t.position && this.position.copy(t.position), 
                    this.quaternion = new o, t.quaternion && this.quaternion.copy(t.quaternion);
                }
                e.exports = s;
                var r = new o;
                s.pointToLocalFrame = function(t, e, i, o) {
                    return o = o || new n, i.vsub(t, o), e.conjugate(r), r.vmult(o, o), o;
                }, s.prototype.pointToLocal = function(t, e) {
                    return s.pointToLocalFrame(this.position, this.quaternion, t, e);
                }, s.pointToWorldFrame = function(t, e, i, o) {
                    return o = o || new n, e.vmult(i, o), o.vadd(t, o), o;
                }, s.prototype.pointToWorld = function(t, e) {
                    return s.pointToWorldFrame(this.position, this.quaternion, t, e);
                }, s.prototype.vectorToWorldFrame = function(t, e) {
                    return e = e || new n, this.quaternion.vmult(t, e), e;
                }, s.vectorToWorldFrame = function(t, e, i) {
                    return t.vmult(e, i), i;
                }, s.vectorToLocalFrame = function(t, e, i, o) {
                    return o = o || new n, e.w *= -1, e.vmult(i, o), e.w *= -1, o;
                };
            }, {
                "./Quaternion": 29,
                "./Vec3": 31
            } ],
            31: [ function(t, e, i) {
                e.exports = h;
                var o = t("./Mat3");
                function h(t, e, i) {
                    this.x = t || 0, this.y = e || 0, this.z = i || 0;
                }
                h.ZERO = new h(0, 0, 0), h.UNIT_X = new h(1, 0, 0), h.UNIT_Y = new h(0, 1, 0), h.UNIT_Z = new h(0, 0, 1), 
                h.prototype.cross = function(t, e) {
                    var i = t.x, o = t.y, n = t.z, s = this.x, r = this.y, a = this.z;
                    return (e = e || new h).x = r * n - a * o, e.y = a * i - s * n, e.z = s * o - r * i, 
                    e;
                }, h.prototype.set = function(t, e, i) {
                    return this.x = t, this.y = e, this.z = i, this;
                }, h.prototype.setZero = function() {
                    this.x = this.y = this.z = 0;
                }, h.prototype.vadd = function(t, e) {
                    if (!e) return new h(this.x + t.x, this.y + t.y, this.z + t.z);
                    e.x = t.x + this.x, e.y = t.y + this.y, e.z = t.z + this.z;
                }, h.prototype.vsub = function(t, e) {
                    if (!e) return new h(this.x - t.x, this.y - t.y, this.z - t.z);
                    e.x = this.x - t.x, e.y = this.y - t.y, e.z = this.z - t.z;
                }, h.prototype.crossmat = function() {
                    return new o([ 0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0 ]);
                }, h.prototype.normalize = function() {
                    var t = this.x, e = this.y, i = this.z, o = Math.sqrt(t * t + e * e + i * i);
                    if (0 < o) {
                        var n = 1 / o;
                        this.x *= n, this.y *= n, this.z *= n;
                    } else this.x = 0, this.y = 0, this.z = 0;
                    return o;
                }, h.prototype.unit = function(t) {
                    t = t || new h;
                    var e = this.x, i = this.y, o = this.z, n = Math.sqrt(e * e + i * i + o * o);
                    return 0 < n ? (n = 1 / n, t.x = e * n, t.y = i * n, t.z = o * n) : (t.x = 1, t.y = 0, 
                    t.z = 0), t;
                }, h.prototype.length = h.prototype.norm = function() {
                    var t = this.x, e = this.y, i = this.z;
                    return Math.sqrt(t * t + e * e + i * i);
                }, h.prototype.lengthSquared = h.prototype.norm2 = function() {
                    return this.dot(this);
                }, h.prototype.distanceTo = function(t) {
                    var e = this.x, i = this.y, o = this.z, n = t.x, s = t.y, r = t.z;
                    return Math.sqrt((n - e) * (n - e) + (s - i) * (s - i) + (r - o) * (r - o));
                }, h.prototype.distanceSquared = function(t) {
                    var e = this.x, i = this.y, o = this.z, n = t.x, s = t.y, r = t.z;
                    return (n - e) * (n - e) + (s - i) * (s - i) + (r - o) * (r - o);
                }, h.prototype.mult = function(t, e) {
                    e = e || new h;
                    var i = this.x, o = this.y, n = this.z;
                    return e.x = t * i, e.y = t * o, e.z = t * n, e;
                }, h.prototype.vmul = function(t, e) {
                    return (e = e || new h).x = t.x * this.x, e.y = t.y * this.y, e.z = t.z * this.z, 
                    e;
                }, h.prototype.scale = h.prototype.mult, h.prototype.addScaledVector = function(t, e, i) {
                    return (i = i || new h).x = this.x + t * e.x, i.y = this.y + t * e.y, i.z = this.z + t * e.z, 
                    i;
                }, h.prototype.dot = function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z;
                }, h.prototype.isZero = function() {
                    return 0 === this.x && 0 === this.y && 0 === this.z;
                }, h.prototype.negate = function(t) {
                    return (t = t || new h).x = -this.x, t.y = -this.y, t.z = -this.z, t;
                };
                var r = new h, a = new h;
                h.prototype.tangents = function(t, e) {
                    var i = this.norm();
                    if (0 < i) {
                        var o = r, n = 1 / i;
                        o.set(this.x * n, this.y * n, this.z * n);
                        var s = a;
                        Math.abs(o.x) < .9 ? s.set(1, 0, 0) : s.set(0, 1, 0), o.cross(s, t), o.cross(t, e);
                    } else t.set(1, 0, 0), e.set(0, 1, 0);
                }, h.prototype.toString = function() {
                    return this.x + "," + this.y + "," + this.z;
                }, h.prototype.toArray = function() {
                    return [ this.x, this.y, this.z ];
                }, h.prototype.copy = function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this;
                }, h.prototype.lerp = function(t, e, i) {
                    var o = this.x, n = this.y, s = this.z;
                    i.x = o + (t.x - o) * e, i.y = n + (t.y - n) * e, i.z = s + (t.z - s) * e;
                }, h.prototype.almostEquals = function(t, e) {
                    return void 0 === e && (e = 1e-6), !(Math.abs(this.x - t.x) > e || Math.abs(this.y - t.y) > e || Math.abs(this.z - t.z) > e);
                }, h.prototype.almostZero = function(t) {
                    return void 0 === t && (t = 1e-6), !(Math.abs(this.x) > t || Math.abs(this.y) > t || Math.abs(this.z) > t);
                };
                var n = new h;
                h.prototype.isAntiparallelTo = function(t, e) {
                    return this.negate(n), n.almostEquals(t, e);
                }, h.prototype.clone = function() {
                    return new h(this.x, this.y, this.z);
                };
            }, {
                "./Mat3": 28
            } ],
            32: [ function(t, e, i) {
                e.exports = w;
                var o = t("../utils/EventTarget"), s = (t("../shapes/Shape"), t("../math/Vec3")), n = t("../math/Mat3"), r = t("../math/Quaternion"), a = (t("../material/Material"), 
                t("../collision/AABB")), h = t("../shapes/Box"), l = t("../world/World");
                function w(t) {
                    t = t || {}, o.apply(this), this.id = w.idCounter++, this.world = null, this.preStep = null, 
                    this.postStep = null, this.vlambda = new s, this.collisionFilterGroup = "number" == typeof t.collisionFilterGroup ? t.collisionFilterGroup : 1, 
                    this.collisionFilterMask = "number" == typeof t.collisionFilterMask ? t.collisionFilterMask : -1, 
                    this.collisionResponse = !0, this.position = new s, this.previousPosition = new s, 
                    this.interpolatedPosition = new s, this.initPosition = new s, t.position && (this.position.copy(t.position), 
                    this.previousPosition.copy(t.position), this.interpolatedPosition.copy(t.position), 
                    this.initPosition.copy(t.position)), this.velocity = new s, t.velocity && this.velocity.copy(t.velocity), 
                    this.initVelocity = new s, this.force = new s;
                    var e = "number" == typeof t.mass ? t.mass : 0;
                    this.mass = e, this.invMass = 0 < e ? 1 / e : 0, this.material = t.material || null, 
                    this.linearDamping = "number" == typeof t.linearDamping ? t.linearDamping : .01, 
                    this.type = e <= 0 ? w.STATIC : w.DYNAMIC, typeof t.type == typeof w.STATIC && (this.type = t.type), 
                    this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.sleepState = 0, 
                    this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .1, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, 
                    this.timeLastSleepy = 0, this._wakeUpAfterNarrowphase = !1, this.torque = new s, 
                    this.quaternion = new r, this.initQuaternion = new r, this.previousQuaternion = new r, 
                    this.interpolatedQuaternion = new r, t.quaternion && (this.quaternion.copy(t.quaternion), 
                    this.initQuaternion.copy(t.quaternion), this.previousQuaternion.copy(t.quaternion), 
                    this.interpolatedQuaternion.copy(t.quaternion)), this.angularVelocity = new s, t.angularVelocity && this.angularVelocity.copy(t.angularVelocity), 
                    this.initAngularVelocity = new s, this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], 
                    this.inertia = new s, this.invInertia = new s, this.invInertiaWorld = new n, this.invMassSolve = 0, 
                    this.invInertiaSolve = new s, this.invInertiaWorldSolve = new n, this.fixedRotation = void 0 !== t.fixedRotation && t.fixedRotation, 
                    this.useGravity = !0, this.angularDamping = void 0 !== t.angularDamping ? t.angularDamping : .01, 
                    this.linearFactor = new s(1, 1, 1), t.linearFactor && this.linearFactor.copy(t.linearFactor), 
                    this.angularFactor = new s(1, 1, 1), t.angularFactor && this.angularFactor.copy(t.angularFactor), 
                    this.aabb = new a, this.aabbNeedsUpdate = !0, this.boundingRadius = 0, this.wlambda = new s, 
                    t.shape && this.addShape(t.shape), this.hasTrigger = !0, this.updateMassProperties();
                }
                ((w.prototype = new o).constructor = w).COLLIDE_EVENT_NAME = "collide", w.DYNAMIC = 1, 
                w.STATIC = 2, w.KINEMATIC = 4, w.AWAKE = 0, w.SLEEPY = 1, w.SLEEPING = 2, w.idCounter = 0, 
                w.wakeupEvent = {
                    type: "wakeup"
                }, w.prototype.wakeUp = function() {
                    var t = this.sleepState;
                    this.sleepState = 0, this._wakeUpAfterNarrowphase = !1, t === w.SLEEPING && this.dispatchEvent(w.wakeupEvent);
                }, w.prototype.sleep = function() {
                    this.sleepState = w.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), 
                    this._wakeUpAfterNarrowphase = !1;
                }, w.sleepyEvent = {
                    type: "sleepy"
                }, w.sleepEvent = {
                    type: "sleep"
                }, w.prototype.sleepTick = function(t) {
                    if (this.allowSleep) {
                        var e = this.sleepState, i = this.velocity.norm2() + this.angularVelocity.norm2(), o = Math.pow(this.sleepSpeedLimit, 2);
                        e === w.AWAKE && i < o ? (this.sleepState = w.SLEEPY, this.timeLastSleepy = t, this.dispatchEvent(w.sleepyEvent)) : e === w.SLEEPY && o < i ? this.wakeUp() : e === w.SLEEPY && t - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), 
                        this.dispatchEvent(w.sleepEvent));
                    }
                }, w.prototype.updateSolveMassProperties = function() {
                    this.sleepState === w.SLEEPING || this.type === w.KINEMATIC ? (this.invMassSolve = 0, 
                    this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, 
                    this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
                }, w.prototype.pointToLocalFrame = function(t, e) {
                    return e = e || new s, t.vsub(this.position, e), this.quaternion.conjugate().vmult(e, e), 
                    e;
                }, w.prototype.vectorToLocalFrame = function(t, e) {
                    return e = e || new s, this.quaternion.conjugate().vmult(t, e), e;
                }, w.prototype.pointToWorldFrame = function(t, e) {
                    return e = e || new s, this.quaternion.vmult(t, e), e.vadd(this.position, e), e;
                }, w.prototype.vectorToWorldFrame = function(t, e) {
                    return e = e || new s, this.quaternion.vmult(t, e), e;
                };
                var p = new s, u = new r;
                w.prototype.addShape = function(t, e, i) {
                    var o, n;
                    return n = i, o = (o = e) || new s, n = n || new r, l.idToShapeMap[t.id] = t, this.shapes.push(t), 
                    this.shapeOffsets.push(o), this.shapeOrientations.push(n), this.updateMassProperties(), 
                    this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, this.updateHasTrigger(), 
                    t.body = this;
                }, w.prototype.removeShape = function(t) {
                    var e = this.shapes.indexOf(t);
                    -1 !== e && (this.shapes.splice(e, 1), this.shapeOffsets.splice(e, 1), this.shapeOrientations.splice(e, 1), 
                    this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, 
                    this.updateHasTrigger());
                }, w.prototype.updateBoundingRadius = function() {
                    for (var t = this.shapes, e = this.shapeOffsets, i = t.length, o = 0, n = 0; n !== i; n++) {
                        var s = t[n];
                        s.updateBoundingSphereRadius();
                        var r = e[n].norm(), a = s.boundingSphereRadius;
                        o < r + a && (o = r + a);
                    }
                    this.boundingRadius = o;
                };
                var d = new a;
                w.prototype.computeAABB = function() {
                    for (var t = this.shapes, e = this.shapeOffsets, i = this.shapeOrientations, o = t.length, n = p, s = u, r = this.quaternion, a = this.aabb, h = d, l = 0; l !== o; l++) {
                        var c = t[l];
                        r.vmult(e[l], n), n.vadd(this.position, n), i[l].mult(r, s), c.calculateWorldAABB(n, s, h.lowerBound, h.upperBound), 
                        0 === l ? a.copy(h) : a.extend(h);
                    }
                    this.aabbNeedsUpdate = !1;
                };
                var c = new n, v = new n;
                new n, w.prototype.updateInertiaWorld = function(t) {
                    var e = this.invInertia;
                    if (e.x !== e.y || e.y !== e.z || t) {
                        var i = c, o = v;
                        i.setRotationFromQuaternion(this.quaternion), i.transpose(o), i.scale(e, i), i.mmult(o, this.invInertiaWorld);
                    }
                };
                var y = new s;
                w.prototype.applyForce = function(t, e) {
                    if (this.type === w.DYNAMIC) {
                        var i = y;
                        e.cross(t, i), this.force.vadd(t, this.force), this.torque.vadd(i, this.torque);
                    }
                };
                var f = new s, m = new s;
                w.prototype.applyLocalForce = function(t, e) {
                    if (this.type === w.DYNAMIC) {
                        var i = f, o = m;
                        this.vectorToWorldFrame(t, i), this.vectorToWorldFrame(e, o), this.applyForce(i, o);
                    }
                };
                var g = new s, x = new s;
                w.prototype.applyImpulse = function(t, e) {
                    if (this.type === w.DYNAMIC) {
                        var i = e, o = g;
                        o.copy(t), o.mult(this.invMass, o), this.velocity.vadd(o, this.velocity);
                        var n = x;
                        i.cross(t, n), this.invInertiaWorld.vmult(n, n), this.angularVelocity.vadd(n, this.angularVelocity);
                    }
                };
                var b = new s, B = new s;
                w.prototype.applyLocalImpulse = function(t, e) {
                    if (this.type === w.DYNAMIC) {
                        var i = b, o = B;
                        this.vectorToWorldFrame(t, i), this.vectorToWorldFrame(e, o), this.applyImpulse(i, o);
                    }
                };
                var E = new s;
                w.prototype.updateMassProperties = function() {
                    var t = E;
                    this.invMass = 0 < this.mass ? 1 / this.mass : 0;
                    var e = this.inertia, i = this.fixedRotation;
                    this.computeAABB(), t.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), 
                    h.calculateInertia(t, this.mass, e), this.invInertia.set(0 < e.x && !i ? 1 / e.x : 0, 0 < e.y && !i ? 1 / e.y : 0, 0 < e.z && !i ? 1 / e.z : 0), 
                    this.updateInertiaWorld(!0);
                }, w.prototype.getVelocityAtWorldPoint = function(t, e) {
                    var i = new s;
                    return t.vsub(this.position, i), this.angularVelocity.cross(i, e), this.velocity.vadd(e, e), 
                    e;
                }, w.prototype.integrate = function(t, e, i) {
                    if (this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), 
                    (this.type === w.DYNAMIC || this.type === w.KINEMATIC) && this.sleepState !== w.SLEEPING) {
                        var o = this.velocity, n = this.angularVelocity, s = this.position, r = this.force, a = this.torque, h = this.quaternion, l = this.invMass, c = this.invInertiaWorld, p = this.linearFactor, u = l * t;
                        o.x += r.x * u * p.x, o.y += r.y * u * p.y, o.z += r.z * u * p.z;
                        var d = c.elements, v = this.angularFactor, y = a.x * v.x, f = a.y * v.y, m = a.z * v.z;
                        n.x += t * (d[0] * y + d[1] * f + d[2] * m), n.y += t * (d[3] * y + d[4] * f + d[5] * m), 
                        n.z += t * (d[6] * y + d[7] * f + d[8] * m), s.x += o.x * t, s.y += o.y * t, s.z += o.z * t, 
                        h.integrate(this.angularVelocity, t, this.angularFactor, h), e && (i ? h.normalizeFast() : h.normalize()), 
                        this.aabbNeedsUpdate = !0, this.updateInertiaWorld();
                    }
                }, w.prototype.isSleeping = function() {
                    return this.sleepState === w.SLEEPING;
                }, w.prototype.isSleepy = function() {
                    return this.sleepState === w.SLEEPY;
                }, w.prototype.isAwake = function() {
                    return this.sleepState === w.AWAKE;
                }, w.prototype.updateHasTrigger = function() {
                    for (var t = this.shapes.length; t-- && (this.hasTrigger = !this.shapes[t].collisionResponse, 
                    !this.hasTrigger); ) ;
                };
            }, {
                "../collision/AABB": 3,
                "../material/Material": 26,
                "../math/Mat3": 28,
                "../math/Quaternion": 29,
                "../math/Vec3": 31,
                "../shapes/Box": 38,
                "../shapes/Shape": 44,
                "../utils/EventTarget": 50,
                "../world/World": 57
            } ],
            33: [ function(t, e, i) {
                t("./Body");
                var S = t("../math/Vec3"), c = t("../math/Quaternion"), o = (t("../collision/RaycastResult"), 
                t("../collision/Ray")), n = t("../objects/WheelInfo");
                function s(t) {
                    this.chassisBody = t.chassisBody, this.wheelInfos = [], this.sliding = !1, this.world = null, 
                    this.indexRightAxis = void 0 !== t.indexRightAxis ? t.indexRightAxis : 1, this.indexForwardAxis = void 0 !== t.indexForwardAxis ? t.indexForwardAxis : 0, 
                    this.indexUpAxis = void 0 !== t.indexUpAxis ? t.indexUpAxis : 2;
                }
                e.exports = s, new S, new S, new S;
                var p = new S, u = new S, d = new S;
                new o, s.prototype.addWheel = function(t) {
                    var e = new n(t = t || {}), i = this.wheelInfos.length;
                    return this.wheelInfos.push(e), i;
                }, s.prototype.setSteeringValue = function(t, e) {
                    this.wheelInfos[e].steering = t;
                }, new S, s.prototype.applyEngineForce = function(t, e) {
                    this.wheelInfos[e].engineForce = t;
                }, s.prototype.setBrake = function(t, e) {
                    this.wheelInfos[e].brake = t;
                }, s.prototype.addToWorld = function(t) {
                    this.constraints, t.addBody(this.chassisBody);
                    var e = this;
                    this.preStepCallback = function() {
                        e.updateVehicle(t.dt);
                    }, t.addEventListener("preStep", this.preStepCallback), this.world = t;
                }, s.prototype.getVehicleAxisWorld = function(t, e) {
                    e.set(0 === t ? 1 : 0, 1 === t ? 1 : 0, 2 === t ? 1 : 0), this.chassisBody.vectorToWorldFrame(e, e);
                }, s.prototype.updateVehicle = function(t) {
                    for (var e = this.wheelInfos, i = e.length, o = this.chassisBody, n = 0; n < i; n++) this.updateWheelTransform(n);
                    this.currentVehicleSpeedKmHour = 3.6 * o.velocity.norm();
                    var s = new S;
                    for (this.getVehicleAxisWorld(this.indexForwardAxis, s), s.dot(o.velocity) < 0 && (this.currentVehicleSpeedKmHour *= -1), 
                    n = 0; n < i; n++) this.castRay(e[n]);
                    this.updateSuspension(t);
                    var r = new S, a = new S;
                    for (n = 0; n < i; n++) {
                        var h = (u = e[n]).suspensionForce;
                        h > u.maxSuspensionForce && (h = u.maxSuspensionForce), u.raycastResult.hitNormalWorld.scale(h * t, r), 
                        u.raycastResult.hitPointWorld.vsub(o.position, a), o.applyImpulse(r, a);
                    }
                    this.updateFriction(t);
                    var l = new S, c = new S, p = new S;
                    for (n = 0; n < i; n++) {
                        var u = e[n];
                        o.getVelocityAtWorldPoint(u.chassisConnectionPointWorld, p);
                        var d = 1;
                        switch (this.indexUpAxis) {
                          case 1:
                            d = -1;
                        }
                        if (u.isInContact) {
                            this.getVehicleAxisWorld(this.indexForwardAxis, c);
                            var v = c.dot(u.raycastResult.hitNormalWorld);
                            u.raycastResult.hitNormalWorld.scale(v, l), c.vsub(l, c);
                            var y = c.dot(p);
                            u.deltaRotation = d * y * t / u.radius;
                        }
                        !u.sliding && u.isInContact || 0 === u.engineForce || !u.useCustomSlidingRotationalSpeed || (u.deltaRotation = (0 < u.engineForce ? 1 : -1) * u.customSlidingRotationalSpeed * t), 
                        Math.abs(u.brake) > Math.abs(u.engineForce) && (u.deltaRotation = 0), u.rotation += u.deltaRotation, 
                        u.deltaRotation *= .99;
                    }
                }, s.prototype.updateSuspension = function(t) {
                    for (var e = this.chassisBody.mass, i = this.wheelInfos, o = i.length, n = 0; n < o; n++) {
                        var s = i[n];
                        if (s.isInContact) {
                            var r, a = s.suspensionRestLength - s.suspensionLength;
                            r = s.suspensionStiffness * a * s.clippedInvContactDotSuspension;
                            var h = s.suspensionRelativeVelocity;
                            r -= (h < 0 ? s.dampingCompression : s.dampingRelaxation) * h, s.suspensionForce = r * e, 
                            s.suspensionForce < 0 && (s.suspensionForce = 0);
                        } else s.suspensionForce = 0;
                    }
                }, s.prototype.removeFromWorld = function(t) {
                    this.constraints, t.remove(this.chassisBody), t.removeEventListener("preStep", this.preStepCallback), 
                    this.world = null;
                };
                var m = new S, w = new S;
                s.prototype.castRay = function(t) {
                    var e = m, i = w;
                    this.updateWheelTransformWorld(t);
                    var o = this.chassisBody, n = -1, s = t.suspensionRestLength + t.radius;
                    t.directionWorld.scale(s, e);
                    var r = t.chassisConnectionPointWorld;
                    r.vadd(e, i);
                    var a = t.raycastResult;
                    a.reset();
                    var h = o.collisionResponse;
                    o.collisionResponse = !1, this.world.rayTest(r, i, a), o.collisionResponse = h;
                    var l = a.body;
                    if (t.raycastResult.groundObject = 0, l) {
                        n = a.distance, t.raycastResult.hitNormalWorld = a.hitNormalWorld, t.isInContact = !0;
                        var c = a.distance;
                        t.suspensionLength = c - t.radius;
                        var p = t.suspensionRestLength - t.maxSuspensionTravel, u = t.suspensionRestLength + t.maxSuspensionTravel;
                        t.suspensionLength < p && (t.suspensionLength = p), t.suspensionLength > u && (t.suspensionLength = u, 
                        t.raycastResult.reset());
                        var d = t.raycastResult.hitNormalWorld.dot(t.directionWorld), v = new S;
                        o.getVelocityAtWorldPoint(t.raycastResult.hitPointWorld, v);
                        var y = t.raycastResult.hitNormalWorld.dot(v);
                        if (-.1 <= d) t.suspensionRelativeVelocity = 0, t.clippedInvContactDotSuspension = 10; else {
                            var f = -1 / d;
                            t.suspensionRelativeVelocity = y * f, t.clippedInvContactDotSuspension = f;
                        }
                    } else t.suspensionLength = t.suspensionRestLength + 0 * t.maxSuspensionTravel, 
                    t.suspensionRelativeVelocity = 0, t.directionWorld.scale(-1, t.raycastResult.hitNormalWorld), 
                    t.clippedInvContactDotSuspension = 1;
                    return n;
                }, s.prototype.updateWheelTransformWorld = function(t) {
                    t.isInContact = !1;
                    var e = this.chassisBody;
                    e.pointToWorldFrame(t.chassisConnectionPointLocal, t.chassisConnectionPointWorld), 
                    e.vectorToWorldFrame(t.directionLocal, t.directionWorld), e.vectorToWorldFrame(t.axleLocal, t.axleWorld);
                }, s.prototype.updateWheelTransform = function(t) {
                    var e = p, i = u, o = d, n = this.wheelInfos[t];
                    this.updateWheelTransformWorld(n), n.directionLocal.scale(-1, e), i.copy(n.axleLocal), 
                    e.cross(i, o), o.normalize(), i.normalize();
                    var s = n.steering, r = new c;
                    r.setFromAxisAngle(e, s);
                    var a = new c;
                    a.setFromAxisAngle(i, n.rotation);
                    var h = n.worldTransform.quaternion;
                    this.chassisBody.quaternion.mult(r, h), h.mult(a, h), h.normalize();
                    var l = n.worldTransform.position;
                    l.copy(n.directionWorld), l.scale(n.suspensionLength, l), l.vadd(n.chassisConnectionPointWorld, l);
                };
                var z = [ new S(1, 0, 0), new S(0, 1, 0), new S(0, 0, 1) ];
                s.prototype.getWheelTransformWorld = function(t) {
                    return this.wheelInfos[t].worldTransform;
                };
                var M = new S, C = [], q = [];
                s.prototype.updateFriction = function(t) {
                    for (var e = M, i = this.wheelInfos, o = i.length, n = this.chassisBody, s = q, r = C, a = 0; a < o; a++) p = (x = i[a]).raycastResult.body, 
                    x.sideImpulse = 0, x.forwardImpulse = 0, s[a] || (s[a] = new S), r[a] || (r[a] = new S);
                    for (a = 0; a < o; a++) if (p = (x = i[a]).raycastResult.body) {
                        var h = r[a];
                        this.getWheelTransformWorld(a).vectorToWorldFrame(z[this.indexRightAxis], h);
                        var l = x.raycastResult.hitNormalWorld, c = h.dot(l);
                        l.scale(c, e), h.vsub(e, h), h.normalize(), l.cross(h, s[a]), s[a].normalize(), 
                        x.sideImpulse = F(n, x.raycastResult.hitPointWorld, p, x.raycastResult.hitPointWorld, h), 
                        x.sideImpulse *= 1;
                    }
                    for (this.sliding = !1, a = 0; a < o; a++) {
                        var p = (x = i[a]).raycastResult.body, u = 0;
                        if (x.slipInfo = 1, p) {
                            var d = x.brake ? x.brake : 0;
                            u = R(n, p, x.raycastResult.hitPointWorld, s[a], d);
                            var v = d / (u += x.engineForce * t);
                            x.slipInfo *= v;
                        }
                        if (x.forwardImpulse = 0, x.skidInfo = 1, p) {
                            x.skidInfo = 1;
                            var y = x.suspensionForce * t * x.frictionSlip, f = y * y;
                            x.forwardImpulse = u;
                            var m = .5 * x.forwardImpulse, w = 1 * x.sideImpulse, g = m * m + w * w;
                            x.sliding = !1, f < g && (this.sliding = !0, x.sliding = !0, v = y / Math.sqrt(g), 
                            x.skidInfo *= v);
                        }
                    }
                    if (this.sliding) for (a = 0; a < o; a++) 0 !== (x = i[a]).sideImpulse && x.skidInfo < 1 && (x.forwardImpulse *= x.skidInfo, 
                    x.sideImpulse *= x.skidInfo);
                    for (a = 0; a < o; a++) {
                        var x = i[a], b = new S;
                        if (x.raycastResult.hitPointWorld.vsub(n.position, b), 0 !== x.forwardImpulse) {
                            var B = new S;
                            s[a].scale(x.forwardImpulse, B), n.applyImpulse(B, b);
                        }
                        if (0 !== x.sideImpulse) {
                            p = x.raycastResult.body;
                            var E = new S;
                            x.raycastResult.hitPointWorld.vsub(p.position, E);
                            var A = new S;
                            r[a].scale(x.sideImpulse, A), n.vectorToLocalFrame(b, b), b["xyz"[this.indexUpAxis]] *= x.rollInfluence, 
                            n.vectorToWorldFrame(b, b), n.applyImpulse(A, b), A.scale(-1, A), p.applyImpulse(A, E);
                        }
                    }
                };
                var v = new S, y = new S, f = new S;
                function R(t, e, i, o, n) {
                    var s = 0, r = i, a = v, h = y, l = f;
                    return t.getVelocityAtWorldPoint(r, a), e.getVelocityAtWorldPoint(r, h), a.vsub(h, l), 
                    n < (s = -o.dot(l) * (1 / (x(t, i, o) + x(e, i, o)))) && (s = n), s < -n && (s = -n), 
                    s;
                }
                var a = new S, h = new S, l = new S, g = new S;
                function x(t, e, i) {
                    var o = a, n = h, s = l, r = g;
                    return e.vsub(t.position, o), o.cross(i, n), t.invInertiaWorld.vmult(n, r), r.cross(o, s), 
                    t.invMass + i.dot(s);
                }
                var b = new S, B = new S, E = new S;
                function F(t, e, i, o, n) {
                    if (1.1 < n.norm2()) return 0;
                    var s = b, r = B, a = E;
                    return t.getVelocityAtWorldPoint(e, s), i.getVelocityAtWorldPoint(o, r), s.vsub(r, a), 
                    -.2 * n.dot(a) * (1 / (t.invMass + i.invMass));
                }
            }, {
                "../collision/Ray": 10,
                "../collision/RaycastResult": 11,
                "../math/Quaternion": 29,
                "../math/Vec3": 31,
                "../objects/WheelInfo": 37,
                "./Body": 32
            } ],
            34: [ function(t, e, i) {
                var r = t("./Body"), a = t("../shapes/Sphere"), o = t("../shapes/Box"), h = t("../math/Vec3"), l = t("../constraints/HingeConstraint");
                function n(t) {
                    if (this.wheelBodies = [], this.coordinateSystem = void 0 === t.coordinateSystem ? new h(1, 2, 3) : t.coordinateSystem.clone(), 
                    this.chassisBody = t.chassisBody, !this.chassisBody) {
                        var e = new o(new h(5, 2, .5));
                        this.chassisBody = new r(1, e);
                    }
                    this.constraints = [], this.wheelAxes = [], this.wheelForces = [];
                }
                (e.exports = n).prototype.addWheel = function(t) {
                    var e = (t = t || {}).body;
                    e = e || new r(1, new a(1.2)), this.wheelBodies.push(e), this.wheelForces.push(0), 
                    new h;
                    var i = void 0 !== t.position ? t.position.clone() : new h, o = new h;
                    this.chassisBody.pointToWorldFrame(i, o), e.position.set(o.x, o.y, o.z);
                    var n = void 0 !== t.axis ? t.axis.clone() : new h(0, 1, 0);
                    this.wheelAxes.push(n);
                    var s = new l(this.chassisBody, e, {
                        pivotA: i,
                        axisA: n,
                        pivotB: h.ZERO,
                        axisB: n,
                        collideConnected: !1
                    });
                    return this.constraints.push(s), this.wheelBodies.length - 1;
                }, n.prototype.setSteeringValue = function(t, e) {
                    var i = this.wheelAxes[e], o = Math.cos(t), n = Math.sin(t), s = i.x, r = i.y;
                    this.constraints[e].axisA.set(o * s - n * r, n * s + o * r, 0);
                }, n.prototype.setMotorSpeed = function(t, e) {
                    var i = this.constraints[e];
                    i.enableMotor(), i.motorTargetVelocity = t;
                }, n.prototype.disableMotor = function(t) {
                    this.constraints[t].disableMotor();
                };
                var s = new h;
                n.prototype.setWheelForce = function(t, e) {
                    this.wheelForces[e] = t;
                }, n.prototype.applyWheelForce = function(t, e) {
                    var i = this.wheelAxes[e], o = this.wheelBodies[e], n = o.torque;
                    i.scale(t, s), o.vectorToWorldFrame(s, s), n.vadd(s, n);
                }, n.prototype.addToWorld = function(t) {
                    for (var e = this.constraints, i = this.wheelBodies.concat([ this.chassisBody ]), o = 0; o < i.length; o++) t.addBody(i[o]);
                    for (o = 0; o < e.length; o++) t.addConstraint(e[o]);
                    t.addEventListener("preStep", this._update.bind(this));
                }, n.prototype._update = function() {
                    for (var t = this.wheelForces, e = 0; e < t.length; e++) this.applyWheelForce(t[e], e);
                }, n.prototype.removeFromWorld = function(t) {
                    for (var e = this.constraints, i = this.wheelBodies.concat([ this.chassisBody ]), o = 0; o < i.length; o++) t.remove(i[o]);
                    for (o = 0; o < e.length; o++) t.removeConstraint(e[o]);
                };
                var c = new h;
                n.prototype.getWheelSpeed = function(t) {
                    var e = this.wheelAxes[t], i = this.wheelBodies[t].angularVelocity;
                    return this.chassisBody.vectorToWorldFrame(e, c), i.dot(c);
                };
            }, {
                "../constraints/HingeConstraint": 16,
                "../math/Vec3": 31,
                "../shapes/Box": 38,
                "../shapes/Sphere": 45,
                "./Body": 32
            } ],
            35: [ function(t, e, i) {
                e.exports = n, t("../shapes/Shape");
                var o = t("../math/Vec3");
                function n() {
                    this.particles = [], this.density = 1, this.smoothingRadius = 1, this.speedOfSound = 1, 
                    this.viscosity = .01, this.eps = 1e-6, this.pressures = [], this.densities = [], 
                    this.neighbors = [];
                }
                t("../math/Quaternion"), t("../shapes/Particle"), t("../objects/Body"), t("../material/Material"), 
                n.prototype.add = function(t) {
                    this.particles.push(t), this.neighbors.length < this.particles.length && this.neighbors.push([]);
                }, n.prototype.remove = function(t) {
                    var e = this.particles.indexOf(t);
                    -1 !== e && (this.particles.splice(e, 1), this.neighbors.length > this.particles.length && this.neighbors.pop());
                };
                var h = new o;
                n.prototype.getNeighbors = function(t, e) {
                    for (var i = this.particles.length, o = t.id, n = this.smoothingRadius * this.smoothingRadius, s = h, r = 0; r !== i; r++) {
                        var a = this.particles[r];
                        a.position.vsub(t.position, s), o !== a.id && s.norm2() < n && e.push(a);
                    }
                };
                var B = new o, E = new o, A = new o, S = new o, z = new o, M = new o;
                n.prototype.update = function() {
                    for (var t = this.particles.length, e = B, i = this.speedOfSound, o = this.eps, n = 0; n !== t; n++) {
                        var s = this.particles[n];
                        (g = this.neighbors[n]).length = 0, this.getNeighbors(s, g), g.push(this.particles[n]);
                        for (var r = g.length, a = 0, h = 0; h !== r; h++) {
                            s.position.vsub(g[h].position, e);
                            var l = e.norm(), c = this.w(l);
                            a += g[h].mass * c;
                        }
                        this.densities[n] = a, this.pressures[n] = i * i * (this.densities[n] - this.density);
                    }
                    var p = E, u = A, d = S, v = z, y = M;
                    for (n = 0; n !== t; n++) {
                        var f, m, g, w = this.particles[n];
                        for (p.set(0, 0, 0), u.set(0, 0, 0), r = (g = this.neighbors[n]).length, h = 0; h !== r; h++) {
                            var x = g[h];
                            w.position.vsub(x.position, v);
                            var b = v.norm();
                            f = -x.mass * (this.pressures[n] / (this.densities[n] * this.densities[n] + o) + this.pressures[h] / (this.densities[h] * this.densities[h] + o)), 
                            this.gradw(v, d), d.mult(f, d), p.vadd(d, p), x.velocity.vsub(w.velocity, y), y.mult(1 / (1e-4 + this.densities[n] * this.densities[h]) * this.viscosity * x.mass, y), 
                            m = this.nablaw(b), y.mult(m, y), u.vadd(y, u);
                        }
                        u.mult(w.mass, u), p.mult(w.mass, p), w.force.vadd(u, w.force), w.force.vadd(p, w.force);
                    }
                }, n.prototype.w = function(t) {
                    var e = this.smoothingRadius;
                    return 315 / (64 * Math.PI * Math.pow(e, 9)) * Math.pow(e * e - t * t, 3);
                }, n.prototype.gradw = function(t, e) {
                    var i = t.norm(), o = this.smoothingRadius;
                    t.mult(945 / (32 * Math.PI * Math.pow(o, 9)) * Math.pow(o * o - i * i, 2), e);
                }, n.prototype.nablaw = function(t) {
                    var e = this.smoothingRadius;
                    return 945 / (32 * Math.PI * Math.pow(e, 9)) * (e * e - t * t) * (7 * t * t - 3 * e * e);
                };
            }, {
                "../material/Material": 26,
                "../math/Quaternion": 29,
                "../math/Vec3": 31,
                "../objects/Body": 32,
                "../shapes/Particle": 42,
                "../shapes/Shape": 44
            } ],
            36: [ function(t, e, i) {
                var o = t("../math/Vec3");
                function n(t, e, i) {
                    i = i || {}, this.restLength = "number" == typeof i.restLength ? i.restLength : 1, 
                    this.stiffness = i.stiffness || 100, this.damping = i.damping || 1, this.bodyA = t, 
                    this.bodyB = e, this.localAnchorA = new o, this.localAnchorB = new o, i.localAnchorA && this.localAnchorA.copy(i.localAnchorA), 
                    i.localAnchorB && this.localAnchorB.copy(i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), 
                    i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
                }
                (e.exports = n).prototype.setWorldAnchorA = function(t) {
                    this.bodyA.pointToLocalFrame(t, this.localAnchorA);
                }, n.prototype.setWorldAnchorB = function(t) {
                    this.bodyB.pointToLocalFrame(t, this.localAnchorB);
                }, n.prototype.getWorldAnchorA = function(t) {
                    this.bodyA.pointToWorldFrame(this.localAnchorA, t);
                }, n.prototype.getWorldAnchorB = function(t) {
                    this.bodyB.pointToWorldFrame(this.localAnchorB, t);
                };
                var m = new o, w = new o, g = new o, x = new o, b = new o, B = new o, E = new o, A = new o, S = new o, z = new o, M = new o;
                n.prototype.applyForce = function() {
                    var t = this.stiffness, e = this.damping, i = this.restLength, o = this.bodyA, n = this.bodyB, s = m, r = w, a = g, h = x, l = M, c = b, p = B, u = E, d = A, v = S, y = z;
                    this.getWorldAnchorA(c), this.getWorldAnchorB(p), c.vsub(o.position, u), p.vsub(n.position, d), 
                    p.vsub(c, s);
                    var f = s.norm();
                    r.copy(s), r.normalize(), n.velocity.vsub(o.velocity, a), n.angularVelocity.cross(d, l), 
                    a.vadd(l, a), o.angularVelocity.cross(u, l), a.vsub(l, a), r.mult(-t * (f - i) - e * a.dot(r), h), 
                    o.force.vsub(h, o.force), n.force.vadd(h, n.force), u.cross(h, v), d.cross(h, y), 
                    o.torque.vsub(v, o.torque), n.torque.vadd(y, n.torque);
                };
            }, {
                "../math/Vec3": 31
            } ],
            37: [ function(t, e, i) {
                var o = t("../math/Vec3"), n = t("../math/Transform"), s = t("../collision/RaycastResult"), r = t("../utils/Utils");
                function a(t) {
                    t = r.defaults(t, {
                        chassisConnectionPointLocal: new o,
                        chassisConnectionPointWorld: new o,
                        directionLocal: new o,
                        directionWorld: new o,
                        axleLocal: new o,
                        axleWorld: new o,
                        suspensionRestLength: 1,
                        suspensionMaxLength: 2,
                        radius: 1,
                        suspensionStiffness: 100,
                        dampingCompression: 10,
                        dampingRelaxation: 10,
                        frictionSlip: 1e4,
                        steering: 0,
                        rotation: 0,
                        deltaRotation: 0,
                        rollInfluence: .01,
                        maxSuspensionForce: Number.MAX_VALUE,
                        isFrontWheel: !0,
                        clippedInvContactDotSuspension: 1,
                        suspensionRelativeVelocity: 0,
                        suspensionForce: 0,
                        skidInfo: 0,
                        suspensionLength: 0,
                        maxSuspensionTravel: 1,
                        useCustomSlidingRotationalSpeed: !1,
                        customSlidingRotationalSpeed: -.1
                    }), this.maxSuspensionTravel = t.maxSuspensionTravel, this.customSlidingRotationalSpeed = t.customSlidingRotationalSpeed, 
                    this.useCustomSlidingRotationalSpeed = t.useCustomSlidingRotationalSpeed, this.sliding = !1, 
                    this.chassisConnectionPointLocal = t.chassisConnectionPointLocal.clone(), this.chassisConnectionPointWorld = t.chassisConnectionPointWorld.clone(), 
                    this.directionLocal = t.directionLocal.clone(), this.directionWorld = t.directionWorld.clone(), 
                    this.axleLocal = t.axleLocal.clone(), this.axleWorld = t.axleWorld.clone(), this.suspensionRestLength = t.suspensionRestLength, 
                    this.suspensionMaxLength = t.suspensionMaxLength, this.radius = t.radius, this.suspensionStiffness = t.suspensionStiffness, 
                    this.dampingCompression = t.dampingCompression, this.dampingRelaxation = t.dampingRelaxation, 
                    this.frictionSlip = t.frictionSlip, this.steering = 0, this.rotation = 0, this.deltaRotation = 0, 
                    this.rollInfluence = t.rollInfluence, this.maxSuspensionForce = t.maxSuspensionForce, 
                    this.engineForce = 0, this.brake = 0, this.isFrontWheel = t.isFrontWheel, this.clippedInvContactDotSuspension = 1, 
                    this.suspensionRelativeVelocity = 0, this.suspensionForce = 0, this.skidInfo = 0, 
                    this.suspensionLength = 0, this.sideImpulse = 0, this.forwardImpulse = 0, this.raycastResult = new s, 
                    this.worldTransform = new n, this.isInContact = !1;
                }
                e.exports = a;
                var h = new o, l = new o;
                h = new o, a.prototype.updateWheel = function(t) {
                    var e = this.raycastResult;
                    if (this.isInContact) {
                        var i = e.hitNormalWorld.dot(e.directionWorld);
                        e.hitPointWorld.vsub(t.position, l), t.getVelocityAtWorldPoint(l, h);
                        var o = e.hitNormalWorld.dot(h);
                        if (-.1 <= i) this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10; else {
                            var n = -1 / i;
                            this.suspensionRelativeVelocity = o * n, this.clippedInvContactDotSuspension = n;
                        }
                    } else e.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, 
                    e.directionWorld.scale(-1, e.hitNormalWorld), this.clippedInvContactDotSuspension = 1;
                };
            }, {
                "../collision/RaycastResult": 11,
                "../math/Transform": 30,
                "../math/Vec3": 31,
                "../utils/Utils": 54
            } ],
            38: [ function(t, e, i) {
                e.exports = n;
                var o = t("./Shape"), r = t("../math/Vec3"), a = t("./ConvexPolyhedron");
                function n(t) {
                    o.call(this, {
                        type: o.types.BOX
                    }), this.halfExtents = t, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), 
                    this.updateBoundingSphereRadius();
                }
                ((n.prototype = new o).constructor = n).prototype.updateConvexPolyhedronRepresentation = function() {
                    var t = this.halfExtents.x, e = this.halfExtents.y, i = this.halfExtents.z, o = r, n = [ new o(-t, -e, -i), new o(t, -e, -i), new o(t, e, -i), new o(-t, e, -i), new o(-t, -e, i), new o(t, -e, i), new o(t, e, i), new o(-t, e, i) ], s = (new o(0, 0, 1), 
                    new o(0, 1, 0), new o(1, 0, 0), new a(n, [ [ 3, 2, 1, 0 ], [ 4, 5, 6, 7 ], [ 5, 4, 0, 1 ], [ 2, 3, 7, 6 ], [ 0, 4, 7, 3 ], [ 1, 2, 6, 5 ] ]));
                    (this.convexPolyhedronRepresentation = s).material = this.material;
                }, n.prototype.calculateLocalInertia = function(t, e) {
                    return e = e || new r, n.calculateInertia(this.halfExtents, t, e), e;
                }, n.calculateInertia = function(t, e, i) {
                    var o = t;
                    o.isZero() ? (i.x = 2 / 12 * e, i.y = 2 / 12 * e, i.z = 2 / 12 * e) : (i.x = 1 / 12 * e * (2 * o.y * 2 * o.y + 2 * o.z * 2 * o.z), 
                    i.y = 1 / 12 * e * (2 * o.x * 2 * o.x + 2 * o.z * 2 * o.z), i.z = 1 / 12 * e * (2 * o.y * 2 * o.y + 2 * o.x * 2 * o.x));
                }, n.prototype.getSideNormals = function(t, e) {
                    var i = t, o = this.halfExtents;
                    if (i[0].set(o.x, 0, 0), i[1].set(0, o.y, 0), i[2].set(0, 0, o.z), i[3].set(-o.x, 0, 0), 
                    i[4].set(0, -o.y, 0), i[5].set(0, 0, -o.z), void 0 !== e) for (var n = 0; n !== i.length; n++) e.vmult(i[n], i[n]);
                    return i;
                }, n.prototype.volume = function() {
                    return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
                }, n.prototype.updateBoundingSphereRadius = function() {
                    this.boundingSphereRadius = this.halfExtents.norm();
                };
                var h = new r;
                new r, n.prototype.forEachWorldCorner = function(t, e, i) {
                    for (var o = this.halfExtents, n = [ [ o.x, o.y, o.z ], [ -o.x, o.y, o.z ], [ -o.x, -o.y, o.z ], [ -o.x, -o.y, -o.z ], [ o.x, -o.y, -o.z ], [ o.x, o.y, -o.z ], [ -o.x, o.y, -o.z ], [ o.x, -o.y, o.z ] ], s = 0; s < n.length; s++) h.set(n[s][0], n[s][1], n[s][2]), 
                    e.vmult(h, h), t.vadd(h, h), i(h.x, h.y, h.z);
                };
                var c = [ new r, new r, new r, new r, new r, new r, new r, new r ];
                n.prototype.calculateWorldAABB = function(t, e, i, o) {
                    var n = this.halfExtents;
                    c[0].set(n.x, n.y, n.z), c[1].set(-n.x, n.y, n.z), c[2].set(-n.x, -n.y, n.z), c[3].set(-n.x, -n.y, -n.z), 
                    c[4].set(n.x, -n.y, -n.z), c[5].set(n.x, n.y, -n.z), c[6].set(-n.x, n.y, -n.z), 
                    c[7].set(n.x, -n.y, n.z);
                    var s = c[0];
                    e.vmult(s, s), t.vadd(s, s), o.copy(s), i.copy(s);
                    for (var r = 1; r < 8; r++) {
                        s = c[r], e.vmult(s, s), t.vadd(s, s);
                        var a = s.x, h = s.y, l = s.z;
                        a > o.x && (o.x = a), h > o.y && (o.y = h), l > o.z && (o.z = l), a < i.x && (i.x = a), 
                        h < i.y && (i.y = h), l < i.z && (i.z = l);
                    }
                };
            }, {
                "../math/Vec3": 31,
                "./ConvexPolyhedron": 39,
                "./Shape": 44
            } ],
            39: [ function(t, e, i) {
                e.exports = u;
                var o = t("./Shape"), x = t("../math/Vec3"), y = (t("../math/Quaternion"), t("../math/Transform"));
                function u(t, e, i) {
                    o.call(this, {
                        type: o.types.CONVEXPOLYHEDRON
                    }), this.vertices = t || [], this.worldVertices = [], this.worldVerticesNeedsUpdate = !0, 
                    this.faces = e || [], this.faceNormals = [], this.computeNormals(), this.worldFaceNormalsNeedsUpdate = !0, 
                    this.worldFaceNormals = [], this.uniqueEdges = [], this.uniqueAxes = i ? i.slice() : null, 
                    this.computeEdges(), this.updateBoundingSphereRadius();
                }
                (u.prototype = new o).constructor = u;
                var p = new x;
                u.prototype.computeEdges = function() {
                    var t = this.faces, e = this.vertices, i = (e.length, this.uniqueEdges);
                    i.length = 0;
                    for (var o = p, n = 0; n !== t.length; n++) for (var s = t[n], r = s.length, a = 0; a !== r; a++) {
                        var h = (a + 1) % r;
                        e[s[a]].vsub(e[s[h]], o), o.normalize();
                        for (var l = !1, c = 0; c !== i.length; c++) if (i[c].almostEquals(o) || i[c].almostEquals(o)) {
                            l = !0;
                            break;
                        }
                        l || i.push(o.clone());
                    }
                }, u.prototype.computeNormals = function() {
                    this.faceNormals.length = this.faces.length;
                    for (var t = 0; t < this.faces.length; t++) {
                        for (var e = 0; e < this.faces[t].length; e++) if (!this.vertices[this.faces[t][e]]) throw new Error("Vertex " + this.faces[t][e] + " not found!");
                        var i = this.faceNormals[t] || new x;
                        this.getFaceNormal(t, i), i.negate(i), this.faceNormals[t] = i;
                        var o = this.vertices[this.faces[t][0]];
                        if (i.dot(o) < 0) for (console.error(".faceNormals[" + t + "] = Vec3(" + i.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule."), 
                        e = 0; e < this.faces[t].length; e++) console.warn(".vertices[" + this.faces[t][e] + "] = Vec3(" + this.vertices[this.faces[t][e]].toString() + ")");
                    }
                };
                var n = new x, s = new x;
                u.computeNormal = function(t, e, i, o) {
                    e.vsub(t, s), i.vsub(e, n), n.cross(s, o), o.isZero() || o.normalize();
                }, u.prototype.getFaceNormal = function(t, e) {
                    var i = this.faces[t], o = this.vertices[i[0]], n = this.vertices[i[1]], s = this.vertices[i[2]];
                    return u.computeNormal(o, n, s, e);
                };
                var b = new x;
                u.prototype.clipAgainstHull = function(t, e, i, o, n, s, r, a, h) {
                    for (var l = b, c = -1, p = -Number.MAX_VALUE, u = 0; u < i.faces.length; u++) {
                        l.copy(i.faceNormals[u]), n.vmult(l, l);
                        var d = l.dot(s);
                        p < d && (p = d, c = u);
                    }
                    for (var v = [], y = i.faces[c], f = y.length, m = 0; m < f; m++) {
                        var w = i.vertices[y[m]], g = new x;
                        g.copy(w), n.vmult(g, g), o.vadd(g, g), v.push(g);
                    }
                    0 <= c && this.clipFaceAgainstHull(s, t, e, v, r, a, h);
                };
                var A = new x, S = new x, z = new x, M = new x, C = new x, q = new x;
                u.prototype.findSeparatingAxis = function(t, e, i, o, n, s, r, a) {
                    var h = A, l = S, c = z, p = M, u = C, d = q, v = Number.MAX_VALUE, y = this;
                    if (y.uniqueAxes) for (m = 0; m !== y.uniqueAxes.length; m++) {
                        if (i.vmult(y.uniqueAxes[m], h), !1 === (x = y.testSepAxis(h, t, e, i, o, n))) return !1;
                        x < v && (v = x, s.copy(h));
                    } else for (var f = r ? r.length : y.faces.length, m = 0; m < f; m++) {
                        var w = r ? r[m] : m;
                        if (h.copy(y.faceNormals[w]), i.vmult(h, h), !1 === (x = y.testSepAxis(h, t, e, i, o, n))) return !1;
                        x < v && (v = x, s.copy(h));
                    }
                    if (t.uniqueAxes) for (m = 0; m !== t.uniqueAxes.length; m++) {
                        if (n.vmult(t.uniqueAxes[m], l), !1 === (x = y.testSepAxis(l, t, e, i, o, n))) return !1;
                        x < v && (v = x, s.copy(l));
                    } else {
                        var g = a ? a.length : t.faces.length;
                        for (m = 0; m < g; m++) {
                            var x;
                            if (w = a ? a[m] : m, l.copy(t.faceNormals[w]), n.vmult(l, l), !1 === (x = y.testSepAxis(l, t, e, i, o, n))) return !1;
                            x < v && (v = x, s.copy(l));
                        }
                    }
                    for (var b = 0; b !== y.uniqueEdges.length; b++) {
                        i.vmult(y.uniqueEdges[b], p);
                        for (var B = 0; B !== t.uniqueEdges.length; B++) if (n.vmult(t.uniqueEdges[B], u), 
                        p.cross(u, d), !d.almostZero()) {
                            d.normalize();
                            var E = y.testSepAxis(d, t, e, i, o, n);
                            if (!1 === E) return !1;
                            E < v && (v = E, s.copy(d));
                        }
                    }
                    return o.vsub(e, c), 0 < c.dot(s) && s.negate(s), !0;
                };
                var d = [], v = [];
                u.prototype.testSepAxis = function(t, e, i, o, n, s) {
                    u.project(this, t, i, o, d), u.project(e, t, n, s, v);
                    var r = d[0], a = d[1], h = v[0], l = v[1];
                    if (r < l || h < a) return !1;
                    var c = r - l, p = h - a;
                    return c < p ? c : p;
                };
                var r = new x, a = new x;
                u.prototype.calculateLocalInertia = function(t, e) {
                    this.computeLocalAABB(r, a);
                    var i = a.x - r.x, o = a.y - r.y, n = a.z - r.z;
                    e.x = 1 / 12 * t * (2 * o * 2 * o + 2 * n * 2 * n), e.y = 1 / 12 * t * (2 * i * 2 * i + 2 * n * 2 * n), 
                    e.z = 1 / 12 * t * (2 * o * 2 * o + 2 * i * 2 * i);
                }, u.prototype.getPlaneConstantOfFace = function(t) {
                    var e = this.faces[t], i = this.faceNormals[t], o = this.vertices[e[0]];
                    return -i.dot(o);
                };
                var I = new x, N = new x, L = new x, W = new x, j = new x, O = new x, k = new x, D = new x;
                u.prototype.clipFaceAgainstHull = function(t, e, i, o, n, s, r) {
                    for (var a = I, h = N, l = L, c = W, p = j, u = O, d = k, v = D, y = this, f = o, m = [], w = -1, g = Number.MAX_VALUE, x = 0; x < y.faces.length; x++) {
                        a.copy(y.faceNormals[x]), i.vmult(a, a);
                        var b = a.dot(t);
                        b < g && (g = b, w = x);
                    }
                    if (!(w < 0)) {
                        var B = y.faces[w];
                        B.connectedFaces = [];
                        for (var E = 0; E < y.faces.length; E++) for (var A = 0; A < y.faces[E].length; A++) -1 !== B.indexOf(y.faces[E][A]) && E !== w && -1 === B.connectedFaces.indexOf(E) && B.connectedFaces.push(E);
                        f.length;
                        for (var S = B.length, z = 0; z < S; z++) {
                            var M = y.vertices[B[z]], C = y.vertices[B[(z + 1) % S]];
                            M.vsub(C, h), l.copy(h), i.vmult(l, l), e.vadd(l, l), c.copy(this.faceNormals[w]), 
                            i.vmult(c, c), e.vadd(c, c), l.cross(c, p), p.negate(p), u.copy(M), i.vmult(u, u), 
                            e.vadd(u, u), u.dot(p);
                            var q = B.connectedFaces[z];
                            d.copy(this.faceNormals[q]);
                            var R = this.getPlaneConstantOfFace(q);
                            v.copy(d), i.vmult(v, v);
                            var F = R - v.dot(e);
                            for (this.clipFaceAgainstPlane(f, m, v, F); f.length; ) f.shift();
                            for (;m.length; ) f.push(m.shift());
                        }
                        for (d.copy(this.faceNormals[w]), R = this.getPlaneConstantOfFace(w), v.copy(d), 
                        i.vmult(v, v), F = R - v.dot(e), E = 0; E < f.length; E++) {
                            var T = v.dot(f[E]) + F;
                            if (T <= n && (T = n), T <= s) {
                                var P = f[E];
                                if (T <= 0) {
                                    var V = {
                                        point: P,
                                        normal: v,
                                        depth: T
                                    };
                                    r.push(V);
                                }
                            }
                        }
                    }
                }, u.prototype.clipFaceAgainstPlane = function(t, e, i, o) {
                    var n, s, r = t.length;
                    if (r < 2) return e;
                    var a = t[t.length - 1], h = t[0];
                    n = i.dot(a) + o;
                    for (var l = 0; l < r; l++) {
                        if (h = t[l], s = i.dot(h) + o, n < 0) if (s < 0) (c = new x).copy(h), e.push(c); else {
                            var c = new x;
                            a.lerp(h, n / (n - s), c), e.push(c);
                        } else s < 0 && (c = new x, a.lerp(h, n / (n - s), c), e.push(c), e.push(h));
                        a = h, n = s;
                    }
                    return e;
                }, u.prototype.computeWorldVertices = function(t, e) {
                    for (var i = this.vertices.length; this.worldVertices.length < i; ) this.worldVertices.push(new x);
                    for (var o = this.vertices, n = this.worldVertices, s = 0; s !== i; s++) e.vmult(o[s], n[s]), 
                    t.vadd(n[s], n[s]);
                    this.worldVerticesNeedsUpdate = !1;
                }, new x, u.prototype.computeLocalAABB = function(t, e) {
                    var i = this.vertices.length, o = this.vertices;
                    t.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), e.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    for (var n = 0; n < i; n++) {
                        var s = o[n];
                        s.x < t.x ? t.x = s.x : s.x > e.x && (e.x = s.x), s.y < t.y ? t.y = s.y : s.y > e.y && (e.y = s.y), 
                        s.z < t.z ? t.z = s.z : s.z > e.z && (e.z = s.z);
                    }
                }, u.prototype.computeWorldFaceNormals = function(t) {
                    for (var e = this.faceNormals.length; this.worldFaceNormals.length < e; ) this.worldFaceNormals.push(new x);
                    for (var i = this.faceNormals, o = this.worldFaceNormals, n = 0; n !== e; n++) t.vmult(i[n], o[n]);
                    this.worldFaceNormalsNeedsUpdate = !1;
                }, u.prototype.updateBoundingSphereRadius = function() {
                    for (var t = 0, e = this.vertices, i = 0, o = e.length; i !== o; i++) {
                        var n = e[i].norm2();
                        t < n && (t = n);
                    }
                    this.boundingSphereRadius = Math.sqrt(t);
                };
                var f = new x;
                u.prototype.calculateWorldAABB = function(t, e, i, o) {
                    for (var n, s, r, a, h, l, c = this.vertices.length, p = this.vertices, u = 0; u < c; u++) f.copy(p[u]), 
                    e.vmult(f, f), t.vadd(f, f), (f.x < n || void 0 === n) && (n = f.x), (f.x > a || void 0 === a) && (a = f.x), 
                    (f.y < s || void 0 === s) && (s = f.y), (f.y > h || void 0 === h) && (h = f.y), 
                    (f.z < r || void 0 === r) && (r = f.z), (f.z > l || void 0 === l) && (l = f.z);
                    i.set(n, s, r), o.set(a, h, l);
                }, u.prototype.volume = function() {
                    return 4 * Math.PI * this.boundingSphereRadius / 3;
                }, u.prototype.getAveragePointLocal = function(t) {
                    t = t || new x;
                    for (var e = this.vertices.length, i = this.vertices, o = 0; o < e; o++) t.vadd(i[o], t);
                    return t.mult(1 / e, t), t;
                }, u.prototype.transformAllPoints = function(t, e) {
                    var i = this.vertices.length, o = this.vertices;
                    if (e) {
                        for (var n = 0; n < i; n++) {
                            var s = o[n];
                            e.vmult(s, s);
                        }
                        for (n = 0; n < this.faceNormals.length; n++) s = this.faceNormals[n], e.vmult(s, s);
                    }
                    if (t) for (n = 0; n < i; n++) (s = o[n]).vadd(t, s);
                };
                var m = new x, w = new x, g = new x;
                u.prototype.pointIsInside = function(t) {
                    var e = this.vertices.length, i = this.vertices, o = this.faces, n = this.faceNormals, s = this.faces.length, r = m;
                    this.getAveragePointLocal(r);
                    for (var a = 0; a < s; a++) {
                        this.faces[a].length, e = n[a];
                        var h = i[o[a][0]], l = w;
                        t.vsub(h, l);
                        var c = e.dot(l), p = g;
                        r.vsub(h, p);
                        var u = e.dot(p);
                        if (c < 0 && 0 < u || 0 < c && u < 0) return !1;
                    }
                    return -1;
                }, new x;
                var B = new x, E = new x;
                u.project = function(t, e, i, o, n) {
                    var s = t.vertices.length, r = B, a = 0, h = 0, l = E, c = t.vertices;
                    l.setZero(), y.vectorToLocalFrame(i, o, e, r), y.pointToLocalFrame(i, o, l, l);
                    var p = l.dot(r);
                    h = a = c[0].dot(r);
                    for (var u = 1; u < s; u++) {
                        var d = c[u].dot(r);
                        a < d && (a = d), d < h && (h = d);
                    }
                    if ((a -= p) < (h -= p)) {
                        var v = h;
                        h = a, a = v;
                    }
                    n[0] = a, n[1] = h;
                };
            }, {
                "../math/Quaternion": 29,
                "../math/Transform": 30,
                "../math/Vec3": 31,
                "./Shape": 44
            } ],
            40: [ function(t, e, i) {
                e.exports = o, t("./Shape");
                var f = t("../math/Vec3"), m = (t("../math/Quaternion"), t("./ConvexPolyhedron"));
                function o(t, e, i, o) {
                    for (var n = o, s = Math.cos, r = Math.sin, a = i / 2, h = [], l = [], c = [ 0 ], p = [ 1 ], u = [], d = 2 * Math.PI / n, v = 0; v < n; v++) h.push(new f(t * Math.cos(d * v), a, t * Math.sin(d * v))), 
                    h.push(new f(t * Math.cos(d * v), -a, t * Math.sin(d * v))), v < n - 1 ? (l.push([ 2 * v + 2, 2 * v + 3, 2 * v + 1, 2 * v ]), 
                    c.push(2 * v + 2), p.push(2 * v + 3)) : l.push([ 0, 1, 2 * v + 1, 2 * v ]), (n % 2 == 1 || v < n / 2) && u.push(new f(s(d * (v + .5)), 0, r(d * (v + .5))));
                    l.push(p);
                    var y = [];
                    for (v = 0; v < c.length; v++) y.push(c[c.length - v - 1]);
                    l.push(y), u.push(new f(0, 1, 0)), m.call(this, h, l, u);
                }
                o.prototype = new m;
            }, {
                "../math/Quaternion": 29,
                "../math/Vec3": 31,
                "./ConvexPolyhedron": 39,
                "./Shape": 44
            } ],
            41: [ function(t, e, i) {
                var o = t("./Shape"), p = t("./ConvexPolyhedron"), u = t("../math/Vec3"), n = t("../utils/Utils");
                function s(t, e) {
                    e = n.defaults(e, {
                        maxValue: null,
                        minValue: null,
                        elementSize: 1
                    }), this.data = t, this.maxValue = e.maxValue, this.minValue = e.minValue, this.elementSize = e.elementSize, 
                    null === e.minValue && this.updateMinValue(), null === e.maxValue && this.updateMaxValue(), 
                    this.cacheEnabled = !0, o.call(this, {
                        type: o.types.HEIGHTFIELD
                    }), this.pillarConvex = new p, this.pillarOffset = new u, this.updateBoundingSphereRadius(), 
                    this._cachedPillars = {};
                }
                ((e.exports = s).prototype = new o).update = function() {
                    this._cachedPillars = {};
                }, s.prototype.updateMinValue = function() {
                    for (var t = this.data, e = t[0][0], i = 0; i !== t.length; i++) for (var o = 0; o !== t[i].length; o++) {
                        var n = t[i][o];
                        n < e && (e = n);
                    }
                    this.minValue = e;
                }, s.prototype.updateMaxValue = function() {
                    for (var t = this.data, e = t[0][0], i = 0; i !== t.length; i++) for (var o = 0; o !== t[i].length; o++) {
                        var n = t[i][o];
                        e < n && (e = n);
                    }
                    this.maxValue = e;
                }, s.prototype.setHeightValueAtIndex = function(t, e, i) {
                    this.data[t][e] = i, this.clearCachedConvexTrianglePillar(t, e, !1), 0 < t && (this.clearCachedConvexTrianglePillar(t - 1, e, !0), 
                    this.clearCachedConvexTrianglePillar(t - 1, e, !1)), 0 < e && (this.clearCachedConvexTrianglePillar(t, e - 1, !0), 
                    this.clearCachedConvexTrianglePillar(t, e - 1, !1)), 0 < e && 0 < t && this.clearCachedConvexTrianglePillar(t - 1, e - 1, !0);
                }, s.prototype.getRectMinMax = function(t, e, i, o, n) {
                    n = n || [];
                    for (var s = this.data, r = this.minValue, a = t; a <= i; a++) for (var h = e; h <= o; h++) {
                        var l = s[a][h];
                        r < l && (r = l);
                    }
                    n[0] = this.minValue, n[1] = r;
                }, s.prototype.getIndexOfPosition = function(t, e, i, o) {
                    var n = this.elementSize, s = this.data, r = Math.floor(t / n), a = Math.floor(e / n);
                    return i[0] = r, i[1] = a, o && (r < 0 && (r = 0), a < 0 && (a = 0), r >= s.length - 1 && (r = s.length - 1), 
                    a >= s[0].length - 1 && (a = s[0].length - 1)), !(r < 0 || a < 0 || r >= s.length - 1 || a >= s[0].length - 1);
                };
                var x = [], b = new u, B = new u, E = new u, A = new u;
                s.prototype.getTriangleAt = function(t, e, i, o, n, s) {
                    var r = x;
                    this.getIndexOfPosition(t, e, r, i);
                    var a = r[0], h = r[1], l = this.data;
                    i && (a = Math.min(l.length - 2, Math.max(0, a)), h = Math.min(l[0].length - 2, Math.max(0, h)));
                    var c = this.elementSize, p = Math.pow(t / c - a, 2) + Math.pow(e / c - h, 2), u = Math.pow(t / c - (a + 1), 2) + Math.pow(e / c - (h + 1), 2) < p;
                    return this.getTriangle(a, h, u, o, n, s), u;
                };
                var l = new u, c = new u, d = new u, v = new u, y = new u;
                s.prototype.getNormalAt = function(t, e, i, o) {
                    var n = l, s = c, r = d, a = v, h = y;
                    this.getTriangleAt(t, e, i, n, s, r), s.vsub(n, a), r.vsub(n, h), a.cross(h, o), 
                    o.normalize();
                }, s.prototype.getAabbAtIndex = function(t, e, i) {
                    var o = this.data, n = this.elementSize;
                    i.lowerBound.set(t * n, e * n, o[t][e]), i.upperBound.set((t + 1) * n, (e + 1) * n, o[t + 1][e + 1]);
                }, s.prototype.getHeightAt = function(t, e, i) {
                    var o = this.data, n = B, s = E, r = A, a = x;
                    this.getIndexOfPosition(t, e, a, i);
                    var h = a[0], l = a[1];
                    i && (h = Math.min(o.length - 2, Math.max(0, h)), l = Math.min(o[0].length - 2, Math.max(0, l)));
                    var c, p, u, d, v, y, f, m, w, g = this.getTriangleAt(t, e, i, n, s, r);
                    return c = t, p = e, u = n.x, d = n.y, v = s.x, y = s.y, f = r.x, m = r.y, (w = b).x = ((y - m) * (c - f) + (f - v) * (p - m)) / ((y - m) * (u - f) + (f - v) * (d - m)), 
                    w.y = ((m - d) * (c - f) + (u - f) * (p - m)) / ((y - m) * (u - f) + (f - v) * (d - m)), 
                    w.z = 1 - w.x - w.y, g ? o[h + 1][l + 1] * b.x + o[h][l + 1] * b.y + o[h + 1][l] * b.z : o[h][l] * b.x + o[h + 1][l] * b.y + o[h][l + 1] * b.z;
                }, s.prototype.getCacheConvexTrianglePillarKey = function(t, e, i) {
                    return t + "_" + e + "_" + (i ? 1 : 0);
                }, s.prototype.getCachedConvexTrianglePillar = function(t, e, i) {
                    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)];
                }, s.prototype.setCachedConvexTrianglePillar = function(t, e, i, o, n) {
                    this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)] = {
                        convex: o,
                        offset: n
                    };
                }, s.prototype.clearCachedConvexTrianglePillar = function(t, e, i) {
                    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)];
                }, s.prototype.getTriangle = function(t, e, i, o, n, s) {
                    var r = this.data, a = this.elementSize;
                    i ? (o.set((t + 1) * a, (e + 1) * a, r[t + 1][e + 1]), n.set(t * a, (e + 1) * a, r[t][e + 1]), 
                    s.set((t + 1) * a, e * a, r[t + 1][e])) : (o.set(t * a, e * a, r[t][e]), n.set((t + 1) * a, e * a, r[t + 1][e]), 
                    s.set(t * a, (e + 1) * a, r[t][e + 1]));
                }, s.prototype.getConvexTrianglePillar = function(t, e, i) {
                    var o = this.pillarConvex, n = this.pillarOffset;
                    if (this.cacheEnabled) {
                        if (s = this.getCachedConvexTrianglePillar(t, e, i)) return this.pillarConvex = s.convex, 
                        void (this.pillarOffset = s.offset);
                        o = new p, n = new u, this.pillarConvex = o, this.pillarOffset = n;
                    }
                    var s = this.data, r = this.elementSize, a = o.faces;
                    o.vertices.length = 6;
                    for (var h = 0; h < 6; h++) o.vertices[h] || (o.vertices[h] = new u);
                    for (a.length = 5, h = 0; h < 5; h++) a[h] || (a[h] = []);
                    var l = o.vertices, c = (Math.min(s[t][e], s[t + 1][e], s[t][e + 1], s[t + 1][e + 1]) - this.minValue) / 2 + this.minValue;
                    i ? (n.set((t + .75) * r, (e + .75) * r, c), l[0].set(.25 * r, .25 * r, s[t + 1][e + 1] - c), 
                    l[1].set(-.75 * r, .25 * r, s[t][e + 1] - c), l[2].set(.25 * r, -.75 * r, s[t + 1][e] - c), 
                    l[3].set(.25 * r, .25 * r, -c - 1), l[4].set(-.75 * r, .25 * r, -c - 1), l[5].set(.25 * r, -.75 * r, -c - 1), 
                    a[0][0] = 0, a[0][1] = 1, a[0][2] = 2, a[1][0] = 5, a[1][1] = 4, a[1][2] = 3, a[2][0] = 2, 
                    a[2][1] = 5, a[2][2] = 3, a[2][3] = 0, a[3][0] = 3, a[3][1] = 4, a[3][2] = 1, a[3][3] = 0, 
                    a[4][0] = 1, a[4][1] = 4, a[4][2] = 5, a[4][3] = 2) : (n.set((t + .25) * r, (e + .25) * r, c), 
                    l[0].set(-.25 * r, -.25 * r, s[t][e] - c), l[1].set(.75 * r, -.25 * r, s[t + 1][e] - c), 
                    l[2].set(-.25 * r, .75 * r, s[t][e + 1] - c), l[3].set(-.25 * r, -.25 * r, -c - 1), 
                    l[4].set(.75 * r, -.25 * r, -c - 1), l[5].set(-.25 * r, .75 * r, -c - 1), a[0][0] = 0, 
                    a[0][1] = 1, a[0][2] = 2, a[1][0] = 5, a[1][1] = 4, a[1][2] = 3, a[2][0] = 0, a[2][1] = 2, 
                    a[2][2] = 5, a[2][3] = 3, a[3][0] = 1, a[3][1] = 0, a[3][2] = 3, a[3][3] = 4, a[4][0] = 4, 
                    a[4][1] = 5, a[4][2] = 2, a[4][3] = 1), o.computeNormals(), o.computeEdges(), o.updateBoundingSphereRadius(), 
                    this.setCachedConvexTrianglePillar(t, e, i, o, n);
                }, s.prototype.calculateLocalInertia = function(t, e) {
                    return (e = e || new u).set(0, 0, 0), e;
                }, s.prototype.volume = function() {
                    return Number.MAX_VALUE;
                }, s.prototype.calculateWorldAABB = function(t, e, i, o) {
                    i.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), o.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                }, s.prototype.updateBoundingSphereRadius = function() {
                    var t = this.data, e = this.elementSize;
                    this.boundingSphereRadius = new u(t.length * e, t[0].length * e, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
                }, s.prototype.setHeightsFromImage = function(t, e) {
                    var i = document.createElement("canvas");
                    i.width = t.width, i.height = t.height;
                    var o = i.getContext("2d");
                    o.drawImage(t, 0, 0);
                    var n = o.getImageData(0, 0, t.width, t.height), s = this.data;
                    s.length = 0, this.elementSize = Math.abs(e.x) / n.width;
                    for (var r = 0; r < n.height; r++) {
                        for (var a = [], h = 0; h < n.width; h++) {
                            var l = (n.data[4 * (r * n.height + h)] + n.data[4 * (r * n.height + h) + 1] + n.data[4 * (r * n.height + h) + 2]) / 4 / 255 * e.z;
                            e.x < 0 ? a.push(l) : a.unshift(l);
                        }
                        e.y < 0 ? s.unshift(a) : s.push(a);
                    }
                    this.updateMaxValue(), this.updateMinValue(), this.update();
                };
            }, {
                "../math/Vec3": 31,
                "../utils/Utils": 54,
                "./ConvexPolyhedron": 39,
                "./Shape": 44
            } ],
            42: [ function(t, e, i) {
                e.exports = s;
                var o = t("./Shape"), n = t("../math/Vec3");
                function s() {
                    o.call(this, {
                        type: o.types.PARTICLE
                    });
                }
                ((s.prototype = new o).constructor = s).prototype.calculateLocalInertia = function(t, e) {
                    return (e = e || new n).set(0, 0, 0), e;
                }, s.prototype.volume = function() {
                    return 0;
                }, s.prototype.updateBoundingSphereRadius = function() {
                    this.boundingSphereRadius = 0;
                }, s.prototype.calculateWorldAABB = function(t, e, i, o) {
                    i.copy(t), o.copy(t);
                };
            }, {
                "../math/Vec3": 31,
                "./Shape": 44
            } ],
            43: [ function(t, e, i) {
                e.exports = s;
                var o = t("./Shape"), n = t("../math/Vec3");
                function s() {
                    o.call(this, {
                        type: o.types.PLANE
                    }), this.worldNormal = new n, this.worldNormalNeedsUpdate = !0, this.boundingSphereRadius = Number.MAX_VALUE;
                }
                ((s.prototype = new o).constructor = s).prototype.computeWorldNormal = function(t) {
                    var e = this.worldNormal;
                    e.set(0, 0, 1), t.vmult(e, e), this.worldNormalNeedsUpdate = !1;
                }, s.prototype.calculateLocalInertia = function(t, e) {
                    return e || new n;
                }, s.prototype.volume = function() {
                    return Number.MAX_VALUE;
                };
                var r = new n;
                s.prototype.calculateWorldAABB = function(t, e, i, o) {
                    r.set(0, 0, 1), e.vmult(r, r);
                    var n = Number.MAX_VALUE;
                    i.set(-n, -n, -n), o.set(n, n, n), 1 === r.x && (o.x = t.x), 1 === r.y && (o.y = t.y), 
                    1 === r.z && (o.z = t.z), -1 === r.x && (i.x = t.x), -1 === r.y && (i.y = t.y), 
                    -1 === r.z && (i.z = t.z);
                }, s.prototype.updateBoundingSphereRadius = function() {
                    this.boundingSphereRadius = Number.MAX_VALUE;
                };
            }, {
                "../math/Vec3": 31,
                "./Shape": 44
            } ],
            44: [ function(t, e, i) {
                e.exports = n;
                var o = t("../utils/EventTarget"), n = t("./Shape");
                function n(t) {
                    t = t || {}, o.apply(this), this.id = n.idCounter++, this.type = t.type || 0, this.boundingSphereRadius = 0, 
                    this.collisionResponse = !t.collisionResponse || t.collisionResponse, this.collisionFilterGroup = void 0 !== t.collisionFilterGroup ? t.collisionFilterGroup : 1, 
                    this.collisionFilterMask = void 0 !== t.collisionFilterMask ? t.collisionFilterMask : -1, 
                    this.material = t.material ? t.material : null, this.body = null;
                }
                t("../math/Vec3"), t("../math/Quaternion"), t("../material/Material"), n.prototype = new o, 
                (n.prototype.constructor = n).prototype.updateBoundingSphereRadius = function() {
                    throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
                }, n.prototype.volume = function() {
                    throw "volume() not implemented for shape type " + this.type;
                }, n.prototype.calculateLocalInertia = function(t, e) {
                    throw "calculateLocalInertia() not implemented for shape type " + this.type;
                }, n.idCounter = 0, n.types = {
                    SPHERE: 1,
                    PLANE: 2,
                    BOX: 4,
                    COMPOUND: 8,
                    CONVEXPOLYHEDRON: 16,
                    HEIGHTFIELD: 32,
                    PARTICLE: 64,
                    CYLINDER: 128,
                    TRIMESH: 256
                };
            }, {
                "../material/Material": 26,
                "../math/Quaternion": 29,
                "../math/Vec3": 31,
                "../utils/EventTarget": 50,
                "./Shape": 44
            } ],
            45: [ function(t, e, i) {
                e.exports = s;
                var o = t("./Shape"), n = t("../math/Vec3");
                function s(t) {
                    if (o.call(this, {
                        type: o.types.SPHERE
                    }), this.radius = void 0 !== t ? t : 1, this.radius < 0) throw new Error("The sphere radius cannot be negative.");
                    this.updateBoundingSphereRadius();
                }
                ((s.prototype = new o).constructor = s).prototype.calculateLocalInertia = function(t, e) {
                    e = e || new n;
                    var i = 2 * t * this.radius * this.radius / 5;
                    return e.x = i, e.y = i, e.z = i, e;
                }, s.prototype.volume = function() {
                    return 4 * Math.PI * this.radius / 3;
                }, s.prototype.updateBoundingSphereRadius = function() {
                    this.boundingSphereRadius = this.radius;
                }, s.prototype.calculateWorldAABB = function(t, e, i, o) {
                    for (var n = this.radius, s = [ "x", "y", "z" ], r = 0; r < s.length; r++) {
                        var a = s[r];
                        i[a] = t[a] - n, o[a] = t[a] + n;
                    }
                };
            }, {
                "../math/Vec3": 31,
                "./Shape": 44
            } ],
            46: [ function(t, e, i) {
                e.exports = w;
                var o = t("./Shape"), l = t("../math/Vec3"), n = (t("../math/Quaternion"), t("../math/Transform")), c = t("../collision/AABB"), s = t("../utils/Octree");
                function w(t, e) {
                    o.call(this, {
                        type: o.types.TRIMESH
                    }), this.vertices = new Float32Array(t), this.indices = new Int16Array(e), this.normals = new Float32Array(e.length), 
                    this.aabb = new c, this.edges = null, this.scale = new l(1, 1, 1), this.tree = new s, 
                    this.updateEdges(), this.updateNormals(), this.updateAABB(), this.updateBoundingSphereRadius(), 
                    this.updateTree();
                }
                (w.prototype = new o).constructor = w;
                var a = new l;
                w.prototype.updateTree = function() {
                    var t = this.tree;
                    t.reset(), t.aabb.copy(this.aabb);
                    var e = this.scale;
                    t.aabb.lowerBound.x *= 1 / e.x, t.aabb.lowerBound.y *= 1 / e.y, t.aabb.lowerBound.z *= 1 / e.z, 
                    t.aabb.upperBound.x *= 1 / e.x, t.aabb.upperBound.y *= 1 / e.y, t.aabb.upperBound.z *= 1 / e.z;
                    for (var i = new c, o = new l, n = new l, s = new l, r = [ o, n, s ], a = 0; a < this.indices.length / 3; a++) {
                        var h = 3 * a;
                        this._getUnscaledVertex(this.indices[h], o), this._getUnscaledVertex(this.indices[1 + h], n), 
                        this._getUnscaledVertex(this.indices[2 + h], s), i.setFromPoints(r), t.insert(i, a);
                    }
                    t.removeEmptyNodes();
                };
                var h = new c;
                w.prototype.getTrianglesInAABB = function(t, e) {
                    h.copy(t);
                    var i = this.scale, o = i.x, n = i.y, s = i.z, r = h.lowerBound, a = h.upperBound;
                    return r.x /= o, r.y /= n, r.z /= s, a.x /= o, a.y /= n, a.z /= s, this.tree.aabbQuery(h, e);
                }, w.prototype.setScale = function(t) {
                    var e = this.scale.x === this.scale.y === this.scale.z, i = t.x === t.y === t.z;
                    e && i || this.updateNormals(), this.scale.copy(t), this.updateAABB(), this.updateBoundingSphereRadius();
                }, w.prototype.updateNormals = function() {
                    for (var t = a, e = this.normals, i = 0; i < this.indices.length / 3; i++) {
                        var o = 3 * i, n = this.indices[o], s = this.indices[1 + o], r = this.indices[2 + o];
                        this.getVertex(n, v), this.getVertex(s, y), this.getVertex(r, f), w.computeNormal(y, v, f, t), 
                        e[o] = t.x, e[1 + o] = t.y, e[2 + o] = t.z;
                    }
                }, w.prototype.updateEdges = function() {
                    function t(t, e) {
                        i[n < s ? n + "_" + s : s + "_" + n] = !0;
                    }
                    for (var i = {}, e = 0; e < this.indices.length / 3; e++) {
                        var o = 3 * e, n = this.indices[o], s = this.indices[1 + o];
                        this.indices[2 + o], t(), t(), t();
                    }
                    var r = Object.keys(i);
                    for (this.edges = new Int16Array(2 * r.length), e = 0; e < r.length; e++) {
                        var a = r[e].split("_");
                        this.edges[2 * e] = parseInt(a[0], 10), this.edges[2 * e + 1] = parseInt(a[1], 10);
                    }
                }, w.prototype.getEdgeVertex = function(t, e, i) {
                    var o = this.edges[2 * t + (e ? 1 : 0)];
                    this.getVertex(o, i);
                };
                var r = new l, p = new l;
                w.prototype.getEdgeVector = function(t, e) {
                    var i = r, o = p;
                    this.getEdgeVertex(t, 0, i), this.getEdgeVertex(t, 1, o), o.vsub(i, e);
                };
                var u = new l, d = new l;
                w.computeNormal = function(t, e, i, o) {
                    e.vsub(t, d), i.vsub(e, u), u.cross(d, o), o.isZero() || o.normalize();
                };
                var v = new l, y = new l, f = new l;
                w.prototype.getVertex = function(t, e) {
                    var i = this.scale;
                    return this._getUnscaledVertex(t, e), e.x *= i.x, e.y *= i.y, e.z *= i.z, e;
                }, w.prototype._getUnscaledVertex = function(t, e) {
                    var i = 3 * t, o = this.vertices;
                    return e.set(o[i], o[1 + i], o[2 + i]);
                }, w.prototype.getWorldVertex = function(t, e, i, o) {
                    return this.getVertex(t, o), n.pointToWorldFrame(e, i, o, o), o;
                }, w.prototype.getTriangleVertices = function(t, e, i, o) {
                    var n = 3 * t;
                    this.getVertex(this.indices[n], e), this.getVertex(this.indices[1 + n], i), this.getVertex(this.indices[2 + n], o);
                }, w.prototype.getNormal = function(t, e) {
                    var i = 3 * t;
                    return e.set(this.normals[i], this.normals[1 + i], this.normals[2 + i]);
                };
                var m = new c;
                w.prototype.calculateLocalInertia = function(t, e) {
                    this.computeLocalAABB(m);
                    var i = m.upperBound.x - m.lowerBound.x, o = m.upperBound.y - m.lowerBound.y, n = m.upperBound.z - m.lowerBound.z;
                    return e.set(1 / 12 * t * (2 * o * 2 * o + 2 * n * 2 * n), 1 / 12 * t * (2 * i * 2 * i + 2 * n * 2 * n), 1 / 12 * t * (2 * o * 2 * o + 2 * i * 2 * i));
                };
                var g = new l;
                w.prototype.computeLocalAABB = function(t) {
                    var e = t.lowerBound, i = t.upperBound, o = this.vertices.length, n = (this.vertices, 
                    g);
                    this.getVertex(0, n), e.copy(n), i.copy(n);
                    for (var s = 0; s !== o; s++) this.getVertex(s, n), n.x < e.x ? e.x = n.x : n.x > i.x && (i.x = n.x), 
                    n.y < e.y ? e.y = n.y : n.y > i.y && (i.y = n.y), n.z < e.z ? e.z = n.z : n.z > i.z && (i.z = n.z);
                }, w.prototype.updateAABB = function() {
                    this.computeLocalAABB(this.aabb);
                }, w.prototype.updateBoundingSphereRadius = function() {
                    for (var t = 0, e = this.vertices, i = new l, o = 0, n = e.length / 3; o !== n; o++) {
                        this.getVertex(o, i);
                        var s = i.norm2();
                        t < s && (t = s);
                    }
                    this.boundingSphereRadius = Math.sqrt(t);
                }, new l;
                var x = new n, b = new c;
                w.prototype.calculateWorldAABB = function(t, e, i, o) {
                    var n = x, s = b;
                    n.position = t, n.quaternion = e, this.aabb.toWorldFrame(n, s), i.copy(s.lowerBound), 
                    o.copy(s.upperBound);
                }, w.prototype.volume = function() {
                    return 4 * Math.PI * this.boundingSphereRadius / 3;
                }, w.createTorus = function(t, e, i, o, n) {
                    t = t || 1, e = e || .5, i = i || 8, o = o || 6, n = n || 2 * Math.PI;
                    for (var s = [], r = [], a = 0; a <= i; a++) for (var h = 0; h <= o; h++) {
                        var l = h / o * n, c = a / i * Math.PI * 2, p = (t + e * Math.cos(c)) * Math.cos(l), u = (t + e * Math.cos(c)) * Math.sin(l), d = e * Math.sin(c);
                        s.push(p, u, d);
                    }
                    for (a = 1; a <= i; a++) for (h = 1; h <= o; h++) {
                        var v = (o + 1) * a + h - 1, y = (o + 1) * (a - 1) + h - 1, f = (o + 1) * (a - 1) + h, m = (o + 1) * a + h;
                        r.push(v, y, m), r.push(y, f, m);
                    }
                    return new w(s, r);
                };
            }, {
                "../collision/AABB": 3,
                "../math/Quaternion": 29,
                "../math/Transform": 30,
                "../math/Vec3": 31,
                "../utils/Octree": 51,
                "./Shape": 44
            } ],
            47: [ function(t, e, i) {
                e.exports = n, t("../math/Vec3"), t("../math/Quaternion");
                var o = t("./Solver");
                function n() {
                    o.call(this), this.iterations = 10, this.tolerance = 1e-7;
                }
                n.prototype = new o;
                var C = [], q = [], R = [];
                n.prototype.solve = function(t, e) {
                    var i, o, n, s, r, a = 0, h = this.iterations, l = this.tolerance * this.tolerance, c = this.equations, p = c.length, u = e.bodies, d = u.length, v = t;
                    if (0 !== p) for (var y = 0; y !== d; y++) u[y].updateSolveMassProperties();
                    var f = q, m = R, w = C;
                    for (f.length = p, m.length = p, w.length = p, y = 0; y !== p; y++) {
                        var g = c[y];
                        w[y] = 0, m[y] = g.computeB(v), f[y] = 1 / g.computeC();
                    }
                    if (0 !== p) {
                        for (y = 0; y !== d; y++) {
                            var x = (E = u[y]).vlambda, b = E.wlambda;
                            x.set(0, 0, 0), b.set(0, 0, 0);
                        }
                        for (a = 0; a !== h; a++) {
                            for (var B = s = 0; B !== p; B++) g = c[B], i = m[B], o = f[B], (r = w[B]) + (n = o * (i - g.computeGWlambda() - g.eps * r)) < g.minForce ? n = g.minForce - r : r + n > g.maxForce && (n = g.maxForce - r), 
                            w[B] += n, s += 0 < n ? n : -n, g.addToWlambda(n);
                            if (s * s < l) break;
                        }
                        for (y = 0; y !== d; y++) {
                            var E, A = (E = u[y]).velocity, S = E.angularVelocity;
                            E.vlambda.vmul(E.linearFactor, E.vlambda), A.vadd(E.vlambda, A), E.wlambda.vmul(E.angularFactor, E.wlambda), 
                            S.vadd(E.wlambda, S);
                        }
                        for (var z = c.length, M = 1 / v; z--; ) c[z].multiplier = w[z] * M;
                    }
                    return a;
                };
            }, {
                "../math/Quaternion": 29,
                "../math/Vec3": 31,
                "./Solver": 48
            } ],
            48: [ function(t, e, i) {
                function o() {
                    this.equations = [];
                }
                (e.exports = o).prototype.solve = function(t, e) {
                    return 0;
                }, o.prototype.addEquation = function(t) {
                    t.enabled && this.equations.push(t);
                }, o.prototype.removeEquation = function(t) {
                    var e = this.equations, i = e.indexOf(t);
                    -1 !== i && e.splice(i, 1);
                }, o.prototype.removeAllEquations = function() {
                    this.equations.length = 0;
                };
            }, {} ],
            49: [ function(t, e, i) {
                e.exports = s, t("../math/Vec3"), t("../math/Quaternion");
                var o = t("./Solver"), n = t("../objects/Body");
                function s(t) {
                    for (o.call(this), this.iterations = 10, this.tolerance = 1e-7, this.subsolver = t, 
                    this.nodes = [], this.nodePool = []; this.nodePool.length < 128; ) this.nodePool.push(this.createNode());
                }
                s.prototype = new o;
                var b = [], B = [], E = {
                    bodies: []
                }, r = n.STATIC;
                function A(t) {
                    for (var e = t.length, i = 0; i !== e; i++) {
                        var o = t[i];
                        if (!(o.visited || o.body.type & r)) return o;
                    }
                    return !1;
                }
                var a = [];
                function S(t, e, i, o) {
                    for (a.push(t), t.visited = !0, e(t, i, o); a.length; ) for (var n, s = a.pop(); n = A(s.children); ) n.visited = !0, 
                    e(n, i, o), a.push(n);
                }
                function z(t, e, i) {
                    e.push(t.body);
                    for (var o = t.eqs.length, n = 0; n !== o; n++) {
                        var s = t.eqs[n];
                        -1 === i.indexOf(s) && i.push(s);
                    }
                }
                function M(t, e) {
                    return e.id - t.id;
                }
                s.prototype.createNode = function() {
                    return {
                        body: null,
                        children: [],
                        eqs: [],
                        visited: !1
                    };
                }, s.prototype.solve = function(t, e) {
                    for (var i = b, o = this.nodePool, n = e.bodies, s = this.equations, r = s.length, a = n.length, h = this.subsolver; o.length < a; ) o.push(this.createNode());
                    i.length = a;
                    for (var l = 0; l < a; l++) i[l] = o[l];
                    for (l = 0; l !== a; l++) {
                        var c = i[l];
                        c.body = n[l], c.children.length = 0, c.eqs.length = 0, c.visited = !1;
                    }
                    for (var p = 0; p !== r; p++) {
                        var u = s[p], d = (l = n.indexOf(u.bi), n.indexOf(u.bj)), v = i[l], y = i[d];
                        v.children.push(y), v.eqs.push(u), y.children.push(v), y.eqs.push(u);
                    }
                    var f, m = 0, w = B;
                    h.tolerance = this.tolerance, h.iterations = this.iterations;
                    for (var g = E; f = A(i); ) {
                        w.length = 0, g.bodies.length = 0, S(f, z, g.bodies, w);
                        var x = w.length;
                        for (w = w.sort(M), l = 0; l !== x; l++) h.addEquation(w[l]);
                        h.solve(t, g), h.removeAllEquations(), m++;
                    }
                    return m;
                };
            }, {
                "../math/Quaternion": 29,
                "../math/Vec3": 31,
                "../objects/Body": 32,
                "./Solver": 48
            } ],
            50: [ function(t, e, i) {
                function o() {}
                (e.exports = o).prototype = {
                    constructor: o,
                    addEventListener: function(t, e) {
                        void 0 === this._listeners && (this._listeners = {});
                        var i = this._listeners;
                        return void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e), this;
                    },
                    hasEventListener: function(t, e) {
                        if (void 0 === this._listeners) return !1;
                        var i = this._listeners;
                        return void 0 !== i[t] && -1 !== i[t].indexOf(e);
                    },
                    hasAnyEventListener: function(t) {
                        return void 0 !== this._listeners && void 0 !== this._listeners[t];
                    },
                    removeEventListener: function(t, e) {
                        if (void 0 === this._listeners) return this;
                        var i = this._listeners;
                        if (void 0 === i[t]) return this;
                        var o = i[t].indexOf(e);
                        return -1 !== o && i[t].splice(o, 1), this;
                    },
                    dispatchEvent: function(t) {
                        if (void 0 === this._listeners) return this;
                        var e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            for (var i = 0, o = e.length; i < o; i++) e[i].call(this, t);
                        }
                        return this;
                    }
                };
            }, {} ],
            51: [ function(t, e, i) {
                var h = t("../collision/AABB"), l = t("../math/Vec3");
                function c(t) {
                    t = t || {}, this.root = t.root || null, this.aabb = t.aabb ? t.aabb.clone() : new h, 
                    this.data = [], this.children = [];
                }
                (e.exports = function o(t, e) {
                    (e = e || {}).root = null, e.aabb = t, c.call(this, e), this.maxDepth = void 0 !== e.maxDepth ? e.maxDepth : 8;
                }).prototype = new c, c.prototype.reset = function(t, e) {
                    this.children.length = this.data.length = 0;
                }, c.prototype.insert = function(t, e, i) {
                    var o = this.data;
                    if (i = i || 0, !this.aabb.contains(t)) return !1;
                    var n = this.children;
                    if (i < (this.maxDepth || this.root.maxDepth)) {
                        var s = !1;
                        n.length || (this.subdivide(), s = !0);
                        for (var r = 0; 8 !== r; r++) if (n[r].insert(t, e, i + 1)) return !0;
                        s && (n.length = 0);
                    }
                    return o.push(e), !0;
                };
                var p = new l;
                c.prototype.subdivide = function() {
                    var t = this.aabb, e = t.lowerBound, i = t.upperBound, o = this.children;
                    o.push(new c({
                        aabb: new h({
                            lowerBound: new l(0, 0, 0)
                        })
                    }), new c({
                        aabb: new h({
                            lowerBound: new l(1, 0, 0)
                        })
                    }), new c({
                        aabb: new h({
                            lowerBound: new l(1, 1, 0)
                        })
                    }), new c({
                        aabb: new h({
                            lowerBound: new l(1, 1, 1)
                        })
                    }), new c({
                        aabb: new h({
                            lowerBound: new l(0, 1, 1)
                        })
                    }), new c({
                        aabb: new h({
                            lowerBound: new l(0, 0, 1)
                        })
                    }), new c({
                        aabb: new h({
                            lowerBound: new l(1, 0, 1)
                        })
                    }), new c({
                        aabb: new h({
                            lowerBound: new l(0, 1, 0)
                        })
                    })), i.vsub(e, p), p.scale(.5, p);
                    for (var n = this.root || this, s = 0; 8 !== s; s++) {
                        var r = o[s];
                        r.root = n;
                        var a = r.aabb.lowerBound;
                        a.x *= p.x, a.y *= p.y, a.z *= p.z, a.vadd(e, a), a.vadd(p, r.aabb.upperBound);
                    }
                }, c.prototype.aabbQuery = function(t, e) {
                    this.data, this.children;
                    for (var i = [ this ]; i.length; ) {
                        var o = i.pop();
                        o.aabb.overlaps(t) && Array.prototype.push.apply(e, o.data), Array.prototype.push.apply(i, o.children);
                    }
                    return e;
                };
                var n = new h;
                c.prototype.rayQuery = function(t, e, i) {
                    return t.getAABB(n), n.toLocalFrame(e, n), this.aabbQuery(n, i), i;
                }, c.prototype.removeEmptyNodes = function() {
                    for (var t = this.children.length - 1; 0 <= t; t--) this.children[t].removeEmptyNodes(), 
                    this.children[t].children.length || this.children[t].data.length || this.children.splice(t, 1);
                };
            }, {
                "../collision/AABB": 3,
                "../math/Vec3": 31
            } ],
            52: [ function(t, e, i) {
                function o() {
                    this.objects = [], this.type = Object;
                }
                (e.exports = o).prototype.release = function() {
                    for (var t = arguments.length, e = 0; e !== t; e++) this.objects.push(arguments[e]);
                    return this;
                }, o.prototype.get = function() {
                    return 0 === this.objects.length ? this.constructObject() : this.objects.pop();
                }, o.prototype.constructObject = function() {
                    throw new Error("constructObject() not implemented in this Pool subclass yet!");
                }, o.prototype.resize = function(t) {
                    for (var e = this.objects; e.length > t; ) e.pop();
                    for (;e.length < t; ) e.push(this.constructObject());
                    return this;
                };
            }, {} ],
            53: [ function(t, e, i) {
                function o() {
                    this.data = {
                        keys: []
                    };
                }
                (e.exports = o).prototype.get = function(t, e) {
                    if (e < t) {
                        var i = e;
                        e = t, t = i;
                    }
                    return this.data[t + "-" + e];
                }, o.prototype.set = function(t, e, i) {
                    if (e < t) {
                        var o = e;
                        e = t, t = o;
                    }
                    var n = t + "-" + e;
                    return this.get(t, e) || this.data.keys.push(n), this.data[n] = i, this.data[n];
                }, o.prototype.del = function(t, e) {
                    if (e < t) {
                        var i = e;
                        e = t, t = i;
                    }
                    var o = t + "-" + e, n = this.data.keys.indexOf(o);
                    return 0 <= n && (this.data.keys.splice(n, 1), delete this.data[o], !0);
                }, o.prototype.reset = function() {
                    this.data = {
                        keys: []
                    };
                }, o.prototype.getLength = function() {
                    return this.data.keys.length;
                }, o.prototype.getKeyByIndex = function(t) {
                    return this.data.keys[t];
                }, o.prototype.getDataByKey = function(t) {
                    return this.data[t];
                };
            }, {} ],
            54: [ function(t, e, i) {
                (e.exports = function o() {}).defaults = function(t, e) {
                    for (var i in t = t || {}, e) i in t || (t[i] = e[i]);
                    return t;
                };
            }, {} ],
            55: [ function(t, e, i) {
                e.exports = s;
                var o = t("../math/Vec3"), n = t("./Pool");
                function s() {
                    n.call(this), this.type = o;
                }
                (s.prototype = new n).constructObject = function() {
                    return new o;
                };
            }, {
                "../math/Vec3": 31,
                "./Pool": 52
            } ],
            56: [ function(t, e, i) {
                e.exports = a;
                var o = t("../collision/AABB"), A = t("../objects/Body"), n = t("../shapes/Shape"), I = t("../collision/Ray"), w = t("../math/Vec3"), N = t("../math/Transform"), s = (t("../shapes/ConvexPolyhedron"), 
                t("../math/Quaternion")), r = (t("../solver/Solver"), t("../utils/Vec3Pool")), c = t("../equations/ContactEquation"), f = t("../equations/FrictionEquation");
                function a(t) {
                    this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], 
                    this.v3pool = new r, this.world = t, this.currentContactMaterial = null, this.enableFrictionReduction = !1;
                }
                a.prototype.createContactEquation = function(t, e, i, o, n, s) {
                    var r;
                    this.contactPointPool.length ? ((r = this.contactPointPool.pop()).bi = t, r.bj = e) : r = new c(t, e);
                    var a = this.currentContactMaterial;
                    r.restitution = a.restitution, r.setSpookParams(a.contactEquationStiffness, a.contactEquationRelaxation, this.world.dt);
                    var h = i.material || t.material, l = o.material || e.material;
                    return h && l && 0 <= h.restitution && 0 <= l.restitution && (r.restitution = h.restitution * l.restitution), 
                    r.si = n || i, r.sj = s || o, r;
                }, a.prototype.createFrictionEquationsFromContact = function(t, e) {
                    var i = t.bi, o = t.bj, n = t.si, s = t.sj, r = this.world, a = this.currentContactMaterial, h = a.friction, l = n.material || i.material, c = s.material || o.material;
                    if (l && c && 0 <= l.friction && 0 <= c.friction && (h = l.friction * c.friction), 
                    0 < h) {
                        var p = h * r.gravity.length(), u = i.invMass + o.invMass;
                        0 < u && (u = 1 / u);
                        var d = this.frictionEquationPool, v = d.length ? d.pop() : new f(i, o, p * u), y = d.length ? d.pop() : new f(i, o, p * u);
                        return v.bi = y.bi = i, v.bj = y.bj = o, v.minForce = y.minForce = -p * u, v.maxForce = y.maxForce = p * u, 
                        v.ri.copy(t.ri), v.rj.copy(t.rj), y.ri.copy(t.ri), y.rj.copy(t.rj), t.ni.tangents(v.t, y.t), 
                        v.setSpookParams(a.frictionEquationStiffness, a.frictionEquationRelaxation, r.dt), 
                        y.setSpookParams(a.frictionEquationStiffness, a.frictionEquationRelaxation, r.dt), 
                        v.enabled = y.enabled = t.enabled, e.push(v, y), !0;
                    }
                    return !1;
                };
                var h = new w, l = new w, p = new w;
                a.prototype.createFrictionFromAverage = function(t) {
                    var e = this.result[this.result.length - 1];
                    if (this.createFrictionEquationsFromContact(e, this.frictionResult) && 1 !== t) {
                        var i = this.frictionResult[this.frictionResult.length - 2], o = this.frictionResult[this.frictionResult.length - 1];
                        h.setZero(), l.setZero(), p.setZero();
                        for (var n = e.bi, s = (e.bj, 0); s !== t; s++) (e = this.result[this.result.length - 1 - s]).bodyA !== n ? (h.vadd(e.ni, h), 
                        l.vadd(e.ri, l), p.vadd(e.rj, p)) : (h.vsub(e.ni, h), l.vadd(e.rj, l), p.vadd(e.ri, p));
                        var r = 1 / t;
                        l.scale(r, i.ri), p.scale(r, i.rj), o.ri.copy(i.ri), o.rj.copy(i.rj), h.normalize(), 
                        h.tangents(i.t, o.t);
                    }
                };
                var S = new w, z = new w, M = new s, C = new s;
                a.prototype.getContacts = function(t, e, i, o, n, s, r) {
                    this.frictionEquationPool = r, this.result = o, this.frictionResult = s;
                    for (var a = M, h = C, l = S, c = z, p = 0, u = t.length; p !== u; p++) {
                        var d = t[p], v = e[p], y = null;
                        d.material && v.material && (y = i.getContactMaterial(d.material, v.material) || null);
                        for (var f = 0 == d.collisionResponse || 0 == v.collisionResponse || d.type & A.KINEMATIC && v.type & A.STATIC || d.type & A.STATIC && v.type & A.KINEMATIC || d.type & A.KINEMATIC && v.type & A.KINEMATIC, m = 0; m < d.shapes.length; m++) {
                            d.quaternion.mult(d.shapeOrientations[m], a), d.quaternion.vmult(d.shapeOffsets[m], l), 
                            l.vadd(d.position, l);
                            for (var w = d.shapes[m], g = 0; g < v.shapes.length; g++) {
                                v.quaternion.mult(v.shapeOrientations[g], h), v.quaternion.vmult(v.shapeOffsets[g], c), 
                                c.vadd(v.position, c);
                                var x = v.shapes[g];
                                if (w.collisionFilterMask & x.collisionFilterGroup && x.collisionFilterMask & w.collisionFilterGroup && !(l.distanceTo(c) > w.boundingSphereRadius + x.boundingSphereRadius)) {
                                    f |= 0 == w.collisionResponse || 0 == x.collisionResponse;
                                    var b = null;
                                    w.material && x.material && (b = i.getContactMaterial(w.material, x.material) || null), 
                                    this.currentContactMaterial = b || y || i.defaultContactMaterial;
                                    var B = this[w.type | x.type];
                                    if (B && (w.type < x.type ? B.call(this, w, x, l, c, a, h, d, v, w, x, f) : B.call(this, x, w, c, l, h, a, v, d, w, x, f)) && f) {
                                        var E = {
                                            si: w,
                                            sj: x
                                        };
                                        i.triggerDic.set(w.id, x.id, E), i.oldTriggerDic.set(w.id, x.id, E);
                                    }
                                }
                            }
                        }
                    }
                }, a.prototype[n.types.BOX | n.types.BOX] = a.prototype.boxBox = function(t, e, i, o, n, s, r, a, h, l, c) {
                    return t.convexPolyhedronRepresentation.material = t.material, e.convexPolyhedronRepresentation.material = e.material, 
                    t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, 
                    this.convexConvex(t.convexPolyhedronRepresentation, e.convexPolyhedronRepresentation, i, o, n, s, r, a, t, e, c);
                }, a.prototype[n.types.BOX | n.types.CONVEXPOLYHEDRON] = a.prototype.boxConvex = function(t, e, i, o, n, s, r, a, h, l, c) {
                    return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, 
                    this.convexConvex(t.convexPolyhedronRepresentation, e, i, o, n, s, r, a, t, e, c);
                }, a.prototype[n.types.BOX | n.types.PARTICLE] = a.prototype.boxParticle = function(t, e, i, o, n, s, r, a, h, l, c) {
                    return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, 
                    this.convexParticle(t.convexPolyhedronRepresentation, e, i, o, n, s, r, a, t, e, c);
                }, a.prototype[n.types.SPHERE] = a.prototype.sphereSphere = function(t, e, i, o, n, s, r, a, h, l, c) {
                    if (c) return i.distanceSquared(o) < Math.pow(t.radius + e.radius, 2);
                    var p = this.createContactEquation(r, a, t, e, h, l);
                    o.vsub(i, p.ni), p.ni.normalize(), p.ri.copy(p.ni), p.rj.copy(p.ni), p.ri.mult(t.radius, p.ri), 
                    p.rj.mult(-e.radius, p.rj), p.ri.vadd(i, p.ri), p.ri.vsub(r.position, p.ri), p.rj.vadd(o, p.rj), 
                    p.rj.vsub(a.position, p.rj), this.result.push(p), this.createFrictionEquationsFromContact(p, this.frictionResult);
                };
                var g = new w, x = new w, b = new w;
                a.prototype[n.types.PLANE | n.types.TRIMESH] = a.prototype.planeTrimesh = function(t, e, i, o, n, s, r, a, h, l, c) {
                    var p = new w, u = g;
                    u.set(0, 0, 1), n.vmult(u, u);
                    for (var d = 0; d < e.vertices.length / 3; d++) {
                        e.getVertex(d, p);
                        var v = new w;
                        v.copy(p), N.pointToWorldFrame(o, s, v, p);
                        var y = x;
                        if (p.vsub(i, y), u.dot(y) <= 0) {
                            if (c) return !0;
                            var f = this.createContactEquation(r, a, t, e, h, l);
                            f.ni.copy(u);
                            var m = b;
                            u.scale(y.dot(u), m), p.vsub(m, m), f.ri.copy(m), f.ri.vsub(r.position, f.ri), f.rj.copy(p), 
                            f.rj.vsub(a.position, f.rj), this.result.push(f), this.createFrictionEquationsFromContact(f, this.frictionResult);
                        }
                    }
                };
                var L = new w, W = new w, j = (new w, new w), O = new w, k = new w, D = new w, _ = new w, U = new w, H = new w, G = new w, X = new w, Q = new w, Y = new w, Z = new o, K = [];
                a.prototype[n.types.SPHERE | n.types.TRIMESH] = a.prototype.sphereTrimesh = function(t, e, i, o, n, s, r, a, h, l, c) {
                    var p = k, u = D, d = _, v = U, y = H, f = G, m = Z, w = O, g = W, x = K;
                    N.pointToLocalFrame(o, s, i, y);
                    var b = t.radius;
                    m.lowerBound.set(y.x - b, y.y - b, y.z - b), m.upperBound.set(y.x + b, y.y + b, y.z + b), 
                    e.getTrianglesInAABB(m, x);
                    for (var B = j, E = t.radius * t.radius, A = 0; A < x.length; A++) for (var S = 0; S < 3; S++) if (e.getVertex(e.indices[3 * x[A] + S], B), 
                    B.vsub(y, g), g.norm2() <= E) {
                        if (w.copy(B), N.pointToWorldFrame(o, s, w, B), B.vsub(i, g), c) return !0;
                        (C = this.createContactEquation(r, a, t, e, h, l)).ni.copy(g), C.ni.normalize(), 
                        C.ri.copy(C.ni), C.ri.scale(t.radius, C.ri), C.ri.vadd(i, C.ri), C.ri.vsub(r.position, C.ri), 
                        C.rj.copy(B), C.rj.vsub(a.position, C.rj), this.result.push(C), this.createFrictionEquationsFromContact(C, this.frictionResult);
                    }
                    for (A = 0; A < x.length; A++) for (S = 0; S < 3; S++) {
                        e.getVertex(e.indices[3 * x[A] + S], p), e.getVertex(e.indices[3 * x[A] + (S + 1) % 3], u), 
                        u.vsub(p, d), y.vsub(u, f);
                        var z = f.dot(d);
                        y.vsub(p, f);
                        var M = f.dot(d);
                        if (0 < M && z < 0 && (y.vsub(p, f), v.copy(d), v.normalize(), M = f.dot(v), v.scale(M, f), 
                        f.vadd(p, f), (V = f.distanceTo(y)) < t.radius)) {
                            if (c) return !0;
                            var C = this.createContactEquation(r, a, t, e, h, l);
                            f.vsub(y, C.ni), C.ni.normalize(), C.ni.scale(t.radius, C.ri), N.pointToWorldFrame(o, s, f, f), 
                            f.vsub(a.position, C.rj), N.vectorToWorldFrame(s, C.ni, C.ni), N.vectorToWorldFrame(s, C.ri, C.ri), 
                            this.result.push(C), this.createFrictionEquationsFromContact(C, this.frictionResult);
                        }
                    }
                    for (var q = X, R = Q, F = Y, T = L, P = (A = 0, x.length); A !== P; A++) {
                        e.getTriangleVertices(x[A], q, R, F), e.getNormal(x[A], T), y.vsub(q, f);
                        var V = f.dot(T);
                        if (T.scale(V, f), y.vsub(f, f), V = f.distanceTo(y), I.pointInTriangle(f, q, R, F) && V < t.radius) {
                            if (c) return !0;
                            C = this.createContactEquation(r, a, t, e, h, l), f.vsub(y, C.ni), C.ni.normalize(), 
                            C.ni.scale(t.radius, C.ri), N.pointToWorldFrame(o, s, f, f), f.vsub(a.position, C.rj), 
                            N.vectorToWorldFrame(s, C.ni, C.ni), N.vectorToWorldFrame(s, C.ri, C.ri), this.result.push(C), 
                            this.createFrictionEquationsFromContact(C, this.frictionResult);
                        }
                    }
                    x.length = 0;
                };
                var v = new w, y = new w, m = new w, B = new w, E = new w;
                a.prototype[n.types.SPHERE | n.types.PLANE] = a.prototype.spherePlane = function(t, e, i, o, n, s, r, a, h, l, c) {
                    if (m.set(0, 0, 1), s.vmult(m, m), m.negate(m), m.normalize(), m.mult(t.radius, B), 
                    i.vsub(o, v), m.mult(m.dot(v), y), v.vsub(y, E), -v.dot(m) <= t.radius) {
                        if (c) return !0;
                        var p = this.createContactEquation(r, a, t, e, h, l);
                        p.ni.copy(m), p.ri.copy(B), p.rj.copy(E);
                        var u = p.ri, d = p.rj;
                        u.vadd(i, u), u.vsub(r.position, u), d.vadd(o, d), d.vsub(a.position, d), this.result.push(p), 
                        this.createFrictionEquationsFromContact(p, this.frictionResult);
                    }
                    return !1;
                };
                var u = new w, d = new w, q = new w;
                function J(t, e, i) {
                    for (var o = null, n = t.length, s = 0; s !== n; s++) {
                        var r = t[s], a = u;
                        t[(s + 1) % n].vsub(r, a);
                        var h = d;
                        a.cross(e, h);
                        var l = q;
                        i.vsub(r, l);
                        var c = h.dot(l);
                        if (!(null === o || 0 < c && !0 === o || c <= 0 && !1 === o)) return !1;
                        null === o && (o = 0 < c);
                    }
                    return !0;
                }
                var $ = new w, tt = new w, et = new w, it = new w, ot = [ new w, new w, new w, new w, new w, new w ], nt = new w, st = new w, rt = new w, at = new w;
                a.prototype[n.types.SPHERE | n.types.BOX] = a.prototype.sphereBox = function(t, e, i, o, n, s, r, a, h, l, c) {
                    var p = this.v3pool, u = ot;
                    i.vsub(o, $), e.getSideNormals(u, s);
                    for (var d = t.radius, v = !1, y = st, f = rt, m = at, w = null, g = 0, x = 0, b = 0, B = null, E = 0, A = u.length; E !== A && !1 === v; E++) {
                        var S = tt;
                        S.copy(u[E]);
                        var z = S.norm();
                        S.normalize();
                        var M = $.dot(S);
                        if (M < z + d && 0 < M) {
                            var C = et, q = it;
                            C.copy(u[(E + 1) % 3]), q.copy(u[(E + 2) % 3]);
                            var R = C.norm(), F = q.norm();
                            C.normalize(), q.normalize();
                            var T = $.dot(C), P = $.dot(q);
                            if (T < R && -R < T && P < F && -F < P) {
                                var V = Math.abs(M - z - d);
                                if ((null === B || V < B) && (B = V, x = T, b = P, w = z, y.copy(S), f.copy(C), 
                                m.copy(q), g++, c)) return !0;
                            }
                        }
                    }
                    if (g) {
                        v = !0;
                        var I = this.createContactEquation(r, a, t, e, h, l);
                        y.mult(-d, I.ri), I.ni.copy(y), I.ni.negate(I.ni), y.mult(w, y), f.mult(x, f), y.vadd(f, y), 
                        m.mult(b, m), y.vadd(m, I.rj), I.ri.vadd(i, I.ri), I.ri.vsub(r.position, I.ri), 
                        I.rj.vadd(o, I.rj), I.rj.vsub(a.position, I.rj), this.result.push(I), this.createFrictionEquationsFromContact(I, this.frictionResult);
                    }
                    for (var N = p.get(), L = nt, W = 0; 2 !== W && !v; W++) for (var j = 0; 2 !== j && !v; j++) for (var O = 0; 2 !== O && !v; O++) if (N.set(0, 0, 0), 
                    W ? N.vadd(u[0], N) : N.vsub(u[0], N), j ? N.vadd(u[1], N) : N.vsub(u[1], N), O ? N.vadd(u[2], N) : N.vsub(u[2], N), 
                    o.vadd(N, L), L.vsub(i, L), L.norm2() < d * d) {
                        if (c) return !0;
                        v = !0, (I = this.createContactEquation(r, a, t, e, h, l)).ri.copy(L), I.ri.normalize(), 
                        I.ni.copy(I.ri), I.ri.mult(d, I.ri), I.rj.copy(N), I.ri.vadd(i, I.ri), I.ri.vsub(r.position, I.ri), 
                        I.rj.vadd(o, I.rj), I.rj.vsub(a.position, I.rj), this.result.push(I), this.createFrictionEquationsFromContact(I, this.frictionResult);
                    }
                    p.release(N), N = null;
                    var k = p.get(), D = p.get(), _ = (I = p.get(), p.get()), U = (V = p.get(), u.length);
                    for (W = 0; W !== U && !v; W++) for (j = 0; j !== U && !v; j++) if (W % 3 != j % 3) {
                        u[j].cross(u[W], k), k.normalize(), u[W].vadd(u[j], D), I.copy(i), I.vsub(D, I), 
                        I.vsub(o, I);
                        var H = I.dot(k);
                        for (k.mult(H, _), O = 0; O === W % 3 || O === j % 3; ) O++;
                        V.copy(i), V.vsub(_, V), V.vsub(D, V), V.vsub(o, V);
                        var G = Math.abs(H), X = V.norm();
                        if (G < u[O].norm() && X < d) {
                            if (c) return !0;
                            v = !0;
                            var Q = this.createContactEquation(r, a, t, e, h, l);
                            D.vadd(_, Q.rj), Q.rj.copy(Q.rj), V.negate(Q.ni), Q.ni.normalize(), Q.ri.copy(Q.rj), 
                            Q.ri.vadd(o, Q.ri), Q.ri.vsub(i, Q.ri), Q.ri.normalize(), Q.ri.mult(d, Q.ri), Q.ri.vadd(i, Q.ri), 
                            Q.ri.vsub(r.position, Q.ri), Q.rj.vadd(o, Q.rj), Q.rj.vsub(a.position, Q.rj), this.result.push(Q), 
                            this.createFrictionEquationsFromContact(Q, this.frictionResult);
                        }
                    }
                    p.release(k, D, I, _, V);
                };
                var ht = new w, lt = new w, ct = new w, pt = new w, ut = new w, dt = new w, vt = new w, yt = new w, ft = new w, mt = new w;
                a.prototype[n.types.SPHERE | n.types.CONVEXPOLYHEDRON] = a.prototype.sphereConvex = function(t, e, i, o, n, s, r, a, h, l, c) {
                    var p = this.v3pool;
                    i.vsub(o, ht);
                    for (var u = e.faceNormals, d = e.faces, v = e.vertices, y = t.radius, f = 0; f !== v.length; f++) {
                        var m = v[f], w = ut;
                        s.vmult(m, w), o.vadd(w, w);
                        var g = pt;
                        if (w.vsub(i, g), g.norm2() < y * y) return !!c || (x = !0, (V = this.createContactEquation(r, a, t, e, h, l)).ri.copy(g), 
                        V.ri.normalize(), V.ni.copy(V.ri), V.ri.mult(y, V.ri), w.vsub(o, V.rj), V.ri.vadd(i, V.ri), 
                        V.ri.vsub(r.position, V.ri), V.rj.vadd(o, V.rj), V.rj.vsub(a.position, V.rj), this.result.push(V), 
                        void this.createFrictionEquationsFromContact(V, this.frictionResult));
                    }
                    for (var x = !1, b = (f = 0, d.length); f !== b && !1 === x; f++) {
                        var B = u[f], E = d[f], A = dt;
                        s.vmult(B, A);
                        var S = vt;
                        s.vmult(v[E[0]], S), S.vadd(o, S);
                        var z = yt;
                        A.mult(-y, z), i.vadd(z, z);
                        var M = ft;
                        z.vsub(S, M);
                        var C = M.dot(A), q = mt;
                        if (i.vsub(S, q), C < 0 && 0 < q.dot(A)) {
                            for (var R = [], F = 0, T = E.length; F !== T; F++) {
                                var P = p.get();
                                s.vmult(v[E[F]], P), o.vadd(P, P), R.push(P);
                            }
                            if (J(R, A, i)) {
                                if (c) return !0;
                                x = !0;
                                var V = this.createContactEquation(r, a, t, e, h, l);
                                A.mult(-y, V.ri), A.negate(V.ni);
                                var I = p.get();
                                A.mult(-C, I);
                                var N = p.get();
                                A.mult(-y, N), i.vsub(o, V.rj), V.rj.vadd(N, V.rj), V.rj.vadd(I, V.rj), V.rj.vadd(o, V.rj), 
                                V.rj.vsub(a.position, V.rj), V.ri.vadd(i, V.ri), V.ri.vsub(r.position, V.ri), p.release(I), 
                                p.release(N), this.result.push(V), this.createFrictionEquationsFromContact(V, this.frictionResult), 
                                F = 0;
                                for (var L = R.length; F !== L; F++) p.release(R[F]);
                                return;
                            }
                            for (F = 0; F !== E.length; F++) {
                                var W = p.get(), j = p.get();
                                s.vmult(v[E[(F + 1) % E.length]], W), s.vmult(v[E[(F + 2) % E.length]], j), o.vadd(W, W), 
                                o.vadd(j, j);
                                var O = lt;
                                j.vsub(W, O);
                                var k = ct;
                                O.unit(k);
                                var D = p.get(), _ = p.get();
                                i.vsub(W, _);
                                var U = _.dot(k);
                                k.mult(U, D), D.vadd(W, D);
                                var H = p.get();
                                if (D.vsub(i, H), 0 < U && U * U < O.norm2() && H.norm2() < y * y) {
                                    if (c) return !0;
                                    for (V = this.createContactEquation(r, a, t, e, h, l), D.vsub(o, V.rj), D.vsub(i, V.ni), 
                                    V.ni.normalize(), V.ni.mult(y, V.ri), V.rj.vadd(o, V.rj), V.rj.vsub(a.position, V.rj), 
                                    V.ri.vadd(i, V.ri), V.ri.vsub(r.position, V.ri), this.result.push(V), this.createFrictionEquationsFromContact(V, this.frictionResult), 
                                    F = 0, L = R.length; F !== L; F++) p.release(R[F]);
                                    return p.release(W), p.release(j), p.release(D), p.release(H), void p.release(_);
                                }
                                p.release(W), p.release(j), p.release(D), p.release(H), p.release(_);
                            }
                            for (F = 0, L = R.length; F !== L; F++) p.release(R[F]);
                        }
                    }
                }, new w, new w, a.prototype[n.types.PLANE | n.types.BOX] = a.prototype.planeBox = function(t, e, i, o, n, s, r, a, h, l, c) {
                    return e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, 
                    e.convexPolyhedronRepresentation.id = e.id, this.planeConvex(t, e.convexPolyhedronRepresentation, i, o, n, s, r, a, t, e, c);
                };
                var R = new w, F = new w, T = new w, P = new w;
                a.prototype[n.types.PLANE | n.types.CONVEXPOLYHEDRON] = a.prototype.planeConvex = function(t, e, i, o, n, s, r, a, h, l, c) {
                    var p = R, u = F;
                    u.set(0, 0, 1), n.vmult(u, u);
                    for (var d = 0, v = T, y = 0; y !== e.vertices.length; y++) if (p.copy(e.vertices[y]), 
                    s.vmult(p, p), o.vadd(p, p), p.vsub(i, v), u.dot(v) <= 0) {
                        if (c) return !0;
                        var f = this.createContactEquation(r, a, t, e, h, l), m = P;
                        u.mult(u.dot(v), m), p.vsub(m, m), m.vsub(i, f.ri), f.ni.copy(u), p.vsub(o, f.rj), 
                        f.ri.vadd(i, f.ri), f.ri.vsub(r.position, f.ri), f.rj.vadd(o, f.rj), f.rj.vsub(a.position, f.rj), 
                        this.result.push(f), d++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(f, this.frictionResult);
                    }
                    this.enableFrictionReduction && d && this.createFrictionFromAverage(d);
                };
                var V = new w, wt = new w;
                a.prototype[n.types.CONVEXPOLYHEDRON] = a.prototype.convexConvex = function(t, e, i, o, n, s, r, a, h, l, c, p, u) {
                    var d = V;
                    if (!(i.distanceTo(o) > t.boundingSphereRadius + e.boundingSphereRadius) && t.findSeparatingAxis(e, i, n, o, s, d, p, u)) {
                        var v = [], y = wt;
                        t.clipAgainstHull(i, n, e, o, s, d, -100, 100, v);
                        for (var f = 0, m = 0; m !== v.length; m++) {
                            if (c) return !0;
                            var w = this.createContactEquation(r, a, t, e, h, l), g = w.ri, x = w.rj;
                            d.negate(w.ni), v[m].normal.negate(y), y.mult(v[m].depth, y), v[m].point.vadd(y, g), 
                            x.copy(v[m].point), g.vsub(i, g), x.vsub(o, x), g.vadd(i, g), g.vsub(r.position, g), 
                            x.vadd(o, x), x.vsub(a.position, x), this.result.push(w), f++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(w, this.frictionResult);
                        }
                        this.enableFrictionReduction && f && this.createFrictionFromAverage(f);
                    }
                };
                var gt = new w, xt = new w, bt = new w;
                a.prototype[n.types.PLANE | n.types.PARTICLE] = a.prototype.planeParticle = function(t, e, i, o, n, s, r, a, h, l, c) {
                    var p = gt;
                    p.set(0, 0, 1), r.quaternion.vmult(p, p);
                    var u = xt;
                    if (o.vsub(r.position, u), p.dot(u) <= 0) {
                        if (c) return !0;
                        var d = this.createContactEquation(a, r, e, t, h, l);
                        d.ni.copy(p), d.ni.negate(d.ni), d.ri.set(0, 0, 0);
                        var v = bt;
                        p.mult(p.dot(o), v), o.vsub(v, v), d.rj.copy(v), this.result.push(d), this.createFrictionEquationsFromContact(d, this.frictionResult);
                    }
                };
                var Bt = new w;
                a.prototype[n.types.PARTICLE | n.types.SPHERE] = a.prototype.sphereParticle = function(t, e, i, o, n, s, r, a, h, l, c) {
                    var p = Bt;
                    if (p.set(0, 0, 1), o.vsub(i, p), p.norm2() <= t.radius * t.radius) {
                        if (c) return !0;
                        var u = this.createContactEquation(a, r, e, t, h, l);
                        p.normalize(), u.rj.copy(p), u.rj.mult(t.radius, u.rj), u.ni.copy(p), u.ni.negate(u.ni), 
                        u.ri.set(0, 0, 0), this.result.push(u), this.createFrictionEquationsFromContact(u, this.frictionResult);
                    }
                };
                var Et = new s, At = new w, St = (new w, new w), zt = new w, Mt = new w;
                a.prototype[n.types.PARTICLE | n.types.CONVEXPOLYHEDRON] = a.prototype.convexParticle = function(t, e, i, o, n, s, r, a, h, l, c) {
                    var p = -1, u = St, d = Mt, v = null, y = At;
                    if (y.copy(o), y.vsub(i, y), n.conjugate(Et), Et.vmult(y, y), t.pointIsInside(y)) {
                        t.worldVerticesNeedsUpdate && t.computeWorldVertices(i, n), t.worldFaceNormalsNeedsUpdate && t.computeWorldFaceNormals(n);
                        for (var f = 0, m = t.faces.length; f !== m; f++) {
                            var w = [ t.worldVertices[t.faces[f][0]] ], g = t.worldFaceNormals[f];
                            o.vsub(w[0], zt);
                            var x = -g.dot(zt);
                            if (null === v || Math.abs(x) < Math.abs(v)) {
                                if (c) return !0;
                                v = x, p = f, u.copy(g);
                            }
                        }
                        if (-1 !== p) {
                            var b = this.createContactEquation(a, r, e, t, h, l);
                            u.mult(v, d), d.vadd(o, d), d.vsub(i, d), b.rj.copy(d), u.negate(b.ni), b.ri.set(0, 0, 0);
                            var B = b.ri, E = b.rj;
                            B.vadd(o, B), B.vsub(a.position, B), E.vadd(i, E), E.vsub(r.position, E), this.result.push(b), 
                            this.createFrictionEquationsFromContact(b, this.frictionResult);
                        } else console.warn("Point found inside convex, but did not find penetrating face!");
                    }
                }, a.prototype[n.types.BOX | n.types.HEIGHTFIELD] = a.prototype.boxHeightfield = function(t, e, i, o, n, s, r, a, h, l, c) {
                    return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, 
                    this.convexHeightfield(t.convexPolyhedronRepresentation, e, i, o, n, s, r, a, t, e, c);
                };
                var Ct = new w, qt = new w, Rt = [ 0 ];
                a.prototype[n.types.CONVEXPOLYHEDRON | n.types.HEIGHTFIELD] = a.prototype.convexHeightfield = function(t, e, i, o, n, s, r, a, h, l, c) {
                    var p = e.data, u = e.elementSize, d = t.boundingSphereRadius, v = qt, y = Rt, f = Ct;
                    N.pointToLocalFrame(o, s, i, f);
                    var m = Math.floor((f.x - d) / u) - 1, w = Math.ceil((f.x + d) / u) + 1, g = Math.floor((f.y - d) / u) - 1, x = Math.ceil((f.y + d) / u) + 1;
                    if (!(w < 0 || x < 0 || m > p.length || g > p[0].length)) {
                        m < 0 && (m = 0), w < 0 && (w = 0), g < 0 && (g = 0), x < 0 && (x = 0), m >= p.length && (m = p.length - 1), 
                        w >= p.length && (w = p.length - 1), x >= p[0].length && (x = p[0].length - 1), 
                        g >= p[0].length && (g = p[0].length - 1);
                        var b = [];
                        e.getRectMinMax(m, g, w, x, b);
                        var B = b[0], E = b[1];
                        if (!(f.z - d > E || f.z + d < B)) for (var A = m; A < w; A++) for (var S = g; S < x; S++) {
                            var z = !1;
                            if (e.getConvexTrianglePillar(A, S, !1), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                            i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (z = this.convexConvex(t, e.pillarConvex, i, v, n, s, r, a, null, null, c, y, null)), 
                            c && z) return !0;
                            if (e.getConvexTrianglePillar(A, S, !0), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                            i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (z = this.convexConvex(t, e.pillarConvex, i, v, n, s, r, a, null, null, c, y, null)), 
                            c && z) return !0;
                        }
                    }
                };
                var Ft = new w, Tt = new w;
                a.prototype[n.types.SPHERE | n.types.HEIGHTFIELD] = a.prototype.sphereHeightfield = function(t, e, i, o, n, s, r, a, h, l, c) {
                    var p = e.data, u = t.radius, d = e.elementSize, v = Tt, y = Ft;
                    N.pointToLocalFrame(o, s, i, y);
                    var f = Math.floor((y.x - u) / d) - 1, m = Math.ceil((y.x + u) / d) + 1, w = Math.floor((y.y - u) / d) - 1, g = Math.ceil((y.y + u) / d) + 1;
                    if (!(m < 0 || g < 0 || f > p.length || w > p[0].length)) {
                        f < 0 && (f = 0), m < 0 && (m = 0), w < 0 && (w = 0), g < 0 && (g = 0), f >= p.length && (f = p.length - 1), 
                        m >= p.length && (m = p.length - 1), g >= p[0].length && (g = p[0].length - 1), 
                        w >= p[0].length && (w = p[0].length - 1);
                        var x = [];
                        e.getRectMinMax(f, w, m, g, x);
                        var b = x[0], B = x[1];
                        if (!(y.z - u > B || y.z + u < b)) for (var E = this.result, A = f; A < m; A++) for (var S = w; S < g; S++) {
                            var z = E.length, M = !1;
                            if (e.getConvexTrianglePillar(A, S, !1), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                            i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (M = this.sphereConvex(t, e.pillarConvex, i, v, n, s, r, a, t, e, c)), 
                            c && M) return !0;
                            if (e.getConvexTrianglePillar(A, S, !0), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                            i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (M = this.sphereConvex(t, e.pillarConvex, i, v, n, s, r, a, t, e, c)), 
                            c && M) return !0;
                            if (2 < E.length - z) return;
                        }
                    }
                };
            }, {
                "../collision/AABB": 3,
                "../collision/Ray": 10,
                "../equations/ContactEquation": 20,
                "../equations/FrictionEquation": 22,
                "../math/Quaternion": 29,
                "../math/Transform": 30,
                "../math/Vec3": 31,
                "../objects/Body": 32,
                "../shapes/ConvexPolyhedron": 39,
                "../shapes/Shape": 44,
                "../solver/Solver": 48,
                "../utils/Vec3Pool": 55
            } ],
            57: [ function(m, w, t) {
                (function(t) {
                    w.exports = u, m("../shapes/Shape");
                    var e = m("../math/Vec3"), i = (m("../math/Quaternion"), m("../solver/GSSolver")), o = (m("../equations/ContactEquation"), 
                    m("../equations/FrictionEquation"), m("./Narrowphase")), n = m("../utils/EventTarget"), s = (m("../collision/ArrayCollisionMatrix"), 
                    m("../collision/ObjectCollisionMatrix")), r = (m("../collision/OverlapKeeper"), 
                    m("../material/Material")), a = m("../material/ContactMaterial"), P = m("../objects/Body"), h = m("../utils/TupleDictionary"), l = m("../collision/RaycastResult"), c = (m("../collision/AABB"), 
                    m("../collision/Ray")), p = m("../collision/NaiveBroadphase");
                    function u(t) {
                        t = t || {}, n.apply(this), this.dt = -1, this.allowSleep = !!t.allowSleep, this.contacts = [], 
                        this.frictionEquations = [], this.triggerDic = new h, this.oldTriggerDic = new h, 
                        this.contactsDic = new h, this.oldContactsDic = new h, this.quatNormalizeSkip = void 0 !== t.quatNormalizeSkip ? t.quatNormalizeSkip : 0, 
                        this.quatNormalizeFast = void 0 !== t.quatNormalizeFast && t.quatNormalizeFast, 
                        this.time = 0, this.stepnumber = 0, this.substeps = 0, this.default_dt = 1 / 60, 
                        this.nextId = 0, this.gravity = new e, t.gravity && this.gravity.copy(t.gravity), 
                        this.broadphase = void 0 !== t.broadphase ? t.broadphase : new p, this.bodies = [], 
                        this.solver = void 0 !== t.solver ? t.solver : new i, this.constraints = [], this.narrowphase = new o(this), 
                        this.collisionMatrix = new s, this.triggerMatrix = new s, this.materials = [], this.contactmaterials = [], 
                        this.contactMaterialTable = new h, this.defaultMaterial = new r("default"), this.defaultContactMaterial = new a(this.defaultMaterial, this.defaultMaterial, {
                            friction: .3,
                            restitution: 0
                        }), this.profile = {
                            solve: 0,
                            makeContactConstraints: 0,
                            broadphase: 0,
                            integrate: 0,
                            narrowphase: 0
                        }, this.accumulator = 0, this.subsystems = [], this.addBodyEvent = {
                            type: "addBody",
                            body: null
                        }, this.removeBodyEvent = {
                            type: "removeBody",
                            body: null
                        }, this.broadphase.setWorld(this);
                    }
                    t ? (t.doProfiling = !1, t.DEBUG = !0) : window && (window.doProfiling = !1, window.DEBUG = !0), 
                    u.idToBodyMap = {}, u.idToShapeMap = {}, u.prototype = new n;
                    var d = new c;
                    u.prototype.getContactMaterial = function(t, e) {
                        return this.contactMaterialTable.get(t.id, e.id);
                    }, u.prototype.numObjects = function() {
                        return this.bodies.length;
                    }, u.prototype.collisionMatrixTick = function() {}, u.prototype.add = u.prototype.addBody = function(t) {
                        -1 === this.bodies.indexOf(t) && (t.index = this.bodies.length, this.bodies.push(t), 
                        t.world = this, t.initPosition.copy(t.position), t.initVelocity.copy(t.velocity), 
                        t.timeLastSleepy = this.time, t instanceof P && (t.initAngularVelocity.copy(t.angularVelocity), 
                        t.initQuaternion.copy(t.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), 
                        this.addBodyEvent.body = t, u.idToBodyMap[t.id] = t, this.dispatchEvent(this.addBodyEvent));
                    }, u.prototype.addConstraint = function(t) {
                        this.constraints.push(t);
                    }, u.prototype.removeConstraint = function(t) {
                        var e = this.constraints.indexOf(t);
                        -1 !== e && this.constraints.splice(e, 1);
                    }, u.prototype.rayTest = function(t, e, i) {
                        i instanceof l ? this.raycastClosest(t, e, {
                            skipBackfaces: !0
                        }, i) : this.raycastAll(t, e, {
                            skipBackfaces: !0
                        }, i);
                    }, u.prototype.raycastAll = function(t, e, i, o) {
                        return i.mode = c.ALL, i.from = t, i.to = e, i.callback = o, d.intersectWorld(this, i);
                    }, u.prototype.raycastAny = function(t, e, i, o) {
                        return i.mode = c.ANY, i.from = t, i.to = e, i.result = o, d.intersectWorld(this, i);
                    }, u.prototype.raycastClosest = function(t, e, i, o) {
                        return i.mode = c.CLOSEST, i.from = t, i.to = e, i.result = o, d.intersectWorld(this, i);
                    }, u.prototype.removeBody = u.prototype.remove = function(t) {
                        t.world = null;
                        var e = this.bodies.length - 1, i = this.bodies, o = i.indexOf(t);
                        if (-1 !== o) {
                            i.splice(o, 1);
                            for (var n = 0; n !== i.length; n++) i[n].index = n;
                            this.collisionMatrix.setNumObjects(e), this.removeBodyEvent.body = t, delete u.idToBodyMap[t.id], 
                            this.dispatchEvent(this.removeBodyEvent);
                        }
                    }, u.prototype.getBodyById = function(t) {
                        return u.idToBodyMap[t];
                    }, u.prototype.getShapeById = function(t) {
                        return u.idToShapeMap[t];
                    }, u.prototype.addMaterial = function(t) {
                        this.materials.push(t);
                    }, u.prototype.addContactMaterial = function(t) {
                        this.contactmaterials.push(t), this.contactMaterialTable.set(t.materials[0].id, t.materials[1].id, t);
                    }, u.prototype.step = function(t, e, i) {
                        if (i = i || 10, e = e || 0, 0 != this.substeps && (y = this.contacts.slice()), 
                        0 === e) this.internalStep(t), this.time += t, this.substeps = 1; else {
                            for (this.accumulator += e, this.substeps = 0; this.accumulator >= t && this.substeps < i; ) this.internalStep(t), 
                            this.accumulator -= t, this.substeps++;
                            for (var o = this.accumulator % t / t, n = 0; n !== this.bodies.length; n++) {
                                var s = this.bodies[n];
                                s.previousPosition.lerp(s.position, o, s.interpolatedPosition), s.previousQuaternion.slerp(s.quaternion, o, s.interpolatedQuaternion), 
                                s.previousQuaternion.normalize();
                            }
                            this.time += e;
                        }
                    };
                    var v = {
                        type: "collide",
                        event: "",
                        body: null,
                        selfShape: null,
                        otherShape: null,
                        contacts: null
                    }, y = [], V = [], I = [], N = [];
                    u.prototype.internalStep = function(t) {
                        this.dt = t;
                        var e = this.contacts, i = I, o = N, n = this.numObjects(), s = this.bodies, r = this.solver, a = this.gravity, h = (this.profile, 
                        P.DYNAMIC), l = this.constraints, c = V, p = a.x, u = a.y, d = a.z, v = 0;
                        for (v = 0; v !== n; v++) if ((z = s[v]).useGravity && z.type === h) {
                            var y = z.force, f = z.mass;
                            y.x += f * p, y.y += f * u, y.z += f * d;
                        }
                        v = 0;
                        for (var m = this.subsystems.length; v !== m; v++) this.subsystems[v].update();
                        i.length = 0, o.length = 0, this.broadphase.collisionPairs(this, i, o);
                        var w = l.length;
                        for (v = 0; v !== w; v++) if (!(B = l[v]).collideConnected) for (var g = i.length - 1; 0 <= g; --g) (B.bodyA === i[g] && B.bodyB === o[g] || B.bodyB === i[g] && B.bodyA === o[g]) && (i.splice(g, 1), 
                        o.splice(g, 1));
                        e.length = 0;
                        var x = this.frictionEquations.length;
                        for (v = 0; v !== x; v++) c.push(this.frictionEquations[v]);
                        for (this.frictionEquations.length = 0, this.narrowphase.getContacts(i, o, this, e, null, this.frictionEquations, c), 
                        v = 0; v < this.frictionEquations.length; v++) r.addEquation(this.frictionEquations[v]);
                        var b = e.length;
                        for (v = 0; v !== b; v++) r.addEquation(e[v]);
                        for (w = l.length, v = 0; v !== w; v++) {
                            var B;
                            (B = l[v]).update(), g = 0;
                            for (var E = B.equations.length; g !== E; g++) {
                                var A = B.equations[g];
                                r.addEquation(A);
                            }
                        }
                        r.solve(t, this), r.removeAllEquations();
                        var S = Math.pow;
                        for (n = this.numObjects(), v = 0; v !== n; v++) {
                            var z;
                            if ((z = s[v]).type & h) {
                                var M = S(1 - z.linearDamping, t), C = z.velocity;
                                C.mult(M, C);
                                var q = z.angularVelocity;
                                if (q) {
                                    var R = S(1 - z.angularDamping, t);
                                    q.mult(R, q);
                                }
                            }
                        }
                        var F = this.stepnumber % (this.quatNormalizeSkip + 1) == 0, T = this.quatNormalizeFast;
                        for (v = 0; v !== n; v++) s[v].integrate(t, F, T);
                        if (this.clearForces(), this.broadphase.dirty = !0, this.time += t, this.stepnumber += 1, 
                        this.allowSleep) for (v = 0; v !== n; v++) s[v].sleepTick(this.time);
                    };
                    var f = {
                        type: "triggered",
                        event: "",
                        selfBody: null,
                        otherBody: null,
                        selfShape: null,
                        otherShape: null
                    };
                    u.prototype.emitTriggeredEvents = function() {
                        if (0 != this.substeps) {
                            for (var t, e, i = this.triggerDic.getLength(); i--; ) if (t = this.triggerDic.getKeyByIndex(i), 
                            null != (e = this.triggerDic.getDataByKey(t))) {
                                var o = e.si, n = e.sj;
                                this.triggerMatrix.get(o, n) ? f.event = "onTriggerStay" : (this.triggerMatrix.set(o, n, !0), 
                                f.event = "onTriggerEnter"), f.selfShape = o, f.otherShape = n, f.selfBody = o.body, 
                                f.otherBody = n.body, o.dispatchEvent(f), f.selfShape = n, f.otherShape = o, f.selfBody = n.body, 
                                f.otherBody = o.body, n.dispatchEvent(f);
                            }
                            for (i = this.oldTriggerDic.getLength(); 0 < i; ) i--, t = this.oldTriggerDic.getKeyByIndex(i), 
                            null == this.triggerDic.getDataByKey(t) && null != (e = this.oldTriggerDic.getDataByKey(t)) && (o = e.si, 
                            n = e.sj, this.triggerMatrix.set(o, n, !1), this.oldTriggerDic.del(o.id, n.id) && i--, 
                            f.event = "onTriggerExit", f.selfShape = o, f.otherShape = n, f.selfBody = o.body, 
                            f.otherBody = n.body, o.dispatchEvent(f), f.selfShape = n, f.otherShape = o, f.selfBody = n.body, 
                            f.otherBody = o.body, n.dispatchEvent(f));
                            this.triggerDic.reset();
                        }
                    }, u.prototype.emitCollisionEvents = function() {
                        if (0 != this.substeps) {
                            for (var t, e, i = this.contacts, o = this.contacts.length; o--; ) {
                                var n = (u = i[o]).si, s = u.sj, r = this.contactsDic.get(n.id, s.id);
                                null == r && (r = this.contactsDic.set(n.id, s.id, [])), r.push(u);
                            }
                            for (o = this.contactsDic.getLength(); o--; ) if (t = this.contactsDic.getKeyByIndex(o), 
                            null != (e = this.contactsDic.getDataByKey(t))) {
                                var a = e[0].bi, h = e[0].bj;
                                if (n = e[0].si, s = e[0].sj, a.allowSleep && a.type === P.DYNAMIC && a.sleepState === P.SLEEPING && h.sleepState === P.AWAKE && h.type !== P.STATIC) {
                                    var l = h.velocity.norm2() + h.angularVelocity.norm2();
                                    2 * Math.pow(h.sleepSpeedLimit, 2) <= l && a.wakeUp();
                                }
                                if (h.allowSleep && h.type === P.DYNAMIC && h.sleepState === P.SLEEPING && a.sleepState === P.AWAKE && a.type !== P.STATIC) {
                                    var c = a.velocity.norm2() + a.angularVelocity.norm2();
                                    2 * Math.pow(a.sleepSpeedLimit, 2) <= c && h.wakeUp();
                                }
                                this.collisionMatrix.get(a, h) ? v.event = "onCollisionStay" : (this.collisionMatrix.set(a, h, !0), 
                                v.event = "onCollisionEnter"), v.contacts = e, v.body = s.body, v.selfShape = n, 
                                v.otherShape = s, n.body.dispatchEvent(v), v.body = n.body, v.selfShape = s, v.otherShape = n, 
                                s.body.dispatchEvent(v);
                            }
                            var p = y;
                            for (o = p.length; o--; ) {
                                var u;
                                n = (u = p[o]).si, s = u.sj, null == this.oldContactsDic.get(n.id, s.id) && this.oldContactsDic.set(n.id, s.id, u);
                            }
                            for (o = this.oldContactsDic.getLength(); o--; ) t = this.oldContactsDic.getKeyByIndex(o), 
                            null == this.contactsDic.getDataByKey(t) && (a = (e = this.oldContactsDic.getDataByKey(t)).bi, 
                            h = e.bj, n = e.si, s = e.sj, this.collisionMatrix.get(a, h) && (a.isSleeping() && h.isSleeping() || (this.collisionMatrix.set(a, h, !1), 
                            v.event = "onCollisionExit", v.body = s.body, v.selfShape = n, v.otherShape = s, 
                            v.contacts.length = 0, v.contacts.push(e), n.body.dispatchEvent(v), v.body = n.body, 
                            v.selfShape = s, v.otherShape = n, s.body.dispatchEvent(v))));
                            this.contactsDic.reset(), this.oldContactsDic.reset();
                        }
                    }, u.prototype.clearForces = function() {
                        for (var t = this.bodies, e = t.length, i = 0; i !== e; i++) {
                            var o = t[i];
                            o.force.set(0, 0, 0), o.torque.set(0, 0, 0);
                        }
                    };
                }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
            }, {
                "../collision/AABB": 3,
                "../collision/ArrayCollisionMatrix": 4,
                "../collision/NaiveBroadphase": 7,
                "../collision/ObjectCollisionMatrix": 8,
                "../collision/OverlapKeeper": 9,
                "../collision/Ray": 10,
                "../collision/RaycastResult": 11,
                "../equations/ContactEquation": 20,
                "../equations/FrictionEquation": 22,
                "../material/ContactMaterial": 25,
                "../material/Material": 26,
                "../math/Quaternion": 29,
                "../math/Vec3": 31,
                "../objects/Body": 32,
                "../shapes/Shape": 44,
                "../solver/GSSolver": 47,
                "../utils/EventTarget": 50,
                "../utils/TupleDictionary": 53,
                "./Narrowphase": 56
            } ]
        }, {}, [ 2 ])(2);
    }));
    cannon_min.CANNON;
    function checkPhysicsModule(obj) {
        return null == obj && (error("[Physics]: Please check to see if physics modules are included."), 
        !0);
    }
    var _class$1N, _class2$1A, _descriptor$1p, _descriptor2$1d, _descriptor3$$, _descriptor4$R, _descriptor5$I, _descriptor6$u, PhysicMaterial = ccclass("cc.PhysicMaterial")((_temp$1C = _class3$E = function(_Asset) {
        function PhysicMaterial() {
            var _this;
            return _classCallCheck(this, PhysicMaterial), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(PhysicMaterial).call(this)), "_friction", _descriptor$1o, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_restitution", _descriptor2$1c, _assertThisInitialized(_this)), 
            PhysicMaterial.allMaterials.push(_assertThisInitialized(_this)), "" == _this._uuid && (_this._uuid = "pm_" + PhysicMaterial._idCounter++), 
            _this;
        }
        return _inherits(PhysicMaterial, _Asset), _createClass(PhysicMaterial, [ {
            key: "friction",
            get: function get() {
                return this._friction;
            },
            set: function set(value) {
                equals(this._friction, value) || (this._friction = value, this.emit("physics_material_update"));
            }
        }, {
            key: "restitution",
            get: function get() {
                return this._restitution;
            },
            set: function set(value) {
                equals(this._restitution, value) || (this._restitution = value, this.emit("physics_material_update"));
            }
        } ]), _createClass(PhysicMaterial, [ {
            key: "clone",
            value: function clone() {
                var c = new PhysicMaterial;
                return c._friction = this._friction, c._restitution = this._restitution, c;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                if (_get(_getPrototypeOf(PhysicMaterial.prototype), "destroy", this).call(this)) {
                    var idx = PhysicMaterial.allMaterials.indexOf(this);
                    return idx >= 0 && PhysicMaterial.allMaterials.splice(idx, 1), !0;
                }
                return !1;
            }
        } ]), PhysicMaterial;
    }(Asset), _class3$E.allMaterials = [], _class3$E._idCounter = 0, _descriptor$1o = _applyDecoratedDescriptor((_class2$1z = _temp$1C).prototype, "_friction", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _descriptor2$1c = _applyDecoratedDescriptor(_class2$1z.prototype, "_restitution", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _applyDecoratedDescriptor(_class2$1z.prototype, "friction", [ property ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "friction"), _class2$1z.prototype), 
    _applyDecoratedDescriptor(_class2$1z.prototype, "restitution", [ property ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "restitution"), _class2$1z.prototype), 
    _class$1M = _class2$1z)) || _class$1M, PhysicsRayResult = function() {
        function PhysicsRayResult() {
            _classCallCheck(this, PhysicsRayResult), this._hitPoint = new Vec3, this._distance = 0, 
            this._collidier = null;
        }
        return _createClass(PhysicsRayResult, [ {
            key: "_assign",
            value: function _assign(hitPoint, distance, collider) {
                Vec3.copy(this._hitPoint, hitPoint), this._distance = distance, this._collidier = collider;
            }
        }, {
            key: "clone",
            value: function clone() {
                var c = new PhysicsRayResult;
                return Vec3.copy(c._hitPoint, this._hitPoint), c._distance = this._distance, c._collidier = this._collidier, 
                c;
            }
        }, {
            key: "hitPoint",
            get: function get() {
                return this._hitPoint;
            }
        }, {
            key: "distance",
            get: function get() {
                return this._distance;
            }
        }, {
            key: "collider",
            get: function get() {
                return this._collidier;
            }
        } ]), PhysicsRayResult;
    }(), PhysicsSystem = ccclass("cc.PhysicsSystem")((_descriptor$1p = _applyDecoratedDescriptor((_class2$1A = function(_System) {
        function PhysicsSystem() {
            var _this;
            return _classCallCheck(this, PhysicsSystem), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsSystem).call(this))).raycastClosestResult = new PhysicsRayResult, 
            _this.raycastResults = [], _initializerDefineProperty(_this, "_enable", _descriptor$1p, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_allowSleep", _descriptor2$1d, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_gravity", _descriptor3$$, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_maxSubStep", _descriptor4$R, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_deltaTime", _descriptor5$I, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_useFixedTime", _descriptor6$u, _assertThisInitialized(_this)), 
            _this._material = null, _this.raycastOptions = {
                group: -1,
                mask: -1,
                queryTrigger: !0,
                maxDistance: 1e7
            }, _this.raycastResultPool = new RecyclePool((function() {
                return new PhysicsRayResult;
            }), 1), _this.physicsWorld = function createPhysicsWorld() {
                return checkPhysicsModule(PhysicsWorld) ? null : new PhysicsWorld;
            }(), _this.gravity = _this._gravity, _this.allowSleep = _this._allowSleep, _this._material = new PhysicMaterial, 
            _this._material.friction = .5, _this._material.restitution = 0, _this._material.on("physics_material_update", _this._updateMaterial, _assertThisInitialized(_this)), 
            _this.physicsWorld.defaultMaterial = _this._material, _this;
        }
        return _inherits(PhysicsSystem, _System), _createClass(PhysicsSystem, [ {
            key: "enable",
            get: function get() {
                return this._enable;
            },
            set: function set(value) {
                this._enable = value;
            }
        }, {
            key: "allowSleep",
            get: function get() {
                return this._allowSleep;
            },
            set: function set(v) {
                this._allowSleep = v, this.physicsWorld.allowSleep = this._allowSleep;
            }
        }, {
            key: "maxSubStep",
            get: function get() {
                return this._maxSubStep;
            },
            set: function set(value) {
                this._maxSubStep = value;
            }
        }, {
            key: "deltaTime",
            get: function get() {
                return this._deltaTime;
            },
            set: function set(value) {
                this._deltaTime = value;
            }
        }, {
            key: "useFixedTime",
            get: function get() {
                return this._useFixedTime;
            },
            set: function set(value) {
                this._useFixedTime = value;
            }
        }, {
            key: "gravity",
            get: function get() {
                return this._gravity;
            },
            set: function set(gravity) {
                this._gravity.set(gravity), this.physicsWorld.gravity = gravity;
            }
        }, {
            key: "defaultMaterial",
            get: function get() {
                return this._material;
            }
        } ], [ {
            key: "instance",
            get: function get() {
                return checkPhysicsModule(PhysicsSystem._instance) ? null : PhysicsSystem._instance;
            }
        } ]), _createClass(PhysicsSystem, [ {
            key: "postUpdate",
            value: function postUpdate(deltaTime) {
                this._enable && (director.emit(Director.EVENT_BEFORE_PHYSICS), this._useFixedTime ? this.physicsWorld.step(this._deltaTime) : this.physicsWorld.step(this._deltaTime, deltaTime, this._maxSubStep), 
                director.emit(Director.EVENT_AFTER_PHYSICS));
            }
        }, {
            key: "raycast",
            value: function raycast(worldRay) {
                var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4294967295, maxDistance = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e7, queryTrigger = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
                return this.raycastResultPool.reset(), this.raycastResults.length = 0, this.raycastOptions.mask = mask, 
                this.raycastOptions.maxDistance = maxDistance, this.raycastOptions.queryTrigger = queryTrigger, 
                this.physicsWorld.raycast(worldRay, this.raycastOptions, this.raycastResultPool, this.raycastResults);
            }
        }, {
            key: "raycastClosest",
            value: function raycastClosest(worldRay) {
                var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4294967295, maxDistance = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e7, queryTrigger = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
                return this.raycastOptions.mask = mask, this.raycastOptions.maxDistance = maxDistance, 
                this.raycastOptions.queryTrigger = queryTrigger, this.physicsWorld.raycastClosest(worldRay, this.raycastOptions, this.raycastClosestResult);
            }
        }, {
            key: "_updateMaterial",
            value: function _updateMaterial() {
                this.physicsWorld.defaultMaterial = this._material;
            }
        } ]), PhysicsSystem;
    }(System)).prototype, "_enable", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor2$1d = _applyDecoratedDescriptor(_class2$1A.prototype, "_allowSleep", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor3$$ = _applyDecoratedDescriptor(_class2$1A.prototype, "_gravity", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(0, -10, 0);
        }
    }), _descriptor4$R = _applyDecoratedDescriptor(_class2$1A.prototype, "_maxSubStep", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor5$I = _applyDecoratedDescriptor(_class2$1A.prototype, "_deltaTime", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1 / 60;
        }
    }), _descriptor6$u = _applyDecoratedDescriptor(_class2$1A.prototype, "_useFixedTime", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _class$1N = _class2$1A)) || _class$1N;
    director.on(Director.EVENT_INIT, (function() {
        var sys = new cc.PhysicsSystem;
        cc.PhysicsSystem._instance = sys, director.registerSystem(PhysicsSystem.ID, sys, 0);
    }));
    var v3_cannon0 = new cannon_min.Vec3, v3_cannon1 = new cannon_min.Vec3, CannonRigidBody = function() {
        function CannonRigidBody() {
            _classCallCheck(this, CannonRigidBody), this._isEnabled = !1;
        }
        return _createClass(CannonRigidBody, [ {
            key: "__preload",
            value: function __preload(com) {
                this._rigidBody = com, this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._rigidBody.node), 
                this._sharedBody.reference = !0, this._sharedBody.wrappedBody = this;
            }
        }, {
            key: "onLoad",
            value: function onLoad() {}
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._isEnabled = !0, this.mass = this._rigidBody.mass, this.allowSleep = this._rigidBody.allowSleep, 
                this.linearDamping = this._rigidBody.linearDamping, this.angularDamping = this._rigidBody.angularDamping, 
                this.useGravity = this._rigidBody.useGravity, this.isKinematic = this._rigidBody.isKinematic, 
                this.fixedRotation = this._rigidBody.fixedRotation, this.linearFactor = this._rigidBody.linearFactor, 
                this.angularFactor = this._rigidBody.angularFactor, this._sharedBody.enabled = !0;
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._isEnabled = !1, this._sharedBody.enabled = !1;
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._sharedBody.reference = !1, this._rigidBody = null, this._sharedBody = null;
            }
        }, {
            key: "wakeUp",
            value: function wakeUp() {
                return this._body.wakeUp();
            }
        }, {
            key: "sleep",
            value: function sleep() {
                return this._body.sleep();
            }
        }, {
            key: "getLinearVelocity",
            value: function getLinearVelocity(out) {
                return Vec3.copy(out, this._body.velocity), out;
            }
        }, {
            key: "setLinearVelocity",
            value: function setLinearVelocity(value) {
                this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.velocity, value);
            }
        }, {
            key: "getAngularVelocity",
            value: function getAngularVelocity(out) {
                return Vec3.copy(out, this._body.angularVelocity), out;
            }
        }, {
            key: "setAngularVelocity",
            value: function setAngularVelocity(value) {
                this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.angularVelocity, value);
            }
        }, {
            key: "applyForce",
            value: function applyForce(force, worldPoint) {
                null == worldPoint && (worldPoint = Vec3.ZERO), this._body.isSleeping() && this._body.wakeUp(), 
                this._body.applyForce(Vec3.copy(v3_cannon0, force), Vec3.copy(v3_cannon1, worldPoint));
            }
        }, {
            key: "applyImpulse",
            value: function applyImpulse(impulse, worldPoint) {
                null == worldPoint && (worldPoint = Vec3.ZERO), this._body.isSleeping() && this._body.wakeUp(), 
                this._body.applyImpulse(Vec3.copy(v3_cannon0, impulse), Vec3.copy(v3_cannon1, worldPoint));
            }
        }, {
            key: "applyLocalForce",
            value: function applyLocalForce(force, localPoint) {
                null == localPoint && (localPoint = Vec3.ZERO), this._body.isSleeping() && this._body.wakeUp(), 
                this._body.applyLocalForce(Vec3.copy(v3_cannon0, force), Vec3.copy(v3_cannon1, localPoint));
            }
        }, {
            key: "applyLocalImpulse",
            value: function applyLocalImpulse(impulse, localPoint) {
                null == localPoint && (localPoint = Vec3.ZERO), this._body.isSleeping() && this._body.wakeUp(), 
                this._body.applyLocalImpulse(Vec3.copy(v3_cannon0, impulse), Vec3.copy(v3_cannon1, localPoint));
            }
        }, {
            key: "applyTorque",
            value: function applyTorque(torque) {
                this._body.isSleeping() && this._body.wakeUp(), this._body.torque.x += torque.x, 
                this._body.torque.y += torque.y, this._body.torque.z += torque.z;
            }
        }, {
            key: "applyLocalTorque",
            value: function applyLocalTorque(torque) {
                this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(v3_cannon0, torque), this._body.vectorToWorldFrame(v3_cannon0, v3_cannon0), 
                this._body.torque.x += v3_cannon0.x, this._body.torque.y += v3_cannon0.y, this._body.torque.z += v3_cannon0.z;
            }
        }, {
            key: "getGroup",
            value: function getGroup() {
                return this._body.collisionFilterGroup;
            }
        }, {
            key: "setGroup",
            value: function setGroup(v) {
                this._body.collisionFilterGroup = v;
            }
        }, {
            key: "addGroup",
            value: function addGroup(v) {
                this._body.collisionFilterGroup |= v;
            }
        }, {
            key: "removeGroup",
            value: function removeGroup(v) {
                this._body.collisionFilterGroup &= ~v;
            }
        }, {
            key: "getMask",
            value: function getMask() {
                return this._body.collisionFilterMask;
            }
        }, {
            key: "setMask",
            value: function setMask(v) {
                this._body.collisionFilterMask = v;
            }
        }, {
            key: "addMask",
            value: function addMask(v) {
                this._body.collisionFilterMask |= v;
            }
        }, {
            key: "removeMask",
            value: function removeMask(v) {
                this._body.collisionFilterMask &= ~v;
            }
        }, {
            key: "isAwake",
            get: function get() {
                return this._body.isAwake();
            }
        }, {
            key: "isSleepy",
            get: function get() {
                return this._body.isSleepy();
            }
        }, {
            key: "isSleeping",
            get: function get() {
                return this._body.isSleeping();
            }
        }, {
            key: "allowSleep",
            set: function set(v) {
                this._body.isSleeping() && this._body.wakeUp(), this._body.allowSleep = v;
            }
        }, {
            key: "mass",
            set: function set(value) {
                this._body.mass = value, 0 == this._body.mass && (this._body.type = cannon_min.Body.STATIC), 
                this._body.updateMassProperties(), this._body.isSleeping() && this._body.wakeUp();
            }
        }, {
            key: "isKinematic",
            set: function set(value) {
                0 == this._body.mass ? this._body.type = cannon_min.Body.STATIC : this._body.type = value ? cannon_min.Body.KINEMATIC : cannon_min.Body.DYNAMIC;
            }
        }, {
            key: "fixedRotation",
            set: function set(value) {
                this._body.isSleeping() && this._body.wakeUp(), this._body.fixedRotation = value, 
                this._body.updateMassProperties();
            }
        }, {
            key: "linearDamping",
            set: function set(value) {
                this._body.linearDamping = value;
            }
        }, {
            key: "angularDamping",
            set: function set(value) {
                this._body.angularDamping = value;
            }
        }, {
            key: "useGravity",
            set: function set(value) {
                this._body.isSleeping() && this._body.wakeUp(), this._body.useGravity = value;
            }
        }, {
            key: "linearFactor",
            set: function set(value) {
                this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.linearFactor, value);
            }
        }, {
            key: "angularFactor",
            set: function set(value) {
                this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.angularFactor, value);
            }
        }, {
            key: "rigidBody",
            get: function get() {
                return this._rigidBody;
            }
        }, {
            key: "sharedBody",
            get: function get() {
                return this._sharedBody;
            }
        }, {
            key: "isEnabled",
            get: function get() {
                return this._isEnabled;
            }
        }, {
            key: "_body",
            get: function get() {
                return this._sharedBody.body;
            }
        } ]), CannonRigidBody;
    }();
    function setWrap(object, wrapper) {
        object.__cc_wrapper__ = wrapper;
    }
    function getWrap(object) {
        return object.__cc_wrapper__;
    }
    function toCannonRaycastOptions(out, options) {
        out.checkCollisionResponse = !options.queryTrigger, out.collisionFilterGroup = -1, 
        out.collisionFilterMask = options.mask, out.skipBackFaces = !1;
    }
    function fillRaycastResult(result, cannonResult) {
        result._assign(Vec3.copy(new Vec3, cannonResult.hitPointWorld), cannonResult.distance, getWrap(cannonResult.shape).collider);
    }
    function commitShapeUpdates(body) {
        body.updateMassProperties(), body.updateBoundingRadius(), body.aabbNeedsUpdate = !0;
    }
    var ERigidBodyType, TriggerEventObject = {
        type: "onTriggerEnter",
        selfCollider: null,
        otherCollider: null
    }, CannonShape = function() {
        function CannonShape() {
            _classCallCheck(this, CannonShape), this._offset = new cannon_min.Vec3, this._orient = new cannon_min.Quaternion, 
            this._index = -1, this.onTriggerListener = this.onTrigger.bind(this);
        }
        return _createClass(CannonShape, [ {
            key: "__preload",
            value: function __preload(comp) {
                this._collider = comp, setWrap(this._shape, this), this._shape.addEventListener("triggered", this.onTriggerListener), 
                this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._collider.node), 
                this._sharedBody.reference = !0;
            }
        }, {
            key: "onLoad",
            value: function onLoad() {
                this.center = this._collider.center, this.isTrigger = this._collider.isTrigger;
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._sharedBody.addShape(this), this._sharedBody.enabled = !0;
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._sharedBody.removeShape(this), this._sharedBody.enabled = !1;
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._sharedBody.reference = !1, this._sharedBody = null, setWrap(this._shape, null), 
                this._offset = null, this._orient = null, this._shape = null, this._collider = null, 
                this.onTriggerListener = null;
            }
        }, {
            key: "getGroup",
            value: function getGroup() {
                return this._body.collisionFilterGroup;
            }
        }, {
            key: "setGroup",
            value: function setGroup(v) {
                this._body.collisionFilterGroup = v;
            }
        }, {
            key: "addGroup",
            value: function addGroup(v) {
                this._body.collisionFilterGroup |= v;
            }
        }, {
            key: "removeGroup",
            value: function removeGroup(v) {
                this._body.collisionFilterGroup &= ~v;
            }
        }, {
            key: "getMask",
            value: function getMask() {
                return this._body.collisionFilterMask;
            }
        }, {
            key: "setMask",
            value: function setMask(v) {
                this._body.collisionFilterMask = v;
            }
        }, {
            key: "addMask",
            value: function addMask(v) {
                this._body.collisionFilterMask |= v;
            }
        }, {
            key: "removeMask",
            value: function removeMask(v) {
                this._body.collisionFilterMask &= ~v;
            }
        }, {
            key: "setScale",
            value: function setScale(scale) {
                this.center = this._collider.center;
            }
        }, {
            key: "setIndex",
            value: function setIndex(index) {
                this._index = index;
            }
        }, {
            key: "setOffsetAndOrient",
            value: function setOffsetAndOrient(offset, Orient) {
                this._offset = offset, this._orient = Orient;
            }
        }, {
            key: "onTrigger",
            value: function onTrigger(event) {
                TriggerEventObject.type = event.event;
                var self = getWrap(event.selfShape), other = getWrap(event.otherShape);
                self && (TriggerEventObject.selfCollider = self.collider, TriggerEventObject.otherCollider = other ? other.collider : null, 
                this._collider.emit(TriggerEventObject.type, TriggerEventObject));
            }
        }, {
            key: "shape",
            get: function get() {
                return this._shape;
            }
        }, {
            key: "collider",
            get: function get() {
                return this._collider;
            }
        }, {
            key: "attachedRigidBody",
            get: function get() {
                return this._sharedBody.wrappedBody ? this._sharedBody.wrappedBody.rigidBody : null;
            }
        }, {
            key: "sharedBody",
            get: function get() {
                return this._sharedBody;
            }
        }, {
            key: "material",
            set: function set(mat) {
                null == mat ? this._shape.material = null : (null == CannonShape.idToMaterial[mat._uuid] && (CannonShape.idToMaterial[mat._uuid] = new cannon_min.Material(mat._uuid)), 
                this._shape.material = CannonShape.idToMaterial[mat._uuid], this._shape.material.friction = mat.friction, 
                this._shape.material.restitution = mat.restitution);
            }
        }, {
            key: "isTrigger",
            set: function set(v) {
                this._shape.collisionResponse = !v, this._index >= 0 && this._body.updateHasTrigger();
            }
        }, {
            key: "center",
            set: function set(v) {
                var lpos = this._offset;
                Vec3.copy(lpos, v), Vec3.multiply(lpos, lpos, this._collider.node.worldScale), this._index >= 0 && commitShapeUpdates(this._body);
            }
        }, {
            key: "_body",
            get: function get() {
                return this._sharedBody.body;
            }
        } ]), CannonShape;
    }();
    CannonShape.idToMaterial = {}, function(ERigidBodyType) {
        ERigidBodyType[ERigidBodyType.DYNAMIC = 1] = "DYNAMIC", ERigidBodyType[ERigidBodyType.STATIC = 2] = "STATIC", 
        ERigidBodyType[ERigidBodyType.KINEMATIC = 4] = "KINEMATIC";
    }(ERigidBodyType || (ERigidBodyType = {}));
    var v3_0 = new Vec3, quat_0 = new Quat, contactsPool = [], CollisionEventObject = {
        type: "onCollisionEnter",
        selfCollider: null,
        otherCollider: null,
        contacts: []
    }, CannonSharedBody = function() {
        function CannonSharedBody(node, wrappedWorld) {
            _classCallCheck(this, CannonSharedBody), this.body = new cannon_min.Body, this.shapes = [], 
            this.wrappedBody = null, this.index = -1, this.ref = 0, this.onCollidedListener = this.onCollided.bind(this), 
            this.wrappedWorld = wrappedWorld, this.node = node, this.body.material = this.wrappedWorld.world.defaultMaterial, 
            this.body.addEventListener("collide", this.onCollidedListener);
        }
        return _createClass(CannonSharedBody, [ {
            key: "enabled",
            set: function set(v) {
                v ? this.index < 0 && (this.index = this.wrappedWorld.bodies.length, this.wrappedWorld.addSharedBody(this), 
                this.syncInitial()) : this.index >= 0 && (0 == this.shapes.length && null == this.wrappedBody || 0 == this.shapes.length && null != this.wrappedBody && !this.wrappedBody.rigidBody.enabledInHierarchy || 0 == this.shapes.length && null != this.wrappedBody && !this.wrappedBody.isEnabled) && (this.body.sleep(), 
                this.index = -1, this.wrappedWorld.removeSharedBody(this));
            }
        }, {
            key: "reference",
            set: function set(v) {
                v ? this.ref++ : this.ref--, 0 == this.ref && this.destroy();
            }
        } ], [ {
            key: "getSharedBody",
            value: function getSharedBody(node, wrappedWorld) {
                var key = node.uuid;
                if (CannonSharedBody.sharedBodesMap.has(key)) return CannonSharedBody.sharedBodesMap.get(key);
                var newSB = new CannonSharedBody(node, wrappedWorld);
                return CannonSharedBody.sharedBodesMap.set(node.uuid, newSB), newSB;
            }
        } ]), _createClass(CannonSharedBody, [ {
            key: "addShape",
            value: function addShape(v) {
                if (this.shapes.indexOf(v) < 0) {
                    var _index = this.body.shapes.length;
                    this.body.addShape(v.shape), this.shapes.push(v), v.setIndex(_index);
                    var offset = this.body.shapeOffsets[_index], orient = this.body.shapeOrientations[_index];
                    v.setOffsetAndOrient(offset, orient);
                }
            }
        }, {
            key: "removeShape",
            value: function removeShape(v) {
                var index = this.shapes.indexOf(v);
                index >= 0 && (this.shapes.splice(index, 1), this.body.removeShape(v.shape), v.setIndex(-1));
            }
        }, {
            key: "syncSceneToPhysics",
            value: function syncSceneToPhysics() {
                if (this.node.hasChangedFlags) {
                    if (Vec3.copy(this.body.position, this.node.worldPosition), Quat.copy(this.body.quaternion, this.node.worldRotation), 
                    this.node.hasChangedFlags & TransformBit.SCALE) for (var i = 0; i < this.shapes.length; i++) this.shapes[i].setScale(this.node.worldScale);
                    this.body.isSleeping() && this.body.wakeUp();
                }
            }
        }, {
            key: "syncPhysicsToScene",
            value: function syncPhysicsToScene() {
                this.body.type != ERigidBodyType.STATIC && (Vec3.copy(v3_0, this.body.position), 
                Quat.copy(quat_0, this.body.quaternion), this.node.worldPosition = v3_0, this.node.worldRotation = quat_0);
            }
        }, {
            key: "syncInitial",
            value: function syncInitial() {
                Vec3.copy(this.body.position, this.node.worldPosition), Quat.copy(this.body.quaternion, this.node.worldRotation);
                for (var i = 0; i < this.shapes.length; i++) this.shapes[i].setScale(this.node.worldScale);
                this.body.isSleeping() && this.body.wakeUp();
            }
        }, {
            key: "destroy",
            value: function destroy() {
                CannonSharedBody.sharedBodesMap.delete(this.node.uuid), this.node = null, this.wrappedWorld = null, 
                this.body = null, this.shapes = null, this.onCollidedListener = null;
            }
        }, {
            key: "onCollided",
            value: function onCollided(event) {
                CollisionEventObject.type = event.event;
                var self = getWrap(event.selfShape), other = getWrap(event.otherShape);
                if (self) {
                    CollisionEventObject.selfCollider = self.collider, CollisionEventObject.otherCollider = other ? other.collider : null;
                    var i = 0;
                    for (i = CollisionEventObject.contacts.length; i--; ) contactsPool.push(CollisionEventObject.contacts.pop());
                    for (i = 0; i < event.contacts.length; i++) {
                        var cq = event.contacts[i];
                        if (contactsPool.length > 0) {
                            var c = contactsPool.pop();
                            Vec3.copy(c.contactA, cq.ri), Vec3.copy(c.contactB, cq.rj), Vec3.copy(c.normal, cq.ni), 
                            CollisionEventObject.contacts.push(c);
                        } else {
                            var _c = {
                                contactA: Vec3.copy(new Vec3, cq.ri),
                                contactB: Vec3.copy(new Vec3, cq.rj),
                                normal: Vec3.copy(new Vec3, cq.ni)
                            };
                            CollisionEventObject.contacts.push(_c);
                        }
                    }
                    for (i = 0; i < this.shapes.length; i++) {
                        this.shapes[i].collider.emit(CollisionEventObject.type, CollisionEventObject);
                    }
                }
            }
        } ]), CannonSharedBody;
    }();
    CannonSharedBody.sharedBodesMap = new Map;
    var CannonWorld = function() {
        function CannonWorld() {
            _classCallCheck(this, CannonWorld), this.bodies = [], this._raycastResult = new cannon_min.RaycastResult, 
            this._world = new cannon_min.World, this._world.broadphase = new cannon_min.NaiveBroadphase;
        }
        return _createClass(CannonWorld, [ {
            key: "world",
            get: function get() {
                return this._world;
            }
        }, {
            key: "defaultMaterial",
            set: function set(mat) {
                this._world.defaultMaterial.friction = mat.friction, this._world.defaultMaterial.restitution = mat.restitution, 
                null != CannonShape.idToMaterial[mat._uuid] && (CannonShape.idToMaterial[mat._uuid] = this._world.defaultMaterial);
            }
        }, {
            key: "allowSleep",
            set: function set(v) {
                this._world.allowSleep = v;
            }
        }, {
            key: "gravity",
            set: function set(gravity) {
                Vec3.copy(this._world.gravity, gravity);
            }
        } ]), _createClass(CannonWorld, [ {
            key: "step",
            value: function step(deltaTime, timeSinceLastCalled, maxSubStep) {
                for (var i = 0; i < this.bodies.length; i++) this.bodies[i].syncSceneToPhysics();
                this._world.step(deltaTime, timeSinceLastCalled, maxSubStep);
                for (var _i = 0; _i < this.bodies.length; _i++) this.bodies[_i].syncPhysicsToScene();
                this._world.emitTriggeredEvents(), this._world.emitCollisionEvents();
                for (var _i2 = 0; _i2 < this.bodies.length; _i2++) this.bodies[_i2].syncSceneToPhysics();
            }
        }, {
            key: "raycastClosest",
            value: function raycastClosest(worldRay, options, result) {
                setupFromAndTo(worldRay, options.maxDistance), toCannonRaycastOptions(raycastOpt, options);
                var hit = this._world.raycastClosest(from, to, raycastOpt, this._raycastResult);
                return hit && fillRaycastResult(result, this._raycastResult), hit;
            }
        }, {
            key: "raycast",
            value: function raycast(worldRay, options, pool, results) {
                return setupFromAndTo(worldRay, options.maxDistance), toCannonRaycastOptions(raycastOpt, options), 
                this._world.raycastAll(from, to, raycastOpt, (function(result) {
                    var r = pool.add();
                    fillRaycastResult(r, result), results.push(r);
                }));
            }
        }, {
            key: "getSharedBody",
            value: function getSharedBody(node) {
                return CannonSharedBody.getSharedBody(node, this);
            }
        }, {
            key: "addSharedBody",
            value: function addSharedBody(sharedBody) {
                this.bodies.indexOf(sharedBody) < 0 && (this.bodies.push(sharedBody), this._world.addBody(sharedBody.body));
            }
        }, {
            key: "removeSharedBody",
            value: function removeSharedBody(sharedBody) {
                var i = this.bodies.indexOf(sharedBody);
                i >= 0 && (this.bodies.splice(i, 1), this._world.remove(sharedBody.body));
            }
        }, {
            key: "addConstraint",
            value: function addConstraint(constraint) {
                this._world.addConstraint(constraint.impl);
            }
        }, {
            key: "removeConstraint",
            value: function removeConstraint(constraint) {
                this._world.removeConstraint(constraint.impl);
            }
        } ]), CannonWorld;
    }(), from = new cannon_min.Vec3, to = new cannon_min.Vec3;
    function setupFromAndTo(worldRay, distance) {
        Vec3.copy(from, worldRay.o), worldRay.computeHit(to, distance);
    }
    var _dec$1N, _dec2$1k, _dec3$12, _dec4$V, _dec5$S, _class$1O, _class2$1B, _descriptor$1q, _descriptor2$1e, _descriptor3$10, raycastOpt = {
        checkCollisionResponse: !1,
        collisionFilterGroup: -1,
        collisionFilterMask: -1,
        skipBackFaces: !1
    };
    (function instantiate$1(boxShape, sphereShape, body, world, capsuleShape) {
        BoxShape = boxShape, SphereShape = sphereShape, RigidBody = body, PhysicsWorld = world, 
        capsuleShape && capsuleShape;
    })(function(_CannonShape) {
        function CannonBoxShape(size) {
            var _this;
            return _classCallCheck(this, CannonBoxShape), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CannonBoxShape).call(this))).halfExtent = new cannon_min.Vec3, 
            Vec3.multiplyScalar(_this.halfExtent, size, .5), _this._shape = new cannon_min.Box(_this.halfExtent.clone()), 
            _this;
        }
        return _inherits(CannonBoxShape, _CannonShape), _createClass(CannonBoxShape, [ {
            key: "boxCollider",
            get: function get() {
                return this.collider;
            }
        }, {
            key: "box",
            get: function get() {
                return this._shape;
            }
        } ]), _createClass(CannonBoxShape, [ {
            key: "onLoad",
            value: function onLoad() {
                _get(_getPrototypeOf(CannonBoxShape.prototype), "onLoad", this).call(this), this.size = this.boxCollider.size;
            }
        }, {
            key: "setScale",
            value: function setScale(scale) {
                _get(_getPrototypeOf(CannonBoxShape.prototype), "setScale", this).call(this, scale), 
                this.size = this.boxCollider.size;
            }
        }, {
            key: "size",
            set: function set(v) {
                Vec3.multiplyScalar(this.halfExtent, v, .5), Vec3.multiply(this.box.halfExtents, this.halfExtent, this.collider.node.worldScale), 
                this.box.updateConvexPolyhedronRepresentation(), -1 != this._index && commitShapeUpdates(this._body);
            }
        } ]), CannonBoxShape;
    }(CannonShape), function(_CannonShape) {
        function CannonSphereShape(radius) {
            var _this;
            return _classCallCheck(this, CannonSphereShape), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CannonSphereShape).call(this)))._radius = radius, 
            _this._shape = new cannon_min.Sphere(_this._radius), _this;
        }
        return _inherits(CannonSphereShape, _CannonShape), _createClass(CannonSphereShape, [ {
            key: "sphereCollider",
            get: function get() {
                return this.collider;
            }
        }, {
            key: "sphere",
            get: function get() {
                return this._shape;
            }
        }, {
            key: "radius",
            get: function get() {
                return this._radius;
            },
            set: function set(v) {
                var max = function maxComponent$1(v) {
                    return Math.max(v.x, Math.max(v.y, v.z));
                }(this.collider.node.worldScale);
                this.sphere.radius = v * Math.abs(max), this.sphere.updateBoundingSphereRadius(), 
                -1 != this._index && commitShapeUpdates(this._body);
            }
        } ]), _createClass(CannonSphereShape, [ {
            key: "onLoad",
            value: function onLoad() {
                _get(_getPrototypeOf(CannonSphereShape.prototype), "onLoad", this).call(this), this.radius = this.sphereCollider.radius;
            }
        }, {
            key: "setScale",
            value: function setScale(scale) {
                _get(_getPrototypeOf(CannonSphereShape.prototype), "setScale", this).call(this, scale), 
                this.radius = this.sphereCollider.radius;
            }
        } ]), CannonSphereShape;
    }(CannonShape), CannonRigidBody, CannonWorld), window && (window.CANNON = cannon_min);
    var _dec$1O, _dec2$1l, _dec3$13, _dec4$W, _class$1P, _class2$1C, _descriptor$1r, ColliderComponent = (_dec$1N = ccclass("cc.ColliderComponent"), 
    _dec2$1k = property({
        type: PhysicMaterial,
        displayName: "Material",
        displayOrder: -1,
        tooltip: "源材质"
    }), _dec3$12 = property({
        displayOrder: 0,
        tooltip: "是否与其它碰撞器产生碰撞，并产生物理行为"
    }), _dec4$V = property({
        type: Vec3,
        displayOrder: 1,
        tooltip: "形状的中心点（与所在 Node 中心点的相对位置）"
    }), _dec5$S = property({
        type: PhysicMaterial
    }), _dec$1N((_applyDecoratedDescriptor((_class2$1B = function(_Component) {
        function ColliderComponent() {
            var _this;
            return _classCallCheck(this, ColliderComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ColliderComponent).call(this)))._callbackTable = createMap(!0), 
            _this._isSharedMaterial = !0, _initializerDefineProperty(_this, "_material", _descriptor$1q, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isTrigger", _descriptor2$1e, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_center", _descriptor3$10, _assertThisInitialized(_this)), 
            _this;
        }
        return _inherits(ColliderComponent, _Component), _createClass(ColliderComponent, [ {
            key: "sharedMaterial",
            get: function get() {
                return this._material;
            },
            set: function set(value) {
                this.material = value;
            }
        }, {
            key: "material",
            get: function get() {
                return this._isSharedMaterial && null != this._material && (this._material.off("physics_material_update", this._updateMaterial, this), 
                this._material = this._material.clone(), this._material.on("physics_material_update", this._updateMaterial, this), 
                this._isSharedMaterial = !1), this._material;
            },
            set: function set(value) {
                null != value && null != this._material ? this._material._uuid != value._uuid && (this._material.off("physics_material_update", this._updateMaterial, this), 
                value.on("physics_material_update", this._updateMaterial, this), this._isSharedMaterial = !1, 
                this._material = value) : null != value && null == this._material ? (value.on("physics_material_update", this._updateMaterial, this), 
                this._material = value) : null == value && null != this._material && (this._material.off("physics_material_update", this._updateMaterial, this), 
                this._material = value), this._updateMaterial();
            }
        }, {
            key: "isTrigger",
            get: function get() {
                return this._isTrigger;
            },
            set: function set(value) {
                this._isTrigger = value, this._shape.isTrigger = this._isTrigger;
            }
        }, {
            key: "center",
            get: function get() {
                return this._center;
            },
            set: function set(value) {
                Vec3.copy(this._center, value), this._shape.center = this._center;
            }
        }, {
            key: "attachedRigidbody",
            get: function get() {
                return this.shape.attachedRigidBody;
            }
        }, {
            key: "shape",
            get: function get() {
                return this._shape;
            }
        }, {
            key: "_assertOnload",
            get: function get() {
                var r = 0 == this._isOnLoadCalled;
                return r && error("Physics Error: Please make sure that the node has been added to the scene"), 
                !r;
            }
        } ]), _createClass(ColliderComponent, [ {
            key: "on",
            value: function on(type, callback, target, useCapture) {}
        }, {
            key: "off",
            value: function off(type, callback, target, useCapture) {}
        }, {
            key: "once",
            value: function once(type, callback, target, useCapture) {}
        }, {
            key: "targetOff",
            value: function targetOff(keyOrTarget) {}
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {}
        }, {
            key: "hasEventListener",
            value: function hasEventListener(key, callback, target) {
                return !1;
            }
        }, {
            key: "removeAll",
            value: function removeAll(keyOrTarget) {}
        }, {
            key: "emit",
            value: function emit(key) {}
        }, {
            key: "setGroup",
            value: function setGroup(v) {
                this._shape.setGroup(v);
            }
        }, {
            key: "getGroup",
            value: function getGroup() {
                return this._shape.getGroup();
            }
        }, {
            key: "addGroup",
            value: function addGroup(v) {
                this._shape.addGroup(v);
            }
        }, {
            key: "removeGroup",
            value: function removeGroup(v) {
                this._shape.removeGroup(v);
            }
        }, {
            key: "getMask",
            value: function getMask() {
                return this._shape.getMask();
            }
        }, {
            key: "setMask",
            value: function setMask(v) {
                this._shape.setMask(v);
            }
        }, {
            key: "addMask",
            value: function addMask(v) {
                this._shape.addMask(v);
            }
        }, {
            key: "removeMask",
            value: function removeMask(v) {
                this._shape.removeMask(v);
            }
        }, {
            key: "__preload",
            value: function __preload() {
                this._shape.__preload(this);
            }
        }, {
            key: "onLoad",
            value: function onLoad() {
                this.sharedMaterial = null == this._material ? PhysicsSystem.instance.defaultMaterial : this._material, 
                this._shape.onLoad();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._shape.onEnable();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._shape.onDisable();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._shape.onDestroy();
            }
        }, {
            key: "_updateMaterial",
            value: function _updateMaterial() {
                this._shape.material = this._material;
            }
        } ]), ColliderComponent;
    }(Component)).prototype, "sharedMaterial", [ _dec2$1k ], Object.getOwnPropertyDescriptor(_class2$1B.prototype, "sharedMaterial"), _class2$1B.prototype), 
    _applyDecoratedDescriptor(_class2$1B.prototype, "isTrigger", [ _dec3$12 ], Object.getOwnPropertyDescriptor(_class2$1B.prototype, "isTrigger"), _class2$1B.prototype), 
    _applyDecoratedDescriptor(_class2$1B.prototype, "center", [ _dec4$V ], Object.getOwnPropertyDescriptor(_class2$1B.prototype, "center"), _class2$1B.prototype), 
    _descriptor$1q = _applyDecoratedDescriptor(_class2$1B.prototype, "_material", [ _dec5$S ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$1e = _applyDecoratedDescriptor(_class2$1B.prototype, "_isTrigger", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$10 = _applyDecoratedDescriptor(_class2$1B.prototype, "_center", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3;
        }
    }), _class$1O = _class2$1B)) || _class$1O);
    applyMixins(ColliderComponent, [ CallbacksInvoker, EventTarget ]);
    var _dec$1P, _dec2$1m, _dec3$14, _dec4$X, _class$1Q, _class2$1D, _descriptor$1s, _dec$1Q, _dec2$1n, _dec3$15, _dec4$Y, _dec5$T, _dec6$K, _class$1R, _class2$1E, _descriptor$1t, _descriptor2$1f, _descriptor3$11, ECapsuleDirection, BoxColliderComponent = (_dec$1O = ccclass("cc.BoxColliderComponent"), 
    _dec2$1l = executionOrder(98), _dec3$13 = menu("Components/BoxCollider"), _dec4$W = property({
        type: Vec3,
        tooltip: "盒的大小，即长、宽、高"
    }), _dec$1O(_class$1P = _dec2$1l(_class$1P = _dec3$13(_class$1P = executeInEditMode((_applyDecoratedDescriptor((_class2$1C = function(_ColliderComponent) {
        function BoxColliderComponent() {
            var _this;
            return _classCallCheck(this, BoxColliderComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BoxColliderComponent).call(this)), "_size", _descriptor$1r, _assertThisInitialized(_this)), 
            _this._shape = function createBoxShape(size) {
                return checkPhysicsModule(BoxShape) ? null : new BoxShape(size);
            }(_this._size), _this;
        }
        return _inherits(BoxColliderComponent, _ColliderComponent), _createClass(BoxColliderComponent, [ {
            key: "size",
            get: function get() {
                return this._size;
            },
            set: function set(value) {
                Vec3.copy(this._size, value), this.boxShape.size = this._size;
            }
        }, {
            key: "boxShape",
            get: function get() {
                return this._shape;
            }
        } ]), BoxColliderComponent;
    }(ColliderComponent)).prototype, "size", [ _dec4$W ], Object.getOwnPropertyDescriptor(_class2$1C.prototype, "size"), _class2$1C.prototype), 
    _descriptor$1r = _applyDecoratedDescriptor(_class2$1C.prototype, "_size", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(1, 1, 1);
        }
    }), _class$1P = _class2$1C)) || _class$1P) || _class$1P) || _class$1P) || _class$1P), SphereColliderComponent = (_dec$1P = ccclass("cc.SphereColliderComponent"), 
    _dec2$1m = executionOrder(98), _dec3$14 = menu("Components/SphereCollider"), _dec4$X = property({
        tooltip: "球的半径"
    }), _dec$1P(_class$1Q = _dec2$1m(_class$1Q = _dec3$14(_class$1Q = executeInEditMode((_applyDecoratedDescriptor((_class2$1D = function(_ColliderComponent) {
        function SphereColliderComponent() {
            var _this;
            return _classCallCheck(this, SphereColliderComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereColliderComponent).call(this)), "_radius", _descriptor$1s, _assertThisInitialized(_this)), 
            _this._shape = function createSphereShape(radius) {
                return checkPhysicsModule(SphereShape) ? null : new SphereShape(radius);
            }(_this._radius), _this;
        }
        return _inherits(SphereColliderComponent, _ColliderComponent), _createClass(SphereColliderComponent, [ {
            key: "radius",
            get: function get() {
                return this._radius;
            },
            set: function set(value) {
                this._radius = value, this.sphereShape.radius = this._radius;
            }
        }, {
            key: "sphereShape",
            get: function get() {
                return this._shape;
            }
        } ]), SphereColliderComponent;
    }(ColliderComponent)).prototype, "radius", [ _dec4$X ], Object.getOwnPropertyDescriptor(_class2$1D.prototype, "radius"), _class2$1D.prototype), 
    _descriptor$1s = _applyDecoratedDescriptor(_class2$1D.prototype, "_radius", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _class$1Q = _class2$1D)) || _class$1Q) || _class$1Q) || _class$1Q) || _class$1Q);
    !function(ECapsuleDirection) {
        ECapsuleDirection[ECapsuleDirection.X_AXIS = 0] = "X_AXIS", ECapsuleDirection[ECapsuleDirection.Y_AXIS = 1] = "Y_AXIS", 
        ECapsuleDirection[ECapsuleDirection.Z_AXIS = 2] = "Z_AXIS";
    }(ECapsuleDirection || (ECapsuleDirection = {})), Enum(ECapsuleDirection);
    var _dec$1R, _dec2$1o, _dec3$16, _dec4$Z, _dec5$U, _dec6$L, _dec7$E, _dec8$s, _dec9$m, _dec10$k, _dec11$k, _class$1S, _class2$1F, _descriptor$1u, _descriptor2$1g, _descriptor3$12, _descriptor4$S, _descriptor5$J, _descriptor6$v, _descriptor7$p, _descriptor8$l, _dec$1S, _dec2$1p, _dec3$17, _dec4$_, _dec5$V, _dec6$M, _dec7$F, _dec8$t, _class$1T, _class2$1G, _descriptor$1v, _descriptor2$1h, _descriptor3$13, _descriptor4$T, _dec$1T, _dec2$1q, _dec3$18, _dec4$$, _dec5$W, _dec6$N, _dec7$G, _class$1U, _class2$1H, _descriptor$1w, _descriptor2$1i, _descriptor3$14, _descriptor4$U, CapsuleColliderComponent = (_dec$1Q = ccclass("cc.CapsuleColliderComponent"), 
    _dec2$1n = executionOrder(98), _dec3$15 = menu("Components/CapsuleCollider"), _dec4$Y = property({
        tooltip: "胶囊体上的球的半径"
    }), _dec5$T = property({
        tooltip: "胶囊体在相应轴向的高度"
    }), _dec6$K = property({
        type: ECapsuleDirection
    }), _dec$1Q(_class$1R = _dec2$1n(_class$1R = _dec3$15(_class$1R = executeInEditMode((_applyDecoratedDescriptor((_class2$1E = function(_ColliderComponent) {
        function CapsuleColliderComponent() {
            var _this;
            return _classCallCheck(this, CapsuleColliderComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(CapsuleColliderComponent).call(this)), "_radius", _descriptor$1t, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_height", _descriptor2$1f, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_direction", _descriptor3$11, _assertThisInitialized(_this)), 
            _this._shape = function createCapsuleShape() {
                var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, height = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, dir = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                return warn("[v1.0.3][Physics]: Currently cannon.js unsupport capsule collider"), 
                {
                    radius: radius,
                    height: height,
                    direction: dir,
                    material: null,
                    isTrigger: !1,
                    center: new Vec3,
                    __preload: function __preload() {},
                    onLoad: function onLoad() {},
                    onEnable: function onEnable() {},
                    onDisable: function onDisable() {},
                    onDestroy: function onDestroy() {}
                };
            }(), _this;
        }
        return _inherits(CapsuleColliderComponent, _ColliderComponent), _createClass(CapsuleColliderComponent, [ {
            key: "radius",
            get: function get() {
                return this._radius;
            },
            set: function set(value) {
                value < 0 && (value = 0), this._radius = value;
                var doubleR = 2 * this._radius;
                this._height < doubleR && (this._height = doubleR), this.capsuleShape.radius = this._radius;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            },
            set: function set(value) {
                value < 2 * this._radius && (value = 2 * this._radius), this._height = value, this.capsuleShape.height = this._height;
            }
        }, {
            key: "direction",
            get: function get() {
                return this._direction;
            },
            set: function set(value) {
                this._direction = value;
            }
        }, {
            key: "capsuleShape",
            get: function get() {
                return this._shape;
            }
        } ]), CapsuleColliderComponent;
    }(ColliderComponent)).prototype, "radius", [ _dec4$Y ], Object.getOwnPropertyDescriptor(_class2$1E.prototype, "radius"), _class2$1E.prototype), 
    _applyDecoratedDescriptor(_class2$1E.prototype, "height", [ _dec5$T ], Object.getOwnPropertyDescriptor(_class2$1E.prototype, "height"), _class2$1E.prototype), 
    _applyDecoratedDescriptor(_class2$1E.prototype, "direction", [ _dec6$K ], Object.getOwnPropertyDescriptor(_class2$1E.prototype, "direction"), _class2$1E.prototype), 
    _descriptor$1t = _applyDecoratedDescriptor(_class2$1E.prototype, "_radius", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .5;
        }
    }), _descriptor2$1f = _applyDecoratedDescriptor(_class2$1E.prototype, "_height", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 2;
        }
    }), _descriptor3$11 = _applyDecoratedDescriptor(_class2$1E.prototype, "_direction", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return ECapsuleDirection.Y_AXIS;
        }
    }), _class$1R = _class2$1E)) || _class$1R) || _class$1R) || _class$1R) || _class$1R), RigidBodyComponent = (_dec$1R = ccclass("cc.RigidBodyComponent"), 
    _dec2$1o = executionOrder(99), _dec3$16 = menu("Components/RigidBody"), _dec4$Z = property({
        displayOrder: 0,
        tooltip: "刚体的质量"
    }), _dec5$U = property({
        displayOrder: 1,
        tooltip: "线性阻尼"
    }), _dec6$L = property({
        displayOrder: 2,
        tooltip: "旋转阻尼"
    }), _dec7$E = property({
        displayOrder: 3,
        tooltip: "刚体是否由物理系统控制运动"
    }), _dec8$s = property({
        displayOrder: 4,
        tooltip: "刚体是否使用重力"
    }), _dec9$m = property({
        displayOrder: 5,
        tooltip: "刚体是否固定旋转"
    }), _dec10$k = property({
        displayOrder: 6,
        tooltip: "线性速度的因子，可以用来控制每个轴方向上的速度的缩放"
    }), _dec11$k = property({
        displayOrder: 7,
        tooltip: "旋转速度的因子，可以用来控制每个轴方向上的旋转速度的缩放"
    }), _dec$1R(_class$1S = _dec2$1o(_class$1S = _dec3$16(_class$1S = executeInEditMode(_class$1S = disallowMultiple((_applyDecoratedDescriptor((_class2$1F = function(_Component) {
        function RigidBodyComponent() {
            var _this;
            return _classCallCheck(this, RigidBodyComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(RigidBodyComponent).call(this)))._allowSleep = !0, 
            _initializerDefineProperty(_this, "_mass", _descriptor$1u, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_linearDamping", _descriptor2$1g, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_angularDamping", _descriptor3$12, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_fixedRotation", _descriptor4$S, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_isKinematic", _descriptor5$J, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_useGravity", _descriptor6$v, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_linearFactor", _descriptor7$p, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_angularFactor", _descriptor8$l, _assertThisInitialized(_this)), 
            _this._body = function createRigidBody() {
                return checkPhysicsModule(RigidBody) ? null : new RigidBody;
            }(), _this;
        }
        return _inherits(RigidBodyComponent, _Component), _createClass(RigidBodyComponent, [ {
            key: "allowSleep",
            get: function get() {
                return this._allowSleep;
            },
            set: function set(v) {
                this._allowSleep = v, this._body.allowSleep = v;
            }
        }, {
            key: "mass",
            get: function get() {
                return this._mass;
            },
            set: function set(value) {
                this._mass = value, this._body.mass = value;
            }
        }, {
            key: "linearDamping",
            get: function get() {
                return this._linearDamping;
            },
            set: function set(value) {
                this._linearDamping = value, this._body.linearDamping = value;
            }
        }, {
            key: "angularDamping",
            get: function get() {
                return this._angularDamping;
            },
            set: function set(value) {
                this._angularDamping = value, this._body.angularDamping = value;
            }
        }, {
            key: "isKinematic",
            get: function get() {
                return this._isKinematic;
            },
            set: function set(value) {
                this._isKinematic = value, this._body.isKinematic = value;
            }
        }, {
            key: "useGravity",
            get: function get() {
                return this._useGravity;
            },
            set: function set(value) {
                this._useGravity = value, this._body.useGravity = value;
            }
        }, {
            key: "fixedRotation",
            get: function get() {
                return this._fixedRotation;
            },
            set: function set(value) {
                this._fixedRotation = value, this._body.fixedRotation = value;
            }
        }, {
            key: "linearFactor",
            get: function get() {
                return this._linearFactor;
            },
            set: function set(value) {
                Vec3.copy(this._linearFactor, value), this._body.linearFactor = this._linearFactor;
            }
        }, {
            key: "angularFactor",
            get: function get() {
                return this._angularFactor;
            },
            set: function set(value) {
                Vec3.copy(this._angularFactor, value), this._body.angularFactor = this._angularFactor;
            }
        }, {
            key: "isAwake",
            get: function get() {
                return !!this._assertOnload && this._body.isAwake;
            }
        }, {
            key: "isSleepy",
            get: function get() {
                return !!this._assertOnload && this._body.isSleepy;
            }
        }, {
            key: "isSleeping",
            get: function get() {
                return !!this._assertOnload && this._body.isSleeping;
            }
        }, {
            key: "rigidBody",
            get: function get() {
                return this._body;
            }
        }, {
            key: "_assertOnload",
            get: function get() {
                var r = 0 == this._isOnLoadCalled;
                return r && error("[Physics]: Please make sure that the node has been added to the scene"), 
                !r;
            }
        } ]), _createClass(RigidBodyComponent, [ {
            key: "__preload",
            value: function __preload() {
                this._body.__preload(this);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._body.onEnable();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._body.onDisable();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._body.onDestroy();
            }
        }, {
            key: "applyForce",
            value: function applyForce(force, relativePoint) {
                this._assertOnload && this._body.applyForce(force, relativePoint);
            }
        }, {
            key: "applyLocalForce",
            value: function applyLocalForce(force, localPoint) {
                this._assertOnload && this._body.applyLocalForce(force, localPoint);
            }
        }, {
            key: "applyImpulse",
            value: function applyImpulse(impulse, relativePoint) {
                this._assertOnload && this._body.applyImpulse(impulse, relativePoint);
            }
        }, {
            key: "applyLocalImpulse",
            value: function applyLocalImpulse(impulse, localPoint) {
                this._assertOnload && this._body.applyLocalImpulse(impulse, localPoint);
            }
        }, {
            key: "applyTorque",
            value: function applyTorque(torque) {
                this._assertOnload && this._body.applyTorque(torque);
            }
        }, {
            key: "applyLocalTorque",
            value: function applyLocalTorque(torque) {
                this._assertOnload && this._body.applyLocalTorque(torque);
            }
        }, {
            key: "wakeUp",
            value: function wakeUp() {
                this._assertOnload && this._body.wakeUp();
            }
        }, {
            key: "sleep",
            value: function sleep() {
                this._assertOnload && this._body.sleep();
            }
        }, {
            key: "getLinearVelocity",
            value: function getLinearVelocity(out) {
                this._assertOnload && this._body.getLinearVelocity(out);
            }
        }, {
            key: "setLinearVelocity",
            value: function setLinearVelocity(value) {
                this._assertOnload && this._body.setLinearVelocity(value);
            }
        }, {
            key: "getAngularVelocity",
            value: function getAngularVelocity(out) {
                this._assertOnload && this._body.getAngularVelocity(out);
            }
        }, {
            key: "setAngularVelocity",
            value: function setAngularVelocity(value) {
                this._assertOnload && this._body.setAngularVelocity(value);
            }
        }, {
            key: "setGroup",
            value: function setGroup(v) {
                this._assertOnload && this._body.setGroup(v);
            }
        }, {
            key: "getGroup",
            value: function getGroup() {
                return this._assertOnload ? this._body.getGroup() : 0;
            }
        }, {
            key: "addGroup",
            value: function addGroup(v) {
                this._assertOnload && this._body.addGroup(v);
            }
        }, {
            key: "removeGroup",
            value: function removeGroup(v) {
                this._assertOnload && this._body.removeGroup(v);
            }
        }, {
            key: "getMask",
            value: function getMask() {
                return this._assertOnload ? this._body.getMask() : 0;
            }
        }, {
            key: "setMask",
            value: function setMask(v) {
                this._assertOnload && this._body.setMask(v);
            }
        }, {
            key: "addMask",
            value: function addMask(v) {
                this._assertOnload && this._body.addMask(v);
            }
        }, {
            key: "removeMask",
            value: function removeMask(v) {
                this._assertOnload && this._body.removeMask(v);
            }
        } ]), RigidBodyComponent;
    }(Component)).prototype, "mass", [ _dec4$Z ], Object.getOwnPropertyDescriptor(_class2$1F.prototype, "mass"), _class2$1F.prototype), 
    _applyDecoratedDescriptor(_class2$1F.prototype, "linearDamping", [ _dec5$U ], Object.getOwnPropertyDescriptor(_class2$1F.prototype, "linearDamping"), _class2$1F.prototype), 
    _applyDecoratedDescriptor(_class2$1F.prototype, "angularDamping", [ _dec6$L ], Object.getOwnPropertyDescriptor(_class2$1F.prototype, "angularDamping"), _class2$1F.prototype), 
    _applyDecoratedDescriptor(_class2$1F.prototype, "isKinematic", [ _dec7$E ], Object.getOwnPropertyDescriptor(_class2$1F.prototype, "isKinematic"), _class2$1F.prototype), 
    _applyDecoratedDescriptor(_class2$1F.prototype, "useGravity", [ _dec8$s ], Object.getOwnPropertyDescriptor(_class2$1F.prototype, "useGravity"), _class2$1F.prototype), 
    _applyDecoratedDescriptor(_class2$1F.prototype, "fixedRotation", [ _dec9$m ], Object.getOwnPropertyDescriptor(_class2$1F.prototype, "fixedRotation"), _class2$1F.prototype), 
    _applyDecoratedDescriptor(_class2$1F.prototype, "linearFactor", [ _dec10$k ], Object.getOwnPropertyDescriptor(_class2$1F.prototype, "linearFactor"), _class2$1F.prototype), 
    _applyDecoratedDescriptor(_class2$1F.prototype, "angularFactor", [ _dec11$k ], Object.getOwnPropertyDescriptor(_class2$1F.prototype, "angularFactor"), _class2$1F.prototype), 
    _descriptor$1u = _applyDecoratedDescriptor(_class2$1F.prototype, "_mass", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 10;
        }
    }), _descriptor2$1g = _applyDecoratedDescriptor(_class2$1F.prototype, "_linearDamping", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _descriptor3$12 = _applyDecoratedDescriptor(_class2$1F.prototype, "_angularDamping", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _descriptor4$S = _applyDecoratedDescriptor(_class2$1F.prototype, "_fixedRotation", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor5$J = _applyDecoratedDescriptor(_class2$1F.prototype, "_isKinematic", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor6$v = _applyDecoratedDescriptor(_class2$1F.prototype, "_useGravity", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor7$p = _applyDecoratedDescriptor(_class2$1F.prototype, "_linearFactor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(1, 1, 1);
        }
    }), _descriptor8$l = _applyDecoratedDescriptor(_class2$1F.prototype, "_angularFactor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(1, 1, 1);
        }
    }), _class$1S = _class2$1F)) || _class$1S) || _class$1S) || _class$1S) || _class$1S) || _class$1S), ConstantForce = (_dec$1S = ccclass("cc.ConstantForce"), 
    _dec2$1p = executionOrder(98), _dec3$17 = requireComponent(RigidBodyComponent), 
    _dec4$_ = menu("Components/ConstantForce"), _dec5$V = property({
        displayOrder: 0,
        tooltip: "世界坐标系下的力"
    }), _dec6$M = property({
        displayOrder: 1,
        tooltip: "本地坐标系下的力"
    }), _dec7$F = property({
        displayOrder: 2,
        tooltip: "世界坐标系下的扭转力"
    }), _dec8$t = property({
        displayOrder: 3,
        tooltip: "本地坐标系下的扭转力"
    }), _dec$1S(_class$1T = _dec2$1p(_class$1T = _dec3$17(_class$1T = _dec4$_(_class$1T = disallowMultiple(_class$1T = executeInEditMode((_descriptor$1v = _applyDecoratedDescriptor((_class2$1G = function(_Component) {
        function ConstantForce() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ConstantForce);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ConstantForce)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._rigidbody = null, 
            _initializerDefineProperty(_this, "_force", _descriptor$1v, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_localForce", _descriptor2$1h, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_torque", _descriptor3$13, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_localTorque", _descriptor4$T, _assertThisInitialized(_this)), 
            _this._mask = 0, _this;
        }
        return _inherits(ConstantForce, _Component), _createClass(ConstantForce, [ {
            key: "onLoad",
            value: function onLoad() {
                this._rigidbody = this.node.getComponent(RigidBodyComponent), this._maskUpdate(this._force, 1), 
                this._maskUpdate(this._localForce, 2), this._maskUpdate(this._torque, 4), this._maskUpdate(this._localTorque, 8);
            }
        }, {
            key: "lateUpdate",
            value: function lateUpdate(dt) {
                null != this._rigidbody && 0 != this._mask && (1 & this._mask && this._rigidbody.applyForce(this._force), 
                2 & this._mask && this._rigidbody.applyLocalForce(this.localForce), 4 & this._mask && this._rigidbody.applyTorque(this._torque), 
                8 & this._mask && this._rigidbody.applyLocalTorque(this._localTorque));
            }
        }, {
            key: "_maskUpdate",
            value: function _maskUpdate(t, m) {
                t.strictEquals(Vec3.ZERO) ? this._mask &= ~m : this._mask |= m;
            }
        }, {
            key: "force",
            get: function get() {
                return this._force;
            },
            set: function set(value) {
                Vec3.copy(this._force, value), this._maskUpdate(this._force, 1);
            }
        }, {
            key: "localForce",
            get: function get() {
                return this._localForce;
            },
            set: function set(value) {
                Vec3.copy(this._localForce, value), this._maskUpdate(this.localForce, 2);
            }
        }, {
            key: "torque",
            get: function get() {
                return this._torque;
            },
            set: function set(value) {
                Vec3.copy(this._torque, value), this._maskUpdate(this._torque, 4);
            }
        }, {
            key: "localTorque",
            get: function get() {
                return this._localTorque;
            },
            set: function set(value) {
                Vec3.copy(this._localTorque, value), this._maskUpdate(this._localTorque, 8);
            }
        } ]), ConstantForce;
    }(Component)).prototype, "_force", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3;
        }
    }), _descriptor2$1h = _applyDecoratedDescriptor(_class2$1G.prototype, "_localForce", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3;
        }
    }), _descriptor3$13 = _applyDecoratedDescriptor(_class2$1G.prototype, "_torque", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3;
        }
    }), _descriptor4$T = _applyDecoratedDescriptor(_class2$1G.prototype, "_localTorque", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3;
        }
    }), _applyDecoratedDescriptor(_class2$1G.prototype, "force", [ _dec5$V ], Object.getOwnPropertyDescriptor(_class2$1G.prototype, "force"), _class2$1G.prototype), 
    _applyDecoratedDescriptor(_class2$1G.prototype, "localForce", [ _dec6$M ], Object.getOwnPropertyDescriptor(_class2$1G.prototype, "localForce"), _class2$1G.prototype), 
    _applyDecoratedDescriptor(_class2$1G.prototype, "torque", [ _dec7$F ], Object.getOwnPropertyDescriptor(_class2$1G.prototype, "torque"), _class2$1G.prototype), 
    _applyDecoratedDescriptor(_class2$1G.prototype, "localTorque", [ _dec8$t ], Object.getOwnPropertyDescriptor(_class2$1G.prototype, "localTorque"), _class2$1G.prototype), 
    _class$1T = _class2$1G)) || _class$1T) || _class$1T) || _class$1T) || _class$1T) || _class$1T) || _class$1T);
    exports.replaceProperty(PhysicsSystem, "PhysicsSystem", [ {
        name: "ins",
        newName: "instance"
    } ]), cc.PhysicsSystem = PhysicsSystem, cc.ColliderComponent = ColliderComponent, 
    cc.BoxColliderComponent = BoxColliderComponent, cc.SphereColliderComponent = SphereColliderComponent, 
    cc.RigidBodyComponent = RigidBodyComponent, cc.PhysicMaterial = PhysicMaterial, 
    cc.PhysicsRayResult = PhysicsRayResult, cc.ConstantForce = ConstantForce;
    var AudioSourceComponent = (_dec$1T = ccclass("cc.AudioSourceComponent"), _dec2$1q = menu("Components/AudioSource"), 
    _dec3$18 = property(AudioClip), _dec4$$ = property({
        type: AudioClip,
        tooltip: "设定要播放的音频"
    }), _dec5$W = property({
        tooltip: "是否循环播放音频"
    }), _dec6$N = property({
        tooltip: "是否启用自动播放"
    }), _dec7$G = property({
        range: [ 0, 1 ],
        tooltip: "音频的音量（大小范围为 0.0 到 1.0 ）\n请注意,在某些平台上，音量控制可能不起效"
    }), _dec$1T(_class$1U = _dec2$1q((_descriptor$1w = _applyDecoratedDescriptor((_class2$1H = function(_Component) {
        function AudioSourceComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, AudioSourceComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AudioSourceComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_clip", _descriptor$1w, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_loop", _descriptor2$1i, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_playOnAwake", _descriptor3$14, _assertThisInitialized(_this)), 
            _initializerDefineProperty(_this, "_volume", _descriptor4$U, _assertThisInitialized(_this)), 
            _this._cachedCurrentTime = 0, _this;
        }
        return _inherits(AudioSourceComponent, _Component), _createClass(AudioSourceComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this._syncStates(), this._playOnAwake && this.play();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.pause();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this.stop();
            }
        }, {
            key: "play",
            value: function play() {
                this._clip && (this.playing ? this.currentTime = 0 : this._clip.play());
            }
        }, {
            key: "pause",
            value: function pause() {
                this._clip && this._clip.pause();
            }
        }, {
            key: "stop",
            value: function stop() {
                this._clip && this._clip.stop();
            }
        }, {
            key: "playOneShot",
            value: function playOneShot(clip) {
                var volumeScale = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                clip.playOneShot(this._volume * volumeScale);
            }
        }, {
            key: "_syncStates",
            value: function _syncStates() {
                this._clip && (this._clip.setCurrentTime(this._cachedCurrentTime), this._clip.setLoop(this._loop), 
                this._clip.setVolume(this._volume, !0), this._volume = this._clip.getVolume());
            }
        }, {
            key: "clip",
            set: function set(val) {
                this._clip = val, this._syncStates();
            },
            get: function get() {
                return this._clip;
            }
        }, {
            key: "loop",
            set: function set(val) {
                this._loop = val, this._clip && this._clip.setLoop(val);
            },
            get: function get() {
                return this._loop;
            }
        }, {
            key: "playOnAwake",
            set: function set(val) {
                this._playOnAwake = val;
            },
            get: function get() {
                return this._playOnAwake;
            }
        }, {
            key: "volume",
            set: function set(val) {
                isNaN(val) ? console.warn("illegal audio volume!") : (val = clamp(val, 0, 1), this._clip ? (this._clip.setVolume(val), 
                this._volume = this._clip.getVolume()) : this._volume = val);
            },
            get: function get() {
                return this._volume;
            }
        }, {
            key: "currentTime",
            set: function set(num) {
                isNaN(num) ? console.warn("illegal audio time!") : (num = clamp(num, 0, this.duration), 
                this._cachedCurrentTime = num, this._clip && this._clip.setCurrentTime(this._cachedCurrentTime));
            },
            get: function get() {
                return this._clip ? this._clip.getCurrentTime() : this._cachedCurrentTime;
            }
        }, {
            key: "duration",
            get: function get() {
                return this._clip ? this._clip.getDuration() : 0;
            }
        }, {
            key: "state",
            get: function get() {
                return this._clip ? this._clip.state : AudioClip.PlayingState.INITIALIZING;
            }
        }, {
            key: "playing",
            get: function get() {
                return this.state === AudioClip.PlayingState.PLAYING;
            }
        } ]), AudioSourceComponent;
    }(Component)).prototype, "_clip", [ _dec3$18 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$1i = _applyDecoratedDescriptor(_class2$1H.prototype, "_loop", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$14 = _applyDecoratedDescriptor(_class2$1H.prototype, "_playOnAwake", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor4$U = _applyDecoratedDescriptor(_class2$1H.prototype, "_volume", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _applyDecoratedDescriptor(_class2$1H.prototype, "clip", [ _dec4$$ ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "clip"), _class2$1H.prototype), 
    _applyDecoratedDescriptor(_class2$1H.prototype, "loop", [ _dec5$W ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "loop"), _class2$1H.prototype), 
    _applyDecoratedDescriptor(_class2$1H.prototype, "playOnAwake", [ _dec6$N ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "playOnAwake"), _class2$1H.prototype), 
    _applyDecoratedDescriptor(_class2$1H.prototype, "volume", [ _dec7$G ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "volume"), _class2$1H.prototype), 
    _class$1U = _class2$1H)) || _class$1U) || _class$1U);
    cc.AudioSourceComponent = AudioSourceComponent;
    var ID_COUNTER = 0, HashElement = function HashElement() {
        _classCallCheck(this, HashElement), this.actions = [], this.target = null, this.actionIndex = 0, 
        this.currentAction = null, this.paused = !1, this.lock = !1;
    }, ActionManager = function() {
        function ActionManager() {
            _classCallCheck(this, ActionManager), this._hashTargets = createMap(!0), this._arrayTargets = [], 
            this._elementPool = [];
        }
        return _createClass(ActionManager, [ {
            key: "_searchElementByTarget",
            value: function _searchElementByTarget(arr, target) {
                for (var k = 0; k < arr.length; k++) if (target === arr[k].target) return arr[k];
                return null;
            }
        }, {
            key: "_getElement",
            value: function _getElement(target, paused) {
                var element = this._elementPool.pop();
                return element || (element = new HashElement), element.target = target, element.paused = !!paused, 
                element;
            }
        }, {
            key: "_putElement",
            value: function _putElement(element) {
                element.actions.length = 0, element.actionIndex = 0, element.currentAction = null, 
                element.paused = !1, element.target = null, element.lock = !1, this._elementPool.push(element);
            }
        }, {
            key: "addAction",
            value: function addAction(action, target, paused) {
                if (action && target) {
                    null == target.uuid && (target.uuid = "_TWEEN_UUID_" + ID_COUNTER++);
                    var element = this._hashTargets[target.uuid];
                    element ? element.actions || (element.actions = []) : (element = this._getElement(target, paused), 
                    this._hashTargets[target.uuid] = element, this._arrayTargets.push(element)), element.actions.push(action), 
                    action.startWithTarget(target);
                } else errorID(1e3);
            }
        }, {
            key: "removeAllActions",
            value: function removeAllActions() {
                for (var locTargets = this._arrayTargets, i = 0; i < locTargets.length; i++) {
                    var element = locTargets[i];
                    element && this._putElement(element);
                }
                this._arrayTargets.length = 0, this._hashTargets = createMap(!0);
            }
        }, {
            key: "removeAllActionsFromTarget",
            value: function removeAllActionsFromTarget(target, forceDelete) {
                if (null != target) {
                    var element = this._hashTargets[target.uuid];
                    element && (element.actions.length = 0, this._deleteHashElement(element));
                }
            }
        }, {
            key: "removeAction",
            value: function removeAction(action) {
                if (null != action) {
                    var target = action.getOriginalTarget(), element = this._hashTargets[target.uuid];
                    if (element) for (var i = 0; i < element.actions.length; i++) if (element.actions[i] === action) {
                        element.actions.splice(i, 1), element.actionIndex >= i && element.actionIndex--;
                        break;
                    }
                }
            }
        }, {
            key: "removeActionByTag",
            value: function removeActionByTag(tag, target) {
                tag === cc.Action.TAG_INVALID && cc.logID(1002), cc.assertID(target, 1003);
                var element = this._hashTargets[target.uuid];
                if (element) for (var limit = element.actions.length, i = 0; i < limit; ++i) {
                    var action = element.actions[i];
                    if (action && action.getTag() === tag && action.getOriginalTarget() === target) {
                        this._removeActionAtIndex(i, element);
                        break;
                    }
                }
            }
        }, {
            key: "getActionByTag",
            value: function getActionByTag(tag, target) {
                tag === cc.Action.TAG_INVALID && cc.logID(1004);
                var element = this._hashTargets[target.uuid];
                if (element) {
                    if (null != element.actions) for (var i = 0; i < element.actions.length; ++i) {
                        var action = element.actions[i];
                        if (action && action.getTag() === tag) return action;
                    }
                    cc.logID(1005, tag);
                }
                return null;
            }
        }, {
            key: "getNumberOfRunningActionsInTarget",
            value: function getNumberOfRunningActionsInTarget(target) {
                var element = this._hashTargets[target.uuid];
                return element && element.actions ? element.actions.length : 0;
            }
        }, {
            key: "pauseTarget",
            value: function pauseTarget(target) {
                var element = this._hashTargets[target.uuid];
                element && (element.paused = !0);
            }
        }, {
            key: "resumeTarget",
            value: function resumeTarget(target) {
                var element = this._hashTargets[target.uuid];
                element && (element.paused = !1);
            }
        }, {
            key: "pauseAllRunningActions",
            value: function pauseAllRunningActions() {
                for (var idsWithActions = [], locTargets = this._arrayTargets, i = 0; i < locTargets.length; i++) {
                    var element = locTargets[i];
                    element && !element.paused && (element.paused = !0, idsWithActions.push(element.target));
                }
                return idsWithActions;
            }
        }, {
            key: "resumeTargets",
            value: function resumeTargets(targetsToResume) {
                if (targetsToResume) for (var i = 0; i < targetsToResume.length; i++) targetsToResume[i] && this.resumeTarget(targetsToResume[i]);
            }
        }, {
            key: "pauseTargets",
            value: function pauseTargets(targetsToPause) {
                if (targetsToPause) for (var i = 0; i < targetsToPause.length; i++) targetsToPause[i] && this.pauseTarget(targetsToPause[i]);
            }
        }, {
            key: "purgeSharedManager",
            value: function purgeSharedManager() {
                cc.director.getScheduler().unscheduleUpdate(this);
            }
        }, {
            key: "_removeActionAtIndex",
            value: function _removeActionAtIndex(index, element) {
                element.actions[index];
                element.actions.splice(index, 1), element.actionIndex >= index && element.actionIndex--, 
                0 === element.actions.length && this._deleteHashElement(element);
            }
        }, {
            key: "_deleteHashElement",
            value: function _deleteHashElement(element) {
                var ret = !1;
                if (element && !element.lock && this._hashTargets[element.target.uuid]) {
                    delete this._hashTargets[element.target.uuid];
                    for (var targets = this._arrayTargets, i = 0, l = targets.length; i < l; i++) if (targets[i] === element) {
                        targets.splice(i, 1);
                        break;
                    }
                    this._putElement(element), ret = !0;
                }
                return ret;
            }
        }, {
            key: "update",
            value: function update(dt) {
                for (var locCurrTarget, locTargets = this._arrayTargets, elt = 0; elt < locTargets.length; elt++) {
                    if (this._currentTarget = locTargets[elt], !(locCurrTarget = this._currentTarget).paused && locCurrTarget.actions) {
                        for (locCurrTarget.lock = !0, locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) if (locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex], 
                        locCurrTarget.currentAction) {
                            if (locCurrTarget.currentAction.step(dt * (locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1)), 
                            locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                                locCurrTarget.currentAction.stop();
                                var action = locCurrTarget.currentAction;
                                locCurrTarget.currentAction = null, this.removeAction(action);
                            }
                            locCurrTarget.currentAction = null;
                        }
                        locCurrTarget.lock = !1;
                    }
                    0 === locCurrTarget.actions.length && this._deleteHashElement(locCurrTarget) && elt--;
                }
            }
        } ]), ActionManager;
    }(), TweenSystem = function(_System) {
        function TweenSystem() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, TweenSystem);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TweenSystem)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).actionMgr = new ActionManager, 
            _this;
        }
        return _inherits(TweenSystem, _System), _createClass(TweenSystem, [ {
            key: "postUpdate",
            value: function postUpdate(dt) {
                this.actionMgr.update(dt);
            }
        }, {
            key: "ActionManager",
            get: function get() {
                return this.actionMgr;
            }
        } ]), TweenSystem;
    }(System);
    TweenSystem.ID = "tween", director.on(Director.EVENT_INIT, (function() {
        var sys = new TweenSystem;
        TweenSystem.instance = sys, director.registerSystem(TweenSystem.ID, sys, 100);
    }));
    var Action = function() {
        function Action() {
            _classCallCheck(this, Action), this.originalTarget = null, this.target = null, this.tag = Action.TAG_INVALID;
        }
        return _createClass(Action, [ {
            key: "clone",
            value: function clone() {
                var action = new Action;
                return action.originalTarget = null, action.target = null, action.tag = this.tag, 
                action;
            }
        }, {
            key: "isDone",
            value: function isDone() {
                return !0;
            }
        }, {
            key: "startWithTarget",
            value: function startWithTarget(target) {
                this.originalTarget = target, this.target = target;
            }
        }, {
            key: "stop",
            value: function stop() {
                this.target = null;
            }
        }, {
            key: "step",
            value: function step(dt) {
                logID(1006);
            }
        }, {
            key: "update",
            value: function update(dt) {
                logID(1007);
            }
        }, {
            key: "getTarget",
            value: function getTarget() {
                return this.target;
            }
        }, {
            key: "setTarget",
            value: function setTarget(target) {
                this.target = target;
            }
        }, {
            key: "getOriginalTarget",
            value: function getOriginalTarget() {
                return this.originalTarget;
            }
        }, {
            key: "setOriginalTarget",
            value: function setOriginalTarget(originalTarget) {
                this.originalTarget = originalTarget;
            }
        }, {
            key: "getTag",
            value: function getTag() {
                return this.tag;
            }
        }, {
            key: "setTag",
            value: function setTag(tag) {
                this.tag = tag;
            }
        }, {
            key: "reverse",
            value: function reverse() {
                return logID(1008), null;
            }
        }, {
            key: "retain",
            value: function retain() {}
        }, {
            key: "release",
            value: function release() {}
        } ]), Action;
    }();
    Action.TAG_INVALID = -1;
    var FiniteTimeAction = function(_Action) {
        function FiniteTimeAction() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, FiniteTimeAction);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FiniteTimeAction)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._duration = 0, 
            _this._timesForRepeat = 1, _this;
        }
        return _inherits(FiniteTimeAction, _Action), _createClass(FiniteTimeAction, [ {
            key: "getDuration",
            value: function getDuration() {
                return this._duration * (this._timesForRepeat || 1);
            }
        }, {
            key: "setDuration",
            value: function setDuration(duration) {
                this._duration = duration;
            }
        }, {
            key: "clone",
            value: function clone() {
                return new FiniteTimeAction;
            }
        } ]), FiniteTimeAction;
    }(Action), ActionInstant = function(_FiniteTimeAction) {
        function ActionInstant() {
            return _classCallCheck(this, ActionInstant), _possibleConstructorReturn(this, _getPrototypeOf(ActionInstant).apply(this, arguments));
        }
        return _inherits(ActionInstant, _FiniteTimeAction), _createClass(ActionInstant, [ {
            key: "isDone",
            value: function isDone() {
                return !0;
            }
        }, {
            key: "step",
            value: function step(dt) {
                this.update(1);
            }
        }, {
            key: "update",
            value: function update(dt) {}
        }, {
            key: "reverse",
            value: function reverse() {
                return this.clone();
            }
        }, {
            key: "clone",
            value: function clone() {
                return new ActionInstant;
            }
        } ]), ActionInstant;
    }(FiniteTimeAction), Show = function(_ActionInstant) {
        function Show() {
            return _classCallCheck(this, Show), _possibleConstructorReturn(this, _getPrototypeOf(Show).apply(this, arguments));
        }
        return _inherits(Show, _ActionInstant), _createClass(Show, [ {
            key: "update",
            value: function update(dt) {
                for (var _renderComps = this.target.getComponentsInChildren(RenderableComponent), i = 0; i < _renderComps.length; ++i) {
                    _renderComps[i].enabled = !0;
                }
            }
        }, {
            key: "reverse",
            value: function reverse() {
                return new Hide;
            }
        }, {
            key: "clone",
            value: function clone() {
                return new Show;
            }
        } ]), Show;
    }(ActionInstant);
    var Hide = function(_ActionInstant2) {
        function Hide() {
            return _classCallCheck(this, Hide), _possibleConstructorReturn(this, _getPrototypeOf(Hide).apply(this, arguments));
        }
        return _inherits(Hide, _ActionInstant2), _createClass(Hide, [ {
            key: "update",
            value: function update(dt) {
                for (var _renderComps = this.target.getComponentsInChildren(RenderableComponent), i = 0; i < _renderComps.length; ++i) {
                    _renderComps[i].enabled = !1;
                }
            }
        }, {
            key: "reverse",
            value: function reverse() {
                return new Show;
            }
        }, {
            key: "clone",
            value: function clone() {
                return new Hide;
            }
        } ]), Hide;
    }(ActionInstant);
    var RemoveSelf = function(_ActionInstant4) {
        function RemoveSelf(isNeedCleanUp) {
            var _this;
            return _classCallCheck(this, RemoveSelf), (_this = _possibleConstructorReturn(this, _getPrototypeOf(RemoveSelf).call(this)))._isNeedCleanUp = !0, 
            void 0 !== isNeedCleanUp && _this.init(isNeedCleanUp), _this;
        }
        return _inherits(RemoveSelf, _ActionInstant4), _createClass(RemoveSelf, [ {
            key: "update",
            value: function update(dt) {
                this.target.removeFromParent(), this._isNeedCleanUp && this.target.destroy();
            }
        }, {
            key: "init",
            value: function init(isNeedCleanUp) {
                return this._isNeedCleanUp = isNeedCleanUp, !0;
            }
        }, {
            key: "reverse",
            value: function reverse() {
                return new RemoveSelf(this._isNeedCleanUp);
            }
        }, {
            key: "clone",
            value: function clone() {
                return new RemoveSelf(this._isNeedCleanUp);
            }
        } ]), RemoveSelf;
    }(ActionInstant);
    var CallFunc = function(_ActionInstant5) {
        function CallFunc(selector, selectorTarget, data) {
            var _this2;
            return _classCallCheck(this, CallFunc), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(CallFunc).call(this)))._selectorTarget = null, 
            _this2._function = null, _this2._data = null, _this2.initWithFunction(selector, selectorTarget, data), 
            _this2;
        }
        return _inherits(CallFunc, _ActionInstant5), _createClass(CallFunc, [ {
            key: "initWithFunction",
            value: function initWithFunction(selector, selectorTarget, data) {
                return selector && (this._function = selector), selectorTarget && (this._selectorTarget = selectorTarget), 
                void 0 !== data && (this._data = data), !0;
            }
        }, {
            key: "execute",
            value: function execute() {
                this._function && this._function.call(this._selectorTarget, this.target, this._data);
            }
        }, {
            key: "update",
            value: function update(dt) {
                this.execute();
            }
        }, {
            key: "getTargetCallback",
            value: function getTargetCallback() {
                return this._selectorTarget;
            }
        }, {
            key: "setTargetCallback",
            value: function setTargetCallback(sel) {
                sel !== this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), 
                this._selectorTarget = sel);
            }
        }, {
            key: "clone",
            value: function clone() {
                var action = new CallFunc;
                return action.initWithFunction(this._function, this._selectorTarget, this._data), 
                action;
            }
        } ]), CallFunc;
    }(ActionInstant);
    var ActionInterval = function(_FiniteTimeAction) {
        function ActionInterval(d) {
            var _this;
            return _classCallCheck(this, ActionInterval), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ActionInterval).call(this))).MAX_VALUE = 2, 
            _this._elapsed = 0, _this._firstTick = !1, _this._easeList = [], _this._speed = 1, 
            _this._repeatForever = !1, _this._repeatMethod = !1, _this._speedMethod = !1, void 0 === d || isNaN(d) || _this.initWithDuration(d), 
            _this;
        }
        return _inherits(ActionInterval, _FiniteTimeAction), _createClass(ActionInterval, [ {
            key: "getElapsed",
            value: function getElapsed() {
                return this._elapsed;
            }
        }, {
            key: "initWithDuration",
            value: function initWithDuration(d) {
                return this._duration = 0 === d ? macro.FLT_EPSILON : d, this._elapsed = 0, this._firstTick = !0, 
                !0;
            }
        }, {
            key: "isDone",
            value: function isDone() {
                return this._elapsed >= this._duration;
            }
        }, {
            key: "_cloneDecoration",
            value: function _cloneDecoration(action) {
                action._repeatForever = this._repeatForever, action._speed = this._speed, action._timesForRepeat = this._timesForRepeat, 
                action._easeList = this._easeList, action._speedMethod = this._speedMethod, action._repeatMethod = this._repeatMethod;
            }
        }, {
            key: "_reverseEaseList",
            value: function _reverseEaseList(action) {
                if (this._easeList) {
                    action._easeList = [];
                    for (var i = 0; i < this._easeList.length; i++) action._easeList.push(this._easeList[i]);
                }
            }
        }, {
            key: "clone",
            value: function clone() {
                var action = new ActionInterval(this._duration);
                return this._cloneDecoration(action), action;
            }
        }, {
            key: "easing",
            value: function easing(easeObj) {
                this._easeList ? this._easeList.length = 0 : this._easeList = [];
                for (var i = 0; i < arguments.length; i++) this._easeList.push(arguments[i]);
                return this;
            }
        }, {
            key: "_computeEaseTime",
            value: function _computeEaseTime(dt) {
                return dt;
            }
        }, {
            key: "step",
            value: function step(dt) {
                this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += dt;
                var t = this._elapsed / (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
                t = 1 > t ? t : 1, this.update(t > 0 ? t : 0), this._repeatMethod && this._timesForRepeat > 1 && this.isDone() && (this._repeatForever || this._timesForRepeat--, 
                this.startWithTarget(this.target), this.step(this._elapsed - this._duration));
            }
        }, {
            key: "startWithTarget",
            value: function startWithTarget(target) {
                Action.prototype.startWithTarget.call(this, target), this._elapsed = 0, this._firstTick = !0;
            }
        }, {
            key: "reverse",
            value: function reverse() {
                return logID(1010), this;
            }
        }, {
            key: "setAmplitudeRate",
            value: function setAmplitudeRate(amp) {
                logID(1011);
            }
        }, {
            key: "getAmplitudeRate",
            value: function getAmplitudeRate() {
                return logID(1012), 0;
            }
        }, {
            key: "speed",
            value: function speed(_speed) {
                return _speed <= 0 ? (logID(1013), this) : (this._speedMethod = !0, this._speed *= _speed, 
                this);
            }
        }, {
            key: "getSpeed",
            value: function getSpeed() {
                return this._speed;
            }
        }, {
            key: "setSpeed",
            value: function setSpeed(speed) {
                return this._speed = speed, this;
            }
        }, {
            key: "repeat",
            value: function repeat(times) {
                return times = Math.round(times), isNaN(times) || times < 1 ? (logID(1014), this) : (this._repeatMethod = !0, 
                this._timesForRepeat *= times, this);
            }
        }, {
            key: "repeatForever",
            value: function repeatForever() {
                return this._repeatMethod = !0, this._timesForRepeat = this.MAX_VALUE, this._repeatForever = !0, 
                this;
            }
        } ]), ActionInterval;
    }(FiniteTimeAction), Sequence = function(_ActionInterval) {
        function Sequence(tempArray) {
            var _this2;
            _classCallCheck(this, Sequence), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(Sequence).call(this)))._actions = [], 
            _this2._split = 0, _this2._last = 0, _this2._reversed = !1;
            var paramArray = tempArray instanceof Array ? tempArray : arguments;
            if (1 === paramArray.length) return errorID(1019), _possibleConstructorReturn(_this2);
            var last = paramArray.length - 1;
            if (last >= 0 && null == paramArray[last] && logID(1015), last >= 0) {
                for (var action1, prev = paramArray[0], i = 1; i < last; i++) paramArray[i] && (action1 = prev, 
                prev = Sequence._actionOneTwo(action1, paramArray[i]));
                _this2.initWithTwoActions(prev, paramArray[last]);
            }
            return _this2;
        }
        return _inherits(Sequence, _ActionInterval), _createClass(Sequence, [ {
            key: "initWithTwoActions",
            value: function initWithTwoActions(actionOne, actionTwo) {
                if (!actionOne || !actionTwo) return errorID(1025), !1;
                var durationOne = actionOne._duration, durationTwo = actionTwo._duration, d = (durationOne *= actionOne._repeatMethod ? actionOne._timesForRepeat : 1) + (durationTwo *= actionTwo._repeatMethod ? actionTwo._timesForRepeat : 1);
                return this.initWithDuration(d), this._actions[0] = actionOne, this._actions[1] = actionTwo, 
                !0;
            }
        }, {
            key: "clone",
            value: function clone() {
                var action = new Sequence;
                return this._cloneDecoration(action), action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone()), 
                action;
            }
        }, {
            key: "startWithTarget",
            value: function startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target), this._split = this._actions[0]._duration / this._duration, 
                this._split *= this._actions[0]._repeatMethod ? this._actions[0]._timesForRepeat : 1, 
                this._last = -1;
            }
        }, {
            key: "stop",
            value: function stop() {
                -1 !== this._last && this._actions[this._last].stop(), Action.prototype.stop.call(this);
            }
        }, {
            key: "update",
            value: function update(dt) {
                var new_t, actionFound, found = 0, locSplit = this._split, locActions = this._actions, locLast = this._last;
                (dt = this._computeEaseTime(dt)) < locSplit ? (new_t = 0 !== locSplit ? dt / locSplit : 1, 
                0 === found && 1 === locLast && this._reversed && (locActions[1].update(0), locActions[1].stop())) : (found = 1, 
                new_t = 1 === locSplit ? 1 : (dt - locSplit) / (1 - locSplit), -1 === locLast && (locActions[0].startWithTarget(this.target), 
                locActions[0].update(1), locActions[0].stop()), 0 === locLast && (locActions[0].update(1), 
                locActions[0].stop())), actionFound = locActions[found], locLast === found && actionFound.isDone() || (locLast !== found && actionFound.startWithTarget(this.target), 
                new_t *= actionFound._timesForRepeat, actionFound.update(new_t > 1 ? new_t % 1 : new_t), 
                this._last = found);
            }
        }, {
            key: "reverse",
            value: function reverse() {
                var action = Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
                return this._cloneDecoration(action), this._reverseEaseList(action), action._reversed = !0, 
                action;
            }
        } ]), Sequence;
    }(ActionInterval);
    function sequence(tempArray) {
        var paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (1 === paramArray.length) return errorID(1019), null;
        var last = paramArray.length - 1;
        last >= 0 && null == paramArray[last] && logID(1015);
        var result = null;
        if (last >= 0) {
            result = paramArray[0];
            for (var i = 1; i <= last; i++) paramArray[i] && (result = Sequence._actionOneTwo(result, paramArray[i]));
        }
        return result;
    }
    Sequence._actionOneTwo = function(actionOne, actionTwo) {
        var sequence = new Sequence;
        return sequence.initWithTwoActions(actionOne, actionTwo), sequence;
    };
    var Repeat = function(_ActionInterval2) {
        function Repeat(action, times) {
            var _this3;
            return _classCallCheck(this, Repeat), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(Repeat).call(this)))._times = 0, 
            _this3._total = 0, _this3._nextDt = 0, _this3._actionInstant = !1, _this3._innerAction = null, 
            void 0 !== times && _this3.initWithAction(action, times), _this3;
        }
        return _inherits(Repeat, _ActionInterval2), _createClass(Repeat, [ {
            key: "initWithAction",
            value: function initWithAction(action, times) {
                var duration = action._duration * times;
                return !!this.initWithDuration(duration) && (this._times = times, this._innerAction = action, 
                action instanceof ActionInstant && (this._actionInstant = !0, this._times -= 1), 
                this._total = 0, !0);
            }
        }, {
            key: "clone",
            value: function clone() {
                var action = new Repeat;
                return this._cloneDecoration(action), action.initWithAction(this._innerAction.clone(), this._times), 
                action;
            }
        }, {
            key: "startWithTarget",
            value: function startWithTarget(target) {
                this._total = 0, this._nextDt = this._innerAction._duration / this._duration, ActionInterval.prototype.startWithTarget.call(this, target), 
                this._innerAction.startWithTarget(target);
            }
        }, {
            key: "stop",
            value: function stop() {
                this._innerAction.stop(), Action.prototype.stop.call(this);
            }
        }, {
            key: "update",
            value: function update(dt) {
                dt = this._computeEaseTime(dt);
                var locInnerAction = this._innerAction, locDuration = this._duration, locTimes = this._times, locNextDt = this._nextDt;
                if (dt >= locNextDt) {
                    for (;dt > locNextDt && this._total < locTimes; ) locInnerAction.update(1), this._total++, 
                    locInnerAction.stop(), locInnerAction.startWithTarget(this.target), locNextDt += locInnerAction._duration / locDuration, 
                    this._nextDt = locNextDt > 1 ? 1 : locNextDt;
                    dt >= 1 && this._total < locTimes && (locInnerAction.update(1), this._total++), 
                    this._actionInstant || (this._total === locTimes ? locInnerAction.stop() : locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration)));
                } else locInnerAction.update(dt * locTimes % 1);
            }
        }, {
            key: "isDone",
            value: function isDone() {
                return this._total === this._times;
            }
        }, {
            key: "reverse",
            value: function reverse() {
                var action = new Repeat(this._innerAction.reverse(), this._times);
                return this._cloneDecoration(action), this._reverseEaseList(action), action;
            }
        }, {
            key: "setInnerAction",
            value: function setInnerAction(action) {
                this._innerAction !== action && (this._innerAction = action);
            }
        }, {
            key: "getInnerAction",
            value: function getInnerAction() {
                return this._innerAction;
            }
        } ]), Repeat;
    }(ActionInterval);
    var RepeatForever = function(_ActionInterval3) {
        function RepeatForever(action) {
            var _this4;
            return _classCallCheck(this, RepeatForever), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(RepeatForever).call(this)))._innerAction = null, 
            action && _this4.initWithAction(action), _this4;
        }
        return _inherits(RepeatForever, _ActionInterval3), _createClass(RepeatForever, [ {
            key: "initWithAction",
            value: function initWithAction(action) {
                return action ? (this._innerAction = action, !0) : (errorID(1026), !1);
            }
        }, {
            key: "clone",
            value: function clone() {
                var action = new RepeatForever;
                return this._cloneDecoration(action), action.initWithAction(this._innerAction.clone()), 
                action;
            }
        }, {
            key: "startWithTarget",
            value: function startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target), this._innerAction.startWithTarget(target);
            }
        }, {
            key: "step",
            value: function step(dt) {
                var locInnerAction = this._innerAction;
                locInnerAction.step(dt), locInnerAction.isDone() && (locInnerAction.startWithTarget(this.target), 
                locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration));
            }
        }, {
            key: "isDone",
            value: function isDone() {
                return !1;
            }
        }, {
            key: "reverse",
            value: function reverse() {
                var action = new RepeatForever(this._innerAction.reverse());
                return this._cloneDecoration(action), this._reverseEaseList(action), action;
            }
        }, {
            key: "setInnerAction",
            value: function setInnerAction(action) {
                this._innerAction !== action && (this._innerAction = action);
            }
        }, {
            key: "getInnerAction",
            value: function getInnerAction() {
                return this._innerAction;
            }
        } ]), RepeatForever;
    }(ActionInterval);
    var Spawn = function(_ActionInterval4) {
        function Spawn(tempArray) {
            var _this5;
            _classCallCheck(this, Spawn), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(Spawn).call(this)))._one = null, 
            _this5._two = null;
            var paramArray = tempArray instanceof Array ? tempArray : arguments;
            if (1 === paramArray.length) return errorID(1020), _possibleConstructorReturn(_this5);
            var last = paramArray.length - 1;
            if (last >= 0 && null == paramArray[last] && logID(1015), last >= 0) {
                for (var action1, prev = paramArray[0], i = 1; i < last; i++) paramArray[i] && (action1 = prev, 
                prev = Spawn._actionOneTwo(action1, paramArray[i]));
                _this5.initWithTwoActions(prev, paramArray[last]);
            }
            return _this5;
        }
        return _inherits(Spawn, _ActionInterval4), _createClass(Spawn, [ {
            key: "initWithTwoActions",
            value: function initWithTwoActions(action1, action2) {
                if (!action1 || !action2) return errorID(1027), !1;
                var ret = !1, d1 = action1._duration, d2 = action2._duration;
                return this.initWithDuration(Math.max(d1, d2)) && (this._one = action1, this._two = action2, 
                d1 > d2 ? this._two = Sequence._actionOneTwo(action2, delayTime(d1 - d2)) : d1 < d2 && (this._one = Sequence._actionOneTwo(action1, delayTime(d2 - d1))), 
                ret = !0), ret;
            }
        }, {
            key: "clone",
            value: function clone() {
                var action = new Spawn;
                return this._cloneDecoration(action), action.initWithTwoActions(this._one.clone(), this._two.clone()), 
                action;
            }
        }, {
            key: "startWithTarget",
            value: function startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target), this._one.startWithTarget(target), 
                this._two.startWithTarget(target);
            }
        }, {
            key: "stop",
            value: function stop() {
                this._one.stop(), this._two.stop(), Action.prototype.stop.call(this);
            }
        }, {
            key: "update",
            value: function update(dt) {
                dt = this._computeEaseTime(dt), this._one && this._one.update(dt), this._two && this._two.update(dt);
            }
        }, {
            key: "reverse",
            value: function reverse() {
                var action = Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
                return this._cloneDecoration(action), this._reverseEaseList(action), action;
            }
        } ]), Spawn;
    }(ActionInterval);
    function spawn(tempArray) {
        var paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (1 === paramArray.length) return errorID(1020), null;
        paramArray.length > 0 && null == paramArray[paramArray.length - 1] && logID(1015);
        for (var prev = paramArray[0], i = 1; i < paramArray.length; i++) null != paramArray[i] && (prev = Spawn._actionOneTwo(prev, paramArray[i]));
        return prev;
    }
    Spawn._actionOneTwo = function(action1, action2) {
        var pSpawn = new Spawn;
        return pSpawn.initWithTwoActions(action1, action2), pSpawn;
    };
    var DelayTime = function(_ActionInterval5) {
        function DelayTime() {
            return _classCallCheck(this, DelayTime), _possibleConstructorReturn(this, _getPrototypeOf(DelayTime).apply(this, arguments));
        }
        return _inherits(DelayTime, _ActionInterval5), _createClass(DelayTime, [ {
            key: "update",
            value: function update(dt) {}
        }, {
            key: "reverse",
            value: function reverse() {
                var action = new DelayTime(this._duration);
                return this._cloneDecoration(action), this._reverseEaseList(action), action;
            }
        }, {
            key: "clone",
            value: function clone() {
                var action = new DelayTime;
                return this._cloneDecoration(action), action.initWithDuration(this._duration), action;
            }
        } ]), DelayTime;
    }(ActionInterval);
    function delayTime(d) {
        return new DelayTime(d);
    }
    var ReverseTime = function(_ActionInterval6) {
        function ReverseTime(action) {
            var _this6;
            return _classCallCheck(this, ReverseTime), (_this6 = _possibleConstructorReturn(this, _getPrototypeOf(ReverseTime).call(this)))._other = null, 
            action && _this6.initWithAction(action), _this6;
        }
        return _inherits(ReverseTime, _ActionInterval6), _createClass(ReverseTime, [ {
            key: "initWithAction",
            value: function initWithAction(action) {
                return action ? action === this._other ? (errorID(1029), !1) : !!ActionInterval.prototype.initWithDuration.call(this, action._duration) && (this._other = action, 
                !0) : (errorID(1028), !1);
            }
        }, {
            key: "clone",
            value: function clone() {
                var action = new ReverseTime;
                return this._cloneDecoration(action), action.initWithAction(this._other.clone()), 
                action;
            }
        }, {
            key: "startWithTarget",
            value: function startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target), this._other.startWithTarget(target);
            }
        }, {
            key: "update",
            value: function update(dt) {
                dt = this._computeEaseTime(dt), this._other && this._other.update(1 - dt);
            }
        }, {
            key: "reverse",
            value: function reverse() {
                return this._other.clone();
            }
        }, {
            key: "stop",
            value: function stop() {
                this._other.stop(), Action.prototype.stop.call(this);
            }
        } ]), ReverseTime;
    }(ActionInterval);
    var TweenAction = function(_ActionInterval) {
        function TweenAction(duration, props, opts) {
            var _this;
            if (_classCallCheck(this, TweenAction), _this = _possibleConstructorReturn(this, _getPrototypeOf(TweenAction).call(this)), 
            null == opts) opts = Object.create(null); else if (function TweenOptionChecker(opts) {
                var header = " [Tween:] ", message = " option is not support in v" + cc.ENGINE_VERSION;
                opts.delay && warn(header + "delay" + message), opts.repeat && warn(header + "repeat" + message), 
                opts.repeatDelay && warn(header + "repeatDelay" + message), opts.interpolation && warn(header + "interpolation" + message), 
                opts.onStop && warn(header + "onStop" + message);
            }(opts), opts.easing && "string" == typeof opts.easing && (opts.easing = function TweenEasinAdapter(easingName) {
                var initialChar = easingName.charAt(0);
                if (/[A-Z]/.test(initialChar)) {
                    var arr = (easingName = easingName.replace(initialChar, initialChar.toLowerCase())).split("-");
                    if (2 == arr.length) {
                        var str0 = arr[0];
                        if ("linear" == str0) easingName = "linear"; else {
                            var str1 = arr[1];
                            switch (str0) {
                              case "quadratic":
                                easingName = "quad" + str1;
                                break;

                              case "quartic":
                                easingName = "quart" + str1;
                                break;

                              case "quintic":
                                easingName = "quint" + str1;
                                break;

                              case "sinusoidal":
                                easingName = "sine" + str1;
                                break;

                              case "exponential":
                                easingName = "expo" + str1;
                                break;

                              case "circular":
                                easingName = "circ" + str1;
                                break;

                              default:
                                easingName = str0 + str1;
                            }
                        }
                    }
                }
                return easingName;
            }(opts.easing)), opts.progress || (opts.progress = _this.progress), opts.easing && "string" == typeof opts.easing) {
                var easingName = opts.easing;
                opts.easing = easing[easingName], opts.easing || warnID(1031, easingName);
            }
            for (var name in _this._opts = opts, _this._props = Object.create(null), props) {
                var value = props[name], _easing = void 0, progress = void 0;
                void 0 !== value.value && (value.easing || value.progress) && ("string" == typeof value.easing ? !(_easing = _easing[value.easing]) && warnID(1031, value.easing) : _easing = value.easing, 
                progress = value.progress, value = value.value);
                var prop = Object.create(null);
                prop.value = value, prop.easing = _easing, prop.progress = progress, _this._props[name] = prop;
            }
            return _this._originProps = props, _this.initWithDuration(duration), _this;
        }
        return _inherits(TweenAction, _ActionInterval), _createClass(TweenAction, [ {
            key: "clone",
            value: function clone() {
                var action = new TweenAction(this._duration, this._originProps, this._opts);
                return this._cloneDecoration(action), action;
            }
        }, {
            key: "startWithTarget",
            value: function startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target);
                var relative = !!this._opts.relative, props = this._props;
                for (var property in props) {
                    var _t = target[property];
                    if (void 0 !== _t) {
                        var prop = props[property], value = prop.value;
                        if ("number" == typeof _t) prop.start = _t, prop.current = _t, prop.end = relative ? _t + value : value; else if ("object" === _typeof(_t)) for (var k in null == prop.start && (prop.start = {}, 
                        prop.current = {}, prop.end = {}), value) prop.start[k] = _t[k], prop.current[k] = _t[k], 
                        prop.end[k] = relative ? _t[k] + value[k] : value[k];
                    }
                }
                this._opts.onStart && this._opts.onStart(this.target);
            }
        }, {
            key: "update",
            value: function update(t) {
                var target = this.target;
                if (target) {
                    var props = this._props, opts = this._opts, easingTime = t;
                    opts.easing && (easingTime = opts.easing(t));
                    var progress = opts.progress;
                    for (var name in props) {
                        var prop = props[name], time = prop.easing ? prop.easing(t) : easingTime, interpolation = prop.progress ? prop.progress : progress, start = prop.start, end = prop.end;
                        if ("number" == typeof start) prop.current = interpolation(start, end, prop.current, time); else if ("object" === _typeof(start)) for (var k in start) prop.current[k] = interpolation(start[k], end[k], prop.current[k], time);
                        target[name] = prop.current;
                    }
                    opts.onUpdate && opts.onUpdate(this.target, t), 1 == t && opts.onComplete && opts.onComplete(this.target);
                }
            }
        }, {
            key: "progress",
            value: function progress(start, end, current, t) {
                return start + (end - start) * t;
            }
        } ]), TweenAction;
    }(ActionInterval), SetAction = function(_ActionInstant) {
        function SetAction(props) {
            var _this;
            return _classCallCheck(this, SetAction), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SetAction).call(this)))._props = {}, 
            void 0 !== props && _this.init(props), _this;
        }
        return _inherits(SetAction, _ActionInstant), _createClass(SetAction, [ {
            key: "init",
            value: function init(props) {
                for (var name in props) this._props[name] = props[name];
                return !0;
            }
        }, {
            key: "update",
            value: function update() {
                var props = this._props, target = this.target;
                for (var name in props) target[name] = props[name];
            }
        }, {
            key: "clone",
            value: function clone() {
                var action = new SetAction;
                return action.init(this._props), action;
            }
        } ]), SetAction;
    }(ActionInstant), Tween = function() {
        function Tween(target) {
            _classCallCheck(this, Tween), this._actions = [], this._finalAction = null, this._target = null, 
            this._target = void 0 === target ? null : target, this._target && this._target instanceof Node$1 && this._target.on(exports.SystemEventType.NODE_DESTROYED, this._destroy, this);
        }
        return _createClass(Tween, [ {
            key: "then",
            value: function then(other) {
                return other instanceof Action ? this._actions.push(other.clone()) : this._actions.push(other._union()), 
                this;
            }
        }, {
            key: "target",
            value: function target(_target) {
                return this._target && this._target instanceof Node$1 && this._target.off(exports.SystemEventType.NODE_DESTROYED, this._destroy, this), 
                this._target = _target, this._target && this._target instanceof Node$1 && this._target.on(exports.SystemEventType.NODE_DESTROYED, this._destroy, this), 
                this;
            }
        }, {
            key: "start",
            value: function start() {
                return this._target ? (this._finalAction && TweenSystem.instance.ActionManager.removeAction(this._finalAction), 
                this._finalAction = this._union(), TweenSystem.instance.ActionManager.addAction(this._finalAction, this._target, !1), 
                this) : (warn("Please set target to tween first"), this);
            }
        }, {
            key: "stop",
            value: function stop() {
                return this._finalAction && TweenSystem.instance.ActionManager.removeAction(this._finalAction), 
                this;
            }
        }, {
            key: "clone",
            value: function clone(target) {
                var action = this._union();
                return tween(target).then(action.clone());
            }
        }, {
            key: "union",
            value: function union() {
                var action = this._union();
                return this._actions.length = 0, this._actions.push(action), this;
            }
        }, {
            key: "to",
            value: function to(duration, props, opts) {
                (opts = opts || Object.create(null)).relative = !1;
                var action = new TweenAction(duration, props, opts);
                return this._actions.push(action), this;
            }
        }, {
            key: "by",
            value: function by(duration, props, opts) {
                (opts = opts || Object.create(null)).relative = !0;
                var action = new TweenAction(duration, props, opts);
                return this._actions.push(action), this;
            }
        }, {
            key: "set",
            value: function set(props) {
                var action = new SetAction(props);
                return this._actions.push(action), this;
            }
        }, {
            key: "delay",
            value: function delay(duration) {
                var action = delayTime(duration);
                return this._actions.push(action), this;
            }
        }, {
            key: "call",
            value: function call(callback) {
                var action = function callFunc(selector, selectorTarget, data) {
                    return new CallFunc(selector, selectorTarget, data);
                }(callback);
                return this._actions.push(action), this;
            }
        }, {
            key: "sequence",
            value: function sequence() {
                var action = Tween._wrappedSequence.apply(Tween, arguments);
                return this._actions.push(action), this;
            }
        }, {
            key: "parallel",
            value: function parallel() {
                var action = Tween._wrappedParallel.apply(Tween, arguments);
                return this._actions.push(action), this;
            }
        }, {
            key: "repeat",
            value: function repeat(repeatTimes, embedTween) {
                if (repeatTimes == 1 / 0) return this.repeatForever(embedTween);
                var action, actions = this._actions;
                return action = embedTween instanceof Tween ? embedTween._union() : actions.pop(), 
                actions.push(function repeat$2(action, times) {
                    return new Repeat(action, times);
                }(action, repeatTimes)), this;
            }
        }, {
            key: "repeatForever",
            value: function repeatForever$1(embedTween) {
                var action, actions = this._actions;
                return action = embedTween instanceof Tween ? embedTween._union() : actions.pop(), 
                actions.push(function repeatForever(action) {
                    return new RepeatForever(action);
                }(action)), this;
            }
        }, {
            key: "reverseTime",
            value: function reverseTime$1(embedTween) {
                var action, actions = this._actions;
                return action = embedTween instanceof Tween ? embedTween._union() : actions.pop(), 
                actions.push(function reverseTime(action) {
                    return new ReverseTime(action);
                }(action)), this;
            }
        }, {
            key: "hide",
            value: function hide$1() {
                var action = function hide() {
                    return new Hide;
                }();
                return this._actions.push(action), this;
            }
        }, {
            key: "show",
            value: function show$1() {
                var action = function show() {
                    return new Show;
                }();
                return this._actions.push(action), this;
            }
        }, {
            key: "removeSelf",
            value: function removeSelf$1() {
                var action = function removeSelf(isNeedCleanUp) {
                    return new RemoveSelf(isNeedCleanUp);
                }(!1);
                return this._actions.push(action), this;
            }
        }, {
            key: "_union",
            value: function _union() {
                var actions = this._actions;
                return 1 === actions.length ? actions[0] : sequence(actions);
            }
        }, {
            key: "_destroy",
            value: function _destroy() {
                this.stop();
            }
        } ], [ {
            key: "_wrappedSequence",
            value: function _wrappedSequence() {
                var tmp_args = Tween._tmp_args;
                tmp_args.length = 0;
                for (var l = arguments.length, i = 0; i < l; i++) {
                    var arg = tmp_args[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                    arg instanceof Tween && (tmp_args[i] = arg._union());
                }
                return sequence.apply(sequence, tmp_args);
            }
        }, {
            key: "_wrappedParallel",
            value: function _wrappedParallel() {
                var tmp_args = Tween._tmp_args;
                tmp_args.length = 0;
                for (var l = arguments.length, i = 0; i < l; i++) {
                    var arg = tmp_args[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                    arg instanceof Tween && (tmp_args[i] = arg._union());
                }
                return spawn.apply(spawn, tmp_args);
            }
        } ]), Tween;
    }();
    function tween(target) {
        return new Tween(target);
    }
    function tweenUtil(target) {
        return warn("tweenUtil' is deprecated, please use 'tween' instead "), new Tween(target);
    }
    Tween._tmp_args = [], cc.Tween = Tween, cc.tween = tween, cc.tweenUtil = tweenUtil;
    var _class$1V, _dec$1V, _dec2$1r, _class$1W, _class2$1I, _descriptor$1x, _descriptor2$1j, _descriptor3$15, _descriptor4$V, _dec3$19, _dec4$10, _dec5$X, _class4$a, _class5$9, _descriptor5$K, _descriptor6$w, _class7$3, _class8$3, _descriptor7$q, _dec7$H, _dec8$u, _dec9$n, _dec10$l, _dec11$l, _dec12$h, _class10$2, _class11$2, _descriptor8$m, _descriptor9$h, _descriptor10$h, HeightField = function() {
        function HeightField(w, h) {
            _classCallCheck(this, HeightField), this.data = new Uint16Array, this.w = 0, this.h = 0, 
            this.w = w, this.h = h, this.data = new Uint16Array(w * h);
            for (var i = 0; i < w * h; ++i) this.data[i] = 0;
        }
        return _createClass(HeightField, [ {
            key: "set",
            value: function set(i, j, value) {
                this.data[j * this.w + i] = value;
            }
        }, {
            key: "get",
            value: function get(i, j) {
                return this.data[j * this.w + i];
            }
        }, {
            key: "getClamp",
            value: function getClamp(i, j) {
                return i = clamp(i, 0, this.w - 1), j = clamp(j, 0, this.h - 1), this.get(i, j);
            }
        }, {
            key: "getAt",
            value: function getAt(x, y) {
                var fx = x / this.w, fy = y / this.h, ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
                ix0 = clamp(ix0, 0, this.w - 1), iz0 = clamp(iz0, 0, this.h - 1), ix1 = clamp(ix1, 0, this.w - 1), 
                iz1 = clamp(iz1, 0, this.h - 1);
                var a = this.get(ix0, iz0), b = this.get(ix1, iz0), c = this.get(ix0, iz1), d = this.get(ix1, iz1), m = .5 * (b + c);
                return dx + dz <= 1 ? d = m + (m - a) : a = m + (m - d), (a * (1 - dx) + b * dx) * (1 - dz) + (c * (1 - dx) + d * dx) * dz;
            }
        } ]), HeightField;
    }(), TerrainBuffer = function() {
        function TerrainBuffer() {
            _classCallCheck(this, TerrainBuffer), this.Length = 0, this.Buffer = new Uint8Array(2048), 
            this._dview = new DataView(this.Buffer.buffer), this._seekPos = 0;
        }
        return _createClass(TerrainBuffer, [ {
            key: "Reserve",
            value: function Reserve(size) {
                if (!(this.Buffer.byteLength > size)) {
                    for (var capacity = this.Buffer.byteLength; capacity < size; ) capacity += capacity;
                    for (var temp = new Uint8Array(capacity), i = 0; i < this.Length; ++i) temp[i] = this.Buffer[i];
                    this.Buffer = temp, this._dview = new DataView(this.Buffer.buffer);
                }
            }
        }, {
            key: "Assign",
            value: function Assign(buff) {
                this.Buffer = buff, this.Length = buff.length, this._seekPos = buff.byteOffset, 
                this._dview = new DataView(buff.buffer);
            }
        }, {
            key: "WriteInt8",
            value: function WriteInt8(value) {
                this.Reserve(this.Length + 1), this._dview.setInt8(this.Length, value), this.Length += 1;
            }
        }, {
            key: "WriteInt16",
            value: function WriteInt16(value) {
                this.Reserve(this.Length + 2), this._dview.setInt16(this.Length, value, !0), this.Length += 2;
            }
        }, {
            key: "WriteInt32",
            value: function WriteInt32(value) {
                this.Reserve(this.Length + 4), this._dview.setInt32(this.Length, value, !0), this.Length += 4;
            }
        }, {
            key: "WriteIntArray",
            value: function WriteIntArray(value) {
                this.Reserve(this.Length + 4 * value.length);
                for (var i = 0; i < value.length; ++i) this._dview.setInt32(this.Length + 4 * i, value[i], !0);
                this.Length += 4 * value.length;
            }
        }, {
            key: "WriteFloat",
            value: function WriteFloat(value) {
                this.Reserve(this.Length + 4), this._dview.setFloat32(this.Length, value, !0), this.Length += 4;
            }
        }, {
            key: "WriteFloatArray",
            value: function WriteFloatArray(value) {
                this.Reserve(this.Length + 4 * value.length);
                for (var i = 0; i < value.length; ++i) this._dview.setFloat32(this.Length + 4 * i, value[i], !0);
                this.Length += 4 * value.length;
            }
        }, {
            key: "WriteString",
            value: function WriteString(value) {
                this.Reserve(this.Length + value.length + 4), this._dview.setInt32(this.Length, value.length, !0);
                for (var i = 0; i < value.length; ++i) this._dview.setInt8(this.Length + 4 + i, value.charCodeAt(i));
                this.Length += value.length + 4;
            }
        }, {
            key: "ReadInt8",
            value: function ReadInt8() {
                var value = this._dview.getInt8(this._seekPos);
                return this._seekPos += 1, value;
            }
        }, {
            key: "ReadInt16",
            value: function ReadInt16() {
                var value = this._dview.getInt16(this._seekPos, !0);
                return this._seekPos += 2, value;
            }
        }, {
            key: "ReadInt",
            value: function ReadInt() {
                var value = this._dview.getInt32(this._seekPos, !0);
                return this._seekPos += 4, value;
            }
        }, {
            key: "ReadIntArray",
            value: function ReadIntArray(value) {
                for (var i = 0; i < value.length; ++i) value[i] = this._dview.getInt32(this._seekPos + 4 * i, !0);
                return this._seekPos += 4 * value.length, value;
            }
        }, {
            key: "ReadFloat",
            value: function ReadFloat() {
                var value = this._dview.getFloat32(this._seekPos, !0);
                return this._seekPos += 4, value;
            }
        }, {
            key: "ReadFloatArray",
            value: function ReadFloatArray(value) {
                for (var i = 0; i < value.length; ++i) value[i] = this._dview.getFloat32(this._seekPos + 4 * i, !0);
                return this._seekPos += 4 * value.length, value;
            }
        }, {
            key: "ReadString",
            value: function ReadString() {
                for (var length = this.ReadInt(), value = "", i = 0; i < length; ++i) value += String.fromCharCode(this.ReadInt8());
                return value;
            }
        } ]), TerrainBuffer;
    }(), TerrainLayerInfo = function TerrainLayerInfo() {
        _classCallCheck(this, TerrainLayerInfo), this.slot = 0, this.tileSize = 1, this.detailMap = "";
    }, TerrainAsset = ccclass("cc.TerrainAsset")(_class$1V = function(_Asset) {
        function TerrainAsset() {
            var _this;
            return _classCallCheck(this, TerrainAsset), (_this = _possibleConstructorReturn(this, _getPrototypeOf(TerrainAsset).call(this)))._data = null, 
            _this._tileSize = 1, _this._blockCount = [ 1, 1 ], _this._weightMapSize = 128, _this._lightMapSize = 128, 
            _this._heights = new Uint16Array, _this._weights = new Uint8Array, _this._layerBuffer = [ -1, -1, -1, -1 ], 
            _this._layerInfos = [], _this.loaded = !1, _this;
        }
        return _inherits(TerrainAsset, _Asset), _createClass(TerrainAsset, [ {
            key: "getLayer",
            value: function getLayer(xblock, yblock, layerId) {
                var index = 4 * (yblock * this.blockCount[0] + xblock) + layerId;
                return xblock < this.blockCount[0] && yblock < this.blockCount[1] && index < this._layerBuffer.length ? this._layerBuffer[index] : -1;
            }
        }, {
            key: "_setNativeData",
            value: function _setNativeData(_nativeData) {
                this._data = _nativeData;
            }
        }, {
            key: "_loadNativeData",
            value: function _loadNativeData(_nativeData) {
                var stream = new TerrainBuffer;
                stream.Assign(_nativeData);
                var version = stream.ReadInt();
                if (16843025 === version) return !0;
                if (16842753 !== version && 16842754 !== version && 16842755 !== version) return !1;
                this.tileSize = stream.ReadFloat(), stream.ReadIntArray(this._blockCount), this.weightMapSize = stream.ReadInt16(), 
                this.lightMapSize = stream.ReadInt16();
                var heightBufferSize = stream.ReadInt();
                this.heights = new Uint16Array(heightBufferSize);
                for (var i = 0; i < this.heights.length; ++i) this.heights[i] = stream.ReadInt16();
                var WeightBufferSize = stream.ReadInt();
                this.weights = new Uint8Array(WeightBufferSize);
                for (var _i = 0; _i < this.weights.length; ++_i) this.weights[_i] = stream.ReadInt8();
                if (version >= 16842754) {
                    var layerBufferSize = stream.ReadInt();
                    this.layerBuffer = new Array(layerBufferSize);
                    for (var _i2 = 0; _i2 < this.layerBuffer.length; ++_i2) this.layerBuffer[_i2] = stream.ReadInt16();
                }
                if (version >= 16842755) {
                    var layerInfoSize = stream.ReadInt();
                    this.layerInfos = new Array(layerInfoSize);
                    for (var _i3 = 0; _i3 < this.layerInfos.length; ++_i3) this.layerInfos[_i3] = new TerrainLayerInfo, 
                    this.layerInfos[_i3].slot = stream.ReadInt(), this.layerInfos[_i3].tileSize = stream.ReadFloat(), 
                    this.layerInfos[_i3].detailMap = stream.ReadString();
                }
                return !0;
            }
        }, {
            key: "_exportNativeData",
            value: function _exportNativeData() {
                var stream = new TerrainBuffer;
                stream.WriteInt32(16842755), stream.WriteFloat(this.tileSize), stream.WriteIntArray(this._blockCount), 
                stream.WriteInt16(this.weightMapSize), stream.WriteInt16(this.lightMapSize), stream.WriteInt32(this.heights.length);
                for (var i = 0; i < this.heights.length; ++i) stream.WriteInt16(this.heights[i]);
                stream.WriteInt32(this.weights.length);
                for (var _i4 = 0; _i4 < this.weights.length; ++_i4) stream.WriteInt8(this.weights[_i4]);
                stream.WriteInt32(this.layerBuffer.length);
                for (var _i5 = 0; _i5 < this.layerBuffer.length; ++_i5) stream.WriteInt16(this.layerBuffer[_i5]);
                stream.WriteInt32(this.layerInfos.length);
                for (var _i6 = 0; _i6 < this.layerInfos.length; ++_i6) stream.WriteInt32(this.layerInfos[_i6].slot), 
                stream.WriteFloat(this.layerInfos[_i6].tileSize), stream.WriteString(this.layerInfos[_i6].detailMap);
                return stream.Buffer;
            }
        }, {
            key: "_exportDefaultNativeData",
            value: function _exportDefaultNativeData() {
                var stream = new TerrainBuffer;
                return stream.WriteInt32(16843025), stream.Buffer;
            }
        }, {
            key: "_nativeAsset",
            get: function get() {
                return this._data.buffer;
            },
            set: function set(value) {
                this._data && this._data.byteLength === value.byteLength ? (this._data.set(new Uint8Array(value)), 
                cc.loader._cache[this.nativeUrl] && (cc.loader._cache[this.nativeUrl].content = this._data.buffer)) : this._data = new Uint8Array(value), 
                this._loadNativeData(this._data), this.loaded = !0, this.emit("load");
            }
        }, {
            key: "tileSize",
            set: function set(value) {
                this._tileSize = value;
            },
            get: function get() {
                return this._tileSize;
            }
        }, {
            key: "blockCount",
            set: function set(value) {
                this._blockCount = value;
            },
            get: function get() {
                return this._blockCount;
            }
        }, {
            key: "lightMapSize",
            set: function set(value) {
                this._lightMapSize = value;
            },
            get: function get() {
                return this._lightMapSize;
            }
        }, {
            key: "weightMapSize",
            set: function set(value) {
                this._weightMapSize = value;
            },
            get: function get() {
                return this._weightMapSize;
            }
        }, {
            key: "heights",
            set: function set(value) {
                this._heights = value;
            },
            get: function get() {
                return this._heights;
            }
        }, {
            key: "weights",
            set: function set(value) {
                this._weights = value;
            },
            get: function get() {
                return this._weights;
            }
        }, {
            key: "layerBuffer",
            set: function set(value) {
                this._layerBuffer = value;
            },
            get: function get() {
                return this._layerBuffer;
            }
        }, {
            key: "layerInfos",
            set: function set(value) {
                this._layerInfos = value;
            },
            get: function get() {
                return this._layerInfos;
            }
        } ]), TerrainAsset;
    }(Asset)) || _class$1V, TerrainInfo = (_dec$1V = ccclass("cc.TerrainInfo"), _dec2$1r = property({
        tooltip: "地形Tile的大小"
    }), _dec$1V((_descriptor$1x = _applyDecoratedDescriptor((_class2$1I = function() {
        function TerrainInfo() {
            _classCallCheck(this, TerrainInfo), _initializerDefineProperty(this, "tileSize", _descriptor$1x, this), 
            _initializerDefineProperty(this, "blockCount", _descriptor2$1j, this), _initializerDefineProperty(this, "weightMapSize", _descriptor3$15, this), 
            _initializerDefineProperty(this, "lightMapSize", _descriptor4$V, this);
        }
        return _createClass(TerrainInfo, [ {
            key: "size",
            get: function get() {
                var sz = new Size(0, 0);
                return sz.width = 32 * this.blockCount[0] * this.tileSize, sz.height = 32 * this.blockCount[1] * this.tileSize, 
                sz;
            }
        }, {
            key: "tileCount",
            get: function get() {
                var _tileCount = [ 0, 0 ];
                return _tileCount[0] = 32 * this.blockCount[0], _tileCount[1] = 32 * this.blockCount[1], 
                _tileCount;
            }
        }, {
            key: "vertexCount",
            get: function get() {
                var _vertexCount = this.tileCount;
                return _vertexCount[0] += 1, _vertexCount[1] += 1, _vertexCount;
            }
        } ]), TerrainInfo;
    }()).prototype, "tileSize", [ _dec2$1r ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor2$1j = _applyDecoratedDescriptor(_class2$1I.prototype, "blockCount", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [ 1, 1 ];
        }
    }), _descriptor3$15 = _applyDecoratedDescriptor(_class2$1I.prototype, "weightMapSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 128;
        }
    }), _descriptor4$V = _applyDecoratedDescriptor(_class2$1I.prototype, "lightMapSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 128;
        }
    }), _class$1W = _class2$1I)) || _class$1W), TerrainLayer = (_dec3$19 = ccclass("cc.TerrainLayer"), 
    _dec4$10 = property({
        tooltip: "当前Layer的纹理"
    }), _dec5$X = property({
        tooltip: "纹理的平铺大小，值越小会在同样大小的区域内进行更多次的平铺"
    }), _dec3$19((_descriptor5$K = _applyDecoratedDescriptor((_class5$9 = function TerrainLayer() {
        _classCallCheck(this, TerrainLayer), _initializerDefineProperty(this, "detailMap", _descriptor5$K, this), 
        _initializerDefineProperty(this, "tileSize", _descriptor6$w, this);
    }).prototype, "detailMap", [ _dec4$10 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor6$w = _applyDecoratedDescriptor(_class5$9.prototype, "tileSize", [ _dec5$X ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _class4$a = _class5$9)) || _class4$a), TerrainRenderable = function(_RenderableComponent) {
        function TerrainRenderable() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, TerrainRenderable);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TerrainRenderable)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._model = null, 
            _this._meshData = null, _this._brushMaterial = null, _this._currentMaterial = null, 
            _this._currentMaterialLayers = 0, _this;
        }
        return _inherits(TerrainRenderable, _RenderableComponent), _createClass(TerrainRenderable, [ {
            key: "destroy",
            value: function destroy() {
                this._invalidMaterial(), null != this._model && (cc.director.root.destroyModel(this._model), 
                this._model = null), _get(_getPrototypeOf(TerrainRenderable.prototype), "destroy", this).call(this);
            }
        }, {
            key: "_invalidMaterial",
            value: function _invalidMaterial() {
                null != this._currentMaterial && (this._clearMaterials(), this._currentMaterial = null, 
                null != this._model && (this._model.enabled = !1));
            }
        }, {
            key: "_updateMaterial",
            value: function _updateMaterial(block, init) {
                if (null != this._meshData && null != this._model) {
                    var nlayers = block.getMaxLayer();
                    if (null == this._currentMaterial || nlayers !== this._currentMaterialLayers) {
                        if (this._currentMaterial = new Material, this._currentMaterial.initialize({
                            effectAsset: cc.EffectAsset.get("builtin-terrain"),
                            defines: block._getMaterialDefines(nlayers)
                        }), null !== this._brushMaterial) this._currentMaterial.passes.push(this._brushMaterial.passes[0]);
                        init && this._model.initSubModel(0, this._meshData, this._currentMaterial), this.setMaterial(this._currentMaterial, 0), 
                        this._currentMaterialLayers = nlayers, this._model.enabled = !0;
                    }
                }
            }
        }, {
            key: "_onMaterialModified",
            value: function _onMaterialModified(idx, mtl) {
                null != this._model && this._onRebuildPSO(idx, mtl || this._getBuiltinMaterial());
            }
        }, {
            key: "_onRebuildPSO",
            value: function _onRebuildPSO(idx, material) {
                this._model && this._model.setSubModelMaterial(idx, material);
            }
        }, {
            key: "_clearMaterials",
            value: function _clearMaterials() {
                null != this._model && this._onMaterialModified(0, null);
            }
        }, {
            key: "_getBuiltinMaterial",
            value: function _getBuiltinMaterial() {
                return builtinResMgr.get("missing-material");
            }
        } ]), TerrainRenderable;
    }(RenderableComponent), TerrainBlockInfo = ccclass("cc.TerrainBlockInfo")((_descriptor7$q = _applyDecoratedDescriptor((_class8$3 = function TerrainBlockInfo() {
        _classCallCheck(this, TerrainBlockInfo), _initializerDefineProperty(this, "layers", _descriptor7$q, this), 
        this.lightMap = null, this.lightMapUOff = 0, this.lightMapVOff = 0, this.lightMapUScale = 0, 
        this.lightMapVScale = 0;
    }).prototype, "layers", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [ -1, -1, -1, -1 ];
        }
    }), _class7$3 = _class8$3)) || _class7$3, TerrainBlock = function() {
        function TerrainBlock(t, i, j) {
            _classCallCheck(this, TerrainBlock), this._index = [ 1, 1 ], this._weightMap = null, 
            this._terrain = t, this._info = t.getBlockInfo(i, j), this._index[0] = i, this._index[1] = j, 
            this._node = new PrivateNode(""), this._node.setParent(this._terrain.node), this._node._objFlags |= cc.Object.Flags.DontSave, 
            this._renderable = this._node.addComponent(TerrainRenderable);
        }
        return _createClass(TerrainBlock, [ {
            key: "build",
            value: function build() {
                for (var gfxDevice = director.root.device, vertexData = new Float32Array(8712), index = 0, j = 0; j < 33; ++j) for (var i = 0; i < 33; ++i) {
                    var x = 32 * this._index[0] + i, y = 32 * this._index[1] + j, position = this._terrain.getPosition(x, y), normal = this._terrain.getNormal(x, y), uv = new Vec2(i / 32, j / 32);
                    vertexData[index++] = position.x, vertexData[index++] = position.y, vertexData[index++] = position.z, 
                    vertexData[index++] = normal.x, vertexData[index++] = normal.y, vertexData[index++] = normal.z, 
                    vertexData[index++] = uv.x, vertexData[index++] = uv.y;
                }
                var vertexBuffer = gfxDevice.createBuffer({
                    usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: 8 * Float32Array.BYTES_PER_ELEMENT * 33 * 33,
                    stride: 8 * Float32Array.BYTES_PER_ELEMENT
                });
                vertexBuffer.update(vertexData);
                var gfxAttributes = [ {
                    name: exports.GFXAttributeName.ATTR_POSITION,
                    format: exports.GFXFormat.RGB32F
                }, {
                    name: exports.GFXAttributeName.ATTR_NORMAL,
                    format: exports.GFXFormat.RGB32F
                }, {
                    name: exports.GFXAttributeName.ATTR_TEX_COORD,
                    format: exports.GFXFormat.RG32F
                } ];
                this._renderable._meshData = {
                    attributes: gfxAttributes,
                    vertexBuffers: [ vertexBuffer ],
                    indexBuffer: this._terrain.getSharedIndexBuffer(),
                    flatBuffers: [],
                    primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_LIST
                }, this._renderable._model = cc.director.root.createModel(Model), this._renderable._model.initialize(this._node), 
                this._renderable._getRenderScene().addModel(this._renderable._model), this._updateWeightMap(), 
                this._updateMaterial(!0);
            }
        }, {
            key: "rebuild",
            value: function rebuild() {
                this._updateHeight(), this._updateWeightMap(), this._renderable._invalidMaterial(), 
                this._updateMaterial(!1);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                null != this._renderable && this._renderable.destroy(), null != this._node && this._node.destroy(), 
                null != this._weightMap && this._weightMap.destroy();
            }
        }, {
            key: "update",
            value: function update() {
                this._updateMaterial(!1);
                var mtl = this._renderable._currentMaterial;
                if (null != mtl) {
                    var nlayers = this.getMaxLayer(), uvScale = new Vec4(1, 1, 1, 1);
                    if (0 === nlayers) if (-1 !== this.layers[0]) {
                        var l0 = this._terrain.getLayer(this.layers[0]);
                        null != l0 && (uvScale.x = 1 / l0.tileSize), mtl.setProperty("detailMap0", null != l0 ? l0.detailMap : null);
                    } else mtl.setProperty("detailMap0", cc.builtinResMgr.get("default-texture")); else if (1 === nlayers) {
                        var _l = this._terrain.getLayer(this.layers[0]), l1 = this._terrain.getLayer(this.layers[1]);
                        null != _l && (uvScale.x = 1 / _l.tileSize), null != l1 && (uvScale.y = 1 / l1.tileSize), 
                        mtl.setProperty("weightMap", this._weightMap), mtl.setProperty("detailMap0", null != _l ? _l.detailMap : null), 
                        mtl.setProperty("detailMap1", null != l1 ? l1.detailMap : null);
                    } else if (2 === nlayers) {
                        var _l2 = this._terrain.getLayer(this.layers[0]), _l3 = this._terrain.getLayer(this.layers[1]), l2 = this._terrain.getLayer(this.layers[2]);
                        null != _l2 && (uvScale.x = 1 / _l2.tileSize), null != _l3 && (uvScale.y = 1 / _l3.tileSize), 
                        null != l2 && (uvScale.z = 1 / l2.tileSize), mtl.setProperty("weightMap", this._weightMap), 
                        mtl.setProperty("detailMap0", null != _l2 ? _l2.detailMap : null), mtl.setProperty("detailMap1", null != _l3 ? _l3.detailMap : null), 
                        mtl.setProperty("detailMap2", null != l2 ? l2.detailMap : null);
                    } else if (3 === nlayers) {
                        var _l4 = this._terrain.getLayer(this.layers[0]), _l5 = this._terrain.getLayer(this.layers[1]), _l6 = this._terrain.getLayer(this.layers[2]), l3 = this._terrain.getLayer(this.layers[3]);
                        null != _l4 && (uvScale.x = 1 / _l4.tileSize), null != _l5 && (uvScale.y = 1 / _l5.tileSize), 
                        null != _l6 && (uvScale.z = 1 / _l6.tileSize), null != l3 && (uvScale.z = 1 / l3.tileSize), 
                        mtl.setProperty("weightMap", this._weightMap), mtl.setProperty("detailMap0", null != _l4 ? _l4.detailMap : null), 
                        mtl.setProperty("detailMap1", null != _l5 ? _l5.detailMap : null), mtl.setProperty("detailMap2", null != _l6 ? _l6.detailMap : null), 
                        mtl.setProperty("detailMap3", null != l3 ? l3.detailMap : null);
                    }
                    mtl.setProperty("UVScale", uvScale), null != this.lightmap && (mtl.setProperty("lightMap", this.lightmap), 
                    mtl.setProperty("lightMapUVParam", this.lightmapUVParam));
                }
            }
        }, {
            key: "setBrushMaterial",
            value: function setBrushMaterial(mtl) {
                this._renderable._brushMaterial !== mtl && (this._renderable._brushMaterial = mtl, 
                this._renderable._invalidMaterial());
            }
        }, {
            key: "getTerrain",
            value: function getTerrain() {
                return this._terrain;
            }
        }, {
            key: "getIndex",
            value: function getIndex() {
                return this._index;
            }
        }, {
            key: "getRect",
            value: function getRect() {
                var rect = new Rect;
                return rect.x = 32 * this._index[0], rect.y = 32 * this._index[1], rect.width = 32, 
                rect.height = 32, rect;
            }
        }, {
            key: "setLayer",
            value: function setLayer(index, layerId) {
                this.layers[index] !== layerId && (this.layers[index] = layerId, this._renderable._invalidMaterial(), 
                this._updateMaterial(!1));
            }
        }, {
            key: "getLayer",
            value: function getLayer(index) {
                return this.layers[index];
            }
        }, {
            key: "getMaxLayer",
            value: function getMaxLayer() {
                return this.layers[3] >= 0 ? 3 : this.layers[2] >= 0 ? 2 : this.layers[1] >= 0 ? 1 : 0;
            }
        }, {
            key: "_getMaterialDefines",
            value: function _getMaterialDefines(nlayers) {
                if (null != this.lightmap) {
                    if (0 === nlayers) return {
                        LAYERS: 1,
                        LIGHT_MAP: 1
                    };
                    if (1 === nlayers) return {
                        LAYERS: 2,
                        LIGHT_MAP: 1
                    };
                    if (2 === nlayers) return {
                        LAYERS: 3,
                        LIGHT_MAP: 1
                    };
                    if (3 === nlayers) return {
                        LAYERS: 4,
                        LIGHT_MAP: 1
                    };
                } else {
                    if (0 === nlayers) return {
                        LAYERS: 1
                    };
                    if (1 === nlayers) return {
                        LAYERS: 2
                    };
                    if (2 === nlayers) return {
                        LAYERS: 3
                    };
                    if (3 === nlayers) return {
                        LAYERS: 4
                    };
                }
                return {
                    LAYERS: 0
                };
            }
        }, {
            key: "_invalidMaterial",
            value: function _invalidMaterial() {
                this._renderable._invalidMaterial();
            }
        }, {
            key: "_updateMaterial",
            value: function _updateMaterial(init) {
                this._renderable._updateMaterial(this, init);
            }
        }, {
            key: "_updateHeight",
            value: function _updateHeight() {
                if (null != this._renderable._meshData) {
                    for (var vertexData = new Float32Array(8712), index = 0, j = 0; j < 33; ++j) for (var i = 0; i < 33; ++i) {
                        var x = 32 * this._index[0] + i, y = 32 * this._index[1] + j, position = this._terrain.getPosition(x, y), normal = this._terrain.getNormal(x, y), uv = new Vec2(i / 33, j / 33);
                        vertexData[index++] = position.x, vertexData[index++] = position.y, vertexData[index++] = position.z, 
                        vertexData[index++] = normal.x, vertexData[index++] = normal.y, vertexData[index++] = normal.z, 
                        vertexData[index++] = uv.x, vertexData[index++] = uv.y;
                    }
                    this._renderable._meshData.vertexBuffers[0].update(vertexData);
                }
            }
        }, {
            key: "_updateWeightMap",
            value: function _updateWeightMap() {
                if (0 !== this.getMaxLayer()) {
                    null == this._weightMap && (this._weightMap = new Texture2D, this._weightMap.create(this._terrain.weightMapSize, this._terrain.weightMapSize, PixelFormat.RGBA8888), 
                    this._weightMap.setFilters(Filter.LINEAR, Filter.LINEAR), this._weightMap.setWrapMode(WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE));
                    for (var weightData = new Uint8Array(this._terrain.weightMapSize * this._terrain.weightMapSize * 4), weightIndex = 0, j = 0; j < this._terrain.weightMapSize; ++j) for (var i = 0; i < this._terrain.weightMapSize; ++i) {
                        var x = this._index[0] * this._terrain.weightMapSize + i, y = this._index[1] * this._terrain.weightMapSize + j, w = this._terrain.getWeight(x, y);
                        weightData[4 * weightIndex + 0] = Math.floor(255 * w.x), weightData[4 * weightIndex + 1] = Math.floor(255 * w.y), 
                        weightData[4 * weightIndex + 2] = Math.floor(255 * w.z), weightData[4 * weightIndex + 3] = Math.floor(255 * w.w), 
                        weightIndex += 1;
                    }
                    this._weightMap.uploadData(weightData);
                } else null != this._weightMap && (this._weightMap.destroy(), this._weightMap = null);
            }
        }, {
            key: "_updateLightmap",
            value: function _updateLightmap(tex, uoff, voff, uscale, vscale) {
                this._info.lightMap = tex, this._info.lightMapUOff = uoff, this._info.lightMapVOff = voff, 
                this._info.lightMapUScale = uscale, this._info.lightMapVScale = vscale, this._invalidMaterial();
            }
        }, {
            key: "layers",
            get: function get() {
                return this._info.layers;
            }
        }, {
            key: "lightmap",
            get: function get() {
                return this._info.lightMap;
            }
        }, {
            key: "lightmapUVParam",
            get: function get() {
                return new Vec4(this._info.lightMapUOff, this._info.lightMapVOff, this._info.lightMapUScale, this._info.lightMapVScale);
            }
        } ]), TerrainBlock;
    }(), Terrain = (_dec7$H = ccclass("cc.Terrain"), _dec8$u = property({
        type: TerrainAsset,
        visible: !1
    }), _dec9$n = property({
        type: TerrainLayer,
        visible: !0
    }), _dec10$l = property({
        visible: !1
    }), _dec11$l = property({
        type: TerrainAsset,
        visible: !0,
        serializable: !1
    }), _dec12$h = property({
        type: TerrainInfo,
        visible: !0
    }), _dec7$H(_class10$2 = executeInEditMode(_class10$2 = disallowMultiple((_descriptor8$m = _applyDecoratedDescriptor((_class11$2 = function(_Component) {
        function Terrain() {
            var _this2;
            _classCallCheck(this, Terrain), _initializerDefineProperty(_this2 = _possibleConstructorReturn(this, _getPrototypeOf(Terrain).call(this)), "__asset", _descriptor8$m, _assertThisInitialized(_this2)), 
            _initializerDefineProperty(_this2, "_layers", _descriptor9$h, _assertThisInitialized(_this2)), 
            _initializerDefineProperty(_this2, "_blockInfos", _descriptor10$h, _assertThisInitialized(_this2)), 
            _this2._tileSize = 1, _this2._blockCount = [ 1, 1 ], _this2._weightMapSize = 128, 
            _this2._lightMapSize = 128, _this2._heights = new Uint16Array, _this2._weights = new Uint8Array, 
            _this2._normals = [], _this2._blocks = [], _this2._sharedIndexBuffer = null;
            for (var i = 0; i < 256; ++i) _this2._layers.push(null);
            return _this2;
        }
        return _inherits(Terrain, _Component), _createClass(Terrain, [ {
            key: "build",
            value: function build(info) {
                return this._tileSize = info.tileSize, this._blockCount[0] = info.blockCount[0], 
                this._blockCount[1] = info.blockCount[1], this._weightMapSize = info.weightMapSize, 
                this._lightMapSize = info.lightMapSize, this._buildImp();
            }
        }, {
            key: "rebuild",
            value: function rebuild(info) {
                for (var blockInfos = [], i = 0; i < info.blockCount[0] * info.blockCount[1]; ++i) blockInfos.push(new TerrainBlockInfo);
                for (var w = Math.min(this._blockCount[0], info.blockCount[0]), h = Math.min(this._blockCount[1], info.blockCount[1]), j = 0; j < h; ++j) for (var _i2 = 0; _i2 < w; ++_i2) {
                    var index0 = j * info.vertexCount[0] + _i2, index1 = j * this.vertexCount[0] + _i2;
                    blockInfos[index0] = this._blockInfos[index1];
                }
                this._blockInfos = blockInfos;
                var _iterator = this._blocks, _isArray = Array.isArray(_iterator), _i3 = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i3 >= _iterator.length) break;
                        _ref = _iterator[_i3++];
                    } else {
                        if ((_i3 = _iterator.next()).done) break;
                        _ref = _i3.value;
                    }
                    _ref.destroy();
                }
                this._blocks = [], this._rebuildHeights(info), this._rebuildWeights(info), this._tileSize = info.tileSize, 
                this._blockCount[0] = info.blockCount[0], this._blockCount[1] = info.blockCount[1], 
                this._weightMapSize = info.weightMapSize, this._lightMapSize = info.lightMapSize, 
                this._buildNormals();
                for (var _j2 = 0; _j2 < this._blockCount[1]; ++_j2) for (var _i4 = 0; _i4 < this._blockCount[0]; ++_i4) this._blocks.push(new TerrainBlock(this, _i4, _j2));
                var _iterator2 = this._blocks, _isArray2 = Array.isArray(_iterator2), _i5 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i5 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i5++];
                    } else {
                        if ((_i5 = _iterator2.next()).done) break;
                        _ref2 = _i5.value;
                    }
                    _ref2.build();
                }
            }
        }, {
            key: "importHeightField",
            value: function importHeightField(hf, heightScale) {
                for (var index = 0, j = 0; j < this.vertexCount[1]; ++j) for (var i = 0; i < this.vertexCount[0]; ++i) {
                    var u = i / this.tileCount[0], v = j / this.tileCount[1], h = hf.getAt(u * hf.w, v * hf.h) * heightScale;
                    this._heights[index++] = h;
                }
                this._buildNormals();
                var _iterator3 = this._blocks, _isArray3 = Array.isArray(_iterator3), _i7 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i7 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i7++];
                    } else {
                        if ((_i7 = _iterator3.next()).done) break;
                        _ref3 = _i7.value;
                    }
                    _ref3._updateHeight();
                }
            }
        }, {
            key: "exportHeightField",
            value: function exportHeightField(hf, heightScale) {
                for (var index = 0, j = 0; j < hf.h; ++j) for (var i = 0; i < hf.w; ++i) {
                    var u = i / (hf.w - 1), v = j / (hf.h - 1), x = u * this.size.width, y = v * this.size.height, h = this.getHeightAt(x, y);
                    null != h && (hf.data[index++] = h * heightScale);
                }
            }
        }, {
            key: "exportAsset",
            value: function exportAsset() {
                var asset = this._asset;
                null == asset && (asset = new TerrainAsset), asset.tileSize = this.tileSize, asset.blockCount = this.blockCount, 
                asset.lightMapSize = this.lightMapSize, asset.weightMapSize = this.weightMapSize, 
                asset.heights = this.heights, asset.weights = this.weights, asset.layerBuffer = new Array(4 * this._blocks.length);
                for (var i = 0; i < this._blocks.length; ++i) asset.layerBuffer[4 * i + 0] = this._blocks[i].layers[0], 
                asset.layerBuffer[4 * i + 1] = this._blocks[i].layers[1], asset.layerBuffer[4 * i + 2] = this._blocks[i].layers[2], 
                asset.layerBuffer[4 * i + 3] = this._blocks[i].layers[3];
                for (var _i9 = 0; _i9 < this._layers.length; ++_i9) {
                    var tlayer = this._layers[_i9];
                    if (null != tlayer && null != tlayer.detailMap) {
                        var ilayer = new TerrainLayerInfo;
                        ilayer.slot = _i9, ilayer.tileSize = tlayer.tileSize, ilayer.detailMap = tlayer.detailMap._uuid, 
                        asset.layerInfos.push(ilayer);
                    }
                }
                return asset;
            }
        }, {
            key: "onLoad",
            value: function onLoad() {
                for (var gfxDevice = cc.director.root.device, indexData = new Uint16Array(6144), index = 0, j = 0; j < 32; ++j) for (var i = 0; i < 32; ++i) {
                    var a = 33 * j + i, b = 33 * j + i + 1, c = 33 * (j + 1) + i, d = 33 * (j + 1) + i + 1;
                    indexData[index++] = a, indexData[index++] = c, indexData[index++] = b, indexData[index++] = b, 
                    indexData[index++] = c, indexData[index++] = d;
                }
                this._sharedIndexBuffer = gfxDevice.createBuffer({
                    usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: 32 * Uint16Array.BYTES_PER_ELEMENT * 32 * 6,
                    stride: Uint16Array.BYTES_PER_ELEMENT
                }), this._sharedIndexBuffer.update(indexData);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                0 === this._blocks.length && this._buildImp();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                var _iterator4 = this._blocks, _isArray4 = Array.isArray(_iterator4), _i10 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i10 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i10++];
                    } else {
                        if ((_i10 = _iterator4.next()).done) break;
                        _ref4 = _i10.value;
                    }
                    _ref4.destroy();
                }
                this._blocks = [];
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                for (var i = 0; i < this._layers.length; ++i) this._layers[i] = null;
                null != this._sharedIndexBuffer && this._sharedIndexBuffer.destroy();
            }
        }, {
            key: "onRestore",
            value: function onRestore() {
                this.onDisable(), this.onLoad(), this._buildImp();
            }
        }, {
            key: "update",
            value: function update(dtime) {
                var _iterator5 = this._blocks, _isArray5 = Array.isArray(_iterator5), _i11 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i11 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i11++];
                    } else {
                        if ((_i11 = _iterator5.next()).done) break;
                        _ref5 = _i11.value;
                    }
                    _ref5.update();
                }
            }
        }, {
            key: "addLayer",
            value: function addLayer(layer) {
                for (var i = 0; i < this._layers.length; ++i) if (null == this._layers[i]) return this._layers[i] = layer, 
                i;
                return -1;
            }
        }, {
            key: "setLayer",
            value: function setLayer(i, layer) {
                this._layers[i] = layer;
            }
        }, {
            key: "removeLayer",
            value: function removeLayer(id) {
                this._layers[id] = null;
            }
        }, {
            key: "getLayer",
            value: function getLayer(id) {
                return -1 === id ? null : this._layers[id];
            }
        }, {
            key: "getPosition",
            value: function getPosition(i, j) {
                var x = i * this._tileSize, z = j * this._tileSize, y = this.getHeight(i, j);
                return new Vec3(x, y, z);
            }
        }, {
            key: "getHeightField",
            value: function getHeightField() {
                return this._heights;
            }
        }, {
            key: "setHeight",
            value: function setHeight(i, j, h) {
                this._heights[j * this.vertexCount[0] + i] = 32768 + h / (1 / 512);
            }
        }, {
            key: "getHeight",
            value: function getHeight(i, j) {
                return (this._heights[j * this.vertexCount[0] + i] - 32768) * (1 / 512);
            }
        }, {
            key: "getHeightClamp",
            value: function getHeightClamp(i, j) {
                return i = clamp(i, 0, this.vertexCount[0] - 1), j = clamp(j, 0, this.vertexCount[1] - 1), 
                this.getHeight(i, j);
            }
        }, {
            key: "getHeightAt",
            value: function getHeightAt(x, y) {
                var fx = x / this.vertexCount[0], fy = y / this.vertexCount[1], ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
                if (ix0 < 0 || ix0 > this.vertexCount[0] - 1 || iz0 < 0 || iz0 > this.vertexCount[1] - 1) return null;
                ix0 = clamp(ix0, 0, this.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this.vertexCount[1] - 1), 
                ix1 = clamp(ix1, 0, this.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this.vertexCount[1] - 1);
                var a = this.getHeight(ix0, iz0), b = this.getHeight(ix1, iz0), c = this.getHeight(ix0, iz1), d = this.getHeight(ix1, iz1), m = .5 * (b + c);
                return dx + dz <= 1 ? d = m + (m - a) : a = m + (m - d), (a * (1 - dx) + b * dx) * (1 - dz) + (c * (1 - dx) + d * dx) * dz;
            }
        }, {
            key: "_setNormal",
            value: function _setNormal(i, j, n) {
                var index = j * this.vertexCount[0] + i;
                this._normals[3 * index + 0] = n.x, this._normals[3 * index + 1] = n.y, this._normals[3 * index + 2] = n.z;
            }
        }, {
            key: "getNormal",
            value: function getNormal(i, j) {
                var index = j * this.vertexCount[0] + i, n = new Vec3;
                return n.x = this._normals[3 * index + 0], n.y = this._normals[3 * index + 1], n.z = this._normals[3 * index + 2], 
                n;
            }
        }, {
            key: "getNormalAt",
            value: function getNormalAt(x, y) {
                var fx = x / this.vertexCount[0], fy = y / this.vertexCount[1], ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
                if (ix0 < 0 || ix0 > this.vertexCount[0] - 1 || iz0 < 0 || iz0 > this.vertexCount[1] - 1) return null;
                ix0 = clamp(ix0, 0, this.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this.vertexCount[1] - 1), 
                ix1 = clamp(ix1, 0, this.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this.vertexCount[1] - 1);
                var a = this.getNormal(ix0, iz0), b = this.getNormal(ix1, iz0), c = this.getNormal(ix0, iz1), d = this.getNormal(ix1, iz1), m = new Vec3;
                Vec3.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d.set(m), d.subtract(a), d.add(m)) : (a.set(m), 
                a.subtract(d), a.add(m));
                var n1 = new Vec3, n2 = new Vec3, n = new Vec3;
                return Vec3.lerp(n1, a, b, dx), Vec3.lerp(n2, c, d, dx), Vec3.lerp(n, n1, n2, dz), 
                n;
            }
        }, {
            key: "setWeight",
            value: function setWeight(i, j, w) {
                var index = j * this._weightMapSize * this._blockCount[0] + i;
                this._weights[4 * index + 0] = 255 * w.x, this._weights[4 * index + 1] = 255 * w.y, 
                this._weights[4 * index + 2] = 255 * w.z, this._weights[4 * index + 3] = 255 * w.w;
            }
        }, {
            key: "getWeight",
            value: function getWeight(i, j) {
                var index = j * this._weightMapSize * this._blockCount[0] + i, w = new Vec4;
                return w.x = this._weights[4 * index + 0] / 255, w.y = this._weights[4 * index + 1] / 255, 
                w.z = this._weights[4 * index + 2] / 255, w.w = this._weights[4 * index + 3] / 255, 
                w;
            }
        }, {
            key: "getWeightAt",
            value: function getWeightAt(x, y) {
                var fx = x / this.vertexCount[0], fy = y / this.vertexCount[1], ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
                if (ix0 < 0 || ix0 > this.vertexCount[0] - 1 || iz0 < 0 || iz0 > this.vertexCount[1] - 1) return null;
                ix0 = clamp(ix0, 0, this.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this.vertexCount[1] - 1), 
                ix1 = clamp(ix1, 0, this.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this.vertexCount[1] - 1);
                var a = this.getWeight(ix0, iz0), b = this.getWeight(ix1, iz0), c = this.getWeight(ix0, iz1), d = this.getWeight(ix1, iz1), m = new Vec4;
                Vec4.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d = new Vec4, Vec4.subtract(d, m, a).add(m)) : (a = new Vec4, 
                Vec4.subtract(a, m, d).add(m));
                var n1 = new Vec4, n2 = new Vec4, n = new Vec4;
                return Vec4.lerp(n1, a, b, dx), Vec4.lerp(n2, c, d, dx), Vec4.lerp(n, n1, n2, dz), 
                n;
            }
        }, {
            key: "getBlockInfo",
            value: function getBlockInfo(i, j) {
                return this._blockInfos[j * this._blockCount[0] + i];
            }
        }, {
            key: "getBlock",
            value: function getBlock(i, j) {
                return this._blocks[j * this._blockCount[0] + i];
            }
        }, {
            key: "getBlocks",
            value: function getBlocks() {
                return this._blocks;
            }
        }, {
            key: "getSharedIndexBuffer",
            value: function getSharedIndexBuffer() {
                return this._sharedIndexBuffer;
            }
        }, {
            key: "rayCheck",
            value: function rayCheck(start, dir, step) {
                var worldspace = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], MAX_COUNT = 2e3, trace = start;
                worldspace && Vec3.subtract(trace, start, this.node.getWorldPosition());
                var dstep = new Vec3;
                dstep.set(dir), dstep.multiplyScalar(step);
                var position = null;
                if (dir.equals(new Vec3(0, 1, 0))) {
                    var y = this.getHeightAt(trace.x, trace.z);
                    null != y && trace.y <= y && (position = new Vec3(trace.x, y, trace.z));
                } else if (dir.equals(new Vec3(0, -1, 0))) {
                    var _y2 = this.getHeightAt(trace.x, trace.z);
                    null != _y2 && trace.y >= _y2 && (position = new Vec3(trace.x, _y2, trace.z));
                } else {
                    for (var i = 0; i++ < MAX_COUNT; ) {
                        var _y3 = this.getHeightAt(trace.x, trace.z);
                        if (null != _y3 && trace.y <= _y3) break;
                        trace.add(dir);
                    }
                    for (;i++ < MAX_COUNT; ) {
                        var _y4 = this.getHeightAt(trace.x, trace.z);
                        if (null != _y4 && trace.y <= _y4) {
                            position = new Vec3(trace.x, _y4, trace.z);
                            break;
                        }
                        trace.add(dstep);
                    }
                }
                return position;
            }
        }, {
            key: "_calcuNormal",
            value: function _calcuNormal(x, z) {
                var right, up, flip = 1, here = this.getPosition(x, z);
                x < this.vertexCount[0] - 1 ? right = this.getPosition(x + 1, z) : (flip *= -1, 
                right = this.getPosition(x - 1, z)), z < this.vertexCount[1] - 1 ? up = this.getPosition(x, z + 1) : (flip *= -1, 
                up = this.getPosition(x, z - 1)), right.subtract(here), up.subtract(here);
                var normal = new Vec3;
                return normal.set(up), normal.cross(right), normal.multiplyScalar(flip), normal.normalize(), 
                normal;
            }
        }, {
            key: "_buildNormals",
            value: function _buildNormals() {
                for (var index = 0, y = 0; y < this.vertexCount[1]; ++y) for (var x = 0; x < this.vertexCount[0]; ++x) {
                    var n = this._calcuNormal(x, y);
                    this._normals[3 * index + 0] = n.x, this._normals[3 * index + 1] = n.y, this._normals[3 * index + 2] = n.z, 
                    index += 1;
                }
            }
        }, {
            key: "_buildImp",
            value: function _buildImp() {
                var _this3 = this;
                if (this.valid) return !0;
                if (null != this.__asset) {
                    this._tileSize = this.__asset.tileSize, this._blockCount = this.__asset.blockCount, 
                    this._weightMapSize = this.__asset.weightMapSize, this._lightMapSize = this.__asset.lightMapSize, 
                    this._heights = this.__asset.heights, this._weights = this.__asset.weights;
                    for (var initial = !0, i = 0; i < this._layers.length; ++i) null != this._layers[i] && (initial = !1);
                    if (initial && null != this._asset) {
                        var _loop = function _loop() {
                            if (_isArray6) {
                                if (_i12 >= _iterator6.length) return "break";
                                _ref6 = _iterator6[_i12++];
                            } else {
                                if ((_i12 = _iterator6.next()).done) return "break";
                                _ref6 = _i12.value;
                            }
                            var i = _ref6, layer = new TerrainLayer;
                            layer.tileSize = i.tileSize, cc.loader.loadRes(i.detailMap, Texture2D, (function(err, asset) {
                                layer.detailMap = asset;
                            })), _this3._layers[i.slot] = layer;
                        }, _iterator6 = this._asset.layerInfos, _isArray6 = Array.isArray(_iterator6), _i12 = 0;
                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            if ("break" === _loop()) break;
                        }
                    }
                }
                if (0 === this._blockCount[0] || 0 === this._blockCount[1]) return !1;
                var vcount = this.vertexCount[0] * this.vertexCount[1];
                if (this._heights.length !== vcount) {
                    this._heights = new Uint16Array(vcount), this._normals = new Array(3 * vcount);
                    for (var _i13 = 0; _i13 < vcount; ++_i13) this._heights[_i13] = 32768, this._normals[3 * _i13 + 0] = 0, 
                    this._normals[3 * _i13 + 1] = 1, this._normals[3 * _i13 + 2] = 0;
                } else this._normals = new Array(3 * vcount), this._buildNormals();
                var weightMapComplexityU = this._weightMapSize * this._blockCount[0], weightMapComplexityV = this._weightMapSize * this._blockCount[1];
                if (this._weights.length !== weightMapComplexityU * weightMapComplexityV * 4) {
                    this._weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4);
                    for (var _i14 = 0; _i14 < weightMapComplexityU * weightMapComplexityV; ++_i14) this._weights[4 * _i14 + 0] = 255, 
                    this._weights[4 * _i14 + 1] = 0, this._weights[4 * _i14 + 2] = 0, this._weights[4 * _i14 + 3] = 0;
                }
                if (this._blockInfos.length !== this._blockCount[0] * this._blockCount[1]) {
                    this._blockInfos = [];
                    for (var j = 0; j < this._blockCount[1]; ++j) for (var _i15 = 0; _i15 < this._blockCount[0]; ++_i15) {
                        var info = new TerrainBlockInfo;
                        null != this._asset && (info.layers[0] = this._asset.getLayer(_i15, j, 0), info.layers[1] = this._asset.getLayer(_i15, j, 1), 
                        info.layers[1] === info.layers[0] && (info.layers[1] = -1), info.layers[2] = this._asset.getLayer(_i15, j, 2), 
                        info.layers[2] === info.layers[0] && (info.layers[2] = -1), info.layers[3] = this._asset.getLayer(_i15, j, 3), 
                        info.layers[3] === info.layers[0] && (info.layers[3] = -1)), this._blockInfos.push(info);
                    }
                }
                for (var _j3 = 0; _j3 < this._blockCount[1]; ++_j3) for (var _i16 = 0; _i16 < this._blockCount[0]; ++_i16) this._blocks.push(new TerrainBlock(this, _i16, _j3));
                var _iterator7 = this._blocks, _isArray7 = Array.isArray(_iterator7), _i17 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i17 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i17++];
                    } else {
                        if ((_i17 = _iterator7.next()).done) break;
                        _ref7 = _i17.value;
                    }
                    _ref7.build();
                }
            }
        }, {
            key: "_rebuildHeights",
            value: function _rebuildHeights(info) {
                if (this.vertexCount[0] === info.vertexCount[0] && this.vertexCount[1] === info.vertexCount[1]) return !1;
                for (var heights = new Uint16Array(info.vertexCount[0] * info.vertexCount[1]), i = 0; i < heights.length; ++i) heights[i] = 32768;
                for (var w = Math.min(this.vertexCount[0], info.vertexCount[0]), h = Math.min(this.vertexCount[1], info.vertexCount[1]), j = 0; j < h; ++j) for (var _i19 = 0; _i19 < w; ++_i19) {
                    var index0 = j * info.vertexCount[0] + _i19, index1 = j * this.vertexCount[0] + _i19;
                    heights[index0] = this._heights[index1];
                }
                return this._heights = heights, !0;
            }
        }, {
            key: "_rebuildWeights",
            value: function _rebuildWeights(info) {
                var _this4 = this, oldWeightMapSize = this._weightMapSize, oldWeightMapComplexityU = this._weightMapSize * this._blockCount[0], oldWeightMapComplexityV = this._weightMapSize * this._blockCount[1], weightMapComplexityU = info.weightMapSize * info.blockCount[0], weightMapComplexityV = info.weightMapSize * info.blockCount[1];
                if (weightMapComplexityU === oldWeightMapComplexityU && weightMapComplexityV === oldWeightMapComplexityV) return !1;
                for (var weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4), i = 0; i < weightMapComplexityU * weightMapComplexityV; ++i) weights[4 * i + 0] = 255, 
                weights[4 * i + 1] = 0, weights[4 * i + 2] = 0, weights[4 * i + 3] = 0;
                for (var w = Math.min(info.blockCount[0], this._blockCount[0]), h = Math.min(info.blockCount[1], this._blockCount[1]), getOldWeight = function getOldWeight(_i, _j, _weights) {
                    var index = _j * oldWeightMapComplexityU + _i, weight = new Vec4;
                    return weight.x = _weights[4 * index + 0] / 255, weight.y = _weights[4 * index + 1] / 255, 
                    weight.z = _weights[4 * index + 2] / 255, weight.w = _weights[4 * index + 3] / 255, 
                    weight;
                }, sampleOldWeight = function sampleOldWeight(_x, _y, _xoff, _yoff, _weights) {
                    var ix0 = Math.floor(_x), iz0 = Math.floor(_y), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = _x - ix0, dz = _y - iz0, a = getOldWeight(ix0 + _xoff, iz0 + _yoff, _this4._weights), b = getOldWeight(ix1 + _xoff, iz0 + _yoff, _this4._weights), c = getOldWeight(ix0 + _xoff, iz1 + _yoff, _this4._weights), d = getOldWeight(ix1 + _xoff, iz1 + _yoff, _this4._weights), m = new Vec4;
                    Vec4.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d.set(m), d.subtract(a), d.add(m)) : (a.set(m), 
                    a.subtract(d), a.add(m));
                    var n1 = new Vec4, n2 = new Vec4, n = new Vec4;
                    return Vec4.lerp(n1, a, b, dx), Vec4.lerp(n2, c, d, dx), Vec4.lerp(n, n1, n2, dz), 
                    n;
                }, j = 0; j < h; ++j) for (var _i20 = 0; _i20 < w; ++_i20) for (var uoff = _i20 * oldWeightMapSize, voff = j * oldWeightMapSize, v = 0; v < this._weightMapSize; ++v) for (var u = 0; u < this._weightMapSize; ++u) {
                    var _w = void 0;
                    if (info.weightMapSize === oldWeightMapSize) _w = getOldWeight(u + uoff, v + voff, this._weights); else _w = sampleOldWeight(u / (this._weightMapSize - 1) * (oldWeightMapSize - 1), v / (this._weightMapSize - 1) * (oldWeightMapSize - 1), uoff, voff, this._weights);
                    var du = _i20 * this._weightMapSize + u, index = (j * this._weightMapSize + v) * weightMapComplexityU + du;
                    weights[4 * index + 0] = 255 * _w.x, weights[4 * index + 1] = 255 * _w.y, weights[4 * index + 2] = 255 * _w.z, 
                    weights[4 * index + 3] = 255 * _w.w;
                }
                return this._weights = weights, !0;
            }
        }, {
            key: "_asset",
            set: function set(value) {
                if (this.__asset !== value && (this.__asset = value, null != this.__asset && this.valid)) {
                    var _iterator8 = this._blocks, _isArray8 = Array.isArray(_iterator8), _i21 = 0;
                    for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                        var _ref8;
                        if (_isArray8) {
                            if (_i21 >= _iterator8.length) break;
                            _ref8 = _iterator8[_i21++];
                        } else {
                            if ((_i21 = _iterator8.next()).done) break;
                            _ref8 = _i21.value;
                        }
                        _ref8.destroy();
                    }
                    this._blocks = [], this._blockInfos = [], this._buildImp();
                }
            },
            get: function get() {
                return this.__asset;
            }
        }, {
            key: "size",
            get: function get() {
                var sz = new Size(0, 0);
                return sz.width = 32 * this.blockCount[0] * this.tileSize, sz.height = 32 * this.blockCount[1] * this.tileSize, 
                sz;
            }
        }, {
            key: "tileSize",
            get: function get() {
                return this._tileSize;
            }
        }, {
            key: "tileCount",
            get: function get() {
                return [ 32 * this.blockCount[0], 32 * this.blockCount[1] ];
            }
        }, {
            key: "vertexCount",
            get: function get() {
                var _vertexCount = this.tileCount;
                return _vertexCount[0] += 1, _vertexCount[1] += 1, _vertexCount;
            }
        }, {
            key: "blockCount",
            get: function get() {
                return this._blockCount;
            }
        }, {
            key: "lightMapSize",
            get: function get() {
                return this._lightMapSize;
            }
        }, {
            key: "weightMapSize",
            get: function get() {
                return this._weightMapSize;
            }
        }, {
            key: "heights",
            get: function get() {
                return this._heights;
            }
        }, {
            key: "weights",
            get: function get() {
                return this._weights;
            }
        }, {
            key: "valid",
            get: function get() {
                return this._blocks.length > 0;
            }
        }, {
            key: "info",
            get: function get() {
                var ti = new TerrainInfo;
                return ti.tileSize = this.tileSize, ti.blockCount[0] = this.blockCount[0], ti.blockCount[1] = this.blockCount[1], 
                ti.weightMapSize = this.weightMapSize, ti.lightMapSize = this.lightMapSize, ti;
            }
        } ]), Terrain;
    }(Component)).prototype, "__asset", [ _dec8$u ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor9$h = _applyDecoratedDescriptor(_class11$2.prototype, "_layers", [ _dec9$n ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor10$h = _applyDecoratedDescriptor(_class11$2.prototype, "_blockInfos", [ _dec10$l ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _applyDecoratedDescriptor(_class11$2.prototype, "_asset", [ _dec11$l ], Object.getOwnPropertyDescriptor(_class11$2.prototype, "_asset"), _class11$2.prototype), 
    _applyDecoratedDescriptor(_class11$2.prototype, "info", [ _dec12$h ], Object.getOwnPropertyDescriptor(_class11$2.prototype, "info"), _class11$2.prototype), 
    _class10$2 = _class11$2)) || _class10$2) || _class10$2) || _class10$2);
    return exports.AffineTransform = AffineTransform, exports.AnimCurve = AnimCurve, 
    exports.AnimationClip = AnimationClip, exports.AnimationComponent = AnimationComponent, 
    exports.AnimationManager = AnimationManager, exports.AnimationState = AnimationState, 
    exports.Asset = Asset, exports.AssetLibrary = AssetLibrary, exports.AudioClip = AudioClip, 
    exports.AudioSourceComponent = AudioSourceComponent, exports.BaseNode = BaseNode, 
    exports.BatchedSkinningModelComponent = BatchedSkinningModelComponent, exports.BatchingUtility = BatchingUtility, 
    exports.BillboardComponent = BillboardComponent, exports.BitMask = BitMask, exports.BitmapFont = BitmapFont, 
    exports.BlockInputEventsComponent = BlockInputEventsComponent, exports.BoxColliderComponent = BoxColliderComponent, 
    exports.ButtonComponent = ButtonComponent, exports.CCBoolean = CCBoolean, exports.CCClass = CCClass, 
    exports.CCFloat = CCFloat, exports.CCInteger = CCInteger, exports.CCObject = CCObject, 
    exports.CCString = CCString, exports.CachedArray = CachedArray, exports.CameraComponent = CameraComponent, 
    exports.CanvasComponent = CanvasComponent, exports.CanvasPool = CanvasPool, exports.CapsuleColliderComponent = CapsuleColliderComponent, 
    exports.ColliderComponent = ColliderComponent, exports.Color = Color, exports.CompactValueTypeArray = CompactValueTypeArray, 
    exports.Component = Component, exports.ComponentModifier = ComponentModifier, exports.ConstantForce = ConstantForce, 
    exports.CubicSplineNumberValue = CubicSplineNumberValue, exports.CubicSplineQuatValue = CubicSplineQuatValue, 
    exports.CubicSplineVec2Value = CubicSplineVec2Value, exports.CubicSplineVec3Value = CubicSplineVec3Value, 
    exports.CubicSplineVec4Value = CubicSplineVec4Value, exports.CurveValueAdapter = CurveValueAdapter, 
    exports.DirectionalLightComponent = DirectionalLightComponent, exports.Director = Director, 
    exports.Downloader = Downloader, exports.EPSILON = 1e-6, exports.EditBoxComponent = EditBoxComponent, 
    exports.EffectAsset = EffectAsset, exports.Enum = Enum, exports.Event = Event, exports.EventAcceleration = EventAcceleration, 
    exports.EventHandler = EventHandler, exports.EventInfo = EventInfo, exports.EventKeyboard = EventKeyboard, 
    exports.EventMouse = EventMouse, exports.EventTarget = EventTarget, exports.EventTouch = EventTouch, 
    exports.Font = Font, exports.GFXBindingLayout = GFXBindingLayout, exports.GFXBindingUnit = function GFXBindingUnit() {
        _classCallCheck(this, GFXBindingUnit), this.binding = 0, this.type = exports.GFXBindingType.UNKNOWN, 
        this.name = "", this.buffer = null, this.texView = null, this.sampler = null;
    }, exports.GFXBlendState = GFXBlendState, exports.GFXBlendTarget = GFXBlendTarget, 
    exports.GFXBuffer = GFXBuffer, exports.GFXBufferTextureCopy = GFXBufferTextureCopy, 
    exports.GFXColorAttachment = function GFXColorAttachment() {
        _classCallCheck(this, GFXColorAttachment), this.format = exports.GFXFormat.UNKNOWN, 
        this.loadOp = exports.GFXLoadOp.CLEAR, this.storeOp = exports.GFXStoreOp.STORE, 
        this.sampleCount = 1, this.beginLayout = exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL, 
        this.endLayout = exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL;
    }, exports.GFXCommandAllocator = GFXCommandAllocator, exports.GFXCommandBuffer = GFXCommandBuffer, 
    exports.GFXDepthStencilAttachment = function GFXDepthStencilAttachment() {
        _classCallCheck(this, GFXDepthStencilAttachment), this.format = exports.GFXFormat.UNKNOWN, 
        this.depthLoadOp = exports.GFXLoadOp.CLEAR, this.depthStoreOp = exports.GFXStoreOp.STORE, 
        this.stencilLoadOp = exports.GFXLoadOp.CLEAR, this.stencilStoreOp = exports.GFXStoreOp.STORE, 
        this.sampleCount = 1, this.beginLayout = exports.GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL, 
        this.endLayout = exports.GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
    }, exports.GFXDepthStencilState = GFXDepthStencilState, exports.GFXDevice = GFXDevice, 
    exports.GFXFormatInfos = GFXFormatInfos, exports.GFXFormatSize = GFXFormatSize, 
    exports.GFXFormatSurfaceSize = GFXFormatSurfaceSize, exports.GFXFramebuffer = GFXFramebuffer, 
    exports.GFXGetTypeSize = GFXGetTypeSize, exports.GFXInputAssembler = GFXInputAssembler, 
    exports.GFXInputState = GFXInputState, exports.GFXObject = GFXObject, exports.GFXPipelineLayout = GFXPipelineLayout, 
    exports.GFXPipelineState = GFXPipelineState, exports.GFXQueue = GFXQueue, exports.GFXRasterizerState = GFXRasterizerState, 
    exports.GFXRenderPass = GFXRenderPass, exports.GFXSampler = GFXSampler, exports.GFXSamplerState = GFXSamplerState, 
    exports.GFXShader = GFXShader, exports.GFXTexture = GFXTexture, exports.GFXTextureCopy = GFXTextureCopy, 
    exports.GFXTextureSubres = GFXTextureSubres, exports.GFXTextureView = GFXTextureView, 
    exports.GFXUniform = function GFXUniform() {
        _classCallCheck(this, GFXUniform), this.name = "", this.type = exports.GFXType.UNKNOWN, 
        this.count = 1;
    }, exports.GFXUniformBlock = function GFXUniformBlock() {
        _classCallCheck(this, GFXUniformBlock), this.binding = -1, this.name = "", this.members = [];
    }, exports.GFXUniformSampler = function GFXUniformSampler() {
        _classCallCheck(this, GFXUniformSampler), this.binding = -1, this.name = "", this.type = exports.GFXType.UNKNOWN, 
        this.count = 1;
    }, exports.GFXWindow = GFXWindow, exports.GFX_DRAW_INFO_SIZE = 56, exports.GFX_MAX_ATTACHMENTS = 4, 
    exports.GFX_MAX_BUFFER_BINDINGS = 24, exports.GFX_MAX_TEXTURE_UNITS = 16, exports.GFX_MAX_VERTEX_ATTRIBUTES = 16, 
    exports.Game = Game, exports.GraphicsComponent = GraphicsComponent, exports.HeightField = HeightField, 
    exports.HierachyModifier = HierachyModifier, exports.HtmlTextParser = HtmlTextParser, 
    exports.ImageAsset = ImageAsset, exports.JavaScript = JavaScript, exports.JsonAsset = JsonAsset, 
    exports.LabelAtlas = LabelAtlas, exports.LabelComponent = LabelComponent, exports.LabelOutlineComponent = LabelOutlineComponent, 
    exports.Layers = Layers, exports.LayoutComponent = LayoutComponent, exports.LightComponent = LightComponent, 
    exports.LineComponent = LineComponent, exports.Loader = Loader, exports.LoadingItems = LoadingItems, 
    exports.MaskComponent = MaskComponent, exports.Mat3 = Mat3, exports.Mat4 = Mat4, 
    exports.Material = Material, exports.Mesh = Mesh, exports.MeshBuffer = MeshBuffer, 
    exports.MissingScript = MissingScript, exports.ModelComponent = ModelComponent, 
    exports.Node = Node$1, exports.NodeActivator = NodeActivator, exports.NodePool = NodePool, 
    exports.PageViewComponent = PageViewComponent, exports.PageViewIndicatorComponent = PageViewIndicatorComponent, 
    exports.ParticleSystemComponent = ParticleSystemComponent, exports.ParticleUtils = ParticleUtils, 
    exports.PhysicMaterial = PhysicMaterial, exports.PhysicsRayResult = PhysicsRayResult, 
    exports.PhysicsSystem = PhysicsSystem, exports.Pipeline = Pipeline, exports.Pool = Pool$1, 
    exports.Prefab = Prefab, exports.PrefabInfo = PrefabInfo, exports.Primitive = Primitive, 
    exports.PrivateNode = PrivateNode, exports.Profiler = Profiler, exports.ProgressBarComponent = ProgressBarComponent, 
    exports.Quat = Quat, exports.RatioSampler = RatioSampler, exports.RawAsset = RawAsset, 
    exports.Rect = Rect, exports.RecyclePool = RecyclePool, exports.RenderFlow = RenderFlow, 
    exports.RenderPipeline = RenderPipeline, exports.RenderPipelineAsset = RenderPipelineAsset, 
    exports.RenderStage = RenderStage, exports.RenderTexture = RenderTexture, exports.RenderView = RenderView, 
    exports.RenderableComponent = RenderableComponent, exports.ResolutionPolicy = ResolutionPolicy, 
    exports.RichTextComponent = RichTextComponent, exports.RigidBodyComponent = RigidBodyComponent, 
    exports.Scene = Scene, exports.SceneAsset = SceneAsset, exports.Scheduler = Scheduler, 
    exports.Script = Script, exports.ScrollBarComponent = ScrollBarComponent, exports.ScrollViewComponent = ScrollViewComponent, 
    exports.Size = Size, exports.SkelAnimDataHub = SkelAnimDataHub, exports.SkeletalAnimationComponent = SkeletalAnimationComponent, 
    exports.SkeletalAnimationState = SkeletalAnimationState, exports.Skeleton = Skeleton, 
    exports.SkinningModelComponent = SkinningModelComponent, exports.SkinningModelUnit = SkinningModelUnit, 
    exports.SliderComponent = SliderComponent, exports.Socket = Socket, exports.SphereColliderComponent = SphereColliderComponent, 
    exports.SphereLightComponent = SphereLightComponent, exports.SpotLightComponent = SpotLightComponent, 
    exports.SpriteAtlas = SpriteAtlas, exports.SpriteComponent = SpriteComponent, exports.SpriteFrame = SpriteFrame, 
    exports.StencilManager = StencilManager, exports.SubContextView = SubContextView, 
    exports.System = System, exports.SystemEvent = SystemEvent, exports.TERRAIN_BLOCK_TILE_COMPLEXITY = 32, 
    exports.TERRAIN_BLOCK_VERTEX_COMPLEXITY = 33, exports.TERRAIN_BLOCK_VERTEX_SIZE = 8, 
    exports.TERRAIN_DATA_VERSION = 16842753, exports.TERRAIN_DATA_VERSION2 = 16842754, 
    exports.TERRAIN_DATA_VERSION3 = 16842755, exports.TERRAIN_DATA_VERSION_DEFAULT = 16843025, 
    exports.TERRAIN_EAST_INDEX = 3, exports.TERRAIN_HEIGHT_BASE = 32768, exports.TERRAIN_HEIGHT_FACTORY = 1 / 512, 
    exports.TERRAIN_MAX_BLEND_LAYERS = 4, exports.TERRAIN_MAX_LAYER_COUNT = 256, exports.TERRAIN_MAX_LEVELS = 4, 
    exports.TERRAIN_NORTH_INDEX = 0, exports.TERRAIN_SOUTH_INDEX = 1, exports.TERRAIN_WEST_INDEX = 2, 
    exports.TTFFont = TTFFont, exports.Terrain = Terrain, exports.TerrainAsset = TerrainAsset, 
    exports.TerrainBlock = TerrainBlock, exports.TerrainBlockInfo = TerrainBlockInfo, 
    exports.TerrainBuffer = TerrainBuffer, exports.TerrainInfo = TerrainInfo, exports.TerrainLayer = TerrainLayer, 
    exports.TerrainLayerInfo = TerrainLayerInfo, exports.TerrainRenderable = TerrainRenderable, 
    exports.TerrainVertex = function TerrainVertex() {
        _classCallCheck(this, TerrainVertex), this.position = new Vec3(0, 0, 0), this.normal = new Vec3(0, 1, 0), 
        this.uv = new Vec2(0, 0);
    }, exports.TextAsset = TextAsset, exports.Texture2D = Texture2D, exports.TextureCube = TextureCube, 
    exports.ToggleComponent = ToggleComponent, exports.ToggleContainerComponent = ToggleContainerComponent, 
    exports.Touch = Touch, exports.Tween = Tween, exports.TweenSystem = TweenSystem, 
    exports.TypeScript = TypeScript, exports.UIComponent = UIComponent, exports.UICoordinateTrackerComponent = UICoordinateTrackerComponent, 
    exports.UIModelComponent = UIModelComponent, exports.UIOpacityComponent = UIOpacityComponent, 
    exports.UIRenderComponent = UIRenderComponent, exports.UIReorderComponent = UIReorderComponent, 
    exports.UIStaticBatchComponent = UIStaticBatchComponent, exports.UITransformComponent = UITransformComponent, 
    exports.UIVertexFormat = UIVertexFormat, exports.UniformCurveValueAdapter = UniformCurveValueAdapter, 
    exports.ValueType = ValueType, exports.Vec2 = Vec2, exports.Vec3 = Vec3, exports.Vec4 = Vec4, 
    exports.View = View, exports.ViewGroupComponent = ViewGroupComponent, exports.WebviewComponent = WebviewComponent, 
    exports.WidgetComponent = WidgetComponent, exports.WorldNode3DToLocalNodeUI = WorldNode3DToLocalNodeUI, 
    exports.WorldNode3DToWorldNodeUI = WorldNode3DToWorldNodeUI, exports._decorator = _decorator, 
    exports.absMax = absMax, exports.absMaxComponent = absMaxComponent, exports.animation = animation, 
    exports.approx = approx, exports.assert = assert, exports.assertID = assertID, exports.barFilled = barFilled, 
    exports.bezier = bezier, exports.bezierByTime = bezierByTime, exports.bits = bits, 
    exports.bmfont = bmfont, exports.builtinResMgr = builtinResMgr, exports.cclegacy = cclegacy, 
    exports.clamp = clamp, exports.clamp01 = clamp01, exports.color = color, exports.computeRatioByType = computeRatioByType, 
    exports.convertUtils = convertUtils, exports.deserialize = deserialize, exports.director = director, 
    exports.easing = easing, exports.effects = effects, exports.equals = equals, exports.error = error, 
    exports.errorID = errorID, exports.eventManager = eventManager, exports.find = find, 
    exports.fragmentText = fragmentText, exports.game = game, exports.geometry = geometry, 
    exports.getPathFromRoot = function getPathFromRoot(target, root) {
        for (var node = target, path = ""; null !== node && node !== root; ) path = "".concat(node.name, "/").concat(path), 
        node = node.parent;
        return path.slice(0, -1);
    }, exports.getWorldTransformUntilRoot = getWorldTransformUntilRoot, exports.graphics = graphicsAssembler, 
    exports.graphicsAssembler = graphicsAssemblerManager, exports.instantiate = instantiate, 
    exports.inverseLerp = inverseLerp, exports.isCustomTargetModifier = isCustomTargetModifier, 
    exports.isDisplayStats = isDisplayStats, exports.isElementModifier = isElementModifier, 
    exports.isPropertyModifier = isPropertyModifier, exports.isUnicodeCJK = isUnicodeCJK, 
    exports.isUnicodeSpace = isUnicodeSpace, exports.isValid = isValid, exports.js = js$1, 
    exports.labelAssembler = labelAssembler, exports.lerp = lerp, exports.letter = letter, 
    exports.loader = loader, exports.log = log, exports.logID = logID, exports.macro = macro, 
    exports.mask = maskAssembler, exports.maskEnd = maskEndAssembler, exports.mat4 = mat4, 
    exports.math = math, exports.memop = index, exports.misc = misc, exports.murmurhash2_32_gc = murmurhash2_32_gc, 
    exports.nextPow2 = nextPow2$1, exports.path = path, exports.pingPong = pingPong, 
    exports.primitives = primitives, exports.profiler = profiler, exports.pseudoRandom = pseudoRandom, 
    exports.pseudoRandomRange = pseudoRandomRange, exports.pseudoRandomRangeInt = pseudoRandomRangeInt, 
    exports.quat = quat, exports.radialFilled = radialFilled, exports.random = random, 
    exports.randomRange = randomRange, exports.randomRangeInt = randomRangeInt, exports.rect = rect, 
    exports.renderer = renderer, exports.repeat = repeat, exports.safeMeasureText = safeMeasureText, 
    exports.sampleAnimationCurve = sampleAnimationCurve, exports.screen = screen$1, 
    exports.setDefaultLogTimes = function setDefaultLogTimes(times) {
        times > 0 && (defaultLogTimes = times);
    }, exports.setDisplayStats = setDisplayStats, exports.simple = simple, exports.size = size, 
    exports.sliced = sliced, exports.spriteAssembler = spriteAssembler, exports.systemEvent = systemEvent, 
    exports.textureUtil = textureUtil, exports.toDegree = toDegree, exports.toRadian = toRadian, 
    exports.ttf = ttf, exports.tween = tween, exports.tweenUtil = tweenUtil, exports.url = url, 
    exports.utils = utils, exports.v2 = v2, exports.v3 = v3, exports.v4 = v4, exports.view = view, 
    exports.warn = warn, exports.warnID = warnID, exports.widgetManager = widgetManager, 
    exports;
}({});
